This article has been accepted for inclusion in a future issue of this journal. Content is final as presented, with the exception of pagination.

IEEE SYSTEMS JOURNAL

1

A Distributed Agent-Based Approach for Optimal QoS Selection in Web of Object Choreography
Nacera Temglit, Abdelghani Chibani, Karim Djouani, and Mohamed Ahmed Nacer

Abstract—The Internet of Things (IoT) refers to the domain of physical/logical objects connected to the Internet that can be accessible anywhere and anytime, giving the access policies. Web objects and services can be seen as distributed and cooperative agents that need to collaborate in order to reach advanced functionalities and also to optimize the overall quality offered to the end users. However, the number of the services that can be supplied through these devices on the Internet will increase more and more. In this context, performing the composition and selection of the best services according to quality-of-service (QoS) criteria become a complex task, especially when dealing with global service selection to satisfy global constraints of users in decentralized environments. For this purpose, we propose a distributed and optimal QoS selection approach based on the multiagent paradigm and the distributed constraint optimization problem (DCOP) formalism. Hence, we revisited a DCOP technique for developing an efﬁcient algorithm: the DPOP4QoS implemented under a real-time Web protocol for IoT communication, the extensible messaging and presence protocol. The proposed algorithm takes into account the speciﬁcities of the service composition context and the satisfaction of the global user constraints. This paper also presents a set of experiments conducted under realistic distributed environment to evaluate the performance of the proposed algorithm.
Index Terms—Multiagent systems, optimization, quality of service (QoS), service interoperability and composability, ubiquitous computing, Web services.
I. INTRODUCTION
I NTERNET of Things (IoT) is emphasizing a world where small intelligent objects are able to collaborate by sharing data and organizing themselves in groups in order to reach complex objectives. The rapid adoption of this technology within the service-oriented approach (SOA) increases the popularity and usage of devices connected through the IoT. According to Gartner,1 the number of connected devices is increasing to reach
Manuscript received March 22, 2016; revised June 12, 2016 and September 24, 2016; accepted November 26, 2016.
N. Temglit is with the National High School for Computer Science (ESI), 16000 Algiers Algeria (e-mail: n_temglit@esi.dz).
A. Chibani is with the Laboratory of Images, Signals and Intelligent Systems, University of Paris-Est Cre´teil, 94000 Cre´teil, France (e-mail: chibani@ u-pec.fr).
K. Djouani is with the French South African Institute of Technology (FSATI), Tshwane University of Technology, Pretoria 0183, South Africa (e-mail: djouani@ieee.org).
M. A. Nacer is with the LSI Laboratory, University of Science and Technology Houari Boumediene, Bab Ezzouar 16111, Algeria (e-mail: med.anacer@ gmail.com).
Digital Object Identiﬁer 10.1109/JSYST.2016.2647281 1Gartner Special Reports. [Online]. Available: //www.gartner.com/ technology/research/

more than 5 million of new devices that can be connected every day. This means that the number of the services that can be supplied through these devices on the internet will increase more and more. In this context, performing the composition and selection of these services according to quality-of-service (QoS) criteria will become a complex task for operators and business application designers. For this reason, service composition applies appropriate techniques to allow the highest QoS to be achieved according to the end-user requirements and priorities [1].
In service-oriented computing, service composition can be modeled and implemented according to one of the two following orchestration architectures: centralized orchestration agent or decentralized orchestration based on the cooperation (called also choreography) of several orchestration agents. In the former, the centralized orchestrator controls the selection and invocation of services participating in the composition and manages execution errors and exceptions. In the latter, we assume that a centralized orchestrator cannot handle the selection and invocation due to several technical reasons. Therefore, the composition is distributed between different agents that are sufﬁciently intelligent to handle the selection and invocation of the services of all the composition in a peer-to-peer mode.
This work has been undertaken in the European project ITEA2 WoO, which aims to propose a new architecture that connects, through Web protocols and services, objects like sensors, actuators, robots, or any physical or virtual object as well to solve the central problem of peer-to-peer services composition. The objective is to select the most appropriate combination of the operational services from those available in the ubiquitous environment to optimize the entire quality of a composite service expected by the end users. QoS values determine whether a Web service is reliable, trustworthy, efﬁcient, or features/has other nonfunctional aspects required by end users. Some examples of common QoS properties include price, response time, reliability, availability, and also energy level of IoT devices. In the case of robotic and automation services, the complexity of the service selection operation will increase as those objects are characterized by their dynamic aspect such as robots mobility, limited connectivity in some situations, and intensive use of battery to handle actuation. These objects that offer the elementary services involved in a composition need to communicate and collaborate in order to share the levels of their QoS with up-to-date information.
In this paper, a distributed optimization approach is proposed to solve the problem of service selection in the context of service choreography architecture. In the literature, various techniques

1937-9234 © 2017 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications standards/publications/rights/index.html for more information.

This article has been accepted for inclusion in a future issue of this journal. Content is final as presented, with the exception of pagination.

2

IEEE SYSTEMS JOURNAL

such as linear programming (LP), constraint optimization problem (CSP) formalism, and heuristic-based methods have been proposed for optimal or near-optimal Web service selection problems in the context of centralized and static environments [2]–[5]. Applying these algorithms in a distributed setting would be difﬁcult and entail large communication overheads. Very few approaches have been proposed to solve the problem of optimal service selection in distributed environments [6]–[8], while most of them focused on a local service selection at each service component of the distributed environment aiming to ﬁnd nearoptimal compositions by avoiding communication between objects. However, the optimality is never achieved especially when the constraints of end users are global. In the present work, we aim to tackle this problem by taking advantage of the multiagent paradigm for implementing an approach to select and orchestrate the execution of services. In other words, the architecture is composed of core agents that are in charge of optimizing the global quality of the composed services and to satisfy the QoS user’s constraints by selecting the best candidate services. This can be formalized as a distributed constraint optimization problem (DCOP) [9], [10] seeking to maximize or minimize the QoS attributes, such as minimizing response time and maximizing availability at the same time. To address the tradeoff between different objectives of service quality, we take advantage of the simple additive weighting (SAW) technique and use the utility function method, which allows a uniﬁed measurement of multiple objectives.
Moreover, in the context of dynamic service environments, the execution time of the distributed service selection algorithms is heavily constrained, as the service availability is not guaranteed and the variation in QoS parameter values is very frequent. For that, in our architecture of service composition, we suggest to reiterate the selection process during the execution of the composite service to take into account the changes that may occur in the environment. This is why the scalability of the selection algorithm is highly required. To be able to address this issue, we propose in this paper a DCOP-based algorithm, the DPOP4QoS, which allows a QoS selection with very low volume of messages exchanged between agents. The DPOP4QoS algorithm revisits the basic dynamic programming optimization protocol (DPOP) [11] and takes also into account: 1) the satisfaction of global user’s constraints that cannot be achieved by local selection methods and 2) the composition structures (sequence, parallel, and loop patterns) are considered as local constraints between agents that decide about how to calculate the utility values.
The rest of this paper is organized as follows. In Section II, we give some basic concepts on service composition and selection as well as a review of some related work of the domain. A global IoT architecture for services composition is discussed in Section III. A DCOP formalization of the service selection problem is given in Section IV. The algorithm proposed to solve the distributed service selection problem is discussed in detail in Section V. Evaluation and experimental results for the proposed algorithm “DPOP4QoS” are presented in Section VI, and then, we conclude and give some perspectives in Section VII.

II. BACKGROUND AND RELATED WORK
In the following, the Web service composition and selection problem is discussed, before reviewing main existing approaches, to the best of our knowledge, proposed in the literature for QoS Web service selection as well as some existing DCOP algorithms.
A. Web Service Composition and Selection
The true potential of Web services can only be realized through assembling multiple services into more powerful applications with more sophisticated functionalities; this is called Web service composition. We perceive solving a Web service composition in two main processes: Vertical and Horizontal composition [12], [13]. The Vertical composition is aimed at ﬁnding a combination of the abstract Web services (abstract composite service), for fulﬁlling functional requirement of the end users. An abstract Web service describes a service from the functional point of view without referring to any existing service and is represented by only functional attributes as the required inputs for a given service as well as the expected outputs. In the abstract composite service, the component services are arranged according to different workﬂow patterns or structures that conﬁgure them into a new composite service with value-added functionality. The main forms of workﬂow structures are sequence, choice, parallel, split, and loop. The Horizontal composition is aimed at ﬁnding the best concrete Web service, from among a set of available functionally equivalent Web services according to QoS attributes. This is known also as Web service selection or QoS-aware service composition. The QoS attributes encompass a number of nonfunctional properties such as the service price, reliability, response time, reputation, availability, etc. [1] The overall quality of the composite service is calculated aggregately from the quality of its constituent services.
The two straightforward solutions for the service selection problem are global and local selection. The selection is done locally when the selection of concrete services for each abstract service is done independently from the others using local cost function. It is applied when the user constraints are local. However, the users specify, usually, their expectations at global level, which implies that the selection must satisfy global constraints. This approach aims to solve the problem at the composite service level by evaluating all possible combinations of concrete services to choose the best combination in terms of QoS, while satisfying the global constraints. The problem of global selection is considered as a multicriteria and NP complexity problem; it is, therefore, difﬁcult to ﬁnd an optimal solution in a reasonable time when the number of abstract component services and concrete candidate services become important. This problem will be the focus of this paper.
For modeling and executing service compositions, two main approaches can be used: the centralized approach that is called service orchestration and the decentralized approach that is called choreography. In orchestration mode, a single execution engine is responsible for the invocation of the elementary services that are part of the composite services, including the enforcement of control ﬂows and message exchanges among

This article has been accepted for inclusion in a future issue of this journal. Content is final as presented, with the exception of pagination.

TEMGLIT et al.: DISTRIBUTED AGENT-BASED APPROACH FOR OPTIMAL QoS SELECTION IN WEB OF OBJECT CHOREOGRAPHY

3

component services. This differs from service choreography, which is peer-to-peer collaborative execution that is handled by services or agents that monitor their execution [14].
B. QoS Web Service Selection Approaches In [15], the authors discuss some works on service selec-
tion based on trust and reputation systems that permit QoS requirements to be negotiable with users. Therefore, the major inconvenience of these approaches is the involvement of users to ensure the voting system, which requires cooperation based on trust between users. Other techniques are based on graph theory, LP, genetic algorithms (GAs), Pareto search, CSP formalism, and decision-making techniques. We review below some of the main contribution and limitations of the works that fall into these categories.
The work of Zeng and Benatallah [2] focuses on dynamic and quality-driven selection of services. The authors use mixed LP techniques to ﬁnd the optimal selection of component services. But, these methods assume linearity of the constraints and the objective function and suffer from poor scalability due to the exponential time complexity of the applied search algorithms. In [16]–[22], the proposed methods are based on GAs to solve the selection problem in a reasonable time. However, as users have often to ﬁx a priori a constant number of iterations or a time deadline to stop the GA, this does not give any guarantee about the quality of the generated solution. Therefore, the GA offers a better scalability but deemed nonuseful for selecting the optimal composition plan. In [5], Le´cue´ proposes a CSP-based formalism to solve the QoS selection problem. The composition-driven CSP is solved by adapting a stochastic search method, which sacriﬁces completeness for speed and scalability. The author uses for this purpose the hill climbing algorithm. Another service composition approach based on the Pareto set model is recently proposed in [23]. This work focuses on ﬁnding the Pareto set of optimal solutions (compositions) by pruning candidate services and workﬂows that are not promising ones for optimal compositions. The authors use a QoS-based dominance relationships for this purpose and propose a parallel algorithm to improve efﬁciency on the composition space size and operation time. However, the approach aims to ﬁnd a set of feasible solutions instead of a unique solution for the problem. In [24], the authors propose a real-time QoS-aware selection using a multicriteria decision-making technique (analysis hierarchy process—AHP). The AHP is used to weigh user preferences and then uses a cost-beneﬁt ratio to rank service choices of two general cloud services: storage and compute cloud services. However, it is difﬁcult to generalize this idea for more than two services especially with various composition patterns. In [25], the authors propose an optimal Cross-Cloud service composition by performing a multilevel iteration process to mine the optimal or most optimal (trusted) subcompositions at different optimization levels. The nth level includes disjoint groups of two composition subgroups of the (n − 1)th level (starting by groups of two composition tasks). A threshold is calculated to sift out useless subcompositions at each iteration level (the subcompositions violating the user constraints). The general idea is interesting, but this work considers only the sequential composition pattern and supposes that the top subcompositions at

each level have a higher possibility to meet QoS constraints; therefore, the global optimality is still not guaranteed.
There has been very few works in the area of distributed QoS selection. In [26], the authors address the problem of satisfying end-to-end user constraints in a distributed environment by proposing a hybrid approach. The global constraints are decomposed into local constraints using mixed integer programming such that the satisfaction of local constraints at each domain guarantees the satisfaction of global constraints. However, the method of extracting QoS levels from the QoS information of service candidates is greedy (does not deal with dependencies between QoS dimensions); this leads to very restrictive decomposition of the global constraints to local constraints. The authors of [27] and [28] base their approaches on a decomposition of the global objective on the local domains on the Cloud and use a GA to ﬁnd the best composition. Zheng et al.’s work [29] adopted a greedy strategy-based solutions by using the CloudRank algorithm for QoS ranking on the cloud; however, this can only produce locally approximate solutions. In [8], two versions of a Web service selection algorithm are proposed: a centralized version and a decentralized one; so that it can be executed on top of centralized and decentralized infrastructures. In the two versions, the authors combine local and global selection techniques. The local selection aims at selecting services with the highest QoS for each activity in the user task using service clustering techniques, notably the K-means algorithm. The global selection aims at selecting near-optimal compositions of services resulting from the local selection by means of a GA.
C. DCOP Algorithms
The DCOP has been viewed as a powerful paradigm for solving combinatorial problems arising in distributed multiagent environments for the purpose of optimization [9]. DCOP techniques build upon the class of distributed constraint satisfaction problem by ﬁnding a complete assignment to the decision variables that not only satisﬁes the problem constraints but also optimizes the relevant objective(s) [30]. Well-known algorithms used to solve DCOP-like problems include SynchB&B [31], ADOPT [10], DPOP [11], OptAPO [32], and distributed stochastic search algorithms [33]. As for a complete algorithm, an optimum solution is guaranteed, despite the extended computing time. The existing algorithms were evaluated for different application use cases or domain areas, as, for instance, the graph coloring, the meeting scheduling, or the sensor network problems. In [34], the authors provide a good evaluation of ADOPT, OptAPO, and DPOP in terms of the number of cycles, the size/quantity of messages, and the running time for the problem of trafﬁc light synchronization. DPOP is linear in terms of the number of agents. Thus, the DPOP algorithm performed better in terms of the number of exchanged messages, the execution time, and the number of cycles. However, the same cannot be said about the size of the messages. ADOPT needs much more time than the others due to the exponential number of messages. OptAPO is a good compromise in terms of execution time and size of messages under partially distributed systems. Therefore, DPOP seems to be more suited for real-world applications requiring strong limitation in communications.

This article has been accepted for inclusion in a future issue of this journal. Content is final as presented, with the exception of pagination.

4

IEEE SYSTEMS JOURNAL

Fig. 1. Architecture of UbiSCo.

III. ARCHITECTURE OF IOT SERVICE COMPOSITION
In order to be able to fully exploit the new opportunities of the IoT vision, a scalable and ﬂexible architecture is needed. Nevertheless, the ever-increasing number of the proposed architectures has not yet converged to a reference model [35]–[37]. From the pool of the proposed models, the basic IoT model is a three-layer architecture [38], [39], consisting of the application, network, and object layers. Ubiquitous service composition (UbiSCo) architecture (depicted in Fig. 1) is based on the basic IoT model, to which we add some abstractions in order to integrate IoT into the Web by making them accessible in a SOA way. Indeed, the service abstraction layer and the service composition and management layer are added between the top layer (application) and the two bottom layers (object/network layers). In the service abstraction layer, all functionalities offered by networked devices are abstracted by services using enabled technologies such as REST [40] and extensible messaging and presence protocol (XMPP) [41]. The service composition and management layer is the most critical layer in our work that is responsible for critical functions such as service discovery, composition, execution, and monitoring of services. The service composition and execution are conducted in decentralized mode, where several distributed agents communicate and collaborate in order to handle the selection and invocation of the services in a peer-to-peer fashion [14]. This differs from the centralized orchestration, where a single execution engine is responsible for the selection and invocation of the elementary services. For service composition and execution, we denote three kinds of agents: choreography agents, local orchestration agents, and selection agents. The local orchestration agents ensure the execution of a localized area of services. The choreography agents collaborate to ensure the decentralized execution of the composite service under the speciﬁed constraints and optimize the solution. The service selection agents interact using a distributed optimal selection algorithm in order to select the best concrete services among the available ones in their respective domain. The selected service descriptions are sent back to the orchestration agents for execution. The selection process can be reiterated during the execution of the composite service in order to take into account any changes that could occur in the ubiqui-

tous environment, such as variation in the QoS parameters and service unavailability.
All the agents communicate in an adhoc and asynchronous way by using point-to-point and publish subscribe messaging middleware. The point-to-point is used to communicate message to speciﬁc agent, whereas publish subscribe is to feed agents with up-to-date notiﬁcations. The proposed architecture is also cloud compatible in the sense that some available services could be hosted on the cloud, so as to have a set of clouds with the access grant policies for each cloud.
IV. DISTRIBUTED SERVICE SELECTION APPROACH
In our architecture, the agents need to collaborate and negotiate their quality level in order to select the best concrete services among several similar services according to QoS end-user requirements. The DCOP is an appropriate formalism to manage this interaction. In this section, we will see how the distributed Web service selection can be formalized as a DCOP and what are the speciﬁcities to be considered.
A. DCOP Formalism Review
Within the DCOP framework, several agents have to communicate in order to converge to an optimal solution, i.e., the best value of their respective variables leading to the minimal (optimal) value of the global cost. Formally, the DCOP is deﬁned by the 6-uplet (X, D, C, A, ψ, φ) with:
1) X the set of distributed variables {x1 , x2 , . . . , xn }; 2) A the agents set {A1 , A2 , . . . , Ak }; 3) ψ : X → A the mapping function that maps each variable
of X to an agent of A; 4) D = {D1 , D2 , . . . , Dn } a set of ﬁnite sets, where Di is
the domain of the variable xi; 5) C = {cij : Di × Dj → R+ , where i, j = 1, . . . , n and
i = j} a set of constraints, corresponding to the local cost function for each couple of variables xi and xj . Only the agent owner of a variable knows the variable domain and has the control on its value. φ(Af ) is the objective function to optimize (maximize or minimize) and Af is the assignment function, which associate to each variable xi a value di ∈ Di.

This article has been accepted for inclusion in a future issue of this journal. Content is final as presented, with the exception of pagination.

TEMGLIT et al.: DISTRIBUTED AGENT-BASED APPROACH FOR OPTIMAL QoS SELECTION IN WEB OF OBJECT CHOREOGRAPHY

5

TABLE I QOS PARAMETERS OR METRICS

TABLE II AGGREGATION OF QOS VALUES BASED ON THE PATTERN: S, P, L

Parameters class

Designation & purpose

S (Sequential)

P (Parallel)

L (Loop N )

Dynamic Parameters Static Parameters

Energy level (EL) Availability (AV)
Response Time (RT) Reliability (RE) Price (Price) Security (Secur)

Actual Battery’s energy level of the Object hosting the service
Represents the accessibility of the service. It is the number of successful invocations over the total number of invocations
Represents the time needed by a given service to respond to the request
represents the services capacity at ensuring reliable message delivery.
the amount of money to pay for each service request
Represents the security level ensured by a service (authentication, encryption, etc.)

φ(A) is the summation of local costs for each couple of variables sharing one constraint

φ(Af ) =

cij (Af (xi), Af (xj )).

(1)

xi ,xj ∈X

DCOPs are commonly visualized as constraint graphs, whose vertices are the agents and whose edges are the constraints. The majority of the DCOP/DisCSP algorithms transform this graph into a depth ﬁrst search (DFS) tree in order to allow a local communication between agents: each agent communicates only with its neighbors (children, parent).

B. QoS Modeling
A QoS model must capture the descriptions of the important aspects of an ubiquitous service and take into account the speciﬁcities of each QoS parameter. Hence, we propose a model that allows for specifying generic QoS attributes like Response time, availability, reliability, and price of the service as well as domain-speciﬁc QoS attributes, e.g., the Energy Level that indicates the actual Battery’s energy level of the ubiquitous object hosting the service. We add to our model the Security Level, which represents the ability of the service to provide appropriate security mechanisms like encryption and authentication. These QoS attributes are classiﬁed into two categories (see Table I) [42].
1) Static parameters (SQP for static quality parameters): SQP values are generally known at the deployment or advertisement time and are usually not updated during the execution, for example, the Price and the Security Level of a service.
2) Dynamic parameters (DQP for dynamic quality parameters): DQP parameters represent the variable characteristics of a given service such as the Response time, Energy level, Availability, and Reliability. DQP attributes are determined at the invocation time and their values are provided by a monitoring process.
The QoS attributes are also qualiﬁed as negative or positive attributes. In negative attributes, the lower the value, the better the quality like Response time and Cost. In positive attributes,

Price Secur EL RE RT AV

Price( a ) +Price( b ) min(Secur( a ) ,Secur( b ) )
(EL( a ) +EL( b ) )/2 RE( a ) *RE( b ) RT( a ) +RT( b ) AV( a ) *AV( b )

Price( a ) +Price( b ) min(Secur( a ) ,Secur( b ) )
min(EL( a ) ,EL( b ) ) RE( a ) *RE( b ) /2
max(RT( a ) ,RT( b ) ) AV( a ) *AV( b )

N *Price(a)

Secur( a )

N i=0

ELi

N i=0

REi

N i=0

RTi

N i=0

AVi

the higher the value, the better the quality like Availability and Reliability. Therefore, the QoS of a concrete service csi is denoted by a vector of the six QoS attributes that can be represented as follows: QoWS(csi) = (Price(csi), Secur(csi), AV(csi), EL(csi), RT(csi), RE(csi)).
The QoS of the composite service is calculated based on the aggregation of all the QoS vectors representing the QoS of the concrete services involved in the composition. This aggregation depends on the structure of the plan (composition patterns) and the type of parameter. In next section, we will see how to calculate QoS values of a composite Web service according to the candidate QoS values and how we can sort the best combination of concrete services ensuring the optimal global quality according to the DCOP formalism.
C. Problem Formulation
An abstract composite service consists of a set of n services denoted as AS = {as1 , as2 , ..., asn }. For each service asi ∈ AS, there are m candidate services proper to implement it, which are represented by CSi = {csa1si, csa2si, ..., csamsi}. The problem is to select distributively one concrete service csajsi for each asi of AS that optimize the global quality of the whole composite service. This is formulated as a DCOP as follows.
1) Each abstract service asi of the abstract composite plan is associated to a variable xi controlled (owned) by one agent Ai in the DCOP context.
2) The domain of values of each abstract service asi is the set of concrete services of its class: D(asi) = {csajsi/1 j m} = CSi.
3) The value of a concrete service csi is the vector of its QoS attributes values. Therefore, the agents will exchange vectors of real values and not single values.
4) The graph of constraints is the composition plan that describes the dependence between the different services involved in the composition according to the three basic composition patterns considered in our work: sequential, parallel, and loop patterns (see Table II).
5) The local cost cij between two given services is computed based on the type of QoS attributes and on the pattern of composition connecting the considered services (see Table II).
Table II shows the aggregate function of QoS values according to three basic composition patterns: sequential, parallel, and loop. For QoS computation, the parallel composition pattern is the AND Join workﬂow pattern because the quality of two

This article has been accepted for inclusion in a future issue of this journal. Content is final as presented, with the exception of pagination.

6

IEEE SYSTEMS JOURNAL

parallel services is calculated at the synchronized point. The sequence pattern includes the SEQUENCE and AND/OR split workﬂow patterns, all the services being in split with a common service (S) are considered to be in sequence with this service (the branches of a split pattern may or may not be synchronized).
The local cost ca,b between two concrete services a and b is computed using the weighted sum of the aggregate function values on all QoS attributes according to the SAW technique used for multiobjective problems

L

ca,b =

Agg(qk (a), qk (b)) ∗ wk

(2)

(k=1)

where

L i=1

wi

=

1,

L

is

the

number

of

QoS

attributes,

and

Agg

denotes the used aggregation operator, as described in Table II .

The global cost function φ(Af ) is always the sum of the local

costs ca,b for each couple of related variables in the composition plan.

We also need to extend the DCOP algorithm to support satis-

faction of global constraints on attributes speciﬁed by the user;

these are bounds on the QoS attributes: upper bounds for the

negative attributes and lower bounds for the positive attributes.

For example, the user may expect that the entire service avail-

ability shall never be under 60% and the price should not exceed

80 dollars.

Generally, let Vr denote the rth QoS attribute value obtained for a concrete composite service (a feasible solution); the QoS

Constraint vector of L QoS attributes (L L) is expressed

as V = (V1 , . . . , VL ). boundr denotes the rth QoS bound on attribute r. The QoS bound vector on L QoS attributes is ex-

pressed as bound = (bound1 , . . . , boundL ). A Boolean func-
tion Constraint (Vr , boundr , Opr ) is deﬁned to verify whether the rth constraint speciﬁed by the user (boundr ) is satisﬁed
by Vr (according to Opr relation); the operator opr can be >, <, , , or =. If the constraint is satisﬁed, the value of the

Boolean function Constraint is true, otherwise false. Vr is obtained as

Vr =

Agg(qr (a), qr (b))

(3)

a , b ∈CS

with qr (a) and qr (b) denote the given rth QoS attribute values of the concrete services a and b, respectively.

The user may have also preferences on the QoS attribute by

specifying weight for each QoS attribute according to its impor-

tance (from the user point of view). Therefore, the user prefer-

ences are denoted by a vector W = (w1 , w2 , . . . , wL ) such that

L i=1

wi

=

1.

Preferences

are

taken

into

account

when

com-

puting local and global cost.

Therefore, solving the problem of service selection is to ﬁnd

a set of concrete services CS = {cs1 , cs2 , . . . , csn } where csi is the concrete service selected for the abstract service asi such as the following.

1) The global cost CostG of CS, deﬁned by the function φ in

formula (1), is minimized.

Fig. 2. Example of a DFS tree [43]. (a) Simple graph. (b) Depth-ﬁrst traversal from X0 .
2) The global quality of CS on each QoS attribute (Vr ) must satisfy the user’s constraints (boundr )
L
Constraint(Vr , boundr , Opr ) = true. (4)
r=1
To resolve our problem, we have revisited the DPOP algorithm, in which only a linear number of messages are exchanged between agents. This is important in distributed settings because sending a large number of small messages (like SynchB&B and ADOPT algorithms do) typically entails large communication overheads especially if the algorithm has to be reiterated several times. We deﬁned new aggregation operators to take into account the composition patterns (when calculating the overall cost) and also the satisfaction of end-user constraints. This will be detailed in the two next sections.
V. DPOP-BASED ALGORITHM FOR DISTRIBUTED AND OPTIMAL WEB SERVICE SELECTION
The DPOP is a DCOP algorithm having the important advantage that it generates only a linear number of messages. To use the DPOP, the graph of constraints must be transformed into a DFS tree. The DFS structure is potentially better than traditional search on linear variable orderings. The reason is that when performed on a DFS structure, search can be done in parallel on distinct branches of the tree.
A. DFS Concepts
A DFS arrangement of a graph G is a rooted tree with the same nodes and edges as G and the property that adjacent nodes from the original graph fall in the same branch of the tree [43].
In DFS structures, only neighboring agents can communicate directly by sending and receiving messages (local communication). In DPOP, two types of messages are exchanged: UTIL messages sent by agents to their parent (bottom-up messages) and VALUE messages sent by agents to their children (top-down messages).
For each node Xi in a given DFS Tree T of a graph G, we have the following.
1) The children Ci/parent Pi of node Xi are the descendants/ancestor of Xi, which are connected to Xi in T (e.g., from Fig. 2(b), P4 = {X1 }, C1 = {X3 , X4 }).
2) The pseudo-parents PPi of node Xi are Xi’s ancestors that are connected to Xi through back-edges (PP8 = {X1 }). Notice that PPi = Pi.

This article has been accepted for inclusion in a future issue of this journal. Content is final as presented, with the exception of pagination.

TEMGLIT et al.: DISTRIBUTED AGENT-BASED APPROACH FOR OPTIMAL QoS SELECTION IN WEB OF OBJECT CHOREOGRAPHY

7

3) The pseudo-children PCi of node Xi are Xi’s descendants directly connected to Xi through back-edges (e.g., PC0 = {X4 , X5 , X1 }).
4) Sepi is the separator set of a node Xi: all ancestors of Xi that are connected with Xi or with descendants of Xi (e.g. ,Sep3 = {X1 }, Sep5 = {X0 , X2 }). Otherwise stated, given a DFS tree, Sepi is the minimal set of ancestors of Xi whose removal completely disconnects the subtree rooted at Xi from the rest of the problem. Each node Xi can easily determine its separator Sepi as the union of separators received from its children, and its parent and
pseudo-parents, minus itself.
5) The induced width of a graph G along a given DFS ar-
rangement is equal to the size of the largest separator in
the DFS arrangement [43].
Generating DFS trees in a distributed manner is a task that
has received a lot of attention, and there are many algorithms
available, for example, [43], [44].

B. Principle Operations on DPOP Messages
Two types of messages are exchanged between agents in the DPOP algorithm through the DFS tree.
1) The UTIL message (UTILji ) sent from Xi to Xj is a multidimensional matrix (hypercube) with one dimension for each variable of Separator set of Xi; note that Xj ∈ (UTILji ) and Xi ∈/ (UTILji ). The UTIL message is a bottom-up process, which starts from the leaves and propagates upwards only through tree edges of the DFS Tree. The agents send UTIL messages to their parents. These messages summarize the inﬂuence of the sending agent and its whole subtree on the rest of the problem.
2) The VALUE message is a top-down process, initiated by the root, when UTIL propagation has ﬁnished. Each agent determines its optimal value based on the VALUE message it has received from its parent. Then, it dispatches this value to its children through VALUE messages.
Three principle operations used in the DPOP algorithm are the following.
1) Projection(⊥): UTILji ⊥ Xk , the projection of UTILji hypercube along Xk , is the optimal instantiation of Xk for each instantiation of variables Xi other than Xk (Xi ∈ dim(UTILji )).
2) Join (⊕): Combine two UTIL hypercubes and produce another UTIL hypercube; the aggregation operator in the original DPOP is the sum, but in our case, it can be either the sum, maximum, minimum, product, etc. with respect to composition patterns between the two variables. UTIL(X1 , X2 , X3 ) ⊕ UTIL (X1 , X2 , X4 ) → UTIL (X1 , X2 , X3 , X4 ). Each agent Xi has to join hypercubes received from its children (UTILCi i ) with hypercubes of its parents and pseudo-parents calculated by Xi (RiPi /PPi ) in order to compute the hypercube to send to its parent Pi (JOINPi i ).
3) Slice: used in the value propagation where each variable should choose a value that maximize (optimize) its UTIL hypercube and send it to its children.

Fig. 3. Examples of composition plans and their corresponding DFS trees required in the DPOP4QoS algorithm.

C. DPOP4QoS Algorithm

We revisit the DPOP algorithm for developing our distributed and optimal Web service selection: the DPOP4QoS. At ﬁrst, we have to scale QoS values of each service candidate in order to combine and compare correctly the utility values independently from the original scales used by their providers. Therefore, the scaled QoS value qscaled (k, j) of the kth QoS parameter of a service j is a value between 0 and 1 and is calculated as follows:

qscaled (k, j)

⎧

=

⎪⎪⎪⎨ ⎪⎪⎪⎩

qm

qmax (k, j ax (k, j) −

) − qk qmin (k,

j)

,

1

−

qmax (k, j) − qk qmax (k, j) − qmin (k,

j)

,

if qk is to be maximized otherwise

qmin (k, j) and qmax (k, j) are, respectively, the minimum and the maximum values of corresponding attributes k in the class of service candidate j and qk is the original attribute value. We set qmin = 0 to avoid division by zero.
In the next step, we have to consider some revisions to the
original DPOP algorithm regarding the DFS tree, the join, pro-
jection, slice operations, and also how to combine at each agent
node hypercubes of children and parent/pseudo-parents (the RiPi /PPi and UTILCi i hypercubes) in order to compute the hypercube to send to the parent.
1) In the DFS tree, we have to sort for each node Xi all its neighbors Pi, PPi, Ci, PCi, Sepi coupled with their patterns with Xi according to the global composition plan representing the constraint graph. We give below two ex-
amples of composition plan with their corresponding DFS
tree (see Fig. 3).
a) The ﬁrst one includes one parallel pattern [see
Fig. 3(a)]. In the DFS tree of this example, the local
view of each node (agent) is as follows:

This article has been accepted for inclusion in a future issue of this journal. Content is final as presented, with the exception of pagination.

8

IEEE SYSTEMS JOURNAL

X1 → P X1 : (X2 : Seq), CX1 : (X3 : Seq) X2 → CX2 : (X1 : Seq), P CX2 : (X4 : Seq) X3 → P X3 : (X1 : Seq), CX3 : (X4 : Seq) X4 → P X4 : (X3 : Join), P P X4 : (X2 : Join), CX4 : (X5 : Seq) X5 → P X5 : (X4 : Seq). The induced width of the DFS tree is 2.
b) The second example includes two parallel patterns
which increases the induced width of the DFS tree
[see Fig. 3(b)]. The DFS local view of each node
Xi is as follows: X1 → P X1 : (X3 : Seq), CX1 : (X2 : Seq) X2 → CX2 : (X4 : Seq, X6 : Seq), P X2 : (X1 : Seq) X3 → CX3 : (X4 : Seq), P CX3 : (X4 : Seq, X5 : Seq) X4 → P X4 : (X2 : Join), P P X4 : (X3 : Join), CX4 : (X5 : Seq) X5 → P X5 : (X4 : Join), P P X5 : (X3 : Join) X6 → P X6 : (X2 : Seq). The induced width of the DFS tree is 3.
2) JOIN operations in the context of Web service composition (⊕): The local utility value UTILji is calculated according to a) the original DPOP algorithm
and b) aggregation formulas for QoS values depending
on composition patterns: sequential, parallel, and loop.
For this purpose, the JOIN (⊕) operation will be exploded into three sub-JOIN operations: ⊕seq , ⊕Parallel, and ⊕loop. Deﬁnition: If U = UTILji ⊕op UTILjk , (op = seq, parallel, or loop), U is also a hypercube with dimension dim(U ) = dim(UTILji ) ∪ dim(UTILjk ). For each possible instantiation s of the variables in dim(U ), the correspond-
ing value of U [s] is the sum, maximum, minimum, or the
product of the two source hypercubes according to the
type of pattern (sequence, parallel, and loop) and the type
of QoS (see Table III).
Other composition patterns like the choice (OR Join work-
ﬂow pattern) can be added to the QoS model by specifying
the aggregation function and the JOIN operation would be
extended to an additional Join operator.
3) Project operation(⊥): In the classic DPOP algorithm, the projection of UTILji matrix along Xk is the optimal instantiation of Xk for each possible instantiation of variables Xi other than Xk . In the case of optimization with satisfaction of constraints, we maintain on each node Xi two hypercubes of utility values: one for saving the global utility values on all QoS attributes UTILji like in classical version and the second for saving a vector of utility values of each QoS attribute (UTILji )r (r = 1...L ) calculated individually. The second hypercube is useful to
check QoS constraints; this is done by choosing the op-
timal values of Xk along Xi axis whose utility values on each attribute r(r = 1...L ) satisfy the global attribute
constraints Boundr [according to formulas (4)]; hence, two ﬁltering steps are performed on UTILji before sending it to the parent.

4) Slice operation: In the slice operation, each variable should also choose a value that maximizes (optimizes) its UTIL hypercube and does not violate any constraints (like in projection step) then send it to its children.
In overall, the DPOP4QoS calculates for each node Xi the hypercube JOINPi i to send to Pi (Xi parent), as in Algorithm 1:
JOINPi i = [(⊕Parallel UTILCj i ) ⊕Parallel (⊕Parallel RiPPi )
⊕Parallel RiPi (ifpattern(Xj , Pi ) = parallel)]⊕seq
[(⊕seq UTILCj i ) ⊕seq (⊕seq RiPPi ) ⊕seq RiPi
(ifpattern(Xj , Pi) = seq)] ⊕seq [LoopNi ].
1) Cumulate using parallel join (⊕Parallel) all received UTIL messages from Ci, where pattern (Ci, Xi) = parallel (lines 10, 11, and 15) and then cumulate (with ⊕Parallel) the computed RiPPi and RiPi , where pattern (Xi, P Pi) = parallel and pattern (Xi, Pi) = parallel (line 18).
2) Cumulate with sequence join (⊕seq ) all received UTIL messages from Ci, where pattern (Ci, Xi) = sequence (lines 10, 11, 12, 13) and then cumulate (with ⊕seq ) the computed RiPPi and RiPi , where pattern (Xi, P Pi) = sequence and pattern (Xi, Pi) = sequence (line 19).
3) Cumulate using sequence join (⊕seq ) all computed parallel join, sequence join, and loop join (lines 6 and 22).
4) Project on Xi according to project operation deﬁnition and then send it to Pi (lines 23 and 24).
The DPOP4QoS realizes a complete search by calculating all possible UTIL hypercubes representing all possible combinations of values corresponding to each agent with their neighbors, propagates, and joins all partial solutions through the DFS tree from the leaves to the root. Therefore, the optimality of the algorithm is guaranteed.
The DPOP4QoS algorithm delivers at worst 2*(number of node − 1) messages: one UTIL message by node-1 (the root) and one VALUE message by node-number of leaves. Then, it is linear in the number of variables (nodes), thus producing small communication overheads. However, the size of exchanged messages are hypercubes of dimension = 1 + number of separators of the given sending node, i.e., the size of the hypercube at node Xi = |Xi | ∗ |Xi+1 | ∗ · · · ∗ |Xnumber of separators|, where |Xi | is the number of Xi values (the number of concrete services). Thus, the maximum message size is exponential in the induced width of the constraint graph, leading to memory restrictions for problems with large width (nested parallel patterns); in this case, reducing the number of candidate values (concrete services) at each node would alleviate the problem.
VI. IMPLEMENTATION AND EXPERIMENT RESULTS
The implementation of the service selection system was based on service composition and orchestration middleware the Ubistruct.2 The platform components are modular, scalable, and
2[Online]. Available: http://ubistruct.ubiquitous-intelligence.eu/architecture

This article has been accepted for inclusion in a future issue of this journal. Content is final as presented, with the exception of pagination.

TEMGLIT et al.: DISTRIBUTED AGENT-BASED APPROACH FOR OPTIMAL QoS SELECTION IN WEB OF OBJECT CHOREOGRAPHY

9

TABLE III JOIN OPERATIONS ACCORDING TO THE COMPOSITION PATTERNS S, P, L

U [s].price U [s].secur U [s].EL U [s].RE U [s].RT U [s].AV

op= Seq (⊕s e q ) UTILji [s].Price + UTILjk [s].Price Min(UTILji [s].secur, UTILjk [s].secur) UTILji [s].EL + UTILjk [s].EL/2
UTILji [s].RE * UTILjk [s].RE UTILji [s].RT + UTILjk [s].RT UTILji [s].AV * UTILjk [s].AV

op= Parallel (⊕P a r a lle l ) UTILji [s].Price + UTILjk [s].Price Min(UTILji [s].secur, UTILjk [s].secur) Min(UTILji [s].EL, UTILjk [s].EL (UTILji [s].RE * UTILjk [s].RE)/2 Max(UTILji [s].RT, UTILjk [s].RT)
UTILji [s].AV * UTILjk [s].AV

op= Loop (⊕loop)

N ∗ UTILji [s].Price

UTILji [s].secur

N i=0

UTILii

[ s ] . EL

N i=0

UTILii [s].RE

N i=0

UTILii

[ s ] . RT

N i=0

UTILii

[ s ] . AV

Algorithm 1: DPOP4QoS Algorithm.

Require: Ai values, Ai Neighbors Pi, PPi, Ci, PCi including their corresponding composition patterns.

1: procedure UTIL Propagation (for all Xi) a Bottom-up UTIL message propagation

2: if Xi is the root then 3: skip this

4: else

5:

Calculate (ParallelRi, SeqRi, LoopRi(N ) )

6:

SeqRiPPi =SeqRiPPi ⊕seq N ∗ LoopRi

7:

ParallelJOINPi i = null

8:

SeqJOINPi i =null

9:

∗ ∗ calculate UTILPi i the hypercube to send to

Pi ∗ ∗

10:

for all Xj ∈ Cido if Xi is a leaf skip this

11:

wait for UTILij message to arrive from Xj

12:

if (Xj .pattern = seq)then

13:

SeqJOINPi i = SeqJOINPi i ⊕seq UTILij

14:

else

15:

ParallelJOINPi i = ParallelJOINPi i

⊕Pa ra lle l UTILij

16:

end if

17:

if (Xj is the last Children)then

18:

ParallelJOINPi i = ParallelJOINPi i

⊕Pa ra lle l ParallelRi

19:

SeqJOINPi i = SeqJOINPi i ⊕seq SeqRi

20:

end if

21: end for

22:

JOINPi i = SeqJOINPi i ⊕seq ParallelJOINPi i

23:

UTILPi i = JOINPi i ⊥ Xi

optimizing on Xi

24:

Send UTILPi i message to Pi

25: end if

26: end procedure

27: procedure Value Propagation (for all Xi)

a

Top-down Value message propagation

28: wait for ValuePi i message from Pi

Value

includes all optimal values of Sepi

29: Vi∗ = slice JOINPi i on ValuePi i

ﬁnd the best vi

of Xi satisfying constraints according to formula 4

30: for all Xj of Cido

31: if Xi is a leafthen

32:

skip

33: else

34:

Send message Value to (Sepi ∪ Vi) to Xj

35: end if

36: end for

37: end procedure

Algorithm 2: Procedure Calculate.

38: procedure CALCULATE ParallelRi, SeqRi,

LoopRi(N )) 39: RiPi is Parent relation of Xi 40: RiPPi [k] are PseudoParent relations of Xi,

k = 1...nb PseudoParents.

41: SeqRiPPi = ⊕seq RiPPi [k] 42: ParallelRiPPi = ⊕ParallelRiPPi [k]

43: if Pi.pattern = seq then

44:

SeqRi = SeqRiPPi ⊕seq RiPi

45: else

46:

ParallelRi = ParallelRiPPi ⊕seq RiPi

47: end if

48: if Xi.pattern = Loop (is a pattern of Xi)then

49:

LoopNi = Rii

50:

for i ← 1, N − 1 do

51:

LoopRi(N ) = Loopi(N ) ⊕seq Rii

52:

end for

53: end if

54: end procedure

secure. Moreover, the platform supports multiple communication protocols for IoT such as REST API and XMPP; this enables the integration of a huge number of devices running on different operating systems or in the Cloud. Indeed, REST is a commonly adopted architectural style for the implementation and the communication of the Web services, managing connected objects on the Web. It is based on a simple point-to-point HTTP communication protocol, using format such as JSON or XML. In addition, REST API is widely used by cloud platforms and enables a simple integration with data collection monitoring systems. The XMPP [41] is an open standardized protocol that allows applications to communicate through instantaneous message exchanges on the Web without the need for a middleware or protocol gateways. Another advantage of using XMPP was to integrate the people and devices in the same collaborative ecosystem. The orchestration platform is also based on a distributed database management system over the domains offering the concrete services. For integrating the service selection system into Ubistruct platform, we implemented and assessed through experiments the “DPOP4QoS” Algorithm.
The experiments has been done on a Windows PC, with a Core i3 Processor clocked at 2.1 GHz and 4 GB of RAM. For better system interoperability, our application was implemented

This article has been accepted for inclusion in a future issue of this journal. Content is final as presented, with the exception of pagination.

10

IEEE SYSTEMS JOURNAL

Fig. 4. DPOP4QoS execution time (in seconds).

Fig. 6. Execution time (in seconds) in DPOP4QoS versus SynchB&B for ﬁve abstract services.

Fig. 5. DPOP4QoS exchanging messages.

Fig. 7. Exchanged messages in DPOP4QoS versus SynchB&B for ﬁve abstract services.

in Java under Eclipse. All the selection agents communicate via the XMPP server “The Google Talk.” To create an XMPP client for each agent, we used the Smack Java API. Hence, each agent has its own login for the Google Talk Server, its own local orchestration plan, as well as the list of the concrete services. Each concrete service corresponds to speciﬁc discrete values of its QoS parameters (a vector of real values). Each agent knows its neighbors in the DFS tree (parent, pseudo-parents, children, pseudo-children) with a speciﬁcation of the link type with each neighbor (sequential, loop, and parallel). The agents have also access to the user’s requirements (global constraints and preferences). We ﬁxed the number of abstract services m to 5, 7, 10, and 15 respectively, and varied the number of concrete services n from 3 to 20. The values of the six QoS parameters have been generated randomly for the n concrete services. The initial scenario of composition used in our experiments is the one explained in the precedent example of Fig. 3(a) with ﬁve nodes. For more than ﬁve nodes, the structures of the composition are built incrementally by adding one agent each time from the last agents (from the leaves in the DFS tree).
Figs. 4 and 5 depict variations in the number of exchanged messages and execution time of DPOP4QoS (transmission time of a message was between 450 and 460 ms). The obtained measurements show that the algorithm is executed in a very reasonable amount of time (i.e., less than 180 s for 15 abstract services and 20 concrete services per abstract service) and the number of exchanged messages are completely independent of the number of concrete services; one UTIL message by node-1 (the root) and one VALUE message by node-number of leaves (for 15 agents, the number of messages is 15-1(the node) + 15-1(one leave) = 28, as shown in Fig. 5). The variations in the execution time depicted in Fig. 4 is explained by the fact that increasing the number of concrete services involves increasing the size of hypercubes per agent, which slows the processing time (JOIN operations).

Fig. 8. Execution time (in seconds) in DPOP4QoS versus SynchB&B for ten abstract services.
Fig. 9. Exchanged messages in DPOP4QoS versus SynchB&B for ten abstract services.
A. Comparative Results In this experiment, we aimed to compare the performance
of our proposed algorithm to another DCOP algorithm named the synchronous branch & bound (SynchB&B) [31] that we developed for the purpose of these experiments. Like DPOP, the SynchB&B is based on global and complete search. We revisited some aspects of the SynchB&B in order to appropriate it to our problem of Web service selection.
Figs. 6–9 compare the performance of DPOP4QoS and SynchB&B algorithms in terms of the execution time and the number of messages for two problem instances (with ﬁve and ten agents) by varying the number of concrete services from 2 to 20. The average transmission delay was 400 ms. It can be observed from Figs. 6–9 and Table IV that the DPOP4QoS far

This article has been accepted for inclusion in a future issue of this journal. Content is final as presented, with the exception of pagination.

TEMGLIT et al.: DISTRIBUTED AGENT-BASED APPROACH FOR OPTIMAL QoS SELECTION IN WEB OF OBJECT CHOREOGRAPHY

11

TABLE IV DPOP4QOS VERSUS SYNCHB&B: NUMBER OF MESSAGES/EXECUTION TIME

DPOP4QoS versus SynchB&B: Number of Messages

Number of CSs

3

5

7

8

10

15

20

DPOP4QoS (ﬁve agents) SynchB&B (ﬁve agents) DPOP4QoS (ten agents) SynchB&B (ten agents) DPOP4QoS Improvement

8 150 18 1520 96.7%

8 430 18 4786 98.8%

8 978 18 5351 99.3%

8 1622
18 5896 99.6%

8 2812 18 6419 99.7%

8 3667 18 10 023 99.8%

8 6321 18 15 277 99.8%

DPOP4QoS versus SynchB&B : Execution time (seconds)

Number of CSs

3

5

7

8

10

15

20

DPOP4QoS (ﬁve agents) SynchB&B (ﬁve agents) DPOP4QoS (ten agents) SynchB&B (ten agents) DPOP4QoS Improvement

3.1 15 7 168 87.5%

5.2 45 9.6 465 93.1%

7.3 100 12 587 95.2%

14.1 273 25 737 95.7%

19 382 29.7 814 95.9%

55.2 683 70 1486 93.5%

138.2 923 160.5 2208 88.8%

outperforms the SynchB&B in terms of the number of messages and the execution time: the reduction in the number of messages reached 99.8% and did not decrease with the number of agents; the reduction in time was between 87.5% and 95.9%, which remains a highly signiﬁcant result. Hence, unlike SynchB&B, the DPOP4QoS scales perfectly for problems with a large number of abstract/concrete services.
The disadvantage of the DPOP4QoS is that the maximal message size and memory requirements increase exponentially in the induced width of the constraint graph. In other words, if the composite service includes a lot of nested parallel patterns, the induced width in the DFS tree will increase, and hence, the dimension of exchanged hypercubes increases as well. For example, if we had used the scenario of Fig. 3(b), the number of messages would be exactly the same as in the ﬁrst scenario [see Fig. 3(a)], but the execution time would be slower because the induced width of the generated DFS tree in the scenario [see Fig. 3(b)] is equal to 2, which increases the dimension of hypercubes and hence the processing time of the JOIN operation on each agent node. This problem can be alleviated by removing useless services from each abstract service set using the Pareto search (as the largest hypercube size = |Xk |inducedWidth, where |Xk | is the number of candidates services at node Xk having the largest number of separators).
VII. CONCLUSION
In this paper, we addressed the problem of global and decentralized Web service selection in the context of Web service choreography architecture for IoT environment. The proposed solution is based on the multiagent paradigm and the DCOP formalism. Our objective has been to propose a scalable approach while achieving an optimal solution at the same time. This was very challenging as the majority of the proposed DCOP algorithms use an exponential number of exchanged messages and very high execution time [9]. For that, we revisited a DCOP algorithm to develop an efﬁcient solution, the DPOP4QoS, that uses the dynamic programming optimization technique and

generates only a linear number of messages. The algorithm is based on a complete utility propagation method, and hence, optimality is guaranteed. The results of experiments show a very satisfying performance of the DPOP4QoS in terms of timeliness and the number of exchanged messages, which makes it an appropriate solution for real-time distributed service selection problems. However, the size of hypercubes generated at each node must be reduced; this seems very feasible by pruning candidate services using Pareto-dominance techniques or by compacting UTIL messages.
Furthermore, in the context of dynamic service composition and execution, different changes can occur during the execution of a composite service as it may take a long time: QoS values and service availability differ from design-time assumptions. In our ongoing work, we are investigating possible optimization to DPOP4QoS, which makes it more responsive to changes by increasing the reusability of previous computation and by limiting the propagation of new messages upon perturbations. In addition, we plan to extend the solution to manage multiple related service compositions, where each agent has to resolve locally a subproblem of Web service selection while optimizing the global solution. Finally, a comparison with other newer DCOP algorithms is envisaged as future work; for instance, concurrent forward bounding for DCOPs [45].
REFERENCES
[1] A. Jula, E. Sundararajan, and Z. Othman, “Review: Cloud computing service composition: A systematic literature review,” Expert Syst. Appl., vol. 41, no. 8, pp. 3809–3824, Jun. 2014.
[2] L. Zeng and B. Benatallah, “QoS-aware middleware for Web services composition,” IEEE Trans. Softw. Eng., vol. 30, no. 5, pp. 311–327, May 2004.
[3] T. Yu, Y. Zhang, and K.-J. Lin, “Efﬁcient algorithms for Web services selection with end-to-end QoS constraints,” ACM Trans. Web, vol. 1, no. 1, 2007, Art. no. 6.
[4] D. Ardagna and B. Pernici, “Adaptive service composition in ﬂexible processes,” IEEE Trans. Softw. Eng., vol. 33, no. 6, pp. 369–384, Jun. 2007.
[5] N. M. Le´cue´, “Towards scalability of quality driven semantic Web service composition,” in Proc. IEEE Int. Conf. Web Services, 2009, pp. 469–476.
[6] M. Alrifai and T. Risse, “Combining global optimization with local selection for efﬁcient QoS-aware service composition,” in Proc. 18th Int. Conf. World Wide Web, New York, NY, USA, 2009, pp. 881–890.
[7] J. Li, Y. Zhao, M. Liu, H. Sun, and D. Ma, “An adaptive heuristic approach for distributed QoS-based service composition,” in Proc. IEEE Symp. Comput. Commun., Jun. 2010, pp. 687–694.
[8] N. B. Mabrouk, N. Georgantas, and V. Issarny, “Set-based bi-level optimisation for QoS-aware service composition in ubiquitous environments,” in Proc. IEEE Int. Conf. Web Services, Jun. 2015, pp. 25–32.
[9] A. R. Leite, F. Enembreck, and J.-P. A. Barths, “Distributed constraint optimization problems: Review and perspectives,” Expert Syst. Appl., vol. 41, no. 11, pp. 5139–5157, 2014.
[10] P. J. Modi, W.-M. Shen, M. Tambe, and M. Yokoo, “Adopt: Asynchronous distributed constraint optimization with quality guarantees,” Artif. Intell., vol. 161, pp. 149–180, 2005.
[11] A. Petcu and B. Faltings, “A scalable method for multiagent constraint optimization,” in Proc. 19th Int. Joint Conf. Artif. Intell., Scoltland, U.K., 2005, pp. 266–271.
[12] A. B. Hassine, S. Matsubara, and T. Ishida, “A constraint-based approach to horizontal Web service composition,” in Proc. 5th Int. Conf. Semantic Web, 2006, pp. 130–143.
[13] W. T. Tsai, P. Zhong, X. Bai, and J. Elston, “Dependence-guided service composition for user-centric SOA,” IEEE Syst. J., vol. 8, no. 3, pp. 889– 899, Sep. 2014.
[14] Q. Z. Sheng, X. Qiao, A. V. Vasilakos, C. Szaboa, S. Bournea, and X. Xu, “Web services composition: A decades overview,” Inf. Sci., vol. 280, pp. 218–238, Oct. 2014.

This article has been accepted for inclusion in a future issue of this journal. Content is final as presented, with the exception of pagination.

12

IEEE SYSTEMS JOURNAL

[15] Y. Wang and J. Vassileva, “Toward trust and reputation based Web service selection: A survey,” Int. Trans. Syst. Sci. Appl., vol. 3, no. 9, pp. 118–132, 2007.
[16] Y. Vanrompay, P. Rigole, and Y. Berbers, “Genetic algorithm-based optimization of service composition and deployment,” in Proc. 3rd Int. Workshop Services Integr. Pervasive Environ., New York, NY, USA, 2008, pp. 13–18.
[17] X. Wu, X. Xiong, J. Ying, and C. Yu, “QoS-driven global optimization approach for large-scale Web services composition,” J. Comput., vol. 6, no. 7, pp. 1452–1460, 2011.
[18] N. Sasikaladevi and L. Arockiam, “Genetic approach for service selection problem in composite Web service,” Int. J. Comput. Appl., vol. 44, no. 4, pp. 22–29, 2012.
[19] M. Chen and S. Ludwig, “Fuzzy-guided genetic algorithm applied to the Web service selection problem,” in Proc. IEEE Int. Conf. Fuzzy Syst., 2012, pp. 1–8.
[20] W. Yang et al., “A hybrid particle swarm optimization algorithm for service selection problem in the cloud,” Int. J. Grid Distrib. Comput., vol. 7, no. 4, pp. 1–10, 2014.
[21] F. Chen, R. Dou, M. Li, and H. Wu, “A ﬂexible QoS-aware Web service composition method by multi-objective optimization in cloud manufacturing,” Comput. Ind. Eng., vol. 99, pp. 423–431, 2016.
[22] Z. Z. Liu, D. H. Chu, Z. P. Jia, J. Shen, and L. Wang, “Two-stage approach for reliable dynamic Web service composition,” Knowl.-Based Syst., vol. 97, pp. 123–143, 2016.
[23] Y. Chen, J. Huang, C. Lin, and J. Hu, “A partial selection methodology for efﬁcient QoS-aware service composition,” IEEE Trans. Services Comput., vol. 8, no. 3, pp. 384–397, May 2015.
[24] M. Zhang, R. Ranjan, M. Menzel, S. Nepal, P. Strazdins, W. Jie, and L. Wang, “An infrastructure service recommendation system for cloud applications with real-time QoS requirement constraints,” IEEE Syst. J., to be published.
[25] T. Wu, W. Dou, C. Hu, and J. Chen, “Service mining for trusted service composition in cross-cloud environment,” IEEE Syst. J., to be published.
[26] M. Alrifai, T. Risse, and W. Nejdl, “A hybrid approach for efﬁcient Web service composition with end-to-end QoS constraints,” ACM Trans. Web, vol. 6, no. 7, 2012, Art. no. 7.
[27] Z. Ye, X. Zhou, and A. Bouguettaya, “Genetic algorithm based QoSaware service compositions in cloud computing,” in Database Systems for Advanced Applications. Berlin, Germany: Springer, 2011, pp. 321–334.
[28] A. Jula, Z. Othman, and E. Sundararajan, “A hybrid imperialist competitive gravitational attraction search algorithm to optimize cloud service composition,” in Proc. IEEE Workshop Memetic Comput., 2013, pp. 37– 43.
[29] Z. Zheng, X. Wu, Y. Zhang, M. Lyu, and J. Wang, “QoS ranking prediction for cloud services,” IEEE Trans. Parallel Distrib. Syst., vol. 24, no. 6, pp. 1213–1222, Jun. 2013.
[30] E. Yokoo, “Distributed constraint satisfaction for formalizing distributed problem solving,” in Proc. Int. Conf. Distrib. Comput. Syst., Yokohama, Japan, 1992, pp. 614–621.
[31] Y. Hirayama and M. Yokoo, “Distributed partial constraint satisfaction problem,” in Proc. Int. Conf. Principles Practice Constraint Program., 1997, pp. 222–236.
[32] R. Mailler and V. Lesser, “Solving distributed constraint optimization problems using cooperative mediation,” in Proc. 3rd Int. Joint Conf. Auton. Agents Multiagent Syst., Jul. 2004, pp. 438–445.
[33] W. Zhang, G. Wang, Z. Xing, and L. Wittenburg, “Distributed stochastic search and distributed breakout: Properties, comparison and applications to constraint optimization problems in sensor networks,” Artif. Intell., vol. 161, nos. 1/2, pp. 55–87, Jan. 2005.
[34] R. Junges and A. L. C. Bazzan, “Evaluating the performance of DCOP algorithms in a real world, dynamic problem,” in Proc. 7th Int. Joint Conf. Auton. Agents Multiagent Syst., 2008, pp. 599–606.
[35] S. Krco, B. Pokric, and F. Carrez, “Designing IoT architecture (s): A European perspective,” in Proc. IEEE World Forum InternetThings, 2014, pp. 79–84.
[36] A. Al-Fuqaha, M. Guizani, M. Mohammadi, M. Aledhari, and M. Ayyash, “Internet of things: A survey on enabling technologies, protocols and applications,” IEEE Commun. Surv. Tuts., vol. 17, no. 4, pp. 2347–2376, Fourth Quarter 2015.
[37] R. Khan, S. U. Khan, R. Zaheer, and S. Khan, “Future Internet: The internet of things architecture, possible applications and key challenges,” in Proc. 10th Int. Conf. Frontiers Inf. Technol., 2012, pp. 257–260.
[38] Z. Yang, Y. Peng, Y. Yue, X. Wang, Y. Yang, and W. Liu, “Study and application on the architecture and key technologies for IOT,” in Proc. Int. Conf. Multimedia Technol., 2011, pp. 747–751.

[39] M. Wu, T.-L. Lu, F.-Y. Ling, L. Sun, and H.-Y. Du, “Research on the architecture of internet of things,” in Proc. 3rd Int. Conf. Adv. Comput. Theory Eng., 2010, vol. 5, pp. V5-484–V5-487.
[40] R. T. Fielding, “Architectural styles and the design of network-based software architectures,” Ph.D. dissertation, Univ. California, Irvine, CA, USA, 2000.
[41] P. Saint-Andre, “Extensible messaging and presence protocol (XMPP): Core,” IETF, Request for Comment 6120, Mar. 2011. [Online]. Available: http://www.ietf.org/rfc/rfc6120.txt
[42] Yachir, “Composition dynamique de services sensibles au contexte dans les syste`mes intelligents ambiants,” Ph.D. dissertation, Univ. Sci. Technol. Houari Boumediene, Bab Ezzouar, Algeria/Univ. Paris-Est Cre´teil, Cre´teil, France, 2013.
[43] A. Petcu, “A class of algorithms for distributed constraint optimization,” Ph.D. dissertation, Ecole Polytechnique Federale de Lausanne, Lausanne, Switzerland, 2007.
[44] Z. Collin, “Self-stabilizing depth-ﬁrst search,” Inf. Process. Lett., vol. 49, no. 6, pp. 301–305, 1994.
[45] A. Netzer, A. Grubshtein, and A. Meisels, “Concurrent forward bounding for distributed constraint optimization problems,” Artif. Intell., vol. 193, pp. 186–216, 2012.
Nacera Temglit received the Eng. degree and Postgraduate degree “Magister” from Science and Technology University Houari Boumediene (USTHB), Bab Ezzouar, Algeria. She is currently working toward the Ph.D. degree at the Computer Engineering Laboratory, USTHB, and the Laboratory of Images, Signals and Intelligent Systems, University of Paris Est-Cre´teil, Cre´teil, France.
She was a Research Engineer with the Research Center on Scientiﬁc and Technical Information, Algiers, Algeria. She is an Assistant Professor “Maitre Assistant” with the National High School for Computer Science (ESI), Algiers. Her research interests include modeling, composing, and optimization of Web services in ubiquitous environment.
Abdelghani Chibani received the M.Sc. degree from Paris 6 UMPC University, Paris, France, and the Ph.D. degree from Paris-12 (UPEC) University, Paris, both in computer science.
He is an Associate Professor with University Paris Est-Cre´teil, Cre´teil, France, where he is also a Project Manager with the Laboratory of Images, Signals and Intelligent Systems. Since 2005, he has been a Principal Investigator involved with more than 13 EU projects including leadership of large pilots. His research interests include services composition, context awareness, and multiagent systems for ubiquitous computing, Internet of Things, and cloud robotics.
Dr. Chibani was the recipient of the Gold Award in 2011 for the best achievement of the ITEA2 MULTIPOL EU project on multidomain semantic policy management.
Karim Djouani is a Professor, Scientist, and Technical Group Supervisor of soft computing, telecommunication, networking systems, and Robotics. Since January 2011, he has been a Full Professor with University Paris Est-Cre´teil, Cre´teil, France, and Tshwane University of Technology (TUT), Pretoria, South Africa. From July 2008 to December 2010, he was seconded by the French Ministry of Higher Education to the French South African Institute of Technology, TUT. He was also a Manager of national and European projects with the Laboratory of Images, Signals and Intelligent Systems, University of Paris EstCre´teil. He is the SARChI Chair in Enabled Environment and Assistive Living at TUT. He has authored or co-authored more than 200 papers in archival journals and conference proceedings. His research interests include the development of novel and highly efﬁcient algorithms for reasoning systems with uncertainty as well as optimization, for distributed systems, networked control systems, wireless ad-hoc network, wireless and mobile communication, and wireless sensors networks as well as robotics.
Mohamed Ahmed Nacer received the Ph.D. degree in computer science from the High School, Polytechnic National Institute, Grenoble, France, in 1994.
He is a Full Professor with Science and Technology University Houari Boumediene, Bab Ezzouar, Algeria, where he is in charge of the software engineering team of the Computer Engineering Laboratory. His current research interests include process modeling, software-architecture-based components, knowledge management, and Web services.

