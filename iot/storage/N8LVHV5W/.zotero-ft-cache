AVERTISSEMENT
Ce document est le fruit d'un long travail approuvé par le jury de soutenance et mis à disposition de l'ensemble de la communauté universitaire élargie.
Il est soumis à la propriété intellectuelle de l'auteur. Ceci implique une obligation de citation et de référencement lors de l’utilisation de ce document.
D'autre part, toute contrefaçon, plagiat, reproduction illicite encourt une poursuite pénale.
Contact : ddoc-theses-contact@univ-lorraine.fr
LIENS
Code de la Propriété Intellectuelle. articles L 122. 4 Code de la Propriété Intellectuelle. articles L 335.2- L 335.10 http://www.cfcopies.com/V2/leg/leg_droi.php http://www.culture.gouv.fr/culture/infos-pratiques/droits/protection.htm

E´cole doctorale IAEM Lorraine

E´valuation et am´elioration des plates-formes logicielles pour r´eseaux de capteurs sans-ﬁl, pour optimiser la
qualit´e de service et l’´energie

THE` SE
pr´esent´ee et soutenue publiquement le 3 juin 2016 pour l’obtention du
Doctorat de l’Universit´e de Lorraine
(mention informatique) par
K´evin Roussel

Composition du jury

Pr´esident :

Franc¸ois Charpillet

Directeur de Recherches INRIA

Rapporteurs : Thierry Val Thomas No¨el

Professeur des Universit´es Professeur des Universit´es

Examinateurs : Thomas Watteyne Emmanuel Baccelli

Charg´e de Recherches INRIA Charg´e de Recherches INRIA

Encadrants :

Ye-Qiong Song Olivier Zendra

Professeur des Universit´es Charg´e de Recherches INRIA

Invit´e :

Jean-Philippe Blanchard Responsable du Pˆole Innovation du Cr´edit Agricole S.A.

INRIA Nancy Grand-Est Laboratoire Lorrain de Recherche en Informatique et ses Applications — UMR 7503

Version 3.1416 du 30 juin 2016
Mis en page avec la classe thesul.

i
À mes parents, À mes grand-parents.

iii
Remerciements
Je tiens, dans la présente section, à exprimer toute ma gratitude envers tous ceux qui ont permis, directement ou indirectement, à ce travail de thèse de Doctorat d’arriver à son terme.
Je remercie donc tout d’abord le Professeur Ye-Qiong SONG, et le Docteur Olivier ZENDRA, mes encadrants, qui m’ont supporté à tout point de vue durant toute la durée de cette thèse, « contre vents et marées » pourrait-on dire.
J’adresse également ma profonde reconnaissance aux Professeurs Thierry VAL et Thomas NOËL, pour l’œil exigeant mais également bienveillant avec lequel ils ont accepté d’évaluer les présents travaux de thèse. Ma reconnaissance va aussi aux Docteurs Thomas WATTEYNE et Emmanuel BACCELLI, ainsi qu’au Professeur François CHARPILLET pour l’intérêt qu’ils ont bien voulu porter aux dits travaux, respectivement en tant qu’examinateurs et président du jury de soutenance.
Je remercie aussi l’équipe Madynes, ses dirigeants (Olivier FESTOR puis Isabelle CHRISMENT) et tous ses membres pour leur compréhension et leurs encouragements dans les moments diﬃciles qui sont régulièrement survenus lors de cette période.
Je me dois également d’exprimer ma reconnaissance au Service des Ressources Humaines de l’INRIA au sein duquel s’est déroulée la présente thèse, notamment François THAVEAU et Patricia VENTURIN, et toutes les personnes intervenues à la demande de ces derniers pour me sortir de l’impasse : il s’agit notamment du Dr. Marie-Hélène GLOC (médecin du travail) et Rachel GRÉGOIRE (assistante sociale), ainsi que des membres du cabinet parisien ARIHM. Parmi ces derniers, j’adresse mes respectueux remerciements au Dr. Gisèle BIRCK pour son écoute et ses conseils, et surtout ma reconnaissance amicale à Timy CASSEREAU pour sa présence, son soutien et sa conﬁance sans failles et sans interruptions.
Plus généralement, je dois également mes remerciements à l’Université de Lorraine et plus précisément au LORIA où s’est déroulée cette thèse, sans qui rien n’aurait bien évidemment été possible. J’adresse également mes remerciements particuliers au Dr. Jean-Philippe BLANCHARD, coordinateur du projet LAR qui a ﬁnancé ma thèse, et n’a jamais ménagé ses eﬀorts mais aussi sa sympathie et son énergie durant toute la durée du dit projet.
J’adresse également mes sentiments amicaux et reconnaissants aux confrères, doctorants et ingénieurs, qui m’ont cotoyé, soutenu et souvent encouragé durant ces trois années, entre autres : Élian AUBRY, Abdallah DIB, François DESPAUX, Iñaki FERNÁNDEZ PÉREZ, Éric FINICKEL, Gaëtan HUREL, Anthéa MAYZAUD, Saïd SEDDIKI, Wazen SHBAIR, Mohamed TLIG, Evangelia TSIONTSIOU, Shouguo ZHUO. . . ainsi que tous les amis moniteurs de l’ENSEM. Je ne vous oublie pas, et vous souhaite bonne chance (pour ceux qui doivent encore ﬁnir leur propre thèse) et bonne continuation et succès (à tous).
Enﬁn, j’adresserai les dernières paroles de cette section à mes parents et à feu mes grands-parents, à qui cette thèse est dédiée. Puissent ces modestes travaux vous apporter un peu de ﬁerté, comme je souhaite qu’ils apportent quelques avancées — aussi modestes soient-elles — à la science et à l’informatique.

v

Sommaire

Table des ﬁgures

xi

Liste des tableaux

xv

1 Introduction

1

2 Contexte et problématique

7

2.1 Réseaux de capteurs et actionneurs sans-ﬁl . . . . . . . . . . . . . . . 7

2.1.1 Déﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7

2.1.2 Constitution d’une “mote” . . . . . . . . . . . . . . . . . . . . 8

2.1.3 Les réseaux de capteurs sans-ﬁl et leur traﬁc . . . . . . . . . . 10

2.1.4 Spéciﬁcités des WSN . . . . . . . . . . . . . . . . . . . . . . . 12

2.2 La Qualité de Service (QdS) . . . . . . . . . . . . . . . . . . . . . . . 14

2.2.1 Notion de QdS . . . . . . . . . . . . . . . . . . . . . . . . . . 14

2.2.2 Critères de QdS . . . . . . . . . . . . . . . . . . . . . . . . . . 15

2.2.3 Stratégies d’assurance de la QdS . . . . . . . . . . . . . . . . 15

2.2.4 Niveaux de service . . . . . . . . . . . . . . . . . . . . . . . . 16

2.2.5 QdS dans les réseaux de capteurs sans-ﬁl . . . . . . . . . . . . 16

2.3 Applications des WSN (et de l’IoT) . . . . . . . . . . . . . . . . . . . 17

2.4 Contexte . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19

2.4.1 Applications d’e-santé des WSN . . . . . . . . . . . . . . . . . 19

2.4.2 Le projet LAR . . . . . . . . . . . . . . . . . . . . . . . . . . 19

2.5 Problématique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21

2.5.1 Exposé de la problématique . . . . . . . . . . . . . . . . . . . 21

2.5.2 Stratégie préconisée . . . . . . . . . . . . . . . . . . . . . . . 21

vii

viii

Sommaire

3 Analyse critique de l’état de l’art

25

3.1 Le protocole IEEE 802.15.4 . . . . . . . . . . . . . . . . . . . . . . . 25

3.1.1 Couche physique . . . . . . . . . . . . . . . . . . . . . . . . . 26

3.1.2 Couche MAC . . . . . . . . . . . . . . . . . . . . . . . . . . . 29

3.2 Protocoles MAC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34

3.2.1 Protocoles MAC synchrones . . . . . . . . . . . . . . . . . . . 35

3.2.2 Protocoles MAC asynchrones LPL . . . . . . . . . . . . . . . 37

3.2.3 Protocoles MAC asynchrones LPP . . . . . . . . . . . . . . . 40

3.2.4 Protocoles MAC à ordonnancement temporel . . . . . . . . . 43

3.2.5 Protocoles MAC multicanaux . . . . . . . . . . . . . . . . . . 45

3.2.6 Protocoles hybrides avancés . . . . . . . . . . . . . . . . . . . 46

3.2.7 Discussion : les protocoles MAC / RDC . . . . . . . . . . . . 60

3.3 Systèmes d’exploitation dédiés . . . . . . . . . . . . . . . . . . . . . . 61

3.3.1 Rappels sur les notions de multi-tâche . . . . . . . . . . . . . 61

3.3.2 TinyOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63

3.3.3 Contiki . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65

3.3.4 Nano-RK . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66

3.3.5 RIOT OS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68

3.3.6 Autres OS spécialisés . . . . . . . . . . . . . . . . . . . . . . . 70

3.3.7 OS temps-réel classiques / généralistes . . . . . . . . . . . . . 72

3.3.8 Discussion : les systèmes d’exploitation dédiés . . . . . . . . . 74

3.4 Conclusion : protocoles MAC / RDC et OS spécialisés . . . . . . . . 75

4 Plates-formes logicielles : évaluation, problèmes et améliorations 79 4.1 Contiki : développement et limitations . . . . . . . . . . . . . . . . . 79 4.1.1 Documentation minimaliste . . . . . . . . . . . . . . . . . . . 80 4.1.2 Limitations techniques . . . . . . . . . . . . . . . . . . . . . . 81 4.1.3 Fonctionnalités temps-réel insuﬃsantes . . . . . . . . . . . . . 86 4.2 RIOT OS : découverte et contributions . . . . . . . . . . . . . . . . . 87 4.2.1 La plate-forme logicielle RIOT OS . . . . . . . . . . . . . . . 87 4.2.2 Contributions au projet RIOT OS . . . . . . . . . . . . . . . 88 4.2.3 Évolution du système RIOT OS . . . . . . . . . . . . . . . . . 95 4.3 La nouvelle pile réseau de RIOT : une analyse critique . . . . . . . . 95 4.3.1 Description . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95

ix

4.3.2 Avantages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98 4.3.3 Inconvénients et manques . . . . . . . . . . . . . . . . . . . . 99 4.3.4 Discussion : la pile « gnrc » . . . . . . . . . . . . . . . . . . . 100 4.4 Discussion : plates-formes logicielles, contributions et conclusions . . 101

5 Évaluation et comparaison des implantations de deux protocoles

MAC / RDC : ContikiMAC et S-CoSenS

103

5.1 Premières plates-formes matérielles . . . . . . . . . . . . . . . . . . . 103

5.2 Implantation de S-CoSenS sous RIOT OS : précision de la

synchronisation entre noeuds . . . . . . . . . . . . . . . . . . . . . . 105

5.3 Évaluation des performances : comparaison avec ContikiMAC . . . . 109

5.3.1 Conﬁguration des expériences . . . . . . . . . . . . . . . . . . 109

5.3.2 Taux de réception des paquets . . . . . . . . . . . . . . . . . 110

5.3.3 Délai total (« de bout-en-bout ») de transmission des trames 114

5.3.4 Consommation d’énergie : “Duty Cycles” . . . . . . . . . . . . 117

5.3.5 Stabilité et contraintes mémoire . . . . . . . . . . . . . . . . . 120

5.3.6 Inﬂuence de l’optimisation des implantations . . . . . . . . . 121

5.3.7 Comparaison avec essais sur matériel . . . . . . . . . . . . . . 123

5.4 Améliorations potentielles des protocoles MAC /RDC . . . . . . . . 125

5.4.1 Propositions d’améliorations algorithmiques . . . . . . . . . . 125

5.4.2 Évaluation de ces propositions : diﬃcultés et inadéquation des

simulations . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127

5.5 Discussion : évaluation et comparaison de protocoles MAC / RDC,

contributions et conclusion . . . . . . . . . . . . . . . . . . . . . . . . 132

6 Validation des expérimentations sur plates-formes réelles

135

6.1 Motivation : limitations et inexactitudes des simulations . . . . . . . 136

6.1.1 Rappels sur Cooja et MSPSim . . . . . . . . . . . . . . . . . 136

6.1.2 Inexactitudes des délais sous MSPSim . . . . . . . . . . . . . 138

6.1.3 Risques et conséquences potentiels . . . . . . . . . . . . . . . 143

6.1.4 Discussion : limites des simulations et émulations . . . . . . . 146

6.2 Validation sur matériel : moyens et objectifs . . . . . . . . . . . . . . 148

6.2.1 Besoins en instrumentation . . . . . . . . . . . . . . . . . . . 148

6.2.2 Choix de plate-forme matérielle . . . . . . . . . . . . . . . . . 149

6.2.3 Travaux de validations prévus et contributions attendues . . . 150

x

Sommaire

6.3 Travaux et mise en œuvre . . . . . . . . . . . . . . . . . . . . . . . . 151 6.3.1 Amélioration du pilote radio : proposition d’API étendue . . 151 6.3.2 Problèmes techniques rencontrés . . . . . . . . . . . . . . . . 154 6.3.3 Situation actuelle . . . . . . . . . . . . . . . . . . . . . . . . . 163
6.4 Discussion : validation, contributions et conclusion . . . . . . . . . . 164

7 Conclusions et perspectives

167

7.1 Conclusions générales . . . . . . . . . . . . . . . . . . . . . . . . . . . 167

7.2 Contributions de la thèse : résumé . . . . . . . . . . . . . . . . . . . 169

7.3 Perspectives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171

7.3.1 Perspectives à court terme . . . . . . . . . . . . . . . . . . . . 171

7.3.2 Perspectives à long terme . . . . . . . . . . . . . . . . . . . . 173

A Publications et Réalisations

175

Bibliographie

179

Glossaire

191

Table des ﬁgures
2.1 Schéma fonctionnel d’une mote WSN / IoT classique. . . . . . . . . . 9 2.2 Principales catégories d’application des réseaux de capteurs sans-ﬁl.
Source : [Akyildiz and Vuran, 2010], ﬁgure 2.1. . . . . . . . . . . . . 17
3.1 Comparaison entre la pile 802.15.4 et les piles OSI et Internet. . . . . 26 3.2 Schéma topologique d’un réseau de capteurs sans-ﬁl (WSN). (D’après
[Song, 2013]) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 3.3 Organigramme de l’algorithme de la méthode CSMA/CA. (Source :
[IEEE 802.15.4, 2011], ﬁgure 11) . . . . . . . . . . . . . . . . . . . . 32 3.4 Cycle de fonctionnement du protocole MAC du standard IEEE 802.15.4
en mode “beacon”. (Source : [Huang et al., 2013]) . . . . . . . . . . . 33 3.5 Adaptative listening entre trois noeuds suivant le protocole S-MAC.
(D’après [Song, 2013]) . . . . . . . . . . . . . . . . . . . . . . . . . . 36 3.6 Comparaison du fonctionnement de S-MAC et T-MAC. (D’après [Song,
2013]) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 3.7 Schéma de fonctionnement de B-MAC (protocole LPL typique). (D’après
[Song, 2013]) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 3.8 Schéma de fonctionnement du protocole X-MAC. (D’après [Song, 2013]) 39 3.9 Fonctionnement du protocole ContikiMAC. (D’après [Song, 2013]) . 40 3.10 Survenue de « collisions cachées » entre deux paires de noeuds menant
chacune une transmission distincte, empêchant la réussite des deux communications. (D’après [Song, 2013] et [Sun et al., 2008]) . . . . . 41 3.11 Principe de transmission de données entre un noeud émetteur (A ou S) et un noeud récepteur (B ou R), selon la méthode RI-LPP (ReceiverInitiated Low Power Probing). (Source : [Song, 2013] et [Huang et al., 2013]) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42 3.12 Illustration de la méthode BEB (Binary Exponential Backoﬀ) employée par RI-MAC pour résoudre les problèmes de collisions dûs à l’envoi simultané de trames par plusieurs émetteurs. (Source : [Song, 2013] d’après [Sun et al., 2008]) . . . . . . . . . . . . . . . . . . . . . 42 3.13 Comparaison entre protocoles “Receiver-Initiated” (LPP) et “SenderInitiated” (LPL) face à la montée en charge du traﬁc réseau. (Source : [Song, 2013] d’après [Österlind et al., 2012]) . . . . . . . . . . . . . . 43
xi

xii

Table des ﬁgures

3.14 Comparaison de l’eﬃcacité entre méthodes basée sur la contention (CSMA) et sur l’ordonnancement (TDMA) en fonction du débit réseau. (Source : [Song, 2013]) . . . . . . . . . . . . . . . . . . . . . . . 44
3.15 Principe de base du protocole CoSenS. (Source : [Nefzi, 2011]) . . . . 47 3.16 Principe d’un cycle de fonctionnement d’un noeud coordinateur S-CoSenS.
(D’après [Nefzi, 2011]) . . . . . . . . . . . . . . . . . . . . . . . . . . 49 3.17 Transmission d’une trame avec le protocole S-CoSenS. . . . . . . . . 50 3.18 Comparaison de la gestion de la montée en charge du traﬁc réseau
entre (1) un protocole uniquement basé sur la contention, et (2) iQueueMAC, qui a recours à une période basée sur TDMA de durée variable, adaptée à la charge réseau. (Source : [Song, 2013]) . . . . . . . . . . 51 3.19 Structure d’une trame iQueue-MAC. (Source : [Song, 2013]) . . . . . 52 3.20 Structure d’un “beacon” iQueue-MAC. (Source : [Song, 2013]) . . . . 52 3.21 Structure d’un cycle iQueue-MAC. (Source : [Song, 2013]) . . . . . . 53 3.22 Exemple de transmission de trames entre deux noeuds simples et un routeur avec le protocole iQueue-MAC. (Source : [Song, 2013]) . . . 53 3.23 Modiﬁcation du fonctionnement du protocole X-MAC par le mécanisme T-AAD. (Source : [Papadopoulos et al., 2014]) . . . . . . . . . 56 3.24 Fonctionnement du protocole avancé M-ContikiMAC, optimisé pour les noeuds mobiles des WSN. (Source : [Papadopoulos et al., 2015b]) 57 3.25 Fonctionnement du protocole avancé ME-ContikiMAC. (Source : [Papadopoulos et al., 2015b]) . . . . . . . . . . . . . . . . . . . . . . . . 58 3.26 Structure d’un cycle du protocole MaCARI. (Source : [Agha et al., 2009] ﬁgure 3) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59 3.27 Taxonomie des diﬀérents protocoles MAC conçus pour les réseaux de capteurs sans-ﬁl (travaux académiques). Source : [Huang et al., 2013] 61 3.28 Principe de base du traitement des évènements temps-réel par les diférents modèles de gestion multi-tâche. . . . . . . . . . . . . . . . . . 63
4.1 Représentation fonctionnelle des dépendances au sein de l’architecture de Contiki OS. (Source : [Udit, 2012]) . . . . . . . . . . . . . . . . . 85
5.1 Schéma fonctionnel de notre PAN virtuel de test. (Légende : R = noeud routeur ; S = “sink”) . . . . . . . . . . . . . . . . . . . . . . . 106
5.2 Copie d’écran d’une des simulations de notre premier jeu de tests sous Cooja. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
5.3 Zoom sur la partie centrale de la timeline de la ﬁgure 5.2 page 107. . 108 5.4 Résultats pour le taux de réception de paquets (PRR) pour un cycle
MAC / RDC de 8 Hz / 125 ms. . . . . . . . . . . . . . . . . . . . . . 111 5.5 Résultats pour le taux de réception de paquets (PRR) pour un cycle
MAC / RDC de 16 Hz / 62 ms. . . . . . . . . . . . . . . . . . . . . . 112 5.6 Résultats pour le taux de réception de paquets (PRR) pour un cycle
MAC / RDC de 32 Hz / 31 ms. . . . . . . . . . . . . . . . . . . . . . 112 5.7 Résultats combinés pour le taux de réception de paquets (TRP) avec
S-CoSenS, en fonction de la durée de la subframe. . . . . . . . . . . . 113

xiii
5.8 Résultats combinés pour le taux de réception de paquets (TRP) avec ContikiMAC, en fonction du channel check rate. . . . . . . . . . . . . 113
5.9 Résultats pour les délais moyens de transmission d’une trame pour un cycle MAC / RDC de 8 Hz / 125 ms. . . . . . . . . . . . . . . . . . . 114
5.10 Résultats pour les délais moyens de transmission d’une trame pour un cycle MAC / RDC de 16 Hz / 62 ms. . . . . . . . . . . . . . . . . . . 115
5.11 Résultats pour les délais moyens de transmission d’une trame pour un cycle MAC / RDC de 32 Hz / 31 ms. . . . . . . . . . . . . . . . . . . 115
5.12 Résultats combinés pour les délais moyens de transmission d’une trame avec S-CoSenS, en fonction de la durée de la subframe. . . . . . . . . 116
5.13 Résultats combinés pour les délais moyens de transmission d’une trame avec ContikiMAC, en fonction du channel check rate. . . . . . . . . . 116
5.14 Comparaison de l’activité radio (duty cycle) sur les noeuds routeurs fonctionnant respectivement sous ContikiMAC et S-CoSenS, avec des subframes de 31 ms. . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
5.15 Comparaison de l’activité radio (duty cycle) sur les noeuds-feuilles fonctionnant respectivement sous ContikiMAC et S-CoSenS, avec des subframes de 31 ms. . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
5.16 Résultats obtenus pour le taux de réception de paquets (TRP) avec S-CoSenS, en fonction de la durée de la subframe, sur des motes IoTLAB WSN430. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
5.17 Résultats obtenus pour les délais moyens de transmission d’une trame avec S-CoSenS, en fonction de la durée de la subframe, sur des motes IoT-LAB WSN430. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
5.18 Inﬂuence du mécanisme de “phase lock” sur l’activité radio (duty cycle) induite par S-CoSenS, avec des subframes de 31 ms. . . . . . . . . . . 129
5.19 Inﬂuence du mécanisme de “phase lock” sur l’activité radio (duty cycle) induite par S-CoSenS et ContikiMAC, avec respectivement des subframes de 125 ms et des CCI de 8 Hz. . . . . . . . . . . . . . . . . . 131
6.1 Schéma fonctionnel de notre seconde conﬁguration de test. (Cette topologie est reprise de la publication [Zhuo et al., 2013] en ﬁgure 15.) 151
6.2 Diagramme complet de la machine à états ﬁnis de l’AT86RF231. (Source : [DataSheet AT86RF231, 2009] ﬁgure 7-8.) . . . . . . . . . . 155
6.3 Schéma logique de l’interface entre MCU et AT86RF231 sur une mote IoT-LAB M3. (D’après [DataSheet AT86RF231, 2009] ﬁgure 6-1.) . . 156
6.4 Disposition physique du PAN de test employé sur IoT-LAB (noeuds de type M3). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
7.1 Capture d’écran d’un “sniﬀer” de paquets Zigbee / 802.15.4 lors de l’exécution de RIOT avec le module csma_sender. (Crédit : Shuguo Zhuo, travail en cours.) . . . . . . . . . . . . . . . . . . . . . . . . . . 172

Liste des tableaux
2.1 Comparaison entre réseaux traditionnels et WSN. (d’après [Dargie and Poellabauer, 2010] table 1.2) . . . . . . . . . . . . . . . . . . . . . . . 13
3.1 Principales plates-formes logicielles utilisables en 2015 dans le cadre des réseaux de capteurs sans-ﬁl. . . . . . . . . . . . . . . . . . . . . . 76
4.1 Liste des fonctions des pilotes radio nouvelle génération (« gnrc »). . 96 4.2 Liste des évènements radio interceptables (« gnrc »). . . . . . . . . . 96 4.3 Liste des options — « capacités » potentielles — des émetteurs / récepteurs
radio (« gnrc »). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97 4.4 Liste des erreurs potentiellement renvoyées (« gnrc »). . . . . . . . . 98
5.1 Débits réseaux utiles programmés sur l’ensemble des noeuds-feuilles. 109 5.2 Statistiques de duty cycle pour ContikiMAC. . . . . . . . . . . . . . 118 5.3 Statistiques de duty cycle pour S-CoSenS. . . . . . . . . . . . . . . . 118 5.4 Delais observés pour le chargement d’une trame de 110 octets dans le
buﬀer d’envoi de la radio CC2420 d’une mote Zolertia Z1, en fonction de l’OS et de l’implantation du pilote SPI. . . . . . . . . . . . . . . . 122 5.5 Statistiques de duty cycle pour S-CoSenS avec optimisation de type “phase-lock” au niveau des noeuds-feuilles. . . . . . . . . . . . . . . . 129 5.6 Statistiques de duty cycle pour ContikiMAC avec un cycle long : CCI de 8 Hz (valeur par défaut), soit un cycle de 125 ms. . . . . . . . . . 130 5.7 Statistiques de duty cycle pour S-CoSenS au niveau des noeuds-feuilles, avec une subframe longue de 125 ms. . . . . . . . . . . . . . . . . . . 130
6.1 Delais observés par le chargement d’un paquet de 110 octets dans le buﬀer d’envoi de la radio CC2420 d’une mote Zolertia Z1, en fonction de l’OS et de l’implantation du pilote SPI, par simulation et par expérimentation sur matériel. . . . . . . . . . . . . . . . . . . . . . . 136
6.2 Delais observés pour le chargement d’un paquet dans le buﬀer d’envoi du CC2420 d’une mote SkyMote/TelosB, avec diﬀérentes conﬁgurations logicielles. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140
6.3 Delais observés pour le chargement d’un paquet dans le buﬀer d’envoi du CC2420 d’une mote Zolertia Z1, avec diﬀérentes conﬁgurations logicielles. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
xv

xvi

Liste des tableaux

6.4 Poids relatif du chargement du buﬀer d’envoi de l’émetteur / récepteur radio dans le temps de transmission d’un paquet. . . . . . . . . . . . 144
6.5 Liste des fonctions de l’API complémentaires de « capacités ». . . . . 152 6.6 Liste des paramètres rajoutés par l’API complémentaires de « capa-
cités ». . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153 6.7 Liste des erreurs pouvant être retournées par les fonctions de l’API
complémentaires de « capacités ». . . . . . . . . . . . . . . . . . . . . 153 6.8 Types d’interruptions de l’AT86RF231. (Source : [DataSheet AT86RF231,
2009] table 6-9.) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157 6.9 Nombre de trames envoyées avec succès par chaque noeud-feuille, sur
500 envoyés. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160

Chapitre 1
Introduction
Les capteurs et actionneurs sans-ﬁl (“Wireless Sensors and Actuators”) — qui sont l’objet même des travaux de cette thèse — sont en fait des « nano-ordinateurs » embarqués, regroupant unité centrale, interface réseau sans-ﬁl (radio), et divers périphériques leur permettant d’interagir avec leur environnement (capteurs et actionneurs), sur une carte électronique dont la taille ne dépasse en général pas celle d’une carte de crédit.
Une de leur spéciﬁcités majeures est de dépendre de batteries (piles ou autres) pour leur alimentation. Cette batterie étant parfois diﬃcile voire impossible à changer, ces nano-ordinateurs doivent être conçus et programmés pour minimiser au maximum leur consommation d’énergie : leur durée de fonctionnement, et parfois même leur durée de vie, en dépend.
Ces nano-ordinateurs sont couramment appelés capteurs sans-ﬁl — les appareils équipés d’actionneurs étant nettement moins nombreux et utilisés —, nœuds ou par le terme anglo-saxon “mote”.
Le terme de « noeud » est ici particulièrement révélateur, car ces appareils sont par nature destinés à fonctionner en réseau, via le médium radio. Ce sont ces réseaux de noeuds qui sont appelés Réseaux de Capteurs Sans-Fil (“Wireless Sensor Networks” ou WSN, selon le terme anglo-saxon).
L’architecture et le fonctionnement de ces capteurs sans-ﬁl et de leurs réseaux, et les déﬁs qu’ils posent, seront déﬁnis et expliqués de façon détaillée en section 2.1.1 page 7 du prochain chapitre.
Ces réseaux de capteurs sans-ﬁl, en s’interconnectant entre eux et avec les réseaux globaux (WAN : Wide Area Network ), ont permis l’apparition de la notion plus récente d’Internet des Objets (IoT : Internet of Things), « organisme » dont ils constituent les cellules.
Il s’agit à l’heure actuelle d’un sujet de recherche et de développement extrêmement vaste, actif et prometteur. Le développement rapide de cet IoT permet l’apparition et la mise en place d’une multitude d’applications nouvelles.
Ces applications, de plus en plus variées, riches et complexes, augmentent encore l’intérêt de plates-formes logicielles (c’est-à-dire de systèmes d’exploitation, en anglais “Operating System” : OS) ﬁables, fonctionnelles, performantes et adaptées aux noeuds de ces WSN constituant le fondement de l’IoT.
1

2

Chapitre 1. Introduction

Les domaines d’application des réseaux de capteurs sans-ﬁl, et par extension de l’Internet des Objets, sont extrêmement étendus. Deux livres [Dargie and Poellabauer, 2010] [Akyildiz and Vuran, 2010] détaillent diﬀérentes applications déjà existantes et exploitées.
On peut notamment citer : — des applications militaires, — des applications industrielles, — des applications environnementales, — des applications domotiques, — des applications à la santé. Ces deux derniers domaines d’application des WSN sont ceux auxquels nous nous intéressons spéciﬁquement dans la présente thèse. Nous disposons notamment, au LORIA / INRIA Nancy Grand-Est, d’un projet d’appartement intelligent pour l’assistance à la personne [LORIA / INRIA Nancy Grand-Est, 2009]. Ce projet, constamment en cours de développement et de perfectionnement, est utilisé de façon intensive par les diﬀérentes équipes de recherche du site, pour le développement et le test d’applications diverses, aussi bien académiques qu’industrielles, principalement pour l’aide au maintien à domicile des personnes âgées et / ou dépendantes. Ce projet relève à la fois de l’application domotique et de l’application de santé, tout comme le projet LAR que nous allons détailler dans le chapitre 2.
Comme la plupart des systèmes informatiques connectés, les capteurs sans-ﬁl ont recours à des piles protocolaires pour gérer l’envoi et la réception de données. Dans leur cas, il s’agit d’émettre et de recevoir ces données sous forme de trames transmises sur le médium radio — par déﬁnition peu ﬁable, et souvent sujet à des perturbations. La plupart des WSN actuels accèdent au médium radio selon le standard IEEE 802.15.4 [IEEE 802.15.4, 2011].
Pour pallier les problèmes liés à l’instabilité de ce médium radio, de nombreux protocoles MAC (“Media Access Control”) ont été développés. Le protocole 802.15.4 en propose lui-même deux versions, mais leurs limitations ont poussé la communauté académique et industrielle à développer de nombreux protocoles alternatifs, basés sur des principes et des techniques diﬀérents.
Pour faciliter la programmation et l’exploitation de ces systèmes spéciaux que sont les capteurs sans-ﬁl, il existe des systèmes d’exploitation spéciﬁques, prenant en compte leurs spéciﬁcités : capacités très limitées, fonctionnement sur batterie faisant de la consommation énergétique un enjeu majeur, communication par radio. Nombre de ces plates-formes logicielles dédiées ont été conçues et sont exploitées à l’heure actuelle, mais les plus utilisés au moment où nous écrivons ces lignes sont Tiny OS [Levis et al., 2005] et surtout Contiki OS [Dunkels et al., 2004]. Ces plates-formes logicielles sont fournies avec leurs propres piles réseau intégrées, qui sont donc la cheville ouvrière du fonctionnement concret des communications sur les réseaux de capteurs sans-ﬁl.

3
Si de nombreux travaux de recherche ont, comme nous l’avons dit, été menés pour développer des protocoles MAC de plus en plus performants pour exploiter au mieux le médium radio et contourner ses limitations, tout en préservant au maximum les ressources énergétiques des capteurs sans-ﬁl, les résultats de ces travaux n’ont malheureusement guère été concrètement implantés et diﬀusés à l’heure actuelle dans les piles réseaux des systèmes d’exploitation spécialisés : celles-ci ne comportent le plus souvent que le protocole MAC du standard IEEE 802.15.4, plus éventuellement quelques protocoles simples et / ou anciens ne représentant nullement l’état de l’art en la matière.
La seule exception notable à cette situation est la présence en standard du protocole ContikiMAC [Dunkels, 2011] dans la pile réseau des versions récentes Contiki OS. Ce protocole, s’il est récent et performant, repose toutefois sur des principes de fonctionnement somme toute classiques (bien qu’optimisés) impliquant certaines limites. De nombreux travaux d’implantation de protocoles diﬀérents — notamment sur leurs principes de fonctionnement — restent encore à entreprendre.
Ainsi, à l’heure actuelle, les couches basses des piles réseau spécialisées pour les capteurs sans-ﬁl, notamment celles intégrées aux plates-formes logicielles dédiées, constituent un « goulot d’étranglement » pour la performance des communications entre motes, les couches MAC (et plus généralement les couches basses) semblant avoir été peu prioritaires dans les eﬀorts de développement et d’implantation des piles réseau des OS pour WSN.
Cette thèse a ainsi pour but de permettre d’obtenir des améliorations signiﬁcatives pour ces couches basses, tant sur le plan des performances que de l’optimisation de la consommation énergétique, via un eﬀort de recherche et d’implantation des piles réseau dédiées, notamment en exploitant au mieux les fonctionnalités oﬀertes par les plates-formes logicielles spécialisées dans les capteurs sans-ﬁl.
Si les OS les plus utilisés que sont Tiny OS [Levis et al., 2005] et Contiki OS [Dunkels et al., 2004] n’oﬀrent pas les fonctionnalités nécessaires, d’autres plates-formes logicielles moins répandues, mais plus performantes et récentes, oﬀrent notamment des mécanismes avancés de gestion des interruptions, un modèle multitâche préemptif, et des fonctionnalités temps-réel (notamment en exposant au mieux — via une API adaptée — les timers matériels présents dans les microntrôleurs équipant les capteurs sans-ﬁl). Ces fonctionnalités sont notamment très utiles pour améliorer la qualité de service (QdS) des réseaux. Parmi les systèmes pour capteurs sans-ﬁl offrant de telles capacités, on pourra entre autres citer Nano-RK [Eswaran et al., 2005] ou RIOT OS [Hahm et al., 2013].
Un autre mécanisme lié à l’OS particulièrement intéressant pour l’économie d’énergie est la présence d’un noyau fonctionnant en mode “tickless”, c’est-à-dire permettant de ne faire fonctionner l’appareil que quand cela est strictement nécessaire.
Nous nous proposons d’exploiter toutes ces fonctionnalités avancées oﬀertes par ces OS dédiés pour tenter d’implanter l’état de l’art en matière de protocoles MAC, et ainsi obtenir de meilleurs résultats en termes de performances de communication et d’économies d’énergie.

4

Chapitre 1. Introduction

Notons que pour des raisons juridiques aussi bien que techniques — possibilité de modiﬁer et d’améliorer le cœur et les diﬀérents composants du système selon nos besoins — nous n’envisagerons dans la présente thèse uniquement l’utilisation des systèmes d’exploitation — et plus généralement des logiciels — à licence libre et open source.

Objectifs
Les travaux de la présente thèse ont les principaux objectifs suivants :
1. Un état de l’art des diﬀérents protocoles MAC créés par la recherche académique ou industrielle, et surtout un passage en revue des principaux systèmes d’exploitation utilisés dans le cadre des réseaux de capteurs sans-ﬁl , en analysant leurs fonctionnalités, déterminant ainsi quels sont les mieux adaptés au développement de couches basses (notamment MAC) avancées et performantes.
2. Le choix de la plate-forme logicielle la mieux adaptée pour le développement de ces couches basses, avec notamment une analyse critique des piles réseau — notamment de l’API et des drivers radio— de ces plates-formes spécialisées (Contiki et RIOT OS).
3. Une implantation du protocole S-CoSenS sur le système RIOT OS — s’inscrivant dans un eﬀort plus global destiné à fournir une couche MAC performante à la pile réseau de cette plate-forme logicielle — suivi d’une comparaison avec l’implantation standard de ContikiMAC sur Contiki OS, notamment en présence d’un traﬁc réseau intense ; et enﬁn la proposition d’idées d’améliorations algorithmiques à apporter aux protocoles MAC .
4. La validation sur plates-formes réelles des résultats de nos expérimentations — eﬀectuées jusqu’alors par simulation / émulation — suite à la découverte d’un problème d’inexactitude temporelle dans l’outil de simulation Cooja / MSPSim, avec une analyse des problèmes rencontrés, et la fourniture d’autant de détails techniques et des pistes de résolution possibles pour aider à la résolution ultérieure des diﬃcultés rencontrées.

Structure
Le présent manuscrit de thèse est organisé de la façon suivante : — Après ce présent chapitre d’introduction, le chapitre 2 page 7 donne les déﬁ-
nitions techniques nécessaires à la bonne compréhension du sujet, développe les diﬀérentes applications possibles des WSN et de l’IoT, puis présente le contexte de la thèse, et enﬁn la problématique que celle-ci se propose de résoudre, en commençant à détailler nos pistes de travail. — Le chapitre 3 page 25 présente l’état de l’art sur le protocole IEEE 802.15.4 sur lequel reposent les réseaux de capteurs sans-ﬁl actuels ; une présentation des diﬀérents axes de recherche et des exemples signiﬁcatifs de protocoles MAC

5
développés par la communauté pour suppléer aux limitations du protocole MAC du standard 802.15.4 ; et enﬁn, nous faisons une première contribution sous la forme d’une revue (“survey”) des systèmes d’exploitation (OS) spécialisés dans le domaine des WSN, en détaillant sucessivement leurs points forts et leurs limitations, et par là-même leur adaptation au développement de protocoles MAC avancés et performants. — Le chapitre 4 page 79 détaille notre recherche d’une plate-forme logicielle (OS) adaptée à nos travaux de recherche sur les protocoles MAC à hautes performances, montre nos contributions au développement de la plate-forme performante et novatrice (RIOT OS) que nous avons choisie, et propose dans ce cadre une étude critique de sa nouvelle pile réseau de RIOT OS (« gnrc »). — Le chapitre 5 page 103 montre les résultats de nos premières expériences en comparant les implantations d’un protocole hybride, S-CoSenS, mis au point au sein de notre équipe, à celle du protocole ContikiMAC, référence largement utilisée dans la communauté. Ces comparaisons montrent en particulier le comportement de ces deux implantations de protocoles face à une montée en charge intensive du traﬁc réseau. Nous proposons également plusieurs techniques susceptibles d’améliorer la robustesse des protocoles MAC / RDC, notamment en complétant l’interface avec la couche 1 (pilotes des émetteurs / récepteurs radio) aﬁn d’inﬂuer dynamiquement sur des paramètres liés à l’écoute du médium. — Le chapitre 6 page 135 présente tout d’abord les inexactitudes d’ordre temporel que nous avons découvertes dans les résultats fournis par Cooja, l’un des simulateurs de WSN les plus utilisés ; nous y montrons nos contributions sous la forme d’une analyse des limitations de ce dernier comme outil d’évaluation de performances, et des conséquences possibles sur la validité et la justesse des travaux basés sur ces simulations (y compris nos propres travaux) ; nous fournissons enﬁn des pistes sérieuses quant aux causes du problème, et aux moyens de le contourner ou d’y remédier. Sont ensuite détaillés les travaux de validation prévus sur matériel pour valider de façon indiscutable nos précédentes expériences, ainsi que pour tester la montée en charge de S-CoSenS sur un réseau de forte taille. Nous continuons en décrivant nos premières expériences sur la plate-forme matérielle de test choisie, le testbed IoT-LAB. Nous détaillons enﬁn les problèmes techniques nous ayant empêché de terminer de mener à bien ces travaux, en tentant de fournir le maximum de pistes techniques pour faciliter leur résolution future. — Enﬁn, le chapitre 7 page 167 termine ce manuscrit de thèse en présentant nos conclusions générales, et en discutant des perspectives pouvant faire suite à nos travaux.

Chapitre 2
Contexte et problématique
2.1 Réseaux de capteurs et actionneurs sans-ﬁl
2.1.1 Déﬁnitions : technologie des réseaux de capteurs et actionneurs sans-ﬁl
Les avancées spectaculaires des dernières décennies en micro-électronique, notamment dans la domaine de la miniaturisation, de l’augmentation constante de la puissance des circuits intégrés, ainsi que dans le domaine de la communication sans-ﬁl — principalement par des moyens radio — ont permis l’émergence d’appareils électroniques miniatures (Microsystèmes électromécaniques : MEMS) capables d’interagir avec leur environnement physique, de traiter des données et de communiquer entre eux et avec d’autres systèmes informatiques sans besoin de recourir à des câbles (communication radio). Ces mêmes avancées de la technologie permettent la fabrication de tels appareils à de très faibles coûts.
Ces appareils miniatures portent le nom de capteurs / actionneurs sans-ﬁl — le terme « capteurs sans-ﬁl » étant le plus souvent utilisé pour désigner tous ces appareils, l’utilisation d’actionneurs agissant sur leur environnement étant à l’heure actuelle plus rare — et sont également souvent appelés par le terme anglais “motes”.
Une des principales spéciﬁcités de ces appareils est d’être alimentés par des batteries de faible puissance : piles AAA, ou piles « boutons » au lithium par exemple. L’énergie est donc un facteur très limitant sur une mote.
Ces appareils, lorsqu’ils sont connectés les uns aux autres, forment des réseaux de capteurs sans-ﬁl (WSN : Wireless Sensor Networks). Ces réseaux, utilisent à la base des technologies spéciﬁques — notamment un protocole radio dédié diﬀérent de celui, par exemple, des téléphones cellulaires ou du WiFi équipant les ordinateurs portables — oﬀrant en contrepartie d’une faible consommation énergétique un débit et une portée très limités. Les réseaux formés par ces motes sont nommés PAN (Personal Area Network), en référence à la très faible portée des émetteurs / récepteurs radio mis en action.
Une évolution plus récente dans le développement des WSN est l’emploi dans les couches supérieures de leur piles réseau, notamment la couche réseau (niveau 3), du
7

8

Chapitre 2. Contexte et problématique

protocole IPv6, adapté pour les appareils de faible puissance (6LoWPAN [Mulligan, 2007] : IPv6 over Low-power Wireless Personal Area Networks), permettant ainsi l’utilisation d’UDP ou d’ICMP pour la couche transport (niveau 4), et des applications basées sur des standards classiques d’internet comme HTTP. L’interconnection et la fusion des WSN avec les réseaux « classiques » composant Internet — réseau global ou WAN (Wide Area Network ) — a donné naissance à la notion d’Internet des Objets (IoT : Internet of Things) ; notion dont l’intérêt et les applications augmentent de façon exponentielle. Le développement et la diﬀusion de ces applications sont rendus d’autant plus faciles par le coût très faible de ces motes constituant les noeuds des WSN et donc de l’IoT.

2.1.2 Constitution d’une “mote”
La structure d’une mote peut être résumée par le schéma montré en ﬁgure 2.1 page ci-contre.
Les motes constituant les noeuds des WSN — et par extension de l’IoT — sont des appareils extrêmement compacts : ils sont conçus autour d’un circuit intégré central regroupant le processeur principal (CPU) et plusieurs périphériques de base intégrés : timers, convertisseurs A/D et D/A, contrôleurs E/S regroupant des broches à usage général, des bus SPI et I2C, etc. Ces circuits intégrés centraux sont appelés microcontrôleurs (MCU : Micro Controller Unit).
Il faut être bien conscient que ces MCU disposent d’une puissance de calcul et d’un espace mémoire extrêmement limités — non seulement comparés aux ordinateurs personnels (PC) actuels, mais également en regard d’appareils mobiles tels que les smartphones et les tablettes. Leur puissance est en fait plutôt comparable, pour les modèles les moins chers (et donc parmi les plus couramment employés), à celle des ordinateurs personnels du début des années 1980 (Apple II, Commodore VIC et 64, Atari 800XL, Amstrad CPC, etc.).
Outre ce MCU central, une mote comprend en général seulement quelques capteurs (“sensors”) — et parfois, plus rarement quelques actionneurs (“actuators”) — leur permettant d’interagir avec leur environnement, en captant et mesurant des phénomènes physiques environnants — température, pression, humidité, présence d’individus, radioactivité... ; l’ensemble des capteurs envisageables est quasiment sans limite — et en agissant sur cet environnement pour les motes équipées d’actionneurs (par exemple : alarme, signaux lumineux, etc.)
De nombreuses motes possèdent, pour des raisons pratiques, des périphériques supplémentaires (externes au MCU) : on citera par exemple de la mémoire Flash supplémentaire pour le stockage permanent de données, ou des ports série / USB pour se connecter à un PC — principalement à des ﬁns de déboguage.
Une mote est bien évidemment équipée d’un émetteur / récepteur radio, pour pouvoir communiquer en réseau. Comme dit ci-dessus, ces appareils sont pour la plupart extrêmement limités en énergie ; ces émetteurs / récepteurs radio utilisent donc un standard conçu pour consommer très peu d’énergie, en contrepartie d’un débit très limité (comparable aux premiers modems analogiques du début des années 1990). La standard spéciﬁquement conçu dans cette optique utilisé par la plupart de

2.1. Réseaux de capteurs et actionneurs sans-ﬁl

9

Figure 2.1 – Schéma fonctionnel d’une mote WSN / IoT classique.

10

Chapitre 2. Contexte et problématique

ces radios est le standard IEEE 802.15.4 [IEEE 802.15.4, 2011] (ne couvrant que les couches les plus basses de la pile réseau) que nous décrirons ultérieurement dans le présent manuscrit en section 3.1 page 25. Notons que certains MCUs récents, dans un souci d’eﬃcacité et d’intégration, intègrent directement un émetteur / récepteur radio sur la même puce.
Enﬁn, une mote est bien évidemment équipée d’une ou plusieurs batteries pour son alimentation. Certains modèles de développement / déboguage oﬀrent également la possibilité d’être alimentés par une source d’énergie externe (secteur).

Les middlewares pour WSN. Avant de nous intéresser en détail au fonctionnement technique des couches de bas niveau des WSN, nous allons très brièvement évoquer un autre sujet de recherche actif dans le domaine des WSN.
Notons en eﬀet que l’absence de standard oﬃciel pour les WSN au-delà des deux couches les plus basses fournies par le standard IEEE 802.15.4 (niveaux OSI 1 : PHYsique, et 2 : Media Access Control, comme nous le verrons dans la section 3.1 page 25 de l’état de l’art) a amené à un développement assez anarchique des piles, protocoles et autres solutions pour les couches plus hautes. À l’heure où nous écrivons ces lignes, aucune des solutions conçues pour travailler par-dessus les réseaux 802.15.4 (telles ZigBee, etc.) ne s’est réellement imposée comme standard, fut-il de fait.
On voit donc, selon les applications prévues pour les diﬀérents WSN, se multiplier des solutions souvent incompatibles dans le déploiement des diﬀérents réseaux de capteurs sans-ﬁl sur le terrain.
Un domaine de recherche dans les WSN est donc la conception de “middlewares” (« intergiciels ») permettant une interaction eﬃcace entre tous ces WSN de conception diﬀérente et le réseau global (Internet), pour tenter de faire de l’IoT une réalité tangible, ﬁable et donc utilisable industriellement. Un article de référence (“survey”) recensait déjà nombre de projets de ce type lors de la décennie précédente [Wang et al., 2008].
Nous n’avons au cours de cette thèse malheureusement quasiment pas eu le temps de nous pencher sur cette problématique, si ce n’est au début pour travailler très brièvement sur le middleware MPIGate [Chehaider et al., 2013]. Les travaux de la présente thèse concernent, à l’exception de la publication cité dans la phrase précédente, uniquement les couches basses des piles réseau des plates-formes spécialisées pour WSN.

2.1.3 Les réseaux de capteurs sans-ﬁl et leur traﬁc
Les réseaux de capteurs sans-ﬁl (WSN) sont, comme nous l’avons vu ci-dessus dans le descriptif des motes, des réseaux à bas débit et à faible portée, en contrepartie d’une consommation d’énergie très limitée.
Le traﬁc réseau est, dans ce genre de réseau, typiquement faible, avec éventuellement des pointes de débit. Les transmissions entre noeuds d’un WSN peuvent, par nature, être déclenchées selon trois modalités diﬀérentes :
Périodique : un noeud capteur analyse son environnement à intervalles réguliers,

2.1. Réseaux de capteurs et actionneurs sans-ﬁl

11

en tire une valeur exploitable (par exemple : température, pression, etc.), et l’émet sur le réseau à l’aide de son émetteur / récepteur radio. L’intervalle de temps entre deux mesures / émissions est à la discrétion des concepteurs du WSN et / ou des programmeurs de la mote.
Évènementiel : un noeud capteur, lors d’une analyse de son environnement, capte une valeur — ou une variation de valeur — anormale ou atypique, et envoie alors un message d’alerte sur le réseau. Là encore, l’intervalle des valeurs normales, ou le type d’évènement susceptible de déclencher l’envoi d’une alerte est à la discrétion des concepteurs du WSN et/ou des programmeurs de la mote.
Par requête : un intervenant extérieur au WSN émet, via la station de base1 une requête vers une mote donnée, qui y répond par le déclenchement d’un actionneur — si le noeud en est équipé — et / ou par l’envoi d’une réponse, correpondant le plus souvent à une valeur analysée par un des capteurs de la mote en question. Ici aussi, la nature des requêtes et des réponses à y apporter sont à la discrétion des concepteurs du WSN et/ou des programmeurs de la mote.
Ces trois modalités ne sont bien évidemment pas exclusives : un même WSN peut utiliser les trois types de fonctionnement en fonction des besoins du moment.
Prenons l’exemple, pour aborder le sujet de l’e-santé qui concerne cette thèse, d’un WSN destiné à monitorer les signes vitaux d’un patient sous surveillance (par exemple : un malade cardiaque) :
— En temps normal, les capteurs présents sur le patient relèvent ses signes vitaux (pulsations cardiaques, pression sanguine, oxymétrie de pouls, mouvements respiratoires, etc.) de façon régulière et envoient ainsi (via l’IoT) les résultats à une base de données spécialisée consultable par les médecins.
— En cas d’anomalie, (par exemple : chute de pression sanguine, ou des pulsations), les capteurs envoient sans attendre un message d’alerte, qui pourra être relayé aux médecins traitant le patient ou même, selon la gravité, au SAMU. Un mécanisme d’IoT permettant d’envoyer des messages (type SMS) à des secouristes présents à proximité du patient pourrait également être envisagé.
— En cas de situation critique (par exemple : ﬁbrillation cardiaque), les messages d’alerte envoyés plus tôt auront alerté les services médicaux d’urgence, qui pourront en attendant l’arrivée physique des secours envoyer (toujours via l’IoT) une requête au WSN présent sur le patient : par exemple pour ordonner la mise en action d’un déﬁbrillateur cardiaque portatif (ou d’un “pace-maker”) connecté au WSN porté par le patient.
Les possibilités oﬀertes par les WSN — ne serait-ce que sur le seul domaine médical vu dans cet exemple — sont donc extrêmement larges.
Il importe toutefois, pour connaître les limites de ces réseaux de capteurs sans-ﬁl, d’en connaître les spéciﬁcités. C’est le sujet que nous allons maintenant aborder dans la prochaine section.
1. La station de base est le noeud (mote ou PC ou tout autre appareil connecté) servant de lien entre un réseau de capteurs sans-ﬁl et le reste de l’Internet : il s’agit, pour faire simple, des passerelles de l’Internet des Objets (IoT). On les nomme également souvent “sinks”.

12

Chapitre 2. Contexte et problématique

2.1.4 Spéciﬁcités des WSN
Par rapport aux réseaux traditionnnels, les réseaux de capteurs sans-ﬁl ont des spéciﬁcités, décrites dans la table 2.1 page suivante.

Les principaux points déterminants concernant ces spéciﬁcités sont les suivants : — Les capteurs sans-ﬁl sont des appareils dont le coût doit rester le plus faible
possible. Cela inﬂue sur les capacités très limitées de ces appareils, et aussi potentiellement sur leur ﬁabilité. — Les réseaux de capteurs sans-ﬁl sont généralement des réseaux ad-hoc, c’està-dire dont la structure n’est pas planiﬁée. Leur mode de fonctionnement est ainsi fondamentalement local, aucune gestion centralisée n’est en général possible. — Les réseaux de capteurs sans-ﬁl sont en général conçus pour servir une et une seule application donnée au cours de leur existence (point commun avec l’informatique / électronique embarquée). Ils peuvent être amenés à opérer dans des conditions environnementales diﬃciles voire hostiles. — Un point commun avec les réseaux traditionnels est la montée en charge. Un réseau de capteurs sans-ﬁl peut résulter de l’interconnexion de centaines de PANs, et regrouper ainsi des milliers de motes. De telles tailles de réseau sont rarement atteintes avec les réseaux sans-ﬁl les plus courants. — Les noeuds de ces réseaux pouvant tomber en panne sans pouvoir être remplacés (défaillance d’un composant, ou d’une batterie non remplaçable), la structure de tels réseaux doit pouvoir « survivre » à ces pannes et les gérer. — Ce sont des réseaux sans-ﬁl, dont le médium radio est peu ﬁable par nature (par rapport aux réseaux câblés), sujet à la diﬀusion, et dont l’état est variable au cours du temps. — Enﬁn, et c’est peut-être le plus important, la consommation d’énergie est une contrainte extrêmement forte dans les réseaux de capteurs sans-ﬁl, bien plus que dans n’importe quel autre type de réseau. Cette contrainte inﬂue directement et lourdement sur la conception des WSN et de leurs noeuds.

Pour répondre à ces diﬀérents problèmes, quatre notions liées à l’auto-gestion sont mises en avant dans [Dargie and Poellabauer, 2010] comme caractéristiques désirables pour les WSN :
“Self-organization”, auto-organisation : est la capacité d’adapter les paramètres de la conﬁguration du réseau en fonction de son état et de son environnement.
“Self-optimization”, auto-optimisation : est la capacité de monitorer et d’optimiser l’utilisation des ressources limitées du réseau.
“Self-protection”, auto-protection : est la capacité de reconnaître les intrusions et attaques et de s’en protéger.
“Self-healing”, auto-réparation : est la capacité de découvrir, d’identiﬁer la cause et de réagir aux pannes et défaillances du réseau.

2.1. Réseaux de capteurs et actionneurs sans-ﬁl

13

Réseaux traditionnels Réseaux généralistes : conçus pour servir toutes les applications possibles. Les principaux objectifs sont la performance du réseau et ses latences. La consommation d’énergie n’est pas une préoccupation majeure. Les réseaux sont conçus et déployés selon des plans prédéterminés .
Les réseaux et leurs composants opèrent dans des environnements contrôlés et des conditions environnementales modérées. La maintenance et la réparation sont des opérations courantes et le réseau et ses composants sont typiquement faciles d’accès. Le coût des composants des réseaux peut être élevé, selon le niveau de performances visé.
La défaillance d’un composant du réseau est réglée par des opérations de maintenance et de réparation . La connaissance de l’état global du réseau est typiquement possible et la gestion centralisée est possible .

Réseaux de capteurs sans-ﬁl Réseaux spéciﬁques : conçus dans un but unique pour servir une application bien déﬁnie. L’énergie est une contrainte centrale dans la conception d’un réseau de capteurs sans-ﬁl et de chacun de ses noeuds.
Le déploiement, la structure des réseaux et l’utilisation des ressources sont souvent déterminés de manière ad-hoc (sans planiﬁcation préalable). Les réseaux de capteurs sans-ﬁl opèrent souvent dans des environnements et des conditions hostiles . L’accès physique aux capteurs sans-ﬁl est souvent diﬃcile voire même impossible.
Le coût des capteurs sans-ﬁl doit rester très faible, d’où le recours à des composants bon marché aux performances (et parfois à la ﬁabilité) limitées. La défaillance d’un ou plusieurs noeuds est prévisible et gérée dans la conception même du réseau.
La plupart des décisions sont prises au niveau local sans intervention d’une gestion centralisée .

Table 2.1 – Comparaison entre réseaux traditionnels et WSN. (d’après [Dargie and Poellabauer, 2010] table 1.2)

14

Chapitre 2. Contexte et problématique

Ces diﬀérentes notions amènent à la capacité de ces réseaux de capteurs sans-ﬁl d’assurer un niveau de service suﬃsant pour les applications ayant des contraintes fortes quant à la qualité et le débit de leurs ﬂux de données. Ce domaine, la Qualité de Service (QdS) (QoS en anglais) va être l’objet d’étude de la prochaine section 2.2.

2.2 La Qualité de Service (QdS)
Note : cette section est inspirée des informations issues de [Nefzi, 2011] et de [Comment ça marche QoS, 2014]
2.2.1 Notion de QdS
Le terme QdS (« Qualité de Service, en anglais QoS : “Quality of Service”) désigne la capacité à fournir un service, ici un support de télécommunications, conforme à des exigences de fonctionnement acceptable à assurer par le fournisseur du service envers l’utilisateur.
Appliquée aux réseaux à commutation de paquets (réseaux basés sur l’utilisation de routeurs) la QoS désigne l’aptitude à pouvoir garantir le non-dépassement d’un niveau acceptable de baisse de qualité, déﬁni contractuellement, pour un usage donné (voix sur IP, vidéo-conférence, etc.).
En eﬀet, contrairement aux réseaux à commutation de circuits, tels que le réseau téléphonique commuté, où un circuit de communication est dédié pendant toute la durée de la communication, il est impossible sur Internet de prédire le chemin emprunté par les diﬀérents paquets.
Cette incertitude est encore plus forte sur les réseaux sans-ﬁl, où le médium radio lui-même est sujet à la diﬀusion, dont l’état et l’encombrement peuvent varier fortement et rapidement au cours du temps. Ce médium est, comparé aux câbles des réseaux informatiques « classiques », bien moins ﬁable.
Ainsi, rien ne garantit qu’une communication nécessitant une régularité du débit pourra avoir lieu sans encombre. C’est pourquoi il existe des mécanismes, dits mécanismes de QoS, permettant de diﬀérencier les diﬀérents ﬂux réseau et réserver une partie de la bande passante pour ceux ayant une importance particulière.
Plus formellement, la recommandation E.800 de septembre 2008 de l’Union Internationale des Télécommunications (UIT) déﬁnit la QdS comme étant « l’ensemble des caractéristiques d’un service de télécommunication qui lui permerrent de satisfaire aux besoins explicites et aux besoins implicites de l’utilisateur du service » ; une caractéristique étant déﬁnie comme une « propriété (qualitative ou quantitative) qui aide à faire la distinction entre les individus d’une population donnée ».
En termes pratiques, une caractéristique du standard E.800 de l’UIT correspond à un critère de QdS. Le but à atteindre étant d’assurer une valeur minimale en-deça de laquelle ne pas tomber pour respecter un contrat de qualité avec l’utilisateur.

2.2. La Qualité de Service (QdS)

15

2.2.2 Critères de QdS
Les principaux critères permettant d’apprécier la qualité de service sont les suivants :
Perte de paquets (en anglais packet loss) : elle correspond à la non-délivrance (perte) de paquets de données, la plupart du temps dûe à un encombrement du réseau.
Débit (en anglais bandwith) — encore appelée bande passante — il déﬁnit le volume maximal d’information (bits) pouvant transiter par unité de temps.
Latence, délai, ou temps de réponse (en anglais delay) : elle caractérise le retard entre l’émission et la réception d’un paquet de données.
Gigue (en anglais jitter ) : elle représente la ﬂuctuation du signal numérique, dans le temps ou en phase.
Déséquencement (en anglais desequencing) : correspond à une modiﬁcation de l’ordre d’arrivée des paquets.
Le rôle d’une politique ou d’un mécanisme de QdS est de toujours garder une valeur acceptable (égale ou supérieure à une valeur-seuil de qualité minimale) pour ces diﬀérents critères.
(À noter qu’à côté de ces principaux critères de QdS, d’autres peuvent être pris en compte, comme par exemple la durée de vie de chaque noeud, le MTBF, le respect du coût, etc.)

2.2.3 Stratégies d’assurance de la QdS
Les stratégies classiques appiquées pour assurer une QdS optimale peuvent se diviser en deux grandes catégories :
— Les méthodes de contrôle a priori ou préventives du traﬁc réseau que sont : > les politiques de gestion de ﬁles d’attente, ou ordonnancement, permettant la mise en place de la diﬀérentiation de service ; > le lissage (ou mise en forme) du traﬁc, consistant à contrôler le volume du traﬁc entrant dans le réseau, la plupart du temps selon les méthodes du seau percé ou du seau à jetons ; > le contrôle du traﬁc, et sa variante extrême, le contrôle d’admission, consistant à refuser le traﬁc entrant en fonction de certains critères.
— Les méthodes de contrôle a posteriori ou réactives du traﬁc réseau : > le contrôle de congestion, acceptant tout le traﬁc arrivant en conditions normales, et diminuant le débit ou supprimant des paquets lors de la survenue d’une congestion ; le mécanisme de fenêtre de congestion de TCP / IP fait partie de ces méthodes ; > le choix dynamique des routes, pour assurer la meilleure QdS possible en fonction de l’état courant d’un réseau : ce mécanisme dépend du protocole de routage de la pile réseau.

16

Chapitre 2. Contexte et problématique

D’une façon générale, les méthodes de contrôle réactives semblent se montrer mieux adaptées aux réseaux sans-ﬁl, notamment aux WSN, les méthodes proactives s’adaptant mal au médium radio et ses caractéristiques.

2.2.4 Niveaux de service
Le terme niveau de service (en anglais Service level ) déﬁnit le niveau d’exigence pour la capacité d’un réseau à fournir un service point à point ou de bout en bout avec un traﬁc donné. On déﬁnit généralement trois niveaux de QdS :
Service garanti (en anglais guaranteed service ou hard QoS ), consistant à réserver des ressources réseau pour certains types de ﬂux. Le principal mécanisme utilisé pour obtenir un tel niveau de service est RSVP (Resource reSerVation Protocol, en français « Protocole de réservation de ressources »).
Service diﬀérencié (en anglais diﬀerenciated service ou soft QoS ), permettant de déﬁnir des niveaux de priorité aux diﬀérents ﬂux réseau sans toutefois fournir une garantie stricte.
Meilleur eﬀort (en anglais best eﬀort), ne fournissant aucune diﬀérenciation entre plusieurs ﬂux réseaux et ne permettant aucune garantie. Ce niveau de service est ainsi parfois appelé (abusivement) lack of QoS.

2.2.5 QdS dans les réseaux de capteurs sans-ﬁl
Les données venant d’être exposées jusqu’ici dans la présente section 2.2 concernent la QdS en général : elles s’appliquent à tous les types de réseaux.
Pour les réseaux de capteurs sans-ﬁl, la nature même du réseau, avec des noeuds aux capacités très limitées, une contrainte énergétique très forte, un médium radio non-ﬁable, et une possibilité de défaillance de noeuds, rend les notions de service garanti ou diﬀérencié impossibles à atteindre. La Qualité de Service, dans le domaine des WSN, est donc quasiment toujours une garantie du type “best eﬀort”.
Concernant les critères de QdS importants et gérés au niveau des couches MAC / RDC des WSN, on s’intéresse principalement au taux de perte de paquets et au délais de transmission. Les autres critères étant soit déﬁnis par les standards gérant le médium radio — par exemple : le débit (théorique) de 250 Kbit/s pour le standard 802.15.4 sur la bande 2,4 GHz — ; soit dépendants de conditions externes sur lesquelles aucune intervention n’est possible (gigue, débit réel diminué par des interférences radio) ; soit réglés par les couches supérieures des piles réseau (déséquencement des paquets).
Enﬁn, le caractère extrêmement contraignant de la limitation énergétique fait de cette obligation d’économie d’énergie un critère à part entière de la QdS — bien que celui-ci soit contradictoire avec les autres critères de QdS. En eﬀet, les motes étant souvent dans des situations où le changement de batterie est diﬃcile ou même impossible, conserver la batterie opérationnelle le plus longtemps possible revient à maintenir le noeud correspondant « en vie » le plus longtemps possible. Une mote à

2.3. Applications des WSN (et de l’IoT)

17

cours d’énergie est en eﬀet souvent une mote perdue déﬁnitivement, donc une perte de fonctionnalité — potentiellement sévère — pour le WSN correspondant.
En résumé, on peut dire que pour les WSN, le lien entre Qualité de Service « fonctionnelle » (bande passante, ﬁabilité et rapidité des transmissions) et économie d’énergie est tout à la fois contradictoire, indissociable et crucial. L’optimisation de la QdS revient ainsi toujours à trouver le meilleur compromis, l’équilibre optimal entre tous les facteurs cités dans cette présente section 2.2.5, en fonction de l’application voulue.
Après toutes ces déﬁnitions techniques, nous allons maintenant dans la section 2.3 suivante passer en revue les diﬀérents domaines d’applications des WSN. Comme nous allons le voir, ceux-ci sont nombreux et variés.

2.3 Applications des WSN (et de l’IoT)
Akyildiz et Vuran, dans leur livre [Akyildiz and Vuran, 2010], considèrent cinq grands types d’applications aux WSN (voir ﬁgure 2.2) :

Figure 2.2 – Principales catégories d’application des réseaux de capteurs sans-ﬁl. Source : [Akyildiz and Vuran, 2010], ﬁgure 2.1.
Applications militaires : les buts sont multiples, comme le contrôle des forces alliées, de leur équipement et de leurs munitions, la surveillance du champ de bataille, la reconnaissance de l’ennemi et du terrain, l’évaluation des dégâts, ou la détection d’attaques non conventionnelles. Plusieurs exemples sont cités dans [Akyildiz and Vuran, 2010] : le projet Smart Dust du DARPA (un pionnier dans les WSN), ou un système de détection de sniper 2.
Applications industrielles : ici aussi, les applications sont nombreuses : la supervision des processus de fabrication et la vériﬁcation de la qualité de production, la localisation et la surveillance de l’équipement industriel, la maintenance préventive des usines (surtout de grande taille) et des conditions de travail ou d’opération du matériel industriel, etc. Un exemple cité dans [Akyildiz and Vuran, 2010] est le projet FabApp [Krishnamurthy et al., 2005], dont le but est d’évaluer les vibrations du matériel industriel lors de son fonctionnement
2. Démontrations vidéos sur cette page Web : http://bbn.com/boomerang

18

Chapitre 2. Contexte et problématique

pour prévenir pannes et accidents (tant dans une usine de fabrication de semiconducteurs que dans un pétrolier). On pourra également citer des applications de contrôle de l’état structurel des bâtiments, comme par exemple la surveillance active du Golden Gate Bridge (San Francisco) [Kim et al., 2007]. Citons aussi l’assistance au domaine minier : l’objectif étant de détecter les évènements dangereux pour les mineurs (poches de gaz, responsables de « coups de grisou ») ainsi que de quantiﬁer les émissions de méthane produites par les mines de charbon (le méthane étant un gaz à eﬀet de serre, celui-ci inﬂue sur le changement climatique actuel).
Applications environnementales : de nombreux projets sont réalisables, comme le suivi des mouvements d’animaux, la détection de feux de forêts ou d’inondations, la recherche météorologique ou géophysique, l’étude de la pollution, etc. Plusieurs exemples sont cités dans [Akyildiz and Vuran, 2010], parmi lesquels : ZebraNet [Zhang et al., 2004] un système de surveillance au long cours de la population de zèbres, déployé au Kenya. Autre exemple : un système de surveillance des volcans [Werner-Allen et al., 2006] — également cité dans [Dargie and Poellabauer, 2010] — le but étant ici de détecter à l’avance les signes avant-coureurs des éruptions, pour mieux prévenir celles-ci, ou d’étudier le fonctionnement de volcans sous-marins, pour mieux comprendre les phénomènes d’activité volcanique. On peut aussi citer un système de détection précoce d’inondations dans les pays en voie de développement [Basha et al., 2008]. Les réseaux de capteurs sans-ﬁl servent également à l’agriculture de précision, en permettant d’analyser précisément l’état des sols, aﬁn de mieux utiliser les ressources à utiliser (eau, engrais, pesticides, herbicides) pour optimiser les récoltes. Plusieurs projets prototypes ont déjà été déployés dans ce but. L’environnement urbain peut également en bénéﬁcier, par exemple par des applications de contrôle actif du traﬁc routier aux États-Unis [Knaian, 2000], ou encore le projet PipeNet [Stoianov et al., 2007] mis en place dans de nombreuses villes américaines pour monitorer les réseaux d’égoûts.
Applications à la santé : le domaine de la santé fait partie du contexte de la présente thèse, et nous y reviendrons donc plus longuement dans une section suivante (section 2.4.1 page suivante).
Applications domotiques : On cite dans [Akyildiz and Vuran, 2010] un système nommé NAWMS [Kim et al., 2008b] destiné à détecter les gaspillages d’eau et leur origine précise, aﬁn d’en informer les usagers pour les aider à réduire leur facture d’eau.
En étudiant les applications des WSN et de l’IoT citées dans [Dargie and Poellabauer, 2010] et [Akyildiz and Vuran, 2010], on voit que ces applications ne manquent pas, et sont appelées à continuer à se développer de façon exponentielle.

2.4. Contexte

19

Nous allons maintenant dans la section 2.4 suivante nous focaliser sur le contexte de la présente thèse.
Ce contexte est celui du domaine d’application de la santé pour les WSN. Nous y étudierons tout particulièrement le projet LAR (“Living Assistant Robot”), dont cette thèse fait partie, dans la section 2.4.2.

2.4 Contexte
2.4.1 Applications d’e-santé des WSN
L’utilisation des réseaux de capteurs sans-ﬁl pour des applications dans le domaine de la santé est un domaine déjà bien établi et très actif : les PAN (Personal Area Network ) dédiés à être installés sur un patient — par exemple pour suivre son état de santé — sont même désignés par un acronyme spéciﬁque : BAN (“Body Area Network”).
Les applications des WSN au domaine de la santé sont également, comme dans les autres domaines, très nombreuses et variées : un article complet de référence [Alemdar and Ersoy, 2010] recensait en 2010 les nombreux projets d’exploitation des réseaux de capteurs sans-ﬁl liés au domaine de la santé.
Parmi les projets les plus ambitieux, les deux livres de [Dargie and Poellabauer, 2010] et de [Akyildiz and Vuran, 2010] citent tous deux des projets de rétines artiﬁcielles [Schwiebert et al., 2001] [US Department of Energy, 2011] combinant une caméra CCD externe couplée à des nano-noeuds sans-ﬁl implantés in vivo sur la rétine du patient. Ces projets visent à apporter une solution à des maladies actuellement incurables, comme la DMLA (Dégénérescence Maculaire Liée à l’Âge) ou la rétinite pigmentaire (maladie génétique).
Sans aller jusqu’à des projets aussi avancés technologiquements (et organiquement invasifs) de nombreux projets de surveillance à domicile de patients fragiles et de réponse aux cas d’urgence sont actuellement mis en place.
Rappelons notamment l’existence du projet d’informatique située, consistant en une plate-forme d’« appartement intelligent pour l’assistance à la personne » [LORIA / INRIA Nancy Grand-Est, 2009], utilisant intensivement les WSN, que l’on peut classer à la fois dans les applications domotiques et les applications à la santé. Ce projet, hébergé au LORIA / INRIA Nancy Grand-Est, implique directement (entre autres) notre équipe — Madynes —, et l’un des encadrants de la présente thèse — Y.-Q. Song.
2.4.2 Le projet LAR
Un autre de ces projets fait également usage des WSN, combinant aussi — comme nous l’avons dit auparavant au chapitre 1 — aspect domotique et aspect santé, est le projet LAR (“Living Assistant Robot”), dont la présente thèse fait partie.

20

Chapitre 2. Contexte et problématique

Le projet LAR a pour objectif d’aider au maintien à domicile des personnes âgées et / ou dépendantes, et de tenter de retarder le plus possible le moment où ces dernières doivent être placées en institutions spécialisées, ce qui représente un coût ﬁnancier et surtout humain considérable.
Dans ce but, le projet vise à fournir des outils de suivi à domicile de la personne dépendante et de son activité, de développer pour cela des outils de perception, de modélisation de l’activité humaine, et d’interaction avec la personne. Comme le nom du projet l’indique, il est question de fournir (du moins dans le cas les plus lourds) un robot d’assistance spécialement conçu par le projet ; mais une grande partie du travail fourni (détection de présence, de mouvement, de chutes, etc.) sera fourni par un ou plusieurs WSN installés chez le patient, le robot étant également porteur de capteurs et actionneurs et donc membre à part entière de ce(s) WSN. Ces WSN sont également reliés à l’IoT, les données médicales recueillies étant destinées à être stockées dans des bases médicales spécialisées, accessibles de façon sécurisée aux personnels de soins (médecins, inﬁrmiers, etc.).
Le principe central du projet LAR est la mise en œuvre d’un écosystème modulaire de services (comme nous venons de le voir : capteurs de données de toutes natures, robots, mais aussi services à la personne, etc.), lesquels services opèrent au sein d’une architecture orientée services (“Service Oriented Architecture” ou SOA) centrée sur un orchestrateur (alias “Enterprise Message Bus”) Microsoft BizTalk.
L’un des objectifs fondamentaux du projet est de commercialiser ce service au coût le plus faible possible, aﬁn de le rendre accessible au plus grand nombre ; c’est pourquoi le recours à des WSN (avec leurs motes à faible coût) est un point clé du programme. L’une des idées directrices du projet est de rendre l’oﬀre modulaire, et de ne fournir que les services nécessaires à l’état courant du patient : les cas les plus légers n’auront ainsi que l’installation d’un WSN « léger » et peu intrusif à leur domicile, l’évolution de l’état du patient pouvant ensuite amener à recourir à des modules supplémentaires ; le robot étant l’élément le plus évolué mais aussi le plus coûteux.
Plusieurs partenaires académiques et industriels sont impliqués dans ce projet : la partie académique est représentée par le LORIA / INRIA Nancy Grand-Est en l’équipe Madynes (dont nous faisons partie) pour les WSN, et l’équipe Larsen — anciennement Maia — pour la partie robotique et reconnaissance des mouvements ; les partenaires industriels sont Diatelic (pour la gestion de la base de données médicales et son accès sécurisé), Robosoft S.A. (pour la conception et la fabrication du robot), et le Pôle Innovation du Crédit Agricole S.A. (qui coordonne le projet). Tous ces partenaires ont formé un consortium — dont le Crédit Agricole a pris la tête — pour répondre à l’appel d’oﬀres « e-santé » lancé en 2011 par la DGCIS — depuis devenue DGE (Direction Générale des Entreprises) —, lequel consortium a remporté l’appel et ainsi fondé le projet LAR. Le contrat correspondant a été signé en 2012, et le projet LAR a été ﬁnancé par la Banque Publique d’Investissement (BPIFrance).

2.5. Problématique

21

2.5 Problématique

2.5.1 Exposé de la problématique
Dans le domaine des réseaux de capteurs sans-ﬁl, les piles réseau spécialisées constituent un domaine de recherche très actif depuis maintenant une quinzaine d’années. On citera actuellement, par exemple dans le domaine des couches hautes, les protocoles de routage (RPL et ses nombreuses variantes et évolutions), ou encore l’activité actuelle autour des CCN (“Content-Centric Networks”).
Pour les couches basses, de nombreux travaux de recherche ont également été eﬀectués sur les protocoles MAC (la couche MAC représentant le niveau 2 dans le modèle OSI), pour suppléer le protocole du standard 802.15.4 et ses limitations, comme nous le verrons au chapitre 3 page 25. Toutefois, beaucoup de ces études se sont principalement consacrées à l’étude théorique de ces protocoles, se contentant souvent — à des ﬁns de tests — de simulations puremement théoriques (avec des outils comme OPNET, ns-3, OMNeT++, voire même MATLAB), ou au mieux par des émulations de motes virtuelles (avec des outils comme TOSSIM [Levis et al., 2003] ou Cooja [Österlind et al., 2006]).
L’implantation de ces couches basses, dans les plates-formes logicielles réelles — c’est à dire les systèmes d’exploitation dédiés aux réseaux de capteurs sans-ﬁl — n’a pas fait l’objet d’un eﬀort de recherche poussé et systématique. Le principal but était de minimiser la consommation d’énergie de ces couches basses, généralement en ayant recours aux protocoles et aux implantations les plus simples possibles.
L’un des seuls eﬀorts remarquables de conception et d’implantation dans ce domaine, le protocole ContikiMAC — développé spéciﬁquement pour la plate-forme logicielle Contiki OS — a ainsi comblé un manque, et est devenu le standard de fait, du moins dans la littérature sur le domaine des réseaux de capteurs sans-ﬁl. Depuis, on ne peut qu’observer un certain statu quo dans ce domaine. Si de nombreux protocoles MAC à hautes performances ont été conçus (comme nous le verrons dans la section 3.2 page 34 de l’état de l’art), aucun d’entre eux n’a été implanté et largement diﬀusé avec un OS spécialisé comme l’est ContikiMAC.

2.5.2 Stratégie préconisée
2.5.2.1 Besoins identiﬁés
Pour avancer dans ce domaine, et notamment pouvoir exploiter les nouvelles motes plus puissantes — par exemple celles basées sur des microcontrôleurs à base ARM Cortex-M — rencontrées de plus en plus souvent (en sus des plates-formes classiques à base MSP430 ou AVR), nous voyons plusieurs besoins à combler :
1. Faire évoluer les plates-formes logicielles (OS) spécialisées dans les réseaux de capteurs sans-ﬁl, en leur ajoutant des fonctionnalités nécessaires au développement de piles réseau plus performantes. La programmation sans OS ni plate-forme d’aucune sorte (programmation “bare metal”) nous semble à proscrire, car les logiciels ainsi créés ne sont nullement

22

Chapitre 2. Contexte et problématique

portables, et doivent être réécrits à chaque changement de matériel, lequel dans ce domaine (comme dans toute l’électronique et l’informatique) évolue très vite. L’utilisation d’une plate-forme logicielle facilite aussi la programmation d’applications, ainsi que les travaux d’évaluation et de comparaison.
2. Expérimenter, de façon intensive et approfondie, ces plates-formes logicielles spécialisées et leurs piles réseau aﬁn de les optimiser et de les ﬁabiliser, tout spécialement leurs couches basses.
3. Tester le comportement et la résilience de ces piles réseau spécialisées (et notamment de leurs couches basses) face à des charges réseau intenses. En eﬀet, la plupart des réseaux de capteurs sans-ﬁl actuels sont conçus pour gérer des traﬁcs faibles à modérés. Lors de situations exceptionnelles — tout spécialement dans le domaine médical — on peut imaginer que ces WSN puissent avoir à gérer des traﬁcs intenses, que ce soit de façon ponctuelle (par exemple : gestion d’un patient à domicile en situation d’urgence vitale) ou continue (comme dans une maison médicalisée ou un hôpital où de nombreux WSN traiteront constamment et de façon concurrente de fortes quantités de données). Nous souhaitons dans cette thèse évaluer, et si nécessaire améliorer et optimiser, le fonctionnement des couches basses — niveaux 1 et surtout 2 du modèle OSI — de ces piles réseau spécialisées face à de telles situations.
Nous nous proposons donc, dans cette thèse, de nous pencher sur les implantations de ces couches basses, au sein d’un ou plusieurs systèmes d’exploitation spécialisés oﬀrant les fonctionnalités nécessaires, et de les optimiser. Nous souhaitons pour cela utiliser l’approche décrite dans la section 2.5.2.2 suivante.

2.5.2.2 Approche mise en œuvre
Lorsque l’on programme les appareils miniatures qui constituent les noeuds des WSN, il est nécessaire de s’adapter aux spéciﬁcités et aux limitations de ces appareils. Ainsi, outre leur puissance très limitée, le principal objectif lorsque l’on programme des motes est de réduire autant que possible leur consommation énergétique. Le but est de faire durer leur(s) batterie(s) aussi longtemps que possible, pour des raisons économiques mais également pratiques : il est parfois diﬃcile — et même quasiment impossible — de changer les batteries de certaines de ces motes, à cause de leur localisation (par exemple : en haut d’immeubles, sous des routes, etc).
De tous les diﬀérents composants constituant une mote, l’élément le plus consommateur d’énergie est, de loin, l’émetteur / récepteur radio (comparer, par exemple, les consommations énergétiques d’un émetteur / récepteur radio comme le TI CC2420 [DataSheet CC2420, 2007] et d’un microcontrôleur comme le MSP430F1611 [DataSheet MSP430F1611, 2011], qui sont les deux principaux composants de la famille répandue de motes que sont les TelosB / SkyMotes [DataSheet TelosB, 2006]). En conséquence, pour limiter la consommation énergétique de ces appareils, un premier point-clé est d’utiliser cet émetteur / récepteur radio uniquement quand cela est

2.5. Problématique

23

nécessaire, en le gardant éteint — ou en mode « sommeil » aussi souvent que possible. L’élément logiciel responsable de contrôler cet émetteur / récepteur radio de façon adéquate est le niveau 2 de la pile réseau logicielle, constituant les couches MAC (Media Access Control ) et RDC (Radio Duty Cycle). Cela implique aussi le plus souvent d’intervenir sur la couche de niveau 1 : la couche PHY ou physique, c’est-à-dire le pilote de l’émetteur / récepteur radio, aﬁn que ce dernier fournisse les fonctionnalités nécessaires aux couches supérieures (notamment la couche MAC / RDC) de la façon la plus eﬃcace possible.
Une stratégie eﬃcace d’économie d’énergie pour les motes repose ainsi sur la recherche du meilleur compromis entre d’une part la réduction de la fraction de temps durant laquelle la radio est active (“duty cycle”), et d’autre part le maintien de la plus haute eﬃcacité possible du réseau sansﬁl (QdS). Ce compromis s’atteint en développant de nouveaux protocoles MAC / RDC « intelligents », s’adaptant dynamiquement et automatiquement au traﬁc réseau en cours d’exécution.
Pour implanter de nouveaux protocoles MAC / RDC à hautes performances, il est nécessaire de pouvoir réagir aux évènements — par exemple : expirations de délais ou arrivées de paquets, prenant souvent au niveau de la programmation la forme d’interruptions — avec une bonne réactivité (latence la plus faible possible) et avec ﬂexibilité. De tels protocoles reposent sur un timing précis pour assurer une synchronisation eﬃcace entre les diﬀérentes motes et autres appareils équipés de radio amenés à faire partie des PANs, permettant ainsi de faire fonctionner les émetteurs / recepteurs radio de ces appareils uniquement lorsque cela est nécessaire.
Le deuxième élément le plus consommateur d’énergie dans une mote, après l’émetteur / récepteur radio, est le microcontrôleur (MCU) au coeur de cette mote. Tous les MCUs actuels oﬀrent des « modes à basse consommation d’énergie », consistant à « éteindre » à la demande les diﬀérents circuits intégrés au MCU, à commencer par le coeur CPU lui-même. Le principal moyen de minimiser la consommation d’énergie d’un MCU est ainsi de désactiver ses fonctionnalités selon les besoins du moment, en ne les réactivant que quand elles sont nécessaires au fonctionnement courant de l’application : cela revient eﬀectivement à mettre le MCU en sommeil aussi souvent et aussi complètement que possible, tout en continuant d’exécuter de façon optimale l’application voulue.
Rappelons toutefois que le contexte de notre thèse (applications médicales) nous poussera toujours à priviligier d’abord la QdS, même si l’optimisation de la consommation d’énergie doit en souﬀrir. Cette approche est constante dans ce travail de thèse ; elle est notamment ce qui nous pousse à tester les couches basses des piles réseau en situation de traﬁc intense.
Dans les deux cas, pour la gestion de l’émetteur / récepteur radio comme pour celle du MCU, il est nécessaire de pouvoir utiliser les timers matériels et les interruptions de façon optimale, pour pouvoir mettre en sommeil et réactiver ces circuits de manière eﬃcace aﬁn d’atteindre le meilleur compromis entre QdS et économies d’énergie, là encore de façon dynamique et automatique.

24

Chapitre 2. Contexte et problématique

Être capable d’utiliser les timers et les interruptions de façon eﬃcace et avec un minimum de diﬃcultés implique l’utilisation d’un système d’exploitation (OS) spécialisé dans les capteurs sans-ﬁl — une plate-forme logicielle adaptée — qui nous oﬀrira en outre les bénéﬁces de la portabilité de nos applications, et des fonctionnalités multitâches facilitant la programmation (revoir le premier point abordé plus haut dans la section 2.5.2.1 page 21).
La recherche de cette plate-forme logicielle la mieux adaptée à nos besoins — outre une section consacrée aux OS spécialisés dans le chapitre sur l’état de l’art (section 3.3 page 61) — fera l’objet d’un chapitre dédié (chapitre 4).
Mais auparavant, nous allons nous pencher sur l’état de l’art concernant les domaines concernés par cette thèse dans le chapitre 3 suivant.

Chapitre 3
Analyse critique de l’état de l’art
Nos travaux ont, d’un point de vue pratique, principalement concerné les couches basses des piles réseau de systèmes d’exploitation spécialisés pour les réseaux de capteurs sans-ﬁl. Ces réseaux fonctionnent à l’heure actuelle principalement avec le protocole IEEE 802.15.4 [IEEE 802.15.4, 2011], même si l’utilisation de technologies alternatives (tel le BLE — Bluetooth Low Energy également appelé Bluetooth Smart) commence à émerger.
Notre objectif était de réaliser et d’améliorer l’implantation logicielle de la couche MAC (Medium Access Control, protocole d’accès au médium, en l’occurence le canal radio 802.15.4 voulu). Pour des raisons techniques évidentes, nous avons également été amenés à travailler sur la couche PHY logicielle sous-jacente (consistant en les pilotes des émetteurs / récepteurs radio des appareils concernés), ainsi que sur l’interface entre ces deux couches.
Le présent chapitre va ainsi s’articuler en 3 sections : — la première va brièvement rappeler les bases du protocole IEEE 802.15.4, dont
la couche physique a servi de base à tous nos travaux ; — la seconde résumera les diﬀérentes familles et technologies des protocoles MAC
applicables aux réseaux 802.15.4 ; — quant à la troisième et dernière, elle reprendra les diﬀérents systèmes d’exploi-
tation spécialisés dans les systèmes embarqués et notamment dans les réseaux de capteurs sans-ﬁl. Cette troisième section sera plus analytique et critique, et s’intéressera particulièrement aux fonctions oﬀertes par ces systèmes aux programmeurs, tout spécialement pour le développement des couches bases des piles réseau. Aucune de ces sections ne prétend à l’exhaustivité, mais cherche à donner les données nécessaires et suﬃsantes pour comprendre les bases à partir desquelles nous avons eﬀectué nos travaux.
3.1 Le protocole IEEE 802.15.4
Le standard IEEE 802.15.4 déﬁnit les couches basses (PHYsique et MAC) de réseaux sans-ﬁl destinés à relier des appareils sur une très faible distance et avec un
25

26

Chapitre 3. Analyse critique de l’état de l’art

faible débit (on parle de LR-WPAN : Low-Rate Wireless Personal Area Network, en contrepartie d’une consommation d’énergie très modeste.
Apparu dans sa première version en 2003, il a été révisé en 2006 puis en 2011, et complété par divers amendements (802.15.4a, 4b, 4c, 4d et à l’heure actuelle 4e).
Ce standard ne déﬁnissant que les deux couches les plus basses de la pile réseau, il est le plus souvent utilisé de concert avec d’autres protocoles déﬁnissant les couches hautes. On peut notamment utiliser des piles protocolaires basées sur IP (Internet Protocol ) — telle que 6LoWPAN [Mulligan, 2007] — ou non — comme ZigBee. Toutes ces piles réseau reposent ainsi sur le standard 802.15.4.
La ﬁgure 3.1 résume de façon schématique la comparaison entre le standard IEEE 802.15.4, et les deux piles de protocoles réseaux complètes et couramment utilisées que sont le modèle OSI et le modèle Internet (souvent appelé abusivement « TCP/IP »).

Figure 3.1 – Comparaison entre la pile 802.15.4 et les piles OSI et Internet.
3.1.1 Couche physique
La couche physique (PHY) 802.15.4 oﬀre les fonctionnalités suivantes :
Bandes de fréquences. De base, le standard oﬀre trois bandes : une fréquence (canal) unique à 868 MHz disponible en Europe ; une bande autour de 915 MHz oﬀrant d’abord 10 canaux (puis étendue à 30) disponible en Amérique du Nord ; et la bande ISM de 2,4 GHz oﬀrant 16 canaux et disponible dans le monde entier. À l’origine (2003), seule la bande à 2,4 GHz permettait d’atteindre le débit maximal de 250 kbps, les basses fréquences (868 et 915 MHz) étaient elles limitées à de faibles débits (20 à 40 kbps) en contrepartie d’une portée plus grande (due à un moindre aﬀaiblissement). Le choix d’une bande de fréquence

3.1. Le protocole IEEE 802.15.4

27

correspondait ainsi à un compromis entre débit et portée, en sus d’un choix dicté par des considérations géographiques.
La révision de 2006, grâce à l’introduction de nouvelles méthodes de modulation du signal radio, a permis aux bandes à 868 et 915 MHz d’atteindre des débits de 100 et 250 kbps. Le choix d’une bande radio dépend donc désormais surtout du déploiement géographique envisagé pour les réseaux considérés.
En outre, les diﬀérents amendements ont ajouté de nouvelles bandes de fréquences disponibles (315, 430 et 780 MHz disponibles en Chine ; 950 MHz disponible au Japon). Ces mêmes amendements apportèrent également des méthodes de modulation de signal supplémentaires, permettant notamment l’utilisation de bandes à très hautes fréquences (jusqu’à 10 GHz).
L’amendement 802.15.4a a égalemement ajouté la notion d’Ultra-Wide Band (UWB), lequel oﬀre, outre de plus hauts débits, la possibilité de mesurer notamment précisément les temps de vol (c-à-d. les délais de communication entre deux noeuds).
Les diﬀérents émetteurs / récepteurs radio (RF) à la norme 802.15.4 ne peuvent pas fonctionner sur toutes les fréquences du standard : leur choix dépend donc de la bande de fréquences souhaitée. Parmi les plus utilisés à l’heure actuelle, on peut par exemple citer : — La famille Texas Instruments (TI) ChipCon (CC) 1000/1100. Cette famille
regroupe des émetteurs / récepteurs pour les bandes à 868 et 915 MHz. — La famille TI CC 2400/2500, regroupant des émetteurs / récepteurs pour
la bande à 2,4 GHz. — La famille Atmel AT86RF230, regroupant également des émetteurs / ré-
cepteurs pour la bande à 2,4 GHz. Nous avons au cours de nos travaux utilisé des appareils dotés de composants radio appartenant aux deux dernières familles citées (CC2420 et AT86RF231/233), et fonctionnant donc sur la seule bande ISM à 2,4 GHz.
Notons également que l’on trouve de plus en plus fréquemment des microcontrôleurs intégrant directement un émetteur / récepteur radio dans la même puce : par exemple, le STM32W108 de ST Microelectronics, le SAMR21 ou la famille ATmegaRFR2 [DataSheet ATmegaRFR2, 2014] d’Atmel.
Mode de liaison. Le couche physique du standard IEEE 802.15.4 est une liaison half-duplex . Cela signiﬁe que si la communication entre deux appareils à la norme IEEE 802.15.4 est bien bidirectionnelle — chaque appareil peut assumer le rôle d’émetteur et celui de récepteur — il est impossible à une seule radio au standard IEEE 802.15.4 d’émettre et de recevoir simultanément. La transmission d’informations entre deux motes dans les réseaux de capteurs sans-ﬁl se fait donc de façon alternée, chaque noeud pouvant à chaque instant donné soit émettre, soit recevoir des données ; mais jamais les deux en même temps (si le noeud ne possède qu’un seul émetteur / récepteur radio).
L’un des rôles majeurs de la couche directement supérieure (MAC) est justement de déterminer à quels instants la radio doit être en mode émission, et à

28

Chapitre 3. Analyse critique de l’état de l’art

quels autres instants en réception — et aussi éventuellement à quels instants elle est désactivée (pour économiser de l’énergie).
Notons que ce fonctionnement half-duplex n’est pas propre à ce standard 802.15.4. Le standard IEEE 802.11 (plus connu sous le nom de “WiFi”) est lui aussi un standard half-duplex. Ce mode de fonctionnement est en fait mieux adapté aux communications sans-ﬁl, utilisant le médium radio, lequel est par nature sujet à la diﬀusion, aux variations rapides d’état et à d’autres facteurs nuisant à la qualité de transmission. (Les réseaux câblés sont la plupart du temps en full-duplex, c-à-d. peuvent transmettre et recevoir simultanément, généralement en consacrant — au moins — un ﬁl à chaque sens de communication.)
Ce mode de fonctionnement half-duplex a des conséquences pratiques : un émetteur / récepteur radio doit régulièrement passer du mode émission au mode réception et inversement. Une telle procédure n’est pas instantanée, chaque puce radio ayant un délai de retournement indiqué dans sa datasheet. Le standard IEEE 802.15.4 — dans sa version de 2011 — indique un délai maximal pour passer du mode émission au mode réception et inversement, que toutes les radios conformes au standard ne sont pas censées dépasser : constante aTurnaroundTime, égale à 12 symboles (soit 192 µsec. pour la plupart des puces radio émettant sur la bande de 2,4 GHz).
Format de trames. Le standard déﬁnit un format — très simple — de trame physique (“frame”), dont la taille est limitée à 127 octets. Ces 127 octets incluant les entêtes des couches supérieures (dont la couche MAC), la taille disponible pour les données proprement dites (charge utile ou “payload”) est en général nettement inférieure.
Modes d’adressage. Deux modes d’adressage complémentaires sont pris en charge : — un adressage court sur 16 bits (plus un identiﬁant de réseau — identiﬁant PAN — de 16 bits également) dont l’intérêt est de limiter la taille des entêtes de trames ; — un adressage long (dit « adressage IEEE ») sur 64 bits permettant a priori directement une identiﬁcation unique de chaque appareil.
Détection du médium. Le standard inclut la détection d’énergie (ED : Energy Detection) sur le médium radio, et par extension la vériﬁcation de la disponibilité du canal radio (CCA : Clear Channel Assessment).
Qualité de service. Le standard prend en charge la déﬁnition et l’indication de la qualité de liaison (LQI : Link Quality Indicator ) pour une transmission de trame donnée. Le RSSI (Received Signal Strength Indicator ), s’il n’est quévoqué dans le glossaire du standard 802.15.4, est également la plupart du temps pris en charge au niveau physique (émetteurs / récepteurs radio).
Toutes ces propriétés sont implantées de façon matérielle par les diﬀérents émetteurs / récepteurs radio conformes au standard 802.15.4 — qu’il s’agisse de composants autonomes, ou de circuits intégrés à des microcontrôleurs ou System-on-Chip (SoC).

3.1. Le protocole IEEE 802.15.4

29

La couche PHY, au niveau logiciel, notamment dans un système d’exploitation spécialisé, consiste donc en un jeu de primitives (implantées dans des pilotes) permettant d’exploiter ces émetteurs / récepteurs radio. On peut envisager cette couche comme une couche d’abstraction matérielle (HAL : Hardware Abstraction Layer ) vis-à-vis de la couche MAC et des couches supérieures de la pile réseau du système.

3.1.2 Couche MAC
Située immédiatement au-dessus de la couche physique, la couche MAC du standard 802.15.4 repose sur la méthode CSMA/CA (Carrier Sense Multiple Access with Collision Avoidance). Une version diﬀérente de cette technologie est déjà utilisée (sous le même nom) dans le standard IEEE 802.11 (alias “WiFi”).
La couche MAC standard peut utiliser cette méthode selon deux modalités différentes, selon l’utilisation ou non de “beacons” (ou balises 1) pour synchroniser les diﬀérents noeuds et identiﬁer les diﬀérents réseaux (PAN). Sans “beacons”, la couche MAC standard emploie toujours des cycles de fonctionnement (“duty cycles”) ﬁxes, sans prendre en compte l’utilisation réelle du réseau et le débit des données transmises. Le mode « avec beacons » permet d’ajuster certains paramètres de fonctionnement [Khssibi, 2015]. Certains éléments restent toutefois immuables, même dans ce mode (par exemple les 16 slots de temps dans la superframe).
Le standard 802.15.4 est à la base conçu pour faire fonctionner des réseaux ayant une topologie en étoile ; pour cela, le standard permet de diﬀérencier les noeuds en deux types :
— les noeuds à fonctionnalités complètes (FFD : Full Function Devices), capables de jouer aussi bien le rôle de « noeud simple » occupant une des extrêmités du réseau, que celui plus évolué de coordinateur de réseau (en mode « avec beacons ») ;
— les noeuds à fonctionnalités réduites (RFD : Reduced Function Devices), limités au rôle de « noeuds simples »
Dans notre terminologie, un « noeud simple » est un noeud dont la défaillance ne met pas en péril le fonctionnement de l’ensemble, au contraire d’un routeur ou d’un coordinateur dont la seule panne entraîne la perte de tout un réseau.
Un exemple de base d’un schéma topologique d’un réseau de capteurs sans-ﬁl (WSN) est montré ﬁgure 3.2 page suivante. Celui présenté ici est composé de quatre sous-réseaux (PAN) diﬀérents, possédant chacun un routeur jouant également le rôle de coordinateur de son PAN. Les noeuds simples (« feuilles » de l’arborescence) ne communiquent qu’avec leur propre coordinateur, ces derniers se chargeant de transmettre les données de PAN en PAN de façon adéquate.
Ces réseaux (PAN) peuvent eux-mêmes être reliés entre eux de façon maillée et/ou arborescente (selon les protocoles de routage utilisés par dessus 802.15.4).
1. Pour des raisons pratiques, nous emploierons dans la suite de ce manuscrit le terme anglosaxon “beacon”, plus utilisé dans la littérature.

30

Chapitre 3. Analyse critique de l’état de l’art

Figure 3.2 – Schéma topologique d’un réseau de capteurs sans-ﬁl (WSN). (D’après [Song, 2013])
3.1.2.1 CSMA/CA
Cette méthode consiste à éviter les collisions potentielles sur le médium en vériﬁant préalablement la disponibilité du canal radio et, en cas d’encombrement, en attendant pendant un délai aléatoire avant de retenter une écoute.
Plus précisément, l’implantation de CSMA/CA dans le standard 802.15.4 en version de base « non slottée » est la suivante :
1. un noeud souhaitant émettre une trame doit d’abord attendre pendant un délai dont la durée est aléatoirement choisie entre 0 et 2BE − 1 unités de temps nommées BP (“Backoﬀ Period”) . La valeur d’une BP est une constante dépendant de la bande choisie pour la couche physique (elle vaut 320 microsecondes pour la bande ISM à 2,4 GHz). La valeur BE est nommée “Backoﬀ Exponent”, et est initialisée à une valeur déﬁnie dans le standard sous le nom de macMinBE (3 par défaut).
2. une procédure de CCA est alors eﬀectuée : le CCA consiste à écouter le medium radio durant un délai spéciﬁque — nommé DIFS (Distributed Inter-Frame Space) —, si le medium reste libre pendant ce délai, le noeud peut alors émettre sa trame ;

3.1. Le protocole IEEE 802.15.4

31

3. si le médium radio est encombré, on revient à la première étape d’attente d’un délai aléatoire, en ayant toutefois incrémenté la valeur de BE, dans la limite de la valeur maximale macMaxBE déﬁnie par le standard (5 par défaut). Toutefois, au bout d’un nombre maximal d’essais, déﬁni par le standard sous le nom de macMaxCSMABackoﬀs (4 par défaut), l’envoi de la trame est considéré comme échoué par la couche MAC.
La méthode CSMA/CA peut également fonctionner en mode « slotté », de façon à s’adapter aux protocoles MAC où les transmissions doivent se caler sur des intervalles de temps (“slots”) bien déﬁnis. Dans ce cas, un nouveau paramètre, nommé “Contention Window” (CW ) intervient pour s’assurer que le médium radio a été détecté libre (CCA) un certain nombre de fois avant de commencer une émission ; cette étape supplémentaire a notamment pour but de faciliter la transmission des messages d’acquittement signalant la bonne réception d’une trame (ACK). Par défaut, le standard ﬁxe la valeur initiale de CW (CW0) à 2.
L’organigramme décrivant le fonctionnement de la méthode CSMA/CA est schématisé dans la ﬁgure 3.3 page suivante. Dans cette ﬁgure, la branche de gauche présente la version « slottée », employée notamment dans le mode “beacon” du protocole MAC du standard IEEE 802.15.4 ; tandis que la branche de droite présente la version simple « non slottée » qui est en général utilisée pour les protocoles non synchronisés (tels que LPL, LPP, cf. suite du chapitre).
En sus de la méthode CSMA/CA, notons qu’il existe également un mécanisme obligatoire d’acquittement des trames. Ainsi, à la réception de chaque trame de données, le noeud de destination doit renvoyer un acquittement à l’envoyeur ; si après envoi d’une trame de données, le noeud émetteur ne reçoit pas d’acquittement dans un délai voulu (“timeout”), l’envoi de la trame est considéré comme un échec.

3.1.2.2 Mode “non-beacon”
Le mode de fonctionnement le plus simple de la couche MAC du standard 802.15.4 repose exclusivement sur l’emploi de la méthode CSMA/CA « non slottée » décrite section 3.1.2.1 page ci-contre. Il n’y a aucune notion de cycle de fonctionnement : le coordinateur est constammant en fonctionnement (la plupart du temps en écoute), tandis que les noeuds simples n’accèdent au médium radio que lorsqu’ils ont besoin d’envoyer ou recevoir des données.
La réception de données s’eﬀectue grâce à un bit nommé “Frame Pending” de l’entête MAC 802.15.4, via lequel le coordinateur indique à un de ses noeuds-feuilles qu’il attend de lui envoyer une trame lui étant destinée. Le noeud destinataire peut alors envoyer une trame spéciale dite « de commande » (“Data Request”) pour déclencher la réception proprement dite.
Ce mode est bien adapté aux réseaux dans lesquels les noeuds simples émettent des données de façon sporadique (c’est-à-dire passent la quasi-totalité de leur temps en « sommeil »), et où les données transmises n’ont pas un caractère urgent (ce mode sans “beacon” n’oﬀrant aucune garantie d’accès au canal pour une période donnée).
Il est ainsi possible d’avoir des noeuds simples fonctionnant sur une batterie

32

Chapitre 3. Analyse critique de l’état de l’art

Figure 3.3 – Organigramme de l’algorithme de la méthode CSMA/CA. (Source : [IEEE 802.15.4, 2011], ﬁgure 11)

3.1. Le protocole IEEE 802.15.4

33

dont l’autonomie pourra être longue. Par contre, le noeud central jouant le rôle de coordinateur doit lui être constamment à l’écoute, ce qui impose la contrainte de le faire fonctionner sur une source d’énergie constante (secteur).

3.1.2.3 Mode “beacon” (ou mode balisé)
Le second mode de fonctionnement de la couche MAC standard impose au noeud central, jouant le rôle de coordinateur de PAN (compatible avec celui de routeur, ce qui représente l’immense majorité des cas), l’envoi régulier de “beacons” à chaque début de cycle de fonctionnement (“duty cycle”).
Ces “beacons” servent à synchroniser les diﬀérents noeuds du PAN (ainsi qu’à identiﬁer ce dernier).
Dans ce mode, un cycle de la couche se décompose en :
l’envoi d’un “beacon” par le noeud coordinateur du PAN, cet envoi n’utilisant pas la méthode CSMA/CA, mais la diﬀusion directe à tous les noeuds à l’écoute (“broadcast”), aucun autre noeud n’étant en eﬀet censé être autorisé à émettre spontanément hors cycle ; le “beacon” est, dans ce mode, en général la trame comportant le fameux bit “Frame Pending” pour permettre l’envoi de données aux noeuds-feuilles ;
une CAP (Contention Access Period ) période durant laquelle les noeuds simples émettent vers le noeud central, ou recoivent les données leur étant destinées depuis celui-ci, en mode CSMA/CA ;
une CFP (Contention Free Period ) période durant laquelle il est possible de garantir l’accès au médium radio pour un noeud (ou plusieurs noeuds consécutifs) ;
une période de sommeil durant laquelle le PAN est mis en inactivité ce qui permet aux diﬀérents noeuds, y compris le noeud central, de désactiver leur émetteur / récepteur radio pour économiser leur énergie.
L’ensemble constitué par la CAP et la CFP d’un cycle donné constitue la supertrame (en anglais “superframe”, par opposition à la periode de sommeil).
Le cycle de fonctionnement du protocole MAC standard 802.15.4 en mode “beacon” est représenté dans la ﬁgure 3.4.

Figure 3.4 – Cycle de fonctionnement du protocole MAC du standard IEEE 802.15.4 en mode “beacon”. (Source : [Huang et al., 2013])

34

Chapitre 3. Analyse critique de l’état de l’art

Cette supertrame est divisée en 16 “time slots”, lequels sont répartis entre CAP et CFP par le noeud coordinateur à chaque nouveau cycle, en fonction des besoins du traﬁc réseau. Les “time slots” alloués à la CFP sont nommés GTS (Guaranteed Time Slots) ; le standard déﬁnit la procédure permettant à un noeud simple de demander au noeud coordinateur de PAN de lui allouer un ou plusieurs GTS au cycle suivant.
On voit ainsi que ce mode oﬀre plusieurs avantages par rapport au mode “nonbeacon” :
— le noeud coordinateur peut établir à lui seul son réseau (PAN) ; — la présence d’une CFP permet de prévoir l’envoi de données importantes,
dont le transport nécessite un accès garanti au médium radio sans risque de collision ; — la CFP permet également d’envisager l’envoi de lots de trames successifs (pour la transmission de données de grande taille), de façon plus robuste que par l’utilisation de la méthode CSMA/CA. On voit que la division de la période d’activité (superframe) en CAP et CFP est un moyen d’adapter le fonctionnement de la couche MAC au traﬁc sur le médium radio. Par défaut, cette adaptabilité est limitée par le fait que la durée d’un cycle, de la superframe, et donc le rapport entre ces deux durées, sont des constantes ﬁxées lors de la conﬁguration du PAN. Des travaux ont récemment été menés pour adapter dynamiquement ces paramètres au traﬁc réseau [Khssibi, 2015], le standard ne le prévoyant pas, mais ne l’interdisant pas non plus.

3.1.2.4 802.15.4e
Le standard IEEE 802.15.4 continue à évoluer, et les groupes de travail dédiés de l’IEEE ne cessent de le réviser et de le compléter — via des amendements — au cours du temps.
Les amendements 802.15.4a, 4b, 4c et 4d ont successivement amené de nouvelles bandes de fréquences et méthodes d’encodage du signal radio, l’amendement IEEE 802.15.4a ayant notamment amené la notion d’UWB, comme dit plus haut en section 3.1.1 page 26
Un amendement récent au standard, l’amendement 802.15.4e, adopté en 2012, a ajouté une nouvelle couche MAC nettement plus complexe, incluant notamment des mécanismes de multiplexage temporel et fréquentiel des transmissions radio. Nous reviendrons sur cet amendement 802.15.4e dans la section 3.2.5 page 45 consacrée aux protocoles MAC multicanaux.

3.2 Protocoles MAC
Outre les couches MAC « oﬃcielles » proposées par le standard 802.15.4, la communauté scientiﬁque a proposé de nombreux protocoles alternatifs destinés à surpasser les limitations du protocole standard, notamment sa version simple reposant sur la seule méthode CSMA/CA.

3.2. Protocoles MAC

35

Contrairement au mode simple, et de façon similaire au mode balisé décrit section 3.1.2.3 page 33, ces protocoles MAC alternatifs reposent sur la notion de “duty cycle”. Toute la diﬃculté pour la mise au point de ces protocoles consiste donc à ﬁxer des points de rendez-vous entre les diﬀérentes noeuds pour assurer correctement leur synchronisation.
On peut ainsi diviser ces divers protocoles en diﬀérentes familles, selon les méthodes utilisées pour ﬁxer ces points de rendez-vous :
— les protocoles MAC synchrones, employant des mécanismes de synchronisation explicites entre noeuds pour la transmission de trames : S-MAC et T-MAC en sont deux exemples ;
— les protocoles MAC asynchrones basés sur l’écoute à basse énergie (LPL : Low Power Listening) : B-MAC, X-MAC et ContikiMAC en sont trois exemples (ce dernier étant aujourd’hui très largement utilisé) ;
— les protocoles MAC asynchrones basés sur l’émission à basse énergie (LPP : Low Power Probing) : RI-MAC en étant l’exemple le plus connu ;
— les protocoles MAC basés sur l’ordonnancement temporel : LMAC, AI-LMAC en sont deux exemples ;
— les protocoles MAC multicanaux : diﬀérents protocoles ont exploré cette voie, mais surtout, l’extension du standard IEEE 802.15.4e fait désormais appel au multiplexage fréquentiel des transmissions, via un mécanisme nommé TCSH.
Nous allons dans cette section étudier ces diﬀérents types de protocoles de façon consécutive, à chaque fois en se penchant sur un ou deux protocoles représentatifs de chaque famille (notre but n’étant ici encore pas d’être exhaustif).
Enﬁn, nous étudierons plus en détail plusieurs protocoles MAC avancés : la famille CoSenS et iQueue-MAC, conçus et développés au sein du LORIA et de l’INRIA Nancy, sur lequels nous avons focalisé nos travaux.
La présente section 3.2 reprend la présentation eﬀectuée dans les supports de cours de Y.-Q. Song sur les systèmes communicants contraints [Song, 2013], ainsi que des données présentées dans l’article de référence (“survey”) de P. Huang, L. Xiao et al [Huang et al., 2013] et la thèse de B. Nefzi [Nefzi, 2011].

3.2.1 Protocoles MAC synchrones
Cette famille de protocoles MAC est basée sur la synchronisation explicite des cycles de fonctionnement de noeuds voisins. Il s’agit de la solution la plus évidente pour permettre la communication entre appareils, mais cela implique des coûts supplémentaires (en temps et en complexité) pour eﬀectuer cette synchronisation. Ce type de protocoles n’ayant pas de diﬃcultés pour établir des communications entre noeuds, ils peuvent faire l’objet d’optimisations pour augmenter le débit de données et réduire les délais de transmission.

3.2.1.1 S-MAC
Un premier exemple de protocole synchrone est le protocole S-MAC [Ye et al., 2002]. Celui-ci est basé sur la méthode CSMA/CA complétée par l’envoi de signaux

36

Chapitre 3. Analyse critique de l’état de l’art

indiquant qu’un noeud a des données à envoyer (RTS : Ready To Send ) et qu’un noeud est prêt à recevoir (CTS : Clear To Send ). Ce mode de fonctionnement est celui utilisé par le standard 802.11 (“Wi-Fi”).
Un cycle de fonctionnement sous le protocole S-MAC est divisé en une période active et une période inactive. La période active est la seule pendant laquelle un noeud peut envoyer et recevoir des données, la période inactive correspondant à la désactivation de l’émetteur / récepteur radio pour économiser l’énergie. La période active est elle-même divisée en une période de synchronisation, et une période d’échange de données.
Dans ce protocole, chaque noeud choisit ses périodes actives et inactives en fonction de ses voisins. Le premier noeud à démarrer est le seul choisissant librement ses périodes, et annonce ensuite régulièrement ses périodes par l’envoi de signaux de synchronisation (SYNC) durant une période dédiée (au début de la période active). Les noeuds démarrant ensuite vont alors adapter leurs propres périodes sur celles annoncées par les noeuds précédents. Ce mécanisme d’adaptation porte le nom “d’adaptative listening”.

Figure 3.5 – Adaptative listening entre trois noeuds suivant le protocole S-MAC. (D’après [Song, 2013])
La ﬁgure 3.5 montre un exemple de synchronisation entre plusieurs noeuds sous S-MAC. Le noeud B, démarrant en dernier, adapte sa période active à celle de ses deux voisins A et C. A et C étant hors de portée l’un de l’autre, ne vont par contre pas se synchroniser entre eux.
Ce protocole est donc basé sur la déﬁnition de rendez-vous entre émetteur et récepteur. L’utilisation de nombreux signaux pour coordonner les transmissions (SYNC, RTS, CTS) entraîne un surcoût (“overhead”) élevé diminuant d’autant la bande passante disponible pour les données, même si S-MAC est capable d’envoyer des trames par lots (“send burst”), après une seule séquence RTS/CTS, pour accélérer le traitement de données volumineuses.

3.2. Protocoles MAC

37

Ce protocole ayant des cycles de fonctionnement ﬁxes et un mécanisme de synchronisation assez lourd, son adaptabilité au traﬁc sur le réseau est très faible.
Notons enﬁn que toute synchronisation entre appareils diﬀérents est susceptible d’être victime du phénomène de dérive des horloges (dû aux inévitables diﬀérences de fonctionnement entre les horloges internes de chaque appareil). S-MAC utilisant des périodes actives assez longues, il est peu sensible aux perturbations dues à ce phénomène.

3.2.1.2 T-MAC
Le protocole T-MAC [Dam and Langendoen, 2003] est une amélioration de SMAC. Dans T-MAC, la durée de la période active n’est plus ﬁxée à l’avance, mais chaque noeud reste éveillé jusqu’à ce qu’aucun signal ne le concernant n’ait été entendu pendant un certain délai (notion de “timeout”). Ce schéma permet un meilleure adaptabilité au traﬁc réseau, en permettant notamment une période de sommeil plus longue en cas de faible traﬁc, d’où une meilleure économie d’énergie. La ﬁgure 3.6 permet de comparer le fonctionnement de base des protocoles S-MAC et T-MAC. On notera que ce dernier adapte sa période d’éveil à l’intensité du traﬁc réseau.

Figure 3.6 – Comparaison du fonctionnement de S-MAC et T-MAC. (D’après [Song, 2013])
T-MAC reprend également la capacité de S-MAC à eﬀectuer des envois de trames par lots (après une unique paire de signaux RTS/CTS) pour un traitement plus eﬃcace des données volumineuses.
3.2.2 Protocoles MAC asynchrones LPL
Dans un protocole MAC asynchrone, chaque noeud garde sa propre base de temps autonome. L’absence de synchronisation entre noeuds voisins permet (en théorie) d’éviter d’employer des phases de synchronisation systématiques à chaque cycle, donc à chaque appareil d’avoir un “duty cycle” plus réduit, et ainsi d’économiser son énergie, mais rend plus délicat l’établissement de communications entre noeuds. Toute la diﬃculté dans la mise au point d’un protocole asynchrone est de trouver une méthode eﬃcace en ce sens.
La famille des protocoles dits LPL (“Low Power Listening”, ou écoute à faible puissance) repose sur le principe suivant : chaque noeud passe la quasi-totalité de son temps en sommeil, c’est-à-dire avec sa radio désactivée ; pour déterminer si un message lui est destiné, il va de façon cyclique activer sa radio et vériﬁer si le canal

38

Chapitre 3. Analyse critique de l’état de l’art

radio est occupé (la procédure consistant à écouter le médium radio pour vériﬁer s’il est libre est appelée CCA : Clear Channel Assessment).
Les protocoles LPL vont diﬀérer sur la méthode d’envoi des données par les noeuds émetteurs : il s’agit en eﬀet de s’assurer que le noeud destinataire remarquera qu’une transmission lui est destinée — et donc d’entrer en contact avec ce dernier lorsqu’il eﬀectue son CCA — tout en essayant de minimiser l’énergie consommée par le noeud émetteur (en limitant le temps où la radio de ce dernier doit émettre).

3.2.2.1 B-MAC
Un premier exemple de protocole LPL est B-MAC (Berkeley MAC) [Polastre et al., 2004]. Dans ce protocole, un noeud devant envoyer des données émet un très long préambule (une trame ne contenant aucune donnée utile et ne servant qu’à signaler une future émission de données). Ce préambule est très long car son émission doit durer plus longtemps que l’intervalle entre deux CCAs consécutifs du récepteur. De plus, ce préambule ayant une taille ﬁxe, le récepteur devra, lorsqu’il l’aura détecté, attendre sa ﬁn avant de pouvoir recevoir ses données proprement dites. Ce mode de fonctionnement est représenté dans la ﬁgure 3.7.

Figure 3.7 – Schéma de fonctionnement de B-MAC (protocole LPL typique). (D’après [Song, 2013])
On voit que cette procédure entraîne une dépense d’énergie maximale pour le noeud émetteur (à cause de la nécessité d’envoyer ce très long préambule) ainsi qu’un encombrement important du canal radio, augmentant le risque de collisions. La taille ﬁxe du préambule comme de l’intervalle entre CCAs consécutifs rend également le protocole très peu adaptable au traﬁc réseau.
3.2.2.2 WiseMAC
Notre second exemple de protocole LPL, nommé WiseMAC [El-Hoiydi and Decotignie, 2004], emploie une technique consistant à « apprendre » les cycles de fonctionnement des noeuds voisins d’un même PAN. Pour ce faire, ce protocole repose d’abord sur l’envoi de longs préambules (comme B-MAC), auquels les noeuds récepteurs du PAN répondent par un acquittement lors de leur phase cyclique de réveil (“channel sampling”). Une fois les cycles de tous les noeuds du PAN connus, WiseMAC se distingue alors de B-MAC, en recourant à l’envoi de préambules bien plus courts, ce qui est possible en démarrant les transmissions au moment adéquat (en

3.2. Protocoles MAC

39

incluant une certaine marge de sécurité pour éviter les problèmes dûs à la dérive des horloges entre appareils). La possibilité, après un temps d’apprentissage, d’utiliser des préambules raccourcis améliore considérablement la consommation d’énergie des diﬀérents noeuds — aussi bien des émetteurs ayant moins de temps à passer à émettre, que des récepteurs n’ayant plus à écouter inutilement des préambules trop longs — et optimise l’utilisation du médium radio en le libérant pour la transmission de données « utiles », augmentant ainsi le débit maximal utile réel du réseau.

3.2.2.3 X-MAC
Notre troisième exemple de protocole LPL, X-MAC [Buettner et al., 2006], optimise nettement la procédure d’envoi, en remplaçant les long préambules de B-MAC par de très courts trames-préambules intégrant en outre l’adresse du noeud destinataire, comme on peut le voir dans la ﬁgure 3.8. Cette technique améliore non seulement la dépense d’énergie par le noeud émetteur ainsi que le taux d’occupation du médium, mais permet également d’éviter de garder inutilement éveillés des noeuds tiers, le destinataire d’une future émission étant clairement identiﬁé par ces courts préambules. Enﬁn, X-MAC inclut également l’envoi d’un acquittement préalable par le noeud récepteur (assimilable à un signal CTS) avant l’envoi des données proprement dites.

Figure 3.8 – Schéma de fonctionnement du protocole X-MAC. (D’après [Song, 2013])
3.2.2.4 ContikiMAC
Notre quatrième exemple de protocole LPL est ContikiMAC [Dunkels, 2011]. Celui-ci est nettement plus récent que les précédents, et a été conçu spéciﬁquement pour fonctionner sous Contiki OS (système que nous présenterons dans la section 3.3.3 page 65).
Ce protocole, par rapport à X-MAC, simpliﬁe encore la procédure d’envoi des données, en supprimant totalement la notion de préambule : lors d’une transmission, c’est désormais la trame de données elle-même qui est émise de façon répétitive, jusqu’au prochain réveil du noeud récepteur. Une fois la trame de données bien reçue, le destinataire envoie un acquittement (ACK standard 802.15.4) pour mettre ﬁn à l’émission de la trame. Le fonctionnement de ContikiMAC est représenté dans la ﬁgure 3.9 page suivante.

40

Chapitre 3. Analyse critique de l’état de l’art

Figure 3.9 – Fonctionnement du protocole ContikiMAC. (D’après [Song, 2013])
Autre particularité : chaque noeud eﬀectue deux CCA à chaque réveil cyclique, et ne retombe en sommeil que si ces deux CCA ont indiqué la non-occupation du canal radio. Ces deux CCA, séparés par un délai calculé à partir du délai standard entre émission de trames — DIFS — et la taille minimale d’une trame 802.15.4, permettent de consommer moins d’énergie qu’une longue écoute. Ces deux CCA ont ainsi la durée minimale nécessaire pour déterminer ou non l’occupation du médium radio.
Enﬁn, signalons que les versions récentes de ContikiMAC bénéﬁcient d’une optimisation supplémentaire : après un envoi réussi, le noeud émetteur mémorise la période de réveil du destinataire, aﬁn d’envoyer les trames suivants au meilleur moment et ainsi limiter au maximum les transmissions inutiles. Cette optimisation est nommée “phase lock” par les concepteurs de ContikiMAC. On peut rapprocher cette technique de “phase lock” du mécanisme d’apprentissage des cycles des noeuds observé antérieurement dans le protocole WiseMAC.
3.2.3 Protocoles MAC asynchrones LPP
Si les protocoles LPL sont conçus pour avoir une meilleure adaptabilité au traﬁc que les protocoles synchrones (comme S-MAC ou T-MAC), ils souﬀrent néanmoins de plusieurs inconvénients :
— une eﬃcacité energétique non optimale : B-MAC, avec ses très longs préambules, est clairement insuﬃsant dans ce domaine ;
— l’envoi de préambules (ou de trames dans le cas de ContikiMAC) avant la « transmission réelle » occupe inutilement le medium, augmentant ainsi les délais de transmission, les risques de collision, et diminuant le débit réel maximal du traﬁc ;
— l’inadéquation aux traﬁcs élevés — par exemple lors de « pics » ou « pointes » de transmissions — à cause de la méthode CSMA/CA sous-jacente ;
— la risque de « collisions cachées » entre noeuds : ce terme regroupe les cas où plusieurs paires de noeuds émetteurs/récepteurs, ayant chacune indépendemment des données à se transmettre, se gênent mutuellement si elles sont partiellement à portée l’une de l’autre. La ﬁgure 3.10 page suivante illustre la survenue de ces problèmes : les deux récepteurs sont à portée des deux émetteurs, ces derniers étant par contre incapables de se détecter mutuellement, ce qui provoque une collision entre les trames transmises par chacun des deux émetteurs.

3.2. Protocoles MAC

41

Figure 3.10 – Survenue de « collisions cachées » entre deux paires de noeuds menant chacune une transmission distincte, empêchant la réussite des deux communications. (D’après [Song, 2013] et [Sun et al., 2008])
Pour tenter de résoudre ces problèmes, un autre famille de protocoles MAC asynchrones a été conçue. Elle repose sur l’idée fondamentale de laisser les noeuds destinataires démarrer les transmissions. On parle donc de communications initiées par le recepteur, chaque noeud émettant cycliquement des “beacons” (ou “probes” : sondes) signalant quand il est prêt à recevoir (RI-LPP : Receiver Initiated Low Power Probing ).
3.2.3.1 RI-MAC
L’exemple de protocole LPP que nous allons examiner ici est RI-MAC [Sun et al., 2008]. Son principe de fonctionnement est le suivant : chaque noeud d’un réseau se réveille périodiquement, et émet un “beacon” signalant qu’il est prêt à recevoir des données. Un noeud ayant des données à transmettre va donc écouter le médium radio et attendre de recevoir un “beacon” issu du destinataire voulu. Dès ce “beacon” reçu, l’émetteur envoie sa trame de données. Le noeud récepteur conﬁrmera ensuite la bonne réception de cette trame par l’envoi d’un nouveau “beacon”, lequel joue à la fois le rôle d’acquittement de la trame reçue (ACK) et de signal pour le lancement d’une nouvelle transmission. Grâce à ce double rôle des “beacons”, l’envoi rapide de trames par lots est possible (par exemple pour gérer les transmissions de grandes quantités de données). Le principe de fonctionnement de la méthode LPP est représentée dans la ﬁgure 3.11 page suivante.
Par rapport aux protocoles LPL, ce principe de fonctionnement permet de réduire l’occupation moyenne du médium radio par un couple de noeuds pour arriver à un point de rendez-vous. En outre, les phénomènes de collisions cachées entre noeuds sont également moins fréquents.
L’un des principaux problèmes du principe LPP survient lorsque plusieurs noeuds ont simultanément besoin d’envoyer des données au même destinataire : à la récep-

42

Chapitre 3. Analyse critique de l’état de l’art

Figure 3.11 – Principe de transmission de données entre un noeud émetteur (A ou S) et un noeud récepteur (B ou R), selon la méthode RI-LPP (Receiver-Initiated Low Power Probing). (Source : [Song, 2013] et [Huang et al., 2013])
tion du “beacon” émis par ce dernier, les diﬀérents noeuds émetteurs vont tous émettre leurs trames de données, ce qui provoquera inévitablement une collision. La probabilité que plusieurs noeuds cherchent à envoyer des données au même noeud au même moment est d’autant plus forte que le traﬁc du réseau concerné devient important.
Pour pallier ce problème, RI-MAC ajoute au principe LPP de base une notion de “backoﬀ ” intégrée aux “beacons” : ces derniers incluent en eﬀet une durée maximale de « silence » parmi laquelle les noeuds émetteurs devront choisir aléatoirement un délai à respecter entre la réception de ce “beacon” et l’envoi de leurs données. Au début, cette fenêtre de “backoﬀ ” est nulle ; à chaque collision détectée, cette fenêtre va voir sa valeur augmenter rapidement pour minimiser les risques de nouvelle collision. Cette procédure est appelée BEB (Binary Exponential Backoﬀ ), et est illustrée dans la ﬁgure 3.12.

Figure 3.12 – Illustration de la méthode BEB (Binary Exponential Backoﬀ) employée par RI-MAC pour résoudre les problèmes de collisions dûs à l’envoi simultané de trames par plusieurs émetteurs. (Source : [Song, 2013] d’après [Sun et al., 2008])
On peut noter que cette procédure de BEB est similaire au mécanisme de “backoﬀ ” utilisé par la méthode CSMA/CA, également dans le but de résoudre les cas de collisions.
Grâce à ces mécanismes de fonctionnement, RI-MAC peut obtenir de meilleurs résultats que X-MAC quand le traﬁc réseau est élevé, tout en ayant un cycle de fonctionnement similairement bas (donc aussi économe en énergie) quand le traﬁc est faible.

3.2. Protocoles MAC

43

De façon générale, on constate que les protocoles basés sur le principe RI (Receiver Initiated ) sont nettement plus performants quand le traﬁc réseau est intense et/ou soumis à des interférences, là où les protocoles laissant l’initiative de la transmission aux émetteurs vont « étouﬀer » le réseau avec des collisions de trames de données. Cela est nettement visible dans le schéma présenté dans la ﬁgure 3.13. On y voit que les protocoles “Receiver-Initiated” (LPP) ont toujours un net avantage, d’autant plus ﬂagrant que le débit augmente.

Figure 3.13 – Comparaison entre protocoles “Receiver-Initiated” (LPP) et “SenderInitiated” (LPL) face à la montée en charge du traﬁc réseau. (Source : [Song, 2013] d’après [Österlind et al., 2012])
Néanmoins, l’utilisation du médium radio par la méthode LPL (même améliorée par RI-MAC) est toujours loin d’être optimale, le recours aux backoﬀs aléatoires pour éviter les collisions provoquant des « temps morts » où le réseau doit rester inutilement silencieux.
3.2.4 Protocoles MAC à ordonnancement temporel
Tous les protocoles que nous avons vus jusqu’ici sont basés sur la contention : les trames de données sont émises sur un médium radio non réservé, ce qui implique un risque de collision et donc de perte de données (ce qui nécessite en général un mécanisme de vériﬁcation et de réémission des données si besoin est).
À l’inverse, les protocoles MAC dit ordonnancés déﬁnissent strictement l’occupation du médium radio, en allouant une partie précise de la bande passante à chaque transmission potentielle, éliminant ainsi les collisions.
La méthode employée pour parvenir à cette ﬁn est basée sur le multiplexage temporel : chaque transmission se voit allouer le canal radio durant un intervalle de temps bien déﬁni. Cette méthode de fonctionnement est nommée TDMA (Time Division Multiple Access). Son fonctionnement est très similaire à la CFP observée plus haut dans le protocole MAC du standard IEEE 802.15.4 en « mode “beacon” ».
— Les protocoles basés sur la méthode TDMA sont considérés comme les plus eﬃcaces pour le traitement de traﬁcs réseaux intenses, car ce sont ceux qui

44

Chapitre 3. Analyse critique de l’état de l’art

permettent d’exploiter le plus eﬃcacement le médium radio, et donc d’approcher le plus de son débit maximal théorique. — Par contre, la nécessité de réserver au préalable les diﬀérents intervalles de temps, quelle que soit l’intensité du traﬁc réseau, entraîne un surcoût d’organisation (“overhead”), ce qui rend les protocoles basés sur la contention plus eﬃcaces pour les faibles traﬁcs. Les réseaux de capteurs sans-ﬁl actuels n’ayant le plus souvent à gérer qu’un faible traﬁc (avec éventuellement quelques pointes), cela explique que les protocoles basés sur la contention restent actuellement les plus utilisés. Tout ceci est résumé de façon claire et synthétique dans le schéma présenté dans la ﬁgure 3.14. On y voit que la contention (CSMA) gère mieux les faibles traﬁcs, tandis que l’ordonnancement (TDMA) est plus eﬃcace pendant les débits intenses (ou les pointes de traﬁc réseau).

Figure 3.14 – Comparaison de l’eﬃcacité entre méthodes basée sur la contention (CSMA) et sur l’ordonnancement (TDMA) en fonction du débit réseau. (Source : [Song, 2013])
En outre, toujours à cause de la nécessité d’organisation préalable du multiplexage temporel du médium radio, les protocoles basés sur l’ordonnancement sont en général du type synchrone, bien mieux adapté.
3.2.4.1 LMAC
Le protocole LMAC [Hoesel and Havinga, 2004] est un exemple typique de protocole basé sur la méthode TDMA. Chaque cycle de fonctionnement (ou « trame ») est divisé en “slots”, représentant une unité minimale de temps qui sera réservée à un noeud donné. Chaque noeud du réseau se verra attribuer un slot donné au sein de chaque trame réseau.

3.2. Protocoles MAC

45

Durant son slot de temps, un noeud doit d’abord émettre un message de contrôle — indiquant s’il a des données à transmettre, et si oui quel est leur destinataire — suivi s’il y a lieu du trame de données à émettre.
Tous les noeuds du réseau doivent ainsi avoir leur émetteur / récepteur radio activé pour écouter le message de contrôle émis au début de chaque slot. Les noeuds n’étant pas destinataires d’un message durant ce slot peuvent ensuite désactiver leur radio (donc tous les noeuds si aucune donnée n’est à émettre durant ce slot).
À noter que l’allocation des slots ne se fait pas de façon centralisée : au démarrage du réseau, chaque noeud doit choisir un slot parmi ceux disponibles, et le réserver pour les trames suivantes en y émettant un message de contrôle.

3.2.4.2 AI-LMAC
Le protocole AI-LMAC [Chatterjea et al., 2004] est une extension de LMAC permettant à un noeud de réserver plusieurs slots au sein de chaque trame. Le choix du nombre de slots à allouer à chaque noeud n’est pas faite de façon distribuée (comme pour la réservation), mais par le coordinateur du réseau en fonction du traﬁc sortant prévu pour chaque noeud.

3.2.5 Protocoles MAC multicanaux
Une dernière catégorie de protocoles MAC repose sur la capacité de la couche physique 802.15.4 d’exploiter plusieurs canaux (c’est-à-dire plusieurs fréquences) radio diﬀérents. Ainsi, tout comme il est possible de multiplexer les diﬀérentes transmissions dans le temps, cette fonctionnalité de la couche physique permet d’eﬀectuer un multiplexage sur les fréquences radio : en assignant des canaux diﬀérents aux diﬀérents noeuds d’un réseau, il devient possible de gérer des transmissions de données parallèles.
Par analogie avec l’acronyme TDMA vu section 3.2.4 page 43, cette méthode de multiplexage sur les fréquences radio est appelée FDMA (Frequency Division Multiple Access).
Les deux principales diﬃcultés pour la conception de tels protocoles sont : — la distribution des diﬀérents canaux aux diﬀérents noeuds d’un réseau ; et — la gestion eﬃcace de la communication entre ces diﬀérents canaux. Le deuxième point est rendu particulièrement diﬃcile, car les émetteurs / récepteurs radio conçus pour le standard 802.15.4 ne sont pas capables d’écouter simultanément plusieurs fréquences. En outre, le standard 802.15.4 limitant la taille des trames physiques à 127 octets, un mécanisme d’attribution des canaux aux diﬀérents noeuds peut rapidement entraîner un surcroît de charge (“overhead”) intolérable pour un réseau de ce type. Diﬀérents protocoles ont été proposés pour contourner ces diﬃcultés, la tendance actuelle étant de combiner multiplexage temporel et multiplexage fréquentiel : on parle ainsi de protocoles TDMA/FDMA. Parmi ces protocoles, on peut citer MCLMAC employant cette méthode pour gérer les envois de reales de données, ainsi que Y-MAC et MuChMAC employant une méthode de « saut de fréquence » (“channel

46

Chapitre 3. Analyse critique de l’état de l’art

hopping”) pour permettre aux diﬀérents noeuds de recevoir des trames de données de plusieurs canaux diﬀérents.
Ces protocoles multicanaux n’ayant pas été traités lors des présents travaux de thèse, nous ne les étudierons pas plus en détail ici ; l’étude de référence (“survey”) de [Huang et al., 2013] consacrant toute sa section V à l’étude de ces protocoles, nous invitons le lecteur souhaitant plus de détails sur ce sujet à s’y reporter.
Il est par contre plus important de noter que l’amendement 802.15.4e du standard, adopté en 2012, consacré à l’amélioration de la couche MAC oﬃcielle du standard IEEE [IEEE 802.15.4e, 2012], inclut un mécanisme nommé “Time Slotted Channel Hopping” ou TSCH. Plus qu’une simple amélioration, il s’agit tout simplement d’une nouvelle couche MAC, totalement compatible avec la couche physique déﬁnie dans les précédentes versions du standard 802.15.4, employant multiplexage temporel et multiplexage fréquentiel pour parvenir à une consommation d’énergie minimale et une ﬁabilité de transmission maximale.
Une version dédiée de la pile IPv6 destinée à fonctionner par-dessus cette nouvelle couche MAC et son mécanisme TSCH est déjà en cours de conception par l’IETF, sous le nom de projet « 6TiSCH » [Thubert et al., 2013]. Cette nouvelle pile protocolaire est notamment destinée à être supportée par la pile réseau avancée OpenWSN [Watteyne et al., 2012], dont nous reparlerons dans plus loin dans le présent chapitre (section 3.3.5 page 68 sur RIOT OS et section 3.3.7.1 page 72 sur FreeRTOS).
Notons toutefois que cette couche MAC est largement plus complexe que celles déﬁnies dans les versions précédentes du standard (et que nous avons étudiées section 3.1.2 page 29). Sa mise en oeuvre pourrait par conséquent poser des diﬃcultés sur les appareils à fonctionnalités réduites (RFD) susceptibles de faire partie d’un réseau de capteurs sans-ﬁl. La description de cette nouvelle couche MAC complexe sort du cadre du présent manuscrit de thèse et ne sera donc pas entreprise ici.
Malgré ces limitations, le standard IEEE 802.15.4e proposant désormais une couche MAC oﬃcielle reposant sur le paradigme TDMA/FDMA, ce mode de fonctionnement sera sans doute appelé à devenir incontournable dans l’implantation des réseaux de capteurs sans-ﬁl du futur.
Après l’étude des principales catégories « standard » de protocoles MAC, et d’exemples représentatifs de ces dernières, nous allons maintenant nous focaliser sur les protocoles avancés ayant fait l’objet des travaux de la présente thèse.

3.2.6 Protocoles hybrides avancés
Des recherches sur la conception de protocoles MAC ont également été menées au sein du centre INRIA Nancy Grand-Est et du LORIA. Ces recherches ont notamment abouti à la conception de plusieurs protocoles évolués, qui ont été à la base des travaux menés dans la présente thèse. Nous allons dans la présente section examiner successivement ces diﬀérents protocoles sur lesquels nous nous sommes focalisés.
Nous aborderons également brièvement — pour compléter notre tour d’horizon des protocoles avancés — dans une autre sous-section les travaux d’autres équipes de recherche sur d’autres protocoles MAC avancés.

3.2. Protocoles MAC

47

Nous évoquerons aussi la couche MAC contenue dans une pile protocolaire intégrée et complète, issue d’un eﬀort de développement suivant une approche dite multi-couches (en anglais “cross-layer” dans une dernière sous-section. De telles approches sortent toutefois du cadre de cette thèse, laquelle se focalise sur les seules couches basses, et ne font par conséquent l’objet d’aucun travail dans cette thèse.
3.2.6.1 CoSenS et S-CoSenS
Ce protocole, conçu par B. Nefzi et Y.-Q. Song [Nefzi and Song, 2010] [Nefzi and Song, 2012], fait partie de la classe des protocoles basés sur la contention. Il est décrit dans le chapitre 3 de la thèse de B. Nefzi [Nefzi, 2011].
Le but de ce protocole est d’améliorer les performances de la couche MAC notamment concernant la qualité de service, tout en limitant les coûts liés à l’implantation de cette couche, ce qui exclut le recours à la méthode TDMA (celle-ci nécessitant une conﬁguration minutieuse du réseau, une précision très ﬁne de la synchronisation entre noeuds, et une adaptation diﬃcile aux changements de traﬁc sur le réseau).
Le protocole CoSenS reprend donc la méthode CSMA/CA, en contrôlant les instants où se déroulent les transmissions et où le médium radio est utilisé. Le principe de base est de séparer temporellement la période où un noeud reçoit des trames de données (période de réception) de celle où ce même noeud émet les trames ainsi reçues (période de retransmission). Ceci est schématisé dans la ﬁgure 3.15. On voit que chaque cycle CoSenS est partagé entre une période de réception (ou période d’écoute : WP) durant laquelle le noeud collecte les trames reçues, suivi d’une période de transmission (TP) durant laquelle tous les trames collectées dans la ﬁle d’envoi sont transmises vers la destination adéquate. (Les trames / paquets collectés pouvant éventuellement être traités par les couches supérieures de la pile de façon arbitraire entre réception et émission).

Figure 3.15 – Principe de base du protocole CoSenS. (Source : [Nefzi, 2011])
Il a été démontré que ce protocole apporte une amélioration sensible des performances et de la qualité de service — notamment au niveau du taux de succès de transmission des trames, du débit réseau maximal supporté, ainsi que du délai de transmission de bout-en-bout des données — par rapport au protocole MAC de base du standard 802.15.4.

48

Chapitre 3. Analyse critique de l’état de l’art

Son principal défaut est par contre de nécessiter que tous les noeuds gardent leur émetteur / récepteur radio allumé en permanence, ce qui représente un sérieux désavantage concernant l’économie d’énergie.
C’est pourquoi ce protocole a été amélioré pour inclure une période de sommeil dans le cycle de fonctionnement des noeuds. Le protocole résultant est nommé SCoSenS, et c’est celui sur lequel nous nous sommes principalement basés lors de nos travaux de thèse. Il s’agit donc à la fois d’un protocole MAC et d’un protocole RDC (Radio Duty Cycle : gérant le cycle d’allumage et d’extinction de l’émetteur / récepteur radio), qui plus est adapté aux phases de routage. Il est décrit dans le chapitre 5 de la thèse de B. Nefzi [Nefzi, 2011].
Tout comme CoSenS, il est basé sur la méthode CSMA/CA, et est ainsi comparable à la couche MAC 802.15.4 en « mode sans “beacon” ». L’idée de base reste de retarder la retransmission des trames reçues, en divisant chaque cycle de fonctionnement d’un noeud coordinateur en trois périodes :
— une période de sommeil (SP : Sleeping Period ) où l’émetteur / récepteur radio est désactivé pour économiser l’énergie du noeud ;
— une période d’écoute ou période d’attente (WP : Waiting Period ) durant laquelle le médium radio est écouté pour collecter les trames de données 802.15.4 arrivantes ;
— et une période de transmission (TP : Transmission Period ) durant laquelle les trames reçues et mis en attente durant la période d’écoute sont réémises, si possible en lot (“burst”).
Le principal avantage de S-CoSenS est son capacité à s’adapter dynamiquement à l’intensité du traﬁc radio en temps réel, en calculant pour chaque cycle radio (commun à tout un PAN fonctionnant sous S-CoSenS) la durée des périodes de sommeil (SP) et d’écoute (WP), en fonction du nombre de trames retransmises durant les cycles précédents.
Notons que l’ensemble constitué de la période de sommeil (SP) et de la période de réception (WP) d’un même cycle est appelé subframe ; il s’agit de la partie du cycle de S-CoSenS dont la durée est calculée et connue a priori. À l’inverse, la durée de la période d’envoi (TP) ne peut être déterminée qu’à son tout début, car cette durée dépend directement de la quantité de trames de données reçues avec succès durant la période d’écoute (WP) précédente.
En outre, le calcul de la durée de la période d’envoi WP se fait via un algorithme de « moyenne glissante », où la durée de WP pour chaque cycle est calculée ainsi :
WPn = α · WPn−1 + (1 − α) · WPn−1
WPn = max(WPmin, min(WPn, WPmax))
où WPn et WPn−1 sont respectivement la durée moyenne de WP au neme et (n−1)eme cycle, tandis que WPn et WPn−1 sont les durées réelles de WP respectivement au neme et (n−1)eme cycles ; α est un paramètre dont la valeur est arbitrairement choisie entre 0 et 1, représentant le poids relatif de l’historique dans le calcul des durées ; WPmin et WPmax étant les limites minimales et maximales imposées à la durée de WP par le programmeur.

3.2. Protocoles MAC

49

La synchronisation locale entre un routeur S-CoSenS et ses noeuds-feuilles, au sein d’un même PAN, se fait grâce à une trame “beacon” émis par le routeur au début de chaque cycle. Ce “beacon” inclut les durées (en microsecondes) choisies pour la période de sommeil (SP) et la période de réception (WP) au cours du cycle dont le “beacon” marque le début.
La représentation schématique d’un cycle complet S-CoSenS, du point de vue d’un routeur gérant un PAN, est décrite dans la ﬁgure 3.16. On distingue la période de sommeil (SP), la période d’écoute / réception (WP) et la période de retransmission (TP). L’ensemble des deux premières périodes constitue la subframe, dont la durée est calculée à l’avance, en fonction du traﬁc réseau observé jusqu’alors.
La ﬁgure 3.16 montre clairement l’adaptation du cycle S-CoSenS à un traﬁc réseau respectivement moyen, intense et faible.

Figure 3.16 – Principe d’un cycle de fonctionnement d’un noeud coordinateur S-CoSenS. (D’après [Nefzi, 2011])
Cette synchronisation locale au sein d’un PAN S-CoSenS, faite grâce à l’envoi cyclique d’un “beacon”, repose donc sur le paradigme LPP (Low Power Probing, principe détaillé plus haut). D’un autre côté, la synchronisation et la communication entre routeurs S-CoSenS appartenant à des PANs diﬀérents se fait grâce à de courtes périodes d’éveil et d’écoute se déroulant durant la période de sommeil (SP), et repose donc sur le paradigme LPL (Low Power Listening, comme pour X-MAC par exemple), pour des raisons de simplicité.
À noter que le cycle S-CoSenS complet (SP + WP + TP) ne concerne que les noeuds jouant le rôle de routeur et de coordinateur de PAN.

50

Chapitre 3. Analyse critique de l’état de l’art

En eﬀet, une propriété intéressante de S-CoSenS est que les noeuds terminaux ou noeuds-feuilles (c’est-à-dire ceux n’ayant pas un rôle de routeur ou de coordinateur de réseau) peuvent garder leur émetteur / récepteur radio constamment éteint, tant qu’ils n’ont pas de trame à envoyer. Quand un de ces noeuds-feuilles doit envoyer une trame de données, il démarre sa radio, écoute et attend le premier “beacon” émis par un routeur, puis émet sa trame en utilisant la méthode CSMA/CA au début de la période de réception (WP) annoncée dans le “beacon” qu’il a reçu. Ce noeud-feuille peut éteindre sa radio pendant le délai courant entre le “beacon” et la WP attendue (c’est-à-dire durant le délai correspondant à la période de sommeil SP du routeur ayant émis le “beacon”), émet sa trame durant la WP voulue, puis peut retourner à l’état de sommeil une fois sa trame transmise avec succès.
Toute cette procédure de transmission est résumée dans la ﬁgure 3.17. Dans cette ﬁgure, les parties grises représentent les périodes où un noeud fait fonctionner sa radio, les blocs oranges correspondent aux transmissions de trames, tandis que les parties blanches sont celles où le noeud met sa radio en sommeil pour économiser son énergie. Le noeud simple émetteur se réveille quand une trame doit être émise, attend le “beacon” issu du routeur, se synchronise alors pour émettre la trame durant la période de réception (WP) du routeur, puis retourne en mode sommeil. Le routeur peut ensuite réemettre la trame vers la destination adéquate durant sa période de transmission (TP).

Figure 3.17 – Transmission d’une trame avec le protocole S-CoSenS.
Si ce protocole représente une amélioration certaine par rapport au protocole MAC de base du standard 802.15.4 et aux protocoles LPL et LPP classiques — comme nous le verrons dans le chapitre 5 de la présente thèse —, il continue néanmoins de souﬀrir des limitations intrinsèques liées au principe de contention sur lequel il est basé : lors de traﬁcs réseaux intenses, la qualité de service (taux de trames transmises avec succès, délais de transmission) chute irrémédiablement. Ces problèmes sont mieux pris en charge par les protocoles basés sur l’ordonnancement (TDMA) mais ceux-ci posent d’autres problèmes (complexité, lourdeur d’organisation). Des recherches ont donc été menées pour contourner ces problèmes, et ont abouti à la mise au point de nouveaux protocoles plus performants, dont celui que nous allons maintenant détailler dans la section 3.2.6.2 suivante.

3.2. Protocoles MAC

51

3.2.6.2 iQueue-MAC
Ce protocole, de conception récente et ambitieuse [Zhuo et al., 2013], est un protocole ordonnancé hybride, utilisant la contention (méthode CSMA/CA) et l’ordonnancement temporel (TDMA) en fonction du traﬁc réseau courant.
Nous avons vu en eﬀet plus haut qu’il a été démontré que la méthode CSMA est plus eﬃcace pour le traitement des faibles traﬁcs, tandis que TDMA est nettement plus appropriée pour supporter les traﬁcs intenses.
Si le protocole MAC standard 802.15.4 en « mode “beacon” » fait déjà appel à une approche hybride (avec les notions de CAP et CFP), il est limité par la conﬁguration totalement statique de ses paramètres de fonctionnement.
À l’inverse, iQueue-MAC est conçu pour s’adapter dynamiquement et en temps réel au traﬁc du réseau, de façon à adopter à chaque instant la meilleure conﬁguration pour optimiser qualité de service et consommation d’énergie (via la maîtrise du duty cycle et de ses diﬀérentes périodes, dont les durées sont dynamiques).
La ﬁgure 3.18 montre comment iQueue-MAC gère la montée en charge du traﬁc réseau de façon totalement diﬀérente d’autres protocoles plus classiques basés sur la seule contention (comme par exemple S-CoSenS).

Figure 3.18 – Comparaison de la gestion de la montée en charge du traﬁc réseau entre (1) un protocole uniquement basé sur la contention, et (2) iQueue-MAC, qui a recours à une période basée sur TDMA de durée variable, adaptée à la charge réseau. (Source : [Song, 2013])
Les idées principales qui sous-tendent la conception d’iQueue-MAC sont les suivantes :
— L’utilisation de la contention (CSMA/CA) quand le traﬁc est faible, et de l’ordonnancement temporel (TDMA) quand le traﬁc devient intense.
— La séparation des noeuds sans-ﬁl en deux catégories : les noeuds simples (terminaux ou noeuds-feuilles) et les routeurs.
— Les noeuds simples (tout comme avec la famille CoSenS) ne s’éveillent que quand ils ont des données à envoyer, et passent donc la majeure partie de leur temps en sommeil pour économiser leur énergie.
— Les routeurs sont les noeuds exécutant véritablement la totalité du mécanisme d’iQueue-MAC.

52

Chapitre 3. Analyse critique de l’état de l’art

Figure 3.19 – Structure d’une trame iQueue-MAC. (Source : [Song, 2013])
Figure 3.20 – Structure d’un “beacon” iQueue-MAC. (Source : [Song, 2013])
— Le protocole base son comportement et sa conﬁguration sur la connaissance de la quantité de trames à envoyer (c’est-à-dire la longueur de la ﬁle d’envoi de trames) pour chaque noeud du réseau.
En eﬀet, chaque noeud simple, lorsqu’il envoie une trame, insère le niveau d’occupation de sa ﬁle d’envoi (juste après l’entête de la trame). Le routeur est donc à chaque cycle capable d’évaluer la charge que devra soutenir le réseau lors du cycle suivant. La structure d’une trame iQueue-MAC est représentée ﬁgure 3.19. On notera l’ajout du taux d’occupation de la ﬁle d’envoi du noeud émetteur entre l’entête MAC et la charge utile (“payload”) de la trame proprement dite.
Chaque cycle iQueue-MAC (également appelé superframe, est représenté ﬁgure 3.21 page ci-contre. La subframe est la partie du cycle dont la durée est calculée (donc connue) à l’avance ; elle comporte la période TDMA, dont la durée varie en fonction de l’intensité du traﬁc réseau, et dont les slots temporels sont alloués aux diﬀérents noeuds en fonction de la quantité de trames qu’ils ont à émettre (ces quantités ayant été transmises durant la période de contention du cycle précédent).
Un cycle iQueue-MAC se décompose donc en les phases suivantes :
B : “beacon”. Celui-ci permet la synchronisation des diﬀérents noeuds du PAN : il indique la durée et l’aﬀectation des diﬀérents slots de la période TDMA, ainsi que la durée de la période de sommeil. L’ensemble regroupant les slots de temps TDMA et la période de sommeil est appelé subframe : c’est la partie du cycle iQueue-MAC dont la durée est calculée et allouée à l’avance. La structure d’un “beacon” iQueue-MAC est détaillée ﬁgure 3.20. Toutes les données nécessaires pour calculer la durée de la subframe, de la section TDMA variable, et l’allocation des diﬀérents slots de temps TDMA aux diﬀérents noeuds demandeurs sont présentes.
SF : SubFrame Cette période contient les slots de temps TDMA dont l’allocation aux diﬀérents noeuds a été annoncée dans le “beacon” ; ces slots TDMA sont suivis de la période de sommeil où la radio du routeur est éteinte pour économiser l’énergie. Notons que comme dans d’autres protocoles tels que X-MAC ou S-CoSenS, de courts moments d’activation de la radio ont lieu durant la période de sommeil, aﬁn de pouvoir détecter et recevoir des messages en provenance de routeurs d’autres PANs.

3.2. Protocoles MAC

53

Figure 3.21 – Structure d’un cycle iQueue-MAC. (Source : [Song, 2013])
CP : Contention Period Période de réception basée sur le principe de la contention (CSMA/CA) où chaque noeud du PAN est autorisé à transmettre une et une seul trame — s’il a plus d’une trame de données à transmettre, l’indicateur de remplissage de sa ﬁle d’envoi situé au début de la charge utile (“payload”) de la trame lui fera allouer le nombre de slots nécessaires durant la subframe du cycle suivant. La durée de la CP n’est pas prédéterminée : le routeur écoute jusqu’à la survenue d’un timeout d’inactivité radio, ce qui est censé donner assez de temps à chaque noeud ayant des données à émettre (principe similaire à celui vu plus haut pour T-MAC).
TP : Transmission Period La retransmission des trames par le routeur — vers le routeur suivant ou le concentrateur ﬁnal / station de base du réseau sans ﬁl (“sink”) — se fait par lots (en mode “burst”), comme par exemple pour les protocoles T-MAC ou RI-MAC vus plus haut : une fois la première trame envoyée avec succès, les trames suivantes sont envoyées avec un minimum d’overhead.

Figure 3.22 – Exemple de transmission de trames entre deux noeuds simples et un routeur avec le protocole iQueue-MAC. (Source : [Song, 2013])

54

Chapitre 3. Analyse critique de l’état de l’art

Donnons ici un exemple de déroulement d’une transmission d’un lot de trames depuis deux noeuds simples vers un routeur iQueue-MAC, tel que montré dans la ﬁgure 3.22 page précédente :
1. Soit un routeur R, et deux noeuds N1 et N2, ayant respectivement 4 et 5 trames de données à transmettre ; on suppose qu’aucune autre transmission n’est en cours à ce moment-là dans ce PAN.
2. Pendant le premier cycle, N1 et N2 reçoivent le “beacon” de synchronisation. Aucun slot TDMA n’étant alloué, ils attendent tous deux la période de contention CP, et émettent chacun leur première trame de données ; la méthode CSMA/CA étant utilisée, ils reçoivent un acquittement pour l’envoi de ces premières trames.
3. Le routeur termine son cycle par sa période de transmission TP, et le premier cycle se termine.
4. Le routeur ayant reçu la taille des ﬁles d’envoi des deux noeuds lors de la période de contention précédente, il alloue donc le nombre de slots TDMA nécessaire aux diﬀérents noeuds : 3 pour N1, et 4 pour N2. Une fois les durées nécessaires calculées, le second cycle commence, et un nouveau “beacon” est envoyé.
5. Les noeuds N1 et N2 reçoivent ce “beacon” et se synchronisent pour l’envoi de leurs données durant la subframe
6. Les trois premiers slots TDMA étant alloués à N1, celui envoie dès le début de la subframe ses trames restantes. Sa ﬁle d’envoi étant désormais vidée, il peut retourner en mode sommeil, jusqu’à ce qu’il ait par la suite de nouvelles données à envoyer.
7. Les quatre slots TDMA suivants étant alloués à N2, il peut lui aussi envoyer à son tour les trames de données restant dans sa ﬁle d’envoi, et à son tour passer en mode sommeil pour économiser son énergie.
8. Toutes les données ayant besoin d’être transmises sont désormais arrivées au routeur, qui peut terminer sa subframe en période de sommeil, puis retransmettre ces trames de façon adéquate durant la période de transmission (TP) qui terminera ce second cycle (mais n’est pas montrée sur la ﬁgure 3.22 page précédente).
Les diﬀérentes expériences menées dans la publication [Zhuo et al., 2013] ont montré la nette supériorité d’iQueue-MAC en termes de qualité de service — taux de trames transmises avec succès, délai total de transmission — dans toutes les conﬁgurations, vis-à-vis de protocoles tels que RI-MAC ou CoSenS (lequels avaient euxmêmes déjà prouvé leur supériorité sur les protocoles LPL classiques couramment utilisés). Cette supériorité est notamment ﬂagrante pour les charges réseaux intenses, ou pour le traitement de pics soudains de traﬁc. Ce protocole semble donc se poser en concurrent sérieux pour le nouveau protocole 802.15.4e ; ce dernier ayant pour avantage sa capacité de traitement multicanal, tandis que iQueue-MAC semble plus à même d’exploiter au mieux le débit maximal théorique d’une unique fréquence

3.2. Protocoles MAC

55

radio, ce qui rend sa conception et son implantation plus simple — avantage non négligeable lorsqu’il s’agit d’implanter un protocole MAC sur un appareil à fonctionnalités limitées (« RFD » standard IEEE 802.15.4).
3.2.6.3 Autres évolutions de protocoles basés sur la contention
Outre les protocoles avancés développés par notre équipe que nous avons décrit ci-dessus dans les sections 3.2.6.1 à 3.2.6.2 pages 47–51, d’autres équipes de recherche continuent également d’apporter de nouvelles idées et techniques pour améliorer les performances et/ou diminuer la consommation énergétique des protocoles MAC / RDC.
Nous citerons ici, à titre d’exemple, les travaux menés à l’Université de Strasbourg pour améliorer les protocoles basés sur la technique LPL, grâce notamment à un mécanisme nommé T-AAD (lightweight “Traﬃc Auto-ADaptations” [Papadopoulos et al., 2014], conçu pour permettre aux protocoles LPL de mieux gérer les pointes (“bursts”) de traﬁc réseau.
Le mécanisme T-AAD consiste à adapter dynamiquement les paramètres de conﬁguration des protocoles MAC en fonction des variations du traﬁc réseau. Le principal paramètre d’un protocole LPL étant la durée de la période de sommeil (ici appelée ST ) entre deux CCA consécutifs — c’est-à-dire en fait la durée du cycle de ces protocoles LPL —, T-AAD se propose d’alterner la durée de ST entre deux extremums, STmin et STmax, selon la charge réseau. STmax est la durée de cycle longue (par exemple, 500 ms), employée par défaut, lorsque la charge réseau est à son niveau « de base ». STmin est la durée de cycle courte (par exemple, 32 ms), utilisée temporairement aﬁn de prendre en charge eﬃcacement les pointes de traﬁc réseau.
Aﬁn de pouvoir estimer dynamiquement la charge réseau à venir, T-AAD impose à chaque noeud d’ajouter, à chaque paquet émis, le nombre de paquets lui restant à émettre dans sa ﬁle d’envoi. Un noeud récepteur employant T-AAD utilise alors cette information pour calculer le temps durant lequel il va passer sa durée de cycle à STmin pour gérer cette charge à venir : cette durée de fonctionnement « intensif » est nommée Tadapt. Une fois la durée Tadapt écoulée, le noeud revient à la durée de cycle par défaut STmax. (Notons que quand les émetteurs ne produisent qu’une charge réseau modérée, Tadapt sera calculée à la valeur 0, et un récepteur gardera alors un cycle standard de durée STmax.)
Le but du mécanisme T-AAD est donc de rendre les protocoles LPL « classiques » (comme X-MAC ou ContikiMAC) auto-adaptatifs à la charge réseau, comme le sont naturellement CoSenS / S-CoSenS et iQueue-MAC.
Notons toutefois qu’il s’agit d’un mécanisme bien plus simple que pour nos deux protocoles, la durée de cycle variant de façon discrète entre deux valeurs, et non de façon continue et précise. L’avantage de T-AAD est d’être ainsi d’une conception bien plus simple, au prix d’une moindre précision dans l’adaptation de la durée des cycles MAC ; toutefois, comme ce mécanisme doit s’adapter à des protocoles n’ayant pas été au départ conçus pour être auto-adaptatifs, une telle simplicité peut être considérée comme mieux adaptée à la cible choisie.

56

Chapitre 3. Analyse critique de l’état de l’art

Ce mécanisme T-AAD a été implémenté et testé pour améliorer des protocoles LPL classiques comme X-MAC [Papadopoulos et al., 2014] [Papadopoulos et al., 2015a] (se reporter à la section 3.2.2.3 page 39 pour les détails sur le fonctionnement « standard » de ce protocole). Les changements apportés par le mécanisme T-AAD dans le fonctionnement de X-MAC sont illustrés dans la ﬁgure 3.23.

Figure 3.23 – Modiﬁcation du fonctionnement du protocole X-MAC par le mécanisme T-AAD. (Source : [Papadopoulos et al., 2014])
Il a été montré dans [Papadopoulos et al., 2014] que ce mécanisme simple — donc relativement facile à implémenter et peu coûteux en occupation mémoire et en temps processeur — a permis d’améliorer signiﬁcativement les performances (notamment en termes de délais de transmission) et l’eﬃcacité énergétique du protocole X-MAC ainsi modiﬁé. Ces améliorations ont été constatées lors de tests faits sur du matériel réel, à savoir : les noeuds du testbed IoT-LAB [FIT IoT-LAB, 2008].
Plus récemment, cette même équipe a publié plusieurs versions améliorées de ContikiMAC (cf. section 3.2.2.4 pour plus de détails sur ce protocole MAC / RDC), destinées à être mieux adaptées aux noeuds mobiles, nommées M-ContikiMAC et ME-ContikiMAC [Papadopoulos et al., 2015b] (M signiﬁant ici “Mobile”, et ME “Mobile Enhanced”).
Le protocole M-ContikiMAC consiste à utiliser pour émettre ses trames un mode de transmission “anycast”, permettant à n’importe quel noeud à portée de recevoir une trame. Contrairement toutefois au mode “broadcast” que nous avons vu pour l’envoi de beacons, en mode “anycast” tout récepteur est tenu de renvoyer une trame d’acquittement, comme pour une transmission classique (également appelée “unicast”). Une fois un ou plusieurs récepteurs identiﬁés grâce aux premiers envois de trames en mode “anycast”, les transmissions suivantes de trames de données peuvent se faire en mode “unicast” classique suivant le mécanisme standard de ContikiMAC. Ce mode opératoire, bien adapté aux noeuds mobiles ne pouvant compter sur des

3.2. Protocoles MAC

57

protocoles de routage avancés pour découvrir leur entourage, peut être illustré grâce au schéma montré en ﬁgure 3.24 (où un noeud mobile communique avec un noeud ﬁxe parmi deux présents dans un WSN donné).

Figure 3.24 – Fonctionnement du protocole avancé M-ContikiMAC, optimisé pour les noeuds mobiles des WSN. (Source : [Papadopoulos et al., 2015b])
Sur la base de M-ContikiMAC, la même équipe a par la suite développé MEContikiMAC. Ce dernier protocole a été conçu pour mieux gérer, par rapport à M-ContikiMAC, les problèmes liés à la duplication des trames et à l’optimisation des délais de transmission. Pour ce faire, ME-ContikiMAC envoie désormais en “anycast”, pour chercher des récepteurs et établir des « connexions », non plus des trames de données (comme dans M-ContikiMAC), mais des trames de contrôle, dont l’émission est maintenue même en cas de collision au niveau des trames d’acquittement, jusqu’à la réception d’une trame d’acquittement correcte. L’envoi des trames de données se fait ensuite uniquement en “unicast”, jusqu’à la ﬁn de la transmission ou la « perte de connexion » (par exemple quand le noeud mobile n’est plus à portée).
Le fonctionnement de ME-ContikiMAC peut être illustré par la ﬁgure 3.25 page suivante. On y voit notamment la façon dont ce protocole gère les collisions au niveau des trames d’acquittement, et ce avec un noeud mobile communicant avec trois noeuds ﬁxes.
[Papadopoulos et al., 2015b] met en évidence de nettes améliorations du point de vue de la qualité de service (déduplication de paquets, occupation du médium radio et délais de transmission réduits) et de la consommation énergétique. Ladite publication montre en particulier que les améliorations apportées par ME-ContikiMAC sont sensibles au niveau des WSN ayant des noeuds statiques mais aussi et surtout des noeuds mobiles. (Notons toutefois que cet article ne s’appuie, contrairement aux publications sur T-AAD, que sur des simulations eﬀectuées sous Cooja.)
On voit donc au ﬁnal que de nombreuses équipes de recherche continuent à explorer activement et sans relâche de nombreuses pistes pour améliorer les couches MAC / RDC des piles protocolaires des WSN, que ce soit par la conception de protocoles entièrement nouveaux — tels CoSenS / S-CoSenS et iQueue-MAC — ou par l’invention de mécanismes astucieux et eﬃcaces pour améliorer les protocoles existants.

58

Chapitre 3. Analyse critique de l’état de l’art

Figure 3.25 – Fonctionnement du protocole avancé ME-ContikiMAC. (Source : [Papadopoulos et al., 2015b])
Les deux approches peuvent l’une comme l’autre permettre d’obtenir des résultats signiﬁcatifs en termes d’optimisation de la qualité de service et de la consommation d’énergie.
3.2.6.4 Approches multi-couches : l’exemple de la pile OCARI
Outre le seul développement de protocoles MAC / RDC — c’est-à-dire de solutions relevant exclusivement de la couche 2 du modèle OSI —, plusieurs travaux consistant en le développement de piles protocolaires complètes, pouvant aller jusqu’aux couches du plus haut niveau, ont été menés. On peut noter que de tels travaux ont été menés plus souvent dans un cadre industriel que dans celui de la recherche purement académique, comme c’était majoritairement le cas des protocoles que nous avons vu jusqu’ici dans cet état de l’art.
De telles approches, dites « multi-couches » ou “cross-layer”, incluent donc une couche MAC qui, par déﬁnition, est intimement liée au reste de la pile, et n’est a priori pas conçue pour être implantée de façon indépendante.
Un exemple d’une telle pile protocolaire complète, basée sur la couche physique du standard IEEE 802.15.4 (sur la bande 2,4 GHz uniquement), est OCARI (Optimisation des Communications Ad-hoc pour les Réseaux Industriels) [Agha et al., 2009]. Comme son nom l’indique, il s’agit ici d’un eﬀort de recherche appliquée — mené par une alliance regroupant diﬀérents acteurs majeurs, industriels et académiques — destiné à fournir une pile réseau à très haute ﬁabilité, aﬁn d’oﬀrir une solution pour des applications critiques comme celles liées aux centrales nucléaires ou aux navires militaires.
De cet eﬀort est née une pile protocolaire complète, allant de la couche MAC / RDC (niveau 2 OSI) aux API destinées à la programmation d’applications (assimi-

3.2. Protocoles MAC

59

lables au niveau 7 OSI). Compte-tenu du sujet de notre thèse, nous nous cantonnerons à l’étude de la couche MAC, nommée MaCARI, bien que celle-ci soit étroitement liée aux autres couches d’OCARI. Cette couche est notamment prévue pour faciliter les opérations de routage, en coopération étroite avec les couches supérieures d’OCARI.
L’organisation d’un cycle MaCARI se divise en trois périodes, et est représentée sur la ﬁgure 3.26.

Figure 3.26 – Structure d’un cycle du protocole MaCARI. (Source : [Agha et al., 2009] ﬁgure 3)
Ces trois périodes sont :
1. une période de synchronisation des diﬀérents noeuds (T0–T1), en gris sur la ﬁgure 3.26 ;
2. une période de transmissions pré-déterminées (T1–T2), basée sur une méthode TDMA optimisée, assurant une réservation de slots évitant toute interférence pour toute transmission, en jaune sur la ﬁgure 3.26 ;
3. une période de transmissions « spontanées » (T2–T3), basée sur la contention (CSMA/CA slottée), en vert sur la ﬁgure 3.26.
Le protocole MaCARI est véritablement un protocole hybride, puisque l’on peut le considérer à la fois comme un protocole synchrone, un protocole basé sur le multiplexage temporel (TDMA), et un protocole basé sur la contention. Il s’agit en outre d’un protocole MAC / RDC complet, l’émetteur / récepteur radio d’un noeud donné pouvant être mis hors fonction pour économiser l’énergie durant la période « déterministe » quand ce noeud n’a pas à communiquer durant son slot assigné.
Si le protocole MaCARI est, comme on le voit, très performant et ingénieux, son intégration étroite avec le reste de la pile OCARI — le rendant délicat à porter et à utiliser indépendamment de cette pile — et son orientation très industrielle ne lui ont jusqu’ici pas permis d’apparaître dans des OS pour WSN comme Contiki. De plus, la présence d’une pile fournissant un ensemble très complet de fonctionnalités, pouvant presque faire doublon avec un système d’exploitation proprement dit, rend un tel portage encore plus sujet à caution.

60

Chapitre 3. Analyse critique de l’état de l’art

Rappelons enﬁn que, les piles protocolaires complètes étant au-delà du sujet de la présente thèse, nous n’avons au cours de cette dernière eﬀectué aucun travail avec OCARI ou MaCARI.

3.2.7 Discussion : les protocoles MAC / RDC
En sus de l’évolution du protocole IEEE 802.15.4, et pour tenter de dépasser les limitations de celui-ci, la recherche académique a depuis maintenant plus d’une douzaine d’années proposé de nombreux protocoles MAC alternatifs. Comme nous venons de le voir, plusieurs approches ont été explorées : protocoles basés sur la contention — qu’ils soient synchrones ou asynchrones, ces derniers pouvant être basés sur l’initiation des transmissions par les noeuds émetteurs (LPL) ou par les noeuds récepteurs (LPP) —, protocoles basés sur l’ordonnancement par multiplexage temporel (TDMA) ou fréquentiel (FDMA) des transmissions. Enﬁn, des protocoles hybrides, exploitant plusieurs de ces approches, ont plus récemment été publiés : nous avons présenté deux de ces protocoles conçus par notre équipe, et l’amendement 802.15.4e du standard IEEE repose lui-même sur une utilisation simultanée des deux techniques de multiplexage temporel et fréquentiel.
Toutes ces approches ont été explorées au cours du temps par diverses équipes. Notre présentation dans la présente section est, comme nous l’avons signalé, loin d’être exhaustive, et la ﬁgure 3.27 page ci-contre reprise de l’article de référence de [Huang et al., 2013] montre l’intense activité de recherche ayant eu lieu dans ce domaine. (Il faut de plus ajouter que cette ﬁgure date de ﬁn 2011, et ne prend pas en compte les développements les plus récents, comme l’amendement 802.15.4e du standard IEEE.)
Pour le moment, et malgré tous ces développements, les protocoles asynchrones LPL restent, du moins dans le milieu académique, les plus couramment utilisés. Ils sont en eﬀet bien adaptés aux traﬁcs réseaux modérés, ce qui correspond au mode de fonctionnement de la majorité des réseaux de capteurs sans-ﬁl à l’heure actuelle, et permettent également une bonne économie des ressources, tant du point de vue énergétique (économie de la batterie des noeuds) que matériel (simplicité d’implantation, d’où une faible occupation de la mémoire — d’une capacité souvent extrêmement limitée — de ces appareils). Le protocole ContikiMAC, grâce à la forte inﬂuence du système d’exploitation Contiki dans le domaine des réseaux de capteurs sans-ﬁl (comme nous allons le voir dans la section 3.3 page suivante) tend actuellement à devenir le standard de fait dans les diﬀérents travaux de recherche dans le domaine.
Toutefois, l’adoption de l’amendement 802.15.4e du standard IEEE, avec sa couche MAC évoluée (mécanisme TSCH), et le développement d’une pile réseau complète sur cette base (projet 6TiSCH [Thubert et al., 2013] [Palattella et al., 2014] [Dujovne et al., 2014]) pourraient prochainement changer la donne, et imposer un nouveau standard notamment dans les réseaux industriels exigeants — surtout ceux composés de noeuds puissants pouvant jouer le rôle de FFD (“Full Function Devices”). Le développement de la pile réseau avancée OpenWSN est un autre facteur susceptible de faciliter une telle évolution.

3.3. Systèmes d’exploitation dédiés

61

Figure 3.27 – Taxonomie des diﬀérents protocoles MAC conçus pour les réseaux de capteurs sans-ﬁl (travaux académiques). Source : [Huang et al., 2013]
3.3 Systèmes d’exploitation dédiés
Des systèmes d’exploitation spécialisés pour les appareils embarqués spéciﬁques que sont les noeuds des réseaux de capteurs sans-ﬁls (les “motes”) ont été conçus et publiés depuis maintenant plus d’une dizaine d’années.
Rappelons que pour des raisons juridiques aussi bien que techniques — possibilité de modiﬁer et d’améliorer le cœur et les diﬀérents composants du système selon nos besoins — nous n’avons étudié et envisagé l’utilisation que des systèmes à licence libre et open source.
3.3.1 Rappels sur les notions de multi-tâche
À un moment donné, un micro-contrôleur (du moins la majorité d’entre eux, qui ne disposent que d’un unique « cœur ») ne peut exécuter qu’une tâche à la fois. Pour qu’un système informatique, comme une mote, puisse eﬀectuer plusieurs tâches, il est nécessaire de passer régulièrement et très rapidement d’une de ces tâches à une autre. Cela introduit la notion de changement de contexte : lorsqu’on passe d’une tâche A à une autre tâche B, on sauvegarde l’état de A pour charger celui de B ;

62

Chapitre 3. Analyse critique de l’état de l’art

l’état d’une tâche étant nommé son contexte (il s’agit des valeurs des registres du processeur, des périphériques, etc.)
L’espace où sont sauvegardés les contextes des diﬀérentes tâches est nommé pile (en anglais : “stack”). Il s’agit d’une structure de données variable située en mémoire (RAM donc), suivant le paradigme « dernier entré, premier sorti » (en anglais LIFO : Last In First Out).
Notons que la pile n’est pas dédiée aux seuls contextes de tâches : elle sert également de zone de travail en mémoire pour les programmes en cours d’exécution (variables locales, appels de sous-programmes, etc.)
Selon la conception du système d’exploitation, il peut y avoir une seule pile commune à tout le système, ou plusieurs piles dédiées aux diﬀérentes tâches, comme nous allons le voir.
On distingue deux principaux modèles conceptuels pour réaliser un système multi-tâche :
le multi-tâche coopératif : dans ce modèle, chaque tâche doit prévoir explicitement dans son code source de « passer la main » (par l’appel à une fonction dédiée du système d’exploitation). Ce modèle rend les systèmes d’exploitation plus simples à concevoir et plus compacts : il est en eﬀet possible dans ce cas d’employer une pile unique pour l’ensemble du système. En contrepartie, la programmation d’applications est plus contraignante : le développeur doit gérer lui-même le basculement d’une tâche à une autre, sinon le système est condamné à mal fonctionner, et même en général à se bloquer (« se planter »). Ce modèle rend donc au ﬁnal le système moins robuste : une tâche mal programmée (par exemple : ne passant pas la main) peut mettre tout le système hors service.
le multi-tâche préemptif : dans ce modèle, le système d’exploitation alloue luimême les intervalles d’exécution à chaque tâche, et planiﬁe automatiquement les changements de contexte entre celles-ci (cette capacité d’interrompre une tâche sans collaboration de sa part est nommée préemption). Ce modèle implique des systèmes d’exploitation plus évolués et gourmands en ressources : il est en eﬀet nécessaire d’avoir une pile distincte par tâche. En contrepartie, la programmation d’applications est nettement simpliﬁée : le développeur n’a pas à se soucier des changements de tâches. Le système est en outre nettement plus robuste : une tâche « bloquée » ne va pas systématiquement mettre hors service tout le système.
En outre, la capacité d’interrompre à n’importe quel moment une tâche en cours est un pré-requis pour implanter un système temps réel, qui a besoin de pouvoir réagir à un évènement comme une interruption en un délai limité. C’est pourquoi les systèmes oﬀrant des fonctionnalités temps-réel sont basés sur le modèle préemptif, le multi-tâche coopératif — qui oblige à attendre que la tâche en cours soit prête à passer la main — étant par conception défavorable à ces fonctionnalités. Cela est illustré par la ﬁgure 3.28 page ci-contre. On notera notamment la latence présente en modèle coopératif A due à l’attente de la ﬁn de la tâche en

3.3. Systèmes d’exploitation dédiés

63

cours, absente du modèle préemptif B pouvant interrompre une tâche à tout moment (sauf à être déjà en train de gérer un évènement ou une interruption).

Figure 3.28 – Principe de base du traitement des évènements temps-réel par les diférents modèles de gestion multi-tâche.
3.3.2 TinyOS
Le premier système ayant connu un large succès dans le domaine des réseaux de capteurs sans-ﬁl est TinyOS [Levis et al., 2005]. Il s’agit d’un système open-source et libre (sous license BSD), dont la première version stable (version 1.0) a été publiée en septembre 2002. Il est extrêmement léger, et par là-même très bien adapté aux appareils limités que sont les noeuds des réseaux de capteurs sans-ﬁl de la première génération (Mica2, MicaZ [DataSheet MicaZ, 2007], TelosB / SkyMote [DataSheet TelosB, 2006], etc.).
Ce système a permis de nombreuses avancées dans le domaine, comme la possibilité d’utiliser le protocole réseau Internet (IP, y compris dans sa dernière version :

64

Chapitre 3. Analyse critique de l’état de l’art

IPv6) ainsi que des protocoles de routage (comme RPL) sur les réseaux au standard IEEE 802.15.4. Il a également introduit la possibilité de simuler des réseaux de motes fonctionnant sous TinyOS, grâce au simulateur TOSSIM [Levis et al., 2003].
L’un des principaux défauts de ce système est la nécessité d’apprendre un langage spéciﬁque — nommé nesC [Gay et al., 2003] — pour pouvoir travailler et développer des applications avec TinyOS. Contrairement à ce que son nom pourrait laisser penser, le langage nesC est très diﬀérent du langage C classique et de tous les autres langages informatiques impératifs couramment utilisés — il ressemble plutôt, dans sa philosophie, aux langages de description de matériel utilisés dans la conception de circuits intégrés, comme VHDL ou Verilog. En cela, il peut se révéler diﬃcile à apprendre et à maîtriser pour des programmeurs ayant une formation de développement informatique classique.
La présence de ce langage spéciﬁque au sein du projet TinyOS n’est pas un hasard : TinyOS est en eﬀet construit sur ses propres paradigmes spéciﬁques. Ce système gère les entrées / sorties (I/O) de façon totalement asynchrone, et fonctionne autour d’une pile unique, depuis laquelle les diﬀérents composants constituant une application TinyOS sont appelés en tant que callbacks statiquement liés. TinyOS a en eﬀet été conçu pour fonctionner de façon principalement évènementielle, via la programmation de gestionnaires d’interruptions.
La notion de « tâche » de longue durée existe, mais la gestion du multitâche est sous TinyOS particulièrement limitée : les « tâches » sont exécutées l’une après l’autre, suivant une ﬁle (FIFO) dont l’ordre ne peut être modiﬁé — l’ordonnanceur de TinyOS n’est pas conçu pour changer dynamiquement l’ordre des tâches à exécuter en fonction du déroulement de l’application et de son environnement. Les tâches ne peuvent en outre être préemptées que par des interruptions (« évènements ») mais jamais par d’autres tâches. Le manuel de TinyOS déﬁnit en fait les tâches comme des appels de procédures diﬀérés (“Deferred Procedure Calls”). Ce fonctionnement permet toutefois de minimiser grandement la consommation d’énergie, toute la mote étant en sommeil lorsqu’aucune tâche n’a à s’exécuter (le prochain réveil étant provoqué par « l’évènement » suivant).
Il est clair que le fonctionnement de TinyOS et ses paradigmes sont particulièrement atypiques par rapport aux autres systèmes décrits dans la présente section. Ceci se ressent dans la programmation d’applications, qui nécessite de maîtriser ces notions pour savoir décomposer tout programme en divers « évènements », « tâches » et autres « commandes » (appel d’un composant à un autre) pour créer les composants constituant les applications. La diﬃculté d’apprentissage et de maîtrise de ce système pour un informaticien formé et habitué aux notions classiques de programmation sera ainsi assez ardue.
L’ensemble des architectures matérielles sur lesquelles TinyOS a été porté semble actuellement se limiter aux familles AVR et MSP430 (un portage sur des architectures plus puissantes comme les Cortex-M est évoqué dans la FAQ du site Web de TinyOS, mais son état d’avancement actuel est inconnu).
Enﬁn, signalons que TinyOS nécessite l’emploi d’outils de développement dédiés (langage spéciﬁque oblige) pour pouvoir être compilé.

3.3. Systèmes d’exploitation dédiés

65

Toutes ces limitations, ajoutées à un rythme de développement relativement lent — la dernière version stable (2.1.2) remonte à août 2012 — ont ces dernières années nui à son adoption, et il n’est désormais plus le système de référence ni le plus utilisé dans le domaine des réseaux de capteurs sans-ﬁl.

3.3.3 Contiki
Le système d’exploitation de référence dans le domaine des réseaux de capteurs sans-ﬁl et par extension de l’Internet des objets (IoT) est Contiki [Dunkels et al., 2004]. Il s’agit également d’un système open source et libre (license BSD), dont la première version publiée remonte à 2002. Le projet Contiki a été à l’origine de nombreuses avancées : on pourra citer entre autres la pile TCP/IP embarquée uIP [Dunkels, 2003] depuis étendue en uIPv6 (qui est présentée comme la pile IPv6 fonctionnelle la plus légère qui soit), la pile réseau Rime [Dunkels, 2007] simpliﬁée et orientée vers les économies d’énergie, ou encore le simulateur avancé de réseaux de capteurs sans-ﬁl Cooja [Österlind et al., 2006].
S’il est légèrement plus exigeant en ressources que TinyOS, Contiki reste très léger et particulièrement bien adapté aux motes constituant les réseaux de capteurs sans-ﬁl.
Son principal avantage sur TinyOS est d’être basé sur des paradigmes standards, avec une API reprenant les principes classiquement rencontrés dans le domaine des systèmes d’exploitation ; il est en outre codé en langage C standard : ceci rend son apprentissage et sa maîtrise bien plus facile pour un programmeur ayant un cursus classique.
Contiki est basé sur un noyau événementiel, implantant un modèle multitâche coopératif. Il oﬀre également une pile réseau complète, directement prête à l’emploi.
Il a été porté sur une multitude de plate-formes, comprenant de nombreuses motes pour réseaux de capteurs sans-ﬁl, mais aussi de vieux modèles d’ordinateurs personnels — Commodore 64, Apple II, Atari 800XL... — et même certains modèles de consoles de jeux (dans des portages non-oﬃciels).
Des modules optionnels permettent également de fournir des fonctionnalités aussi diverses qu’une interface graphique, un système de ﬁchiers, ou encore une mise à jour du programme (“ﬁrmware”) durant l’exécution (suivant un processus certes complexe).
Toutes ces caractéristiques et avantages ont largement contribué à la diﬀusion et à l’adoption massive de Contiki, ce qui fait qu’il s’agit désormais du système d’exploitation de référence dans le monde des réseaux de capteurs sans-ﬁl.
Les développeurs de Contiki ont également été actifs quant au développement de la couche MAC/RDC : nombre de protocoles classiques (comme par exemple XMAC) ont été implantés dans la pile réseau de ce système ; et un nouveau protocole, ContikiMAC [Dunkels, 2011], a été spéciﬁquement conçu pour jouer le rôle de protocole RDC par défaut de Contiki (en collaboration avec le protocole CSMA/CA du standard IEEE 802.15.4 en tant que couche MAC). Nous avons abordé ce protocole ContikiMAC dans l’étude des protocoles LPL plus haut en section 3.2.2.4 page 39.

66

Chapitre 3. Analyse critique de l’état de l’art

Toutefois, la compacité de Contiki, son optimisation et ses fonctionnalités imposent en contrepartie diverses limitations à ce système.
Contiki est basé sur un modèle multitâche coopératif, et non préemptif : l’ordonnanceur de tâches se déclenche en réaction à des « évènements » (pour reprendre la terminologie de Contiki). Cet ordonnanceur ne peut se déclencher que selon un rythme spéciﬁque, dont la fréquence (intervalle de déclenchement) est déterminée à la compilation. Ce modèle de fonctionnement multitâche est, comme nous l’avons vu ci-dessus en section 3.3.1 page 61, un obstacle à la présence de fonctionnalités temps-réel.
Il faut en outre noter que l’ordonnanceur coopératif de Contiki est conçu pour traiter un type spéciﬁque de tâches nommé protothreads [Dunkels et al., 2006]. Ce mécanisme permet de gérer diﬀérentes ﬁles d’exécution (“threads”) sans avoir besoin de maintenir une pile d’exécution séparée pour chacun d’entre eux. Le grand avantage de cette technique est la possibilité d’utiliser une pile unique pour tout un système, diminuant ainsi signiﬁcativement la quantité de RAM nécessaire, sans pour autant devoir se limiter à un mécanisme d’ordonnancement statique comme dans TinyOS. Ce mécanisme de protothreads est d’ailleurs utilisé dans plusieurs autres applications en dehors de Contiki. La contrepartie de ce mécanisme est qu’il est nécessaire de respecter certaines règles rigoureuses quant à l’utilisation de certains éléments du langage C : il est notamment impossible d’utiliser l’instruction switch dans certaines parties d’un programme utilisant ces protothreads.
Toutes ces limitations du système Contiki ont posé des problèmes non résolus pour nos travaux de thèse, comme nous le verrons dans la section 4.1 page 79 du présent manuscrit.

3.3.4 Nano-RK
Un système spécialisé dans les réseaux de capteurs sans-ﬁl présentant des propriétés très intéressantes, et surtout proches de nos besoins, est Nano-RK [Eswaran et al., 2005]. Il a été conçu à l’Université de Carnegie Mellon à partir de 2005.
Il s’agit également d’un système open source, publié selon un schéma de double licence permettant l’utilisation de la GNU GPL (General Public License) si tel est le choix du développeur. On peut donc le considérer comme un logiciel libre.
Celui-ci fournit de nombreuses fonctionnalités intéressantes : — Un noyau fonctionnant en mode tickless (c’est-à-dire sans nécessiter un timer
le déclenchant de façon régulière). — Un ordonnanceur temps-réel avec multi-tâche préemptif gérant les
priorités . La granularité théorique — permettant de descendre jusqu’à la nano-seconde par l’utilisation de la représentation temporelle POSIX, réimplantée sous le nom de nrk_time_t — est excellente. Mais en pratique, la granularité eﬀective garantie pour les interruptions (“timer tick”) est de l’ordre de la milliseconde [Nano-RK Time Management API, 2015]. Cela implique une gigue (“jitter”) pouvant aller jusqu’à 1000 microsecondes, alors que la durée de base d’une période de backoﬀ CSMA/CA est de seulement 320 microsecondes. Les fonc-

3.3. Systèmes d’exploitation dédiés

67

tionnalités temps-réel de Nano-RK, aussi avancées et complètes soient-elles, oﬀrent donc une granularité pouvant ne pas être suﬃsante pour nos travaux. — Un paradigme de réservations de ressources très intéressant, permettant par exemple d’accorder respectivement 100 ms de temps d’exécution ou l’envoi de 10 paquets par seconde pour une tâche ou un noeud donnés. Il s’agit en fait d’un principe de quotas, assuré par le noyau système, et permettant de prévoir un « budget énergétique » consommé par un appareil donné pendant une période de temps. Il s’agit d’une spéciﬁcité très avancée et fonctionnellement très prometteuse de Nano-RK. — Une occupation mémoire réduite (bien que légèrement supérieure à celle de TinyOS ou Contiki). — Une gestion intégrée des erreurs fatales (violations d’espace mémoire ou de timing, watchdog, chutes d’alimentation énergétique...) — Le système est écrit en langage C standard, et est donc compilable avec le compilateur GNU GCC classique. — Une pile réseau légère, comprenant notamment plusieurs protocoles MAC classiques, dont le protocole LPL B-MAC (voir section 3.2.2.1 page 38) ; d’autres protocoles spéciﬁques et expérimentaux sont proposés, ainsi qu’une fonction simple de passerelle vers un réseau IP nommée “SLIPStream”.
Ce système a le principal désavantage d’avoir été porté sur un nombre limité d’architectures de microcontrôleurs : seules les plates-formes MSP430 et AVR sont supportées, avec une activité et une spécialisation nettement plus grandes vis-à-vis de cette dernière. Les principales plates-formes matérielles sur lesquelles Nano-RK est employé sont en eﬀet :
— la “mote” MICAz [DataSheet MicaZ, 2007], de conception déjà ancienne (contemporaine de la TelosB/SkyMote) basée sur un MCU ATmega128L [DataSheet ATmega128L, 2011] et le classique TI CC2420 [DataSheet CC2420, 2007] comme radio ;
— la plus récente FireFly3 [FireFly3, 2012], spéciﬁquement conçue par Carnegie Mellon pour servir de plate-forme matérielle à Nano-RK. Elle a la particularité d’être conçue autour d’un microcontrôleur intégrant un émetteur / récepteur radio, l’ATmega128RFA1 [DataSheet ATmega128RFA1, 2014], et peut accueillir plusieurs cartes d’extension, notamment une carte comportant de nombreux capteurs (température, pression, humidité, accéléromètre, audio, mouvement...).
Ces deux “motes”, mises en avant sur le site de Nano-RK, sont toutes deux basées sur l’architecture Atmel AVR. Si cela peut présenter certains avantages — comme la possibilité, mise en avant par le projet, de développer et déboguer directement Nano-RK avec l’outil Atmel Studio — cela implique une forte limitation au niveau de la portabilité, laquelle est pourtant l’un des principaux objectifs recherchés en utilisant un système d’exploitation pour développer sur WSN.
Aucune activité de portage sur d’autres matériels ou architectures ne semble entreprise : cela est fort regrettable, sachant que les “motes” basées sur des microcontrôleurs 32 bits (comme ceux d’architecture ARM), plus puissantes, apparaissent

68

Chapitre 3. Analyse critique de l’état de l’art

et se répandent de plus en plus. Cela n’empêche toutefois pas Nano-RK d’être encore activement développé (bien
qu’avec des moyens humains visiblement limités, comme beaucoup de projets strictement académiques), et de faire régulièrement l’objet de publications, citons par exemple [Buevich et al., 2013].
Toutefois, malgré ces qualités, nous n’avons pas dans le cadre de cette thèse travaillé avec Nano-RK, car nous avons été amenés à découvrir une autre plateforme logicielle très intéressante et plus ouverte. Nous allons maintenant aborder cette plate-forme dans la section 3.3.5 ci-dessous.

3.3.5 RIOT OS
Nous avons été amenés à nous intéresser, dans le cadre de nos travaux de thèse, à RIOT OS [Hahm et al., 2013].
Ce nouveau système — sa première version a été publiée en 2013 — est également open source et publié sous une licence libre (LGPL v2.1), et est spéciﬁquement conçu pour les noeuds de réseaux de capteurs sans-ﬁl.
Il est développé principalement avec le soutien de la Freie Universität Berlin, de l’INRIA, et de la Hamburg University of Applied Sciences. Il est à noter que l’équipe de développement de ce projet est particulièrement accueillante et ouverte aux contributions extérieures.
Il fournit les avantages de base que l’on peut attendre d’un OS pour réseaux de capteurs sans-ﬁl, notamment la portabilité (il fonctionne sur de nombreux appareils reposant sur les architectures MSP430, AVR et ARM — notamment la famille des Cortex-M), ainsi qu’un ensemble complet de fonctionnalités, notamment une pile réseau.
Parmi les fonctionnalités oﬀertes, on retrouve de nombreuses capacités avancées des autres OS spécialisés dans les capteurs sans-ﬁl (comme Nano-RK), plus d’autres a priori inédites :
— Un micro-noyau léger, dirigé par les interruptions, fonctionnant par défaut de façon tickless (c’est-à-dire sans nécessiter qu’un timer le déclenche de façon régulière).
— Un ordonnanceur, intégré au micro-noyau, fonctionnant en mode multi-tâche préemptif avec gestion des priorités.
— Une utilisation optimisée des timers matériels grâce à une API dédiée, permettant de programmer le déclenchement d’actions avec une granularité très ﬁne, de l’ordre de la dizaine de microsecondes.
— Des structures de données de base : piles, ﬁles, listes chaînées et circulaires. — Des mécanismes de communication entre tâches (threads) : notamment un
système de passage de messages — implanté par l’utilisation de queues (FIFO) de messages, appartenant chacune à un thread donné —, ainsi que des mutex. — RIOT est entièrement écrit en langage C standard ; de plus, contrairement à Contiki, il n’y a aucune restriction quant aux éléments utilisables du langage (telles que les limitations imposées par les protothreads).

3.3. Systèmes d’exploitation dédiés

69

— Une conception claire et modulaire, rendant le développement avec mais aussi dans le système plus facile et productive.
— Une gestion des erreurs critiques, que nous avons dans le cadre de cette thèse initiée et contribué à mettre en place.
Les trois premières fonctionnalités citées ci-dessus font de RIOT un système temps-réel à part entière.
Notons que le mécanisme de gestion des timers matériels a évolué pendant l’année 2015. L’ancien mécanisme hwtimer, qui était intégré au noyau lui-même, a été supprimé et remplacé par un module nommé xtimer.
Toutes les expériences décrites dans ce manuscrit ont, sauf indication contraire, été basées sur une version de RIOT utilisant l’ancien système hwtimer intégré au noyau. Celui-ci a été conçu pour oﬀrir la possibilité d’utiliser les timers matériels du microcontrôleur, et ce avec une granularité aussi ﬁne que le permettent les “ticks” de ces timers. Sur les premières motes que nous avons utilisé (voir section 5.1 page 103), nous avons ainsi disposé d’une granularité d’environ 30, 5 µs pour programmer le déclenchement de nos évènements.
Le nouveau module xtimer permet lui de s’abstraire de la notion de “tick”, c’est à dire du délai (en général ﬁxe) entre deux déclenchements successifs d’un timer matériel, pour proposer des délais exprimés systématiquement en microsecondes, le module xtimer étant conçu pour être implanté sur la base d’un timer matériel dont la cadence est ﬁxée à 1 MHz. Cette implantation lui permet donc d’atteindre, en théorie, une granularité à la microseconde près ; dans les faits, les délais d’exécution des fonctions mêmes de xtimer, ainsi que la possibilité de préemption par le noyau (hors gestionnaire d’interruption) génèrent une gigue allant jusqu’à quelques dizaines de microsecondes, soit (dans les cas les moins favorables) une granularité comparable à celle oﬀerte par le mécanisme précédent.
Notons quoi qu’il en soit que la disponibilité en standard d’une granularité temporelle, pour les mécanismes temps-réel de RIOT, de l’ordre de la dizaine de microsecondes (c’est-à-dire largement inférieure à la milliseconde) est une fonctionnalité exceptionnelle : nous ne l’avons retrouvée lors de nos recherches dans aucun autre OS dédié aux WSN (par exemple, dans Nano-RK [Nano-RK Time Management API, 2015] qui dispose pourtant d’un mécanisme de timing évolué). Même FreeRTOS (cf. section 3.3.7.1 page 72) n’oﬀre par défaut qu’un mécanisme de software timer d’une granularité d’1 ms, l’utilisation des potentialités des timers matériels étant laissée à la seule charge du développeur d’applications [FreeRTOS Timer Resolution, 2012].
Le fonctionnement tickless du noyau et l’utilisation optimale des timers matériels font également de RIOT OS une plate-forme logicielle prometteuse pour le développement d’applications particulièrement optimisées et économes en énergie, ces deux fonctionnalités permettant potentiellement de garder le MCU en état de « sommeil » (basse consommation) durant une fraction de temps aussi élevée que possible. NanoRK a déjà exploré la piste du fonctionnement tickless pour augmenter son eﬃcacité énergétique (voir [Nano-RK Time Management API, 2015]).
Un des désavantages de RIOT, par rapport à TinyOS et Contiki, est sa plus

70

Chapitre 3. Analyse critique de l’état de l’art

grande exigence en ressources matérielles, notamment concernant l’occupation mémoire. La pile réseau complète (de la couche physique à l’implantation 6LoWPAN en passant par les couches RPL et MAC / RDC) ne peut pas être compilée pour un matériel de type SkyMote / TelosB car la quantité de mémoire exigée dépasse celle disponible sur ces appareils. À l’heure actuelle, des noeuds limités comme ceux basés sur l’architecture MSP430 sont cantonnés sous RIOT au rôle de RFD, les rôles de FFD étant pour l’instant réservés aux matériels plus puissants (comme ceux basés sur des microcontrôleurs ARM).
Notons toutefois que, grâce à l’architecture modulaire du système, le noyau RIOT compilé avec les seules couches PHY et MAC / RDC reste très léger et occupe très peu de mémoire, étant ainsi parfaitement compatible même avec les appareils les plus limités.
En outre, la partie réseau du système ayant fait l’objet d’une réorganisation en profondeur (comme nous le verrons plus en détail ultérieurement en section 4.3 page 95), nous espérons qu’à l’avenir, il sera possible d’utiliser encore plus eﬃcacement des appareils aux ressources limitées sous RIOT.
Notons également qu’outre la pile réseau intégrée de RIOT, la pile OpenWSN [Watteyne et al., 2012] a fait l’objet d’un portage sur le noyau RIOT. Ce dernier est donc l’une des deux plates-formes logicielles sélectionnées pour accueillir cette pile à hautes performances (l’autre étant le noyau FreeRTOS [Barry, 2006]).

3.3.6 Autres OS spécialisés
D’autres systèmes d’exploitation spéciﬁquement conçus pour les réseaux de capteurs sans-ﬁl ont été développés, mais ceux-ci sont nettement moins utilisés, et souﬀrent de limitations nous ayant empêché d’envisager sérieusement leur utilisation.
SOS [Han et al., 2005] Le développement de ce système a été arrêté en novembre 2008. Ses auteurs recommandent explicitement sur leur site Web de « considérer l’utilisation d’alternatives activement maintenues. »
Lorien [Porter and Coulson, 2009] Si celui-ci est basé sur approche orientée composant intéressante, ce système ne semble pas d’une utilisation très répandue. Il n’est actuellement disponible que pour un seul type de matériel (TelosB / SkyMote) ce qui limite considérablement la portabilité que l’on est en droit d’attendre de l’utilisation d’un OS, donc son intérêt. En outre, son développement semble avoir nettement ralenti, la dernière version stable publiée par le projet Lorien datant de 2011, tandis que le dernier commit dans le dépôt SourceForge du projet (r46) remonte à janvier 2013.
Mantis [Abrach et al., 2003] Alors que ce projet prétend être open source, celui-ci n’a publié aucune version accessible sur son site SourceForge ; en outre, l’accès au dépôt source du projet (http://mantis.cs.colorado.edu/viewcvs) semble défaillant. Enﬁn, les dernières nouvelles oﬃcielles aﬃchées sur la page Web principale du projet parlent d’une version bêta censée être publiée en 2007. Les

3.3. Systèmes d’exploitation dédiés

71

dernières publications scientiﬁques concernant MantisOS semblent également remonter à l’année 2007. Tous ces éléments nous font penser que ce projet est tombé à l’abandon...
LiteOS [Cao et al., 2008] Ce système oﬀre des fonctionnalités très intéressantes, notamment la possibilité de mettre à jour le ﬁrmware des noeuds à la volée, depuis la connexion réseau sans-ﬁl (mise à jour “Over-the-Air”, dont LiteOS semble avoir été le pionnier), ainsi que le support intégré d’un système de ﬁchiers hiérarchique. Malheureusement, LiteOS est actuellement uniquement disponible pour les plates-formes matérielles IRIS et MicaZ, et nécessite l’emploi d’Atmel Studio pour son développement. Cela nuit gravement à la portabilité du système, vu que LiteOS semble très fortement lié à l’architecture de microcontrôleurs AVR.
MansOS [Strazdins et al., 2010] Ce système très récent oﬀre de nombreuses fonctionnalités intéressantes, comme le multi-tâche préemptif (de façon optionnelle), une pile réseau intégrée, et un langage de script. Il est disponible sur deux architectures de microcontrôleurs : AVR et MSP430 (mais malheureusement, pas les architectures ARM dont la progression est constante). En outre, les capacités temps-réel du système semblent limitées : seuls des timers logiciels d’une granularité minimale de 1 milliseconde semblent disponibles.
NanoQplus [Kim et al., 2008a] Il s’agit d’un système dédié aux WSN, apparu semble-t-il en 2008, annonçant des fonctionnalités intéressantes comme le multitâche préemptif, une grande portabilité sur de nombreuses architectures de MCUs (allant des 8 bits aux 32 bits), et surtout un système de protection mémoire. L’article de 2008 le présentant [Kim et al., 2008a] semble prometteur, et un autre article de 2011 [Jeong et al., 2011] indique qu’une pile IPv6 ainsi que RPL y ont été portés. Malheureusement, le site du projet (http://dukemon.tistory.com/tag/NanoQplus) est exclusivement en coréen, et seul un faible nombre d’articles écrits en Corée (le plus souvent en coréen) semblent y faire référence — les deux publications citées dans le présent paragraphe, certes en anglais, sont parues dans des journaux / évènements se voulant internationaux mais s’étant déroulés en Corée. Il semble donc malheureusement diﬃcile de se faire une idée précise de ce système, dont l’adoption hors de son pays d’origine semble actuellement extrêmement limitée.
OpenTag Il s’agit d’une pile réseau chargée d’implanter le protocole DASH7 (standard ISO/IEC 18000-7, spécialisé dans le RFID et incompatible avec le standard IEEE 802.15.4), fournie avec son propre système temps-réel minimaliste (noyau dédié). S’il s’agit stricto sensu d’un système fonctionnant sur des WSN, lesdits WSN sont très diﬀérents de ceux que nous étudions dans cette thèse — ils fonctionnent par exemple à la fréquence radio de 433 MHz réservée à DASH7. Leur développement a au départ été prévu pour des applications militaires. Il ne s’agit donc pas d’un système comparable à tous ceux que nous avons vu jusqu’à présent, et ne correspond absolument pas aux travaux de notre thèse.

72

Chapitre 3. Analyse critique de l’état de l’art

3.3.7 OS temps-réel classiques / généralistes
Une autre possibilité utilisée par plusieurs constructeurs de motes est de recourir à des systèmes embarqués « classiques », lesquels oﬀrent le plus souvent des fonctionnalités temps-réel.

3.3.7.1 FreeRTOS
La référence actuelle en matière de système d’exploitation temps-réel open source pour l’embarqué est FreeRTOS [Barry, 2006].
FreeRTOS est un projet mature (première version publiée en 2003), stable et très largement employé, notamment dans l’industrie.
Il a été porté sur plus de 30 architectures de microcontrôleurs diﬀérentes, c’està-dire quasiment toutes les architectures présentes sur le marché ; ce qui en fait le système le plus portable cité jusqu’ici dans le présent manuscrit, largement devant n’importe quel système dédié aux réseaux de capteurs sans-ﬁl.
L’un des points forts majeurs de FreeRTOS est son excellente documentation : le code source est abondamment et consciencieusement commenté, et l’auteur publie deux manuels complets (en anglais uniquement) sur son système :
1. un manuel d’utilisation [Barry, 2010], complet et très didactique, tant sur l’utilisation du système lui-même que sur les notions de temps-réel en informatique et les conséquences de ces notions quant aux bonnes pratiques de programmation ;
2. un manuel de référence du système [Real Time Engineers Ltd., 2013], détaillant de façon exhaustive l’API et les options de conﬁguration, avec de nombreux exemples de code (“listings”).
Ces deux ouvrages, rédigés avec soin et maintenus à jour, facilitent considérablement l’apprentissage et la programmation avec ce système. Il s’agit également d’une des sources de revenus du projet FreeRTOS, ces deux manuels étant vendus sous forme électronique sur le site Web du projet : cette documentation sur FreeRTOS n’est donc pas libre, contrairement au système lui-même qui est publié sous la licence GNU GPL.
Le code source du noyau en lui-même se compose uniquement de quatre ﬁchiers source en langage C — dont un représente une fonction optionnelle (coroutines). Le reste du source du projet se compose des portages (couches d’abstraction) pour les nombreuses plates-formes matérielles et compilateurs supportés, et d’exemples. Ce système reste ainsi très léger quant aux ressources matérielles exigées (généralement moins de 10 Ko de code programme) ce qui le rend parfaitement adapté aux systèmes embarqués les plus limités.
La simplicité du noyau (quantité de code minimale) et les critères de qualité stricts imposés au code source contribuent à la robustesse de FreeRTOS.
Cela lui permet d’ailleurs de fournir une version certiﬁée pour les utilisations dans les systèmes embarqués critiques, nommée SafeRTOS. Contrairement au noyau FreeRTOS de base, SafeRTOS n’est pas un logiciel libre : l’achat d’une licence

3.3. Systèmes d’exploitation dédiés

73

payante est exigé, en échange de la certiﬁcation (IEC 61508 : SIL 3) et d’un support technique avancé. Cette version spéciale, SafeRTOS, est une autre source de revenus du projet FreeRTOS (en plus de la vente de manuels citée plus haut).
Citons également l’existence d’OpenRTOS, qui est un clone absolu de FreeRTOS sous une licence propriétaire, vendu à l’intention des industriels rebutés par les exigences de la GNU GPL, et fournissant également un support technique — et par la même occasion une troisième source de revenus au projet FreeRTOS.

Le noyau FreeRTOS fournit des fonctionnalités avancées telles que :
— le multi-tâche, préemptif par défaut, coopératif en option, via un ordonnanceur gérant les priorités ;
— un mode “tickless” optionnel ; — des structures de données de base (listes, ﬁles) ; — des mécanismes de communication entre tâches (“Inter Process Communica-
tion”) : sémaphores, mutex ; — des timers logiciels ; — et une gestion optionnelle de l’allocation de mémoire (“heap”) : trois méca-
nismes diﬀérents disponibles.
Cette compacité a toutefois un prix : FreeRTOS n’est en fait qu’un noyau, fournissant les fonctionnalités de base citées ci-dessus. Il est dépourvu de tout pilote matériel, y compris pour les périphériques de base intégrés aux microcontrôleurs (par exemple : les ports séries ou les GPIO) — ces pilotes de périphériques devant être développés et fournis en sus par les fournisseurs de matériels et / ou d’applications désireux de l’utiliser.
Par conséquent, il est également évident que FreeRTOS ne fournit aucune pile réseau, aussi rudimentaire soit-elle.
Notons qu’il existe des extensions réseau proposées en sus pour FreeRTOS, mais la plupart sont des composants logiciels propriétaires et à source secret (proposés dans le cadre du projet « FreeRTOS plus », un écosystème de logiciels basé sur FreeRTOS), ce qui ne peut convenir pour nos travaux de thèse.
Toutefois, cette situation pourrait changer, car la pile réseau avancée OpenWSN [Watteyne et al., 2012] a été développée en prenant pour l’un de ses noyaux de base FreeRTOS (l’autre noyau étant celui de RIOT OS comme nous l’avons vu plus haut). Si l’intégration d’OpenWSN et du noyau FreeRTOS se développe et est amenée à être largement adoptée, nous pourrons alors compter sur un nouveau système dédié aux réseaux de capteurs sans-ﬁl à part entière, open source et très performant.

Certains constructeurs de capteurs sans-ﬁl ont bâti leur propre système d’exploitation dédié en se basant sur FreeRTOS : on pourra notamment citer la société HiKoB et son projet OpenLab. Malheureusement, un tel projet est par déﬁnition intimement lié à un type de matériel donné, et fait donc perdre l’un des principaux avantages liés à l’utilisation d’un OS, à savoir la portabilité.

74

Chapitre 3. Analyse critique de l’état de l’art

3.3.7.2 Autres OS temps-réel
Notons qu’il existe d’autres systèmes temps-réel embarqués et open source, tel qu’Erika Entreprise, largement utilisé dans l’industrie notamment automobile. Ce système, ayant un long historique (première version datant de 2002), et ayant reçu une certiﬁcation (OSEK/VDX), a lui aussi été porté sur de nombreuses plates-formes, dont des motes comme la MicaZ. Toutefois, les WSN ne sont absolument pas la spécialité de ce système — il n’oﬀre aucune pile réseau —, et s’il a un succès certain dans l’industrie, il est totalement ignoré dans le milieu de la recherche académique (nous n’avons trouvé aucune publication le mettant en œuvre).
De nombreux autres systèmes d’exploitation temps-réel existent, dotés d’une licence libre ou propriétaire — la plupart du temps destinés à l’embarqué —, mais à notre connaissance, aucun d’entre eux n’est employé, même de façon ponctuelle, dans le cadre des WSN.
FreeRTOS est actuellement l’OS temps-réel embarqué « généraliste » ayant largement le plus de succès comme plate-forme de recherche dans le domaine des réseaux de capteurs sans-ﬁl.

3.3.8 Discussion : les systèmes d’exploitation dédiés
Depuis l’an 2000, plusieurs OS open source spécialisés dans les réseaux de capteurs sans-ﬁl ont été développés : TinyOS en a été le pionnier. Toutefois, ses nombreuses et importantes limitations, ses paradigmes inhabituels et son langage spéciﬁque inhabituel (nesC) en font désormais un système en perte d’inﬂuence.
La référence actuelle en ce domaine est Contiki : sa légèreté quant aux ressources matérielles demandées, ses nombreuses fonctionnalités, assurées par diverses innovations techniques signiﬁcatives, l’importante communauté de développeurs qu’il a su réunir autour de lui, et désormais le support professionnel assuré par une société fondée par les créateurs du système (Thingsquare) en font le système incontournable et la référence dans le domaine des réseaux de capteurs sans-ﬁl.
Celui-ci souﬀre toutefois de limitations — principalement liées aux choix techniques eﬀectués lors de sa conception, notamment pour créer un système économe en ressources matérielles.
La communauté académique n’en est pas restée là, et a démarré plusieurs autres projets de systèmes dédiés aux réseaux de capteurs sans-ﬁl. Si nombre d’entre eux semblent être tombés en désuétude, plusieurs projets ont montré des qualités dignes d’intérêt : citons notamment LiteOS, ayant développé la notion de mise à jour du ﬁrmware des noeuds à l’exécution via la communication sur le réseau (“On the Air”), et surtout Nano-RK et RIOT OS, qui sont à la fois des systèmes embarqués tempsréel et conçus pour les réseaux de capteurs sans-ﬁl.
On citera également les OS embarqués « classiques », dont FreeRTOS qui est la référence actuelle en matière de système temps-réel open source. FreeRTOS, comme

3.4. Conclusion : protocoles MAC / RDC et OS spécialisés

75

RIOT, sont les deux noyaux systèmes sélectionnés pour accueillir la pile réseau avancée OpenWSN, développée pour implanter l’état de l’art en matière de réseaux de capteurs sans-ﬁl (notamment les avancées de l’amendement 802.15.4e et la pile protocolaire 6TiSCH).
La liste des principaux OS utilisables pour les réseaux de capteurs sans-ﬁl, avec leurs points forts et leurs faiblesses, peut ainsi être résumée dans les données de la table 3.1 page suivante.
Ainsi, si Contiki est à l’heure actuelle la référence en matière de système pour réseaux de capteurs sans-ﬁl, les récentes avancées apportées par l’amendement 802.15.4e du protocole IEEE pourraient faire évoluer le paysage.
En eﬀet, les insuﬃsances des fonctionnalités temps-réel de Contiki rendent très délicates les synchronisations temporelles — plus exactement : le déclenchement d’évènements à des moments extrêmement précis, jusqu’à quelques dizaines de microsecondes près — nécessaires au caractère “slotté” (TDMA et même FDMA) de la nouvelle couche MAC étendue.
Dans ces conditions, le domaine des plates-formes logicielles pour réseaux de capteurs sans-ﬁl pourrait largement évoluer, et permettre à des systèmes comme RIOT OS et / ou le couple FreeRTOS / OpenWSN de s’imposer à l’avenir dans le paysage des WSN.
Pour les besoins de développement rapide, facile, permettant de passer facilement de l’émulation au test sur matériel de prototypage, une solution originale comme OpenWiNo [van den Bossche and Val, 2013], qui n’est pas un OS complet, mais un noyau ultra-léger oﬀrant une pile protocolaire et des fonctionnalités de gestion de timers, pourrait devenir une alternative intéressante lorsqu’elle sera publiquement disponible.

3.4 Conclusion : protocoles MAC / RDC et OS spécialisés
L’analyse de l’état de l’art sur les protocoles MAC basés sur la couche physique du standard IEEE 802.15.4 d’une part, et d’autre part sur les systèmes d’exploitation dédiés aux réseaux de capteurs sans-ﬁl, nous permet de faire le lien entre ces deux sujets.
Ainsi, nous pouvons déterminer que pour réussir à implanter eﬃcacement des protocoles MAC avancés permettant d’optimiser à la fois la qualité de service « fonctionnelle » et la consommation d’énergie (voir 3.2.6 page 46), nous avons besoin de fonctionnalités temps-réel permettant de réagir eﬃcacement aux évènements, notamment temporels — en d’autres termes, respecter des délais très stricts —, ces protocoles avancés nécessitant une synchronisation précise entre les diﬀérents noeuds communicants, et souvent un recours au multiplexage temporel (TDMA), comme iQueue-MAC, ou même la couche MAC du standard 802.15.4 en « mode “beacon” », a fortiori la couche MAC améliorée de l’extension 802.15.4e.

Chapitre 3. Analyse critique de l’état de l’art

Nom TinyOS Contiki OS Nano-RK RIOT OS
Lite OS
Mans OS FreeRTOS

Noyau (capacités) modulaire statique
multitâche coopératif
multitâche préemptif temps-réel
multitâche préemptif temps-réel
multitâche préemptif
multitâche préemptif en option
multitâche préemptif temps-réel (coopératif en option)

Exigences matérielles minimales
très modérées relativement modérées
moyennes (modérées pour le seul noyau)
modérées
relativement modérées
modérées

Pile réseau
oui (intégrée)
deux : uIPv6 ou Rime oui (intégrée)
oui (intégrée), plus utilisation possible d’OpenWSN (projet externe) oui (intégrée)
deux : intégrée et uIPv6
non (utilisation possible d’OpenWSN, projet externe)

Fonctionnalités de base gestion asynchrone des E/S
gestion des E/S, timers logiciels, IPC (limitées) gestion des E/S, timers logiciels, IPC
gestion des E/S, timers logiciels, IPC, structures de données (listes...)
gestion des E/S, mutex
gestion des E/S, timers logiciels, mutex
timers logiciels, IPC, coroutines (option), structures de données (listes...)

spéciﬁques

langage

spéciﬁque

(nesC), simili-« mode

tickless »

noyau évènementiel, pro-

tothreads, reprogram-

mation à l’exécution

gestion des erreurs fa-

tales, mécanisme de ré-

servation de ressources,

mode tickless

gestion des erreurs fa-

tales, gestion avancée des

timers matériels, repro-

grammation à l’exécu-

tion en cours de dévelop-

pement, mode tickless

reprogrammation

à

l’exécution (pionnier),

système de ﬁchiers

intégré, journalisation

d’évènements

gestion du GPS, repro-

grammation à l’exécu-

tion, langage de script

disponible

noyau uniquement, excellente documentation, gestion mémoire, mode tickless optionnel

Portabilité
moyenne (AVR, MSP430)
élevée (AVR, MSP430, PIC, etc.) assez faible (MSP430 mais surtout AVR) bonne (MSP430, ARM, AVR, x86)
faible (AVR uniquement)

moyenne

(AVR

et

MSP430)

excellente (plus de 35 architectures matérielles)

Adoption
Pionnier, Répandu (mais en baisse) Très répandu (OS de référence) Relativement répandu
Moyennement répandu (en expansion)
Relativement répandu
Apparemment peu répandu
Extrêmement répandu (généraliste, non dédié aux WSN)

Table 3.1 – Principales plates-formes logicielles utilisables en 2015 dans le cadre des réseaux de capteurs sans-ﬁl.

76

3.4. Conclusion : protocoles MAC / RDC et OS spécialisés

77

C’est pourquoi nous chercherons, dans le chapitre 4 suivant, la meilleure plateforme logicielle (c-à-d. système d’exploitation) pour atteindre ces objectifs.

Chapitre 4
Plates-formes logicielles : évaluation, problèmes et
améliorations
Une étape essentielle de nos travaux a consisté à chercher une plate-forme logicielle (c’est-à-dire un système d’exploitation) spécialisée dans les réseaux de capteurs sans-ﬁl et présentant les caractéristiques adéquates pour nos travaux ; ces travaux consistant notamment à implanter et à évaluer les performances des protocoles réseaux avancés décrits dans la section 3.2.6 page 46 du présent manuscrit.
Suite à l’analyse de l’état de l’art sur les systèmes d’exploitation dédiés (cf. section 3.3 page 61), nous avons retenu deux plates-formes logicielles de travail : la référence actuelle, Contiki OS (décrit en section 3.3.3 page 65), et celle nous semblant la plus prometteuse du point du vue fonctionnel, RIOT OS (détaillée dans la section 3.3.5 page 68).
Cette tâche s’est révélée plus longue et ardue que nous ne l’avions imaginé a priori, les systèmes de référence établis de longue date ne convenant pas à nos besoins.
4.1 Contiki : développement et limitations
Notons que nous avons dès le départ écarté TinyOS, pour toutes les raisons décrites dans la section 3.3.2 page 63 qui lui est consacrée. Notre premier choix de plate-forme logicielle a donc été logiquement le système de référence actuel, Contiki OS.
Comme indiqué précédemment dans la section 3.3.3 page 65, les qualités proposées par ce système, notamment le support actif des communautés tant académique qu’industrielle, en faisait un choix de départ logique pour eﬀectuer nos développements.
En outre, ce système est depuis 2011 fourni avec son propre protocole MAC, ContikiMAC (décrit en section 3.2.2.4 page 39), lequel est désormais le protocole utilisé par défaut par Contiki. Ce protocole est ainsi devenu le standard de fait dans
79

80

Chapitre 4. Plates-formes logicielles

nombre de publications récentes dans le domaine des réseaux de capteurs sans-ﬁl. L’une des premières tâches à laquelle nous nous sommes attelés est ainsi d’implan-
ter S-CoSenS (décrit dans la section 3.2.6.1 page 47 sur nos protocoles avancés) aﬁn de pouvoir eﬀectuer une comparaison équitable entre ce protocole et ContikiMAC. Nous avons préféré commencer par implanter ce protocole plutôt qu’iQueue-MAC, nettement plus performant mais aussi plus complexe à implanter.
L’intégration de S-CoSenS dans la pile réseau Contiki devait notamment nous permettre d’évaluer l’inﬂuence de toutes les couches de la pile réseau, et l’interaction de celles-ci avec chaque protocole MAC / RDC, aﬁn d’obtenir des résultats les plus ﬁdèles possibles à la réalité du déploiement d’un réseau de capteurs sans-ﬁl en production.

Malheureusement, durant notre eﬀort d’implantation du protocole S-CoSenS au sein de la pile réseau (“netstack”) de Contiki, nous avons fait face à de nombreux problèmes nuisant au développement à l’intérieur de ce système, tant au niveau général que dans le domaine plus spéciﬁque de la pile réseau [Roussel and Song, 2013]. Nous allons dans la présente section décrire les problèmes rencontrés, en tentant — quand cela est possible — de proposer des solutions ou tout au moins des moyens de contournement.

4.1.1 Documentation minimaliste
Ceci est un problème récurrent avec Contiki : à l’exception du code source du système et des exemples d’applications fournis, il n’y a quasiment aucune documentation. Ceci concerne de façon générale l’ensemble de Contiki, y compris et notamment sa pile réseau.
On regrettera notamment l’absence totale de documents techniques de référence, où l’architecture générale du système, les choix de conception et d’implantation seraient expliqués ; une telle documentation de référence représente un outil essentiel pour réellement comprendre une plate-forme logicielle, et ainsi permettre aux développeurs débutants de devenir rapidement eﬃcaces dans leur travail.
Il y a également très peu de documents d’introduction (« tutoriels ») : le seul document d’initiation oﬃciel est la page “get started” du site Web du projet Contiki. Celle-ci montre comment télécharger et utiliser la distribution Linux dédiée au test du système, nommée “Instant Contiki”, pour eﬀectuer rapidement des simulations de réseaux de capteurs sans-ﬁl — grâce à l’utilisation du simulateur Cooja [Österlind et al., 2006] fourni par le projet Contiki — puis télécharger des programmes d’exemple sur du matériel (des motes de type Zolertia Z1). Aucun document n’est disponible pour montrer et (plus important encore) expliquer aux développeurs les nombreuses fonctionnalités de Cooja ; aucun document pour détailler comment programmer des applications avec Contiki ; aucune introduction signalant quelles sont les spéciﬁcités du développement embarqué sur des systèmes aussi contraints que les motes constituant les réseaux de capteurs sans-ﬁl (par opposition au développement « classique » sur PC). Enﬁn, l’absence de documentation sur le fonctionnement interne de Contiki,

4.1. Contiki : développement et limitations

81

et sur les méthodes éventuelles pour adapter le système à ses propres besoins, est particulièrement regrettable pour qui souhaite mener des travaux concrets de recherche et de développement avec, et surtout dans ce système — or, de telles initiatives d’exploitation « avancée » sont appelées à être relativement nombreuses, étant donné le statut d’OS pour WSN de référence que possède actuellement Contiki.
En résumé, une telle absence de documentation raisonnablement accessible rend l’approche initiale de Contiki diﬃcile pour les nouveaux développeurs, et contribue à leur imposer une courbe d’apprentissage relativement élevée.
La principale source de documentation, en matière de développement sous Contiki, est la mailing-list "contiki-developers"1. Toute personne souhaitant développer sur cette plate-forme logicielle (qu’il s’agisse d’applications ou au niveau du système) ne peut espérer atteindre un quelconque but sérieux sans souscrire à cette liste, et demander de l’aide et des renseignements à ses membres. Bien que cette liste soit une source riche d’informations, soit réactive, et en général bien disposée à l’égard des nouveaux venus, on peut diﬃcilement considérer qu’elle remplace de façon satisfaisante le manque de documentation technique et de tutoriels.
Ajoutons également que, si de nombreux exemples d’applications conçues avec le système Contiki sont fournis avec le code source du système, il n’y a par contre aucun exemple de code destiné à s’insérer dans le système lui-même (comme par exemple un plug-in pour la pile réseau ou toute autre partie du cœur du système). Le développement au sein du système Contiki, par exemple pour l’adapter à ses besoins ou y rajouter des fonctionnalités, n’en est ainsi qu’encore plus diﬃcile à apprendre et à maîtriser.

4.1.2 Limitations techniques
De nombreuses limitations du système Contiki ont été dictées par les contraintes fortes imposées par les appareils constituant les réseaux de capteurs sans-ﬁl : ces noeuds sont en eﬀet extrêmement limités quant à leur puissance de calcul et (surtout) leur espace mémoire disponible.
Nous étudierons dans cette section ces diﬀérentes limitations, certaines étant dues à des problèmes plus profonds, découlant directement de choix de conception, notamment concernant la pile réseau de Contiki.

4.1.2.1 Fonctionnalités manquantes : pilotes radio incomplets
La version stable de Contiki alors disponible au moment des présents travaux (version 2.7, datant de novembre 2013) disposait pour les émetteurs / récepteurs radio de pilotes dont l’API n’oﬀrait que les fonctionnalités les plus basiques possibles :
— envoi et réception de trames, — mise en fonction (“on”) et hors fonction (“oﬀ ”) de la radio, — et vériﬁcation de la disponibilité du médium radio (CCA : Clear Channel
Assessment ).
1. Adresse : contiki-developers@lists.sourceforge.net URL de gestion : https://lists.sourceforge.net/lists/listinfo/contiki-developers

