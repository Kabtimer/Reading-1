Radio logicielle pour des réseaux de capteurs sans fil cognitifs : un standard IEEE 802.15.4 reconfigurable
Rafik Zitouni
To cite this version:
Rafik Zitouni. Radio logicielle pour des réseaux de capteurs sans fil cognitifs : un standard IEEE 802.15.4 reconfigurable. Computation and Language [cs.CL]. Université Paris-Est, 2015. English. ￿NNT : 2015PESC1126￿. ￿tel-01361325￿

HAL Id: tel-01361325 https://tel.archives-ouvertes.fr/tel-01361325
Submitted on 7 Sep 2016

HAL is a multi-disciplinary open access archive for the deposit and dissemination of scientific research documents, whether they are published or not. The documents may come from teaching and research institutions in France or abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est destinée au dépôt et à la diffusion de documents scientifiques de niveau recherche, publiés ou non, émanant des établissements d’enseignement et de recherche français ou étrangers, des laboratoires publics ou privés.

THÈSE
en vue de l’obtention du titre de
Docteur de l'Université de Paris Est
Spécialité : Informatique
Présentée Par: Raﬁk Zitouni
Software Defined Radio for Cognitive Wireless Sensor Networks:
A reconfigurable Ieee 802.15.4 Standard

Soutenue le 14 Octobre, 2015

Jury

Directeur : Rapporteurs : Examinateurs :
Invitée :

M SFDPM LataaieaibduscfrciirhaieeaeenenrlnleMtLALMMeGtiagaitiseRrnmhsoueoeiaraaytnnguneet

-

CNRS/UPEMLV/ESIEE/ENPC (LIGM), France Université de Blaise Pascal/LIMOS, France INRIA, France CNAM, France Safran Engineering Services, France ECE Paris, France ECE Paris, France

PhD prepared at ECE Paris – LACSC Laboratoire d’Analyse et Contrôle des Systèmes Complexe 37, Quai de Grenelle CS 71520 75725 PARIS CEDEX 15
PhD in collaboration with UPEC – LiSSi (EA 3956) Laboratoire Images, Signaux et Systèmes Intelligents Domaine Chérioux 122 rue Paul Armangot 94400 Vitry sur Seine

Software Defined Radio for Cognitive Wireless Sensor Networks: A reconfigurable Ieee 802.15.4 Standard
Abstract
The Increasing number of Wireless Sensor Networks (WSNs) applications has led industries to design the physical layer (PHY) of these networks following the IEEE 802.15.4 standard. The traditional design of that layer is on hardware suﬀering from a lack of ﬂexibility of radio parameters, such as changing both frequency bands and modulations. This problem is emphasized by the scarcity of the radio-frequency spectrum. Software Deﬁned Radio (SDR) is an attracting solution to easily reconﬁgure radio parameters. In addition to SDR, a cognitive radio concept can be proposed by spectrum sensing and Dynamic Spectrum Access (DSA) both to overcome the spectrum scarcity problem. This thesis proposes a new SDR solution for WSNs based on the IEEE 802.15.4 standard. Our aim is to characterize an SDR platform that implements two standardized PHY layers and cognitive radio for WSNs.
In this thesis, we carried out SDR implementations using a GNU Radio and Universal Software Peripheral Radio (USRP) platform. We chose this particular platform because it is one of the most practical and well-performed ones. A thorough study was performed to analyze GNU Radio software architecture before its usage. USRPs and their daughter boards were also analyzed through experimental radio-frequency measurements. The analysis of the GNU Radio USRP platform brought a detailed description of its architecture and performances as well as the way to implement an SDR. This description particularly assists researchers to quickly develop eﬃcient SDR receivers and transmitters. We show through our experiments that the measured performances of daughter boards mounted on a USRP are lower than expected ones. Despite these results, some daughter boards have many interesting features such as large covered frequency bands and with a linear output power. An empirical model was introduced to accurately characterize the average output power of a particular daughter board.
Then, we implemented a new possible standardized PHY layer for the 868/915 MHz frequency band. A reverse engineering process of another implementation was performed for the 2450 MHz frequency band. These two PHY layers were described by communication chains or ﬂow graphs. We suggested a new Cognitive Radio by a reconﬁguration of these ﬂow graphs within the corresponding frequency bands. The particularity of our cognitive radio is to reconﬁgure ﬂow graphs in function to the selected frequency. This selection is performed by both DSA and spectrum sensing based on energy detection through real wireless communications. We introduced a message based algorithm in order to reconﬁgure the ﬂow graphs and to synchronize the selection of a carrier frequency.
Our two implemented PHY layers for the 2450 MHz and the 868/915 frequency bands were found functional. The ﬁrst one was tested by exchanging data packets with real sensor nodes. The second was also experienced by a packet exchange, but via GNURadio/USRP communications. Both tests were carried out through real communications. We were also able to measure two wireless communication parameters: Bit Error Rate (BER) and the Packet Success Rate (PSR). The result of functional PHY layers was beneﬁcial for realization and experiments of our cognitive radio. We found that our DSA signiﬁcantly improves the packet success rate compared to that obtained with static spectrum access in an indoor environment. The results of this thesis lead to experiment a cognitive radio with an SDR not only for a WSN, but also for other wireless networks and radio standards.
Keywords: Software Deﬁned Radio (SDR), IEEE 802.15.4, Wireless Sensor Networks (WSN), Physical Layer, Cognitive Radio, Dynamic Spectrum Access (DSA), Universal Software Radio Peripheral (USRP), GNU Radio

Radio Logicielle pour des Réseaux de Capteurs Sans Fil Cognitifs: Un Standard IEEE 802.15.4 Reconfigurable
Résumé
Le nombre croissant d’applications des Réseaux de Capteurs Sans Fils (RCSFs) a conduit les industriels à concevoir ces réseaux avec une couche Physique (PHY) suivant le standard IEEE 802.15.4. Actuellement, cette couche est implémentée en matériel souﬀrant d’un manque de ﬂexibilité du changement des paramètres radio, telles que bandes de fréquences et modulations. Ce problème est accentué par la rareté du spectre radio fréquences. La Radio Logicielle (RL) est une nouvelle solution pour reconﬁgurer plus facilement des paramètres radio. A partir d’une RL, il est possible de développer une radio cognitive permettant une écoute de spectre et un Accès Dynamic au Spectre (ADS). Ces deux possibilités sont utiles pour surmonter le problème de la rareté du spectre. Cette thèse propose une nouvelle solution Radio logicielle pour un RCSF basé sur le standard IEEE 802.15.4. Notre objectif est de caractériser une plate-forme RL qui implémente à la fois deux couches PHY standardisées et une radio cognitive pour des RCSFs.
Dans cette thèse, nous avons réalisé des implémentations RL en utilisant une plateforme composée de la solution Universal Software Peripheral Radio (USRP) d’Ettus Research et de GNU Radio. Nous avons choisi cette plateforme particulière puisqu’elle est parmi les outils les plus performants et les plus pratiques d’après notre état de l’art. Une étude minutieuse a été eﬀectuée pour analyser l’architecture logicielle de la GNU Radio avant son utilisation. Des USRPs et leurs cartes ﬁlles ont été aussi analysés à travers des mesures expérimentales radio fréquences. L’analyse de la plate-forme GNU Radio USRP a apporté une description détaillée de son architecture et de ses performances pour la réalisation d’une RL. Cette description doit permettre à la communauté de chercheurs de développer rapidement des récepteurs et émetteurs radio logiciels. Nous avons prouvé à travers nos expériences que les performances mesurées sont plus faibles que celles attendues pour certaines cartes ﬁlles d’USRP. Malgré ces résultats, certaines cartes ont de nombreuses caractéristiques intéressantes, comme de grandes bandes de fréquences couvertes et avec une puissance de sortie linéaire. Un modèle empirique a été introduit pour caractériser avec précision la puissance de sortie moyenne d’une carte ﬁlle particulière.
Nous avons ensuite implémenté une nouvelle couche PHY standardisée pour la bande de fréquence 868/915 MHz basée sur le standard 802.15.4. Un processus de rétro-ingénierie d’une autre implémentation développée pour la bande 2.4GHz a été eﬀectué. Ces deux couches ont été décrites par des chaines de communications ou des graphes de ﬂux. Nous avons ﬁnalement proposé une nouvelle radio cognitive par une reconﬁguration de ces graphes de ﬂux dans les deux bandes de fréquences correspondantes. La particularité de notre radio cognitive est de reconﬁgurer les graphes de ﬂux en fonction de la fréquence sélectionnée. Cette sélection est eﬀectuée par un ADS et une écoute de spectre basé sur une détection d’énergie, validés tous les deux au travers des réelles communications sans ﬁl. Nous avons introduit un algorithme à base de messages aﬁn de reconﬁgurer les graphes de ﬂux et de synchroniser la sélection sur une fréquence porteuse.
Les deux couches physiques en radio logicielle pour les bandes 2.4 GHz et 868/915 MHz ont été testées et sont fonctionnelles. La première a été testée en échangeant des paquets de données avec des nœuds capteurs réels. La deuxième a été expérimentée par l’échange de paquets, à travers une communication entre deux radios logicielles USRP/GNU Radio. Les deux tests ont été réalisés à travers des communications réelles. Nous avons réussi à mesurer deux paramètres réels d’une communication sans ﬁl : le taux d’erreur binaire et le taux de succès des paquets. Les couches PHY résultantes ont servi à la réalisation et à l’expérimentation d’un ADS de notre radio cognitive. Un ADS a amélioré signiﬁcativement le taux de succès de paquets par rapport à celui obtenu avec un accès statique dans un environnement indoor. Les résultats de cette thèse conduisent à expérimenter une radio cognitive avec une radio logicielle non seulement pour un RCSF, mais pour d’autres réseaux sans ﬁl et standards radio.
Mots-clés : Radio Logicielle, IEEE 802.15.4, Réseaux de Capteurs Sans ﬁls (RCSFs), Couche physique,
Radio Cognitive, Accès Dynamique au Spectre (ADS), Universal Software Radio Peripheral (USRP), GNU
Radio

Remerciement
Je tiens tout d’abord à remercier Laurent George pour avoir dirigé cette thèse. Laurent m’a fait conﬁance dès le début en me proposant un sujet de recherche d’actualité. Il m’a guidé, encouragé, conseillé tout en me laissant une grande liberté de travail et en me déléguant plusieurs responsabilités ; ce fut un honneur et j’espère avoir été à la hauteur.
Cette thèse a été traitée en marge d’un projet de recherche auquel l’ECE Paris participait. Le consortium du projet a ﬁnancé une partie de la thèse, en facilitant l’acquisition de nouveaux matériels de test et d’expérimentation. Je remercie les ﬁnanceurs de ce projet qui se reconnaîtront en lisant ces lignes.
Je remercie également Stefan Ataman qui était mon encadrant de thèse. Stefan m’a permis avec sa rigueur d’appréhender certains concepts nécessaires à l’avancement de cette thèse. Il m’a facilité l’acquisition des connaissances en traitement de signal et en communication numériques. Mes remerciements vont aussi à Marie Mathian qui était mon encadrante au début de cette thèse et qui m’a épaulé dans le projet de recherche.
Je remercie aussi Michel Misson et Pascale Minet d’avoir bien voulu être mes rapporteurs. Je remercie vivement Didier Le Ruyet et Fabien Ligreau pour leur participation au jury.
J’adresse un remerciement particulier à Yacine Amirat directeur du laboratoire LISSI de l’Université de Paris Est Créteil. Yacine m’a initié à la recherche et ses conseils étaient utiles pour la concrétisation de ce doctorat.
Mon arrivée à Paris peut être considérée comme une "nouvelle" date de naissance. Paris m’a permis d’accéder facilement à de multiples sources de savoir : conférences en philosophie, en culture d’orient et en psychologie, etc. Ces activités m’ont enrichi, m’ont marqué et ont nourri ma soif de savoir. Cela m’a permis également de prendre du recul par rapport à mon domaine de recherche. Bien que ces savoirs soient accessibles virtuellement via le web, elles restent beaucoup plus stimulantes à travers un contact réel. Comme le dit si bien la sagesse arabe "Il est préférable d’acquérir le savoir en étant proche des Hommes de la science". Je remercie donc le destin qui m’a donné la chance de m’enrichir à travers cette ville.
Mon travail à l’ECE Paris était particulièrement riche d’expériences. Je reconnais l’apport de l’environnement stimulant de l’ECE et je dis merci à ceux qui y ont participé de près ou de loin. Je commence par les collègues doctorants, ceux qui ont ﬁni leurs thèses : Pierre et Vincent, c’étaient des collègues sympathiques et modestes. Pierre était proche, bienveillant et m’a initié à la culture française. La rencontre des autres doctorants comme Clément, Thomas, Olivier, Ermis ou Nora était aussi enrichissante humainement. Les enseignants chercheurs de l’ECE ont été une source de courage, en l’occurence ceux qui partagent mon bureau : Fréderic Fauberteau, Xiaoting Li, Benaoumeur Senouci, Jean François

2

Remerciement

Hermant et Yves Rakotondratsimba. Je n’oublie pas ceux avec qui j’ai partagé des discussions intéressantes : Max Agueh et Houari Mechkour. Un merci aux collègues généreux et généreuses, qui ont relu mes résumés en anglais et en français, en particulier : Waleed Mouhali et Kristen Bini. Je remercie aussi Assia Soukane et Valéria Nuzzo qui m’ont permis de rédiger ma thèse dans les meilleures conditions possibles.
J’adresse ensuite une dédicace aux personnes que j’ai eu le plaisir de côtoyer durant ces dernières années. Hafid, Ihssen, Mouhamed et Mehdi m’ont soutenu depuis le début de ma thèse. C’étaient pour moi des compagnons présents et proches durant les bons et les mauvais moments.
Je remercie Claire Bozec, son mari Jean-Jacques et leur ﬁlle Sylvie pour leur générosité. En eﬀet, ils m’ont beaucoup aidé en acceptant de relire une partie de mon manuscrit. . . Les premières corrections de mon manuscrit m’ont permis d’améliorer mon anglais.
Ma gratitude et mes remerciements vont aussi à toute ma famille pour leur soutien et leur amour. Un grand Merci à ma mère et mon père qui m’ont transmis les valeurs nécessaires pour avancer et surmonter les diﬃcultés de cette thèse. Merci à mes grand-mères et ma tante qui ont été une source d’aﬀection et d’énergie mentale, et à mes frères et sœurs, Imad et Mourad, Nassima, Nadia, Sihem, Habiba et Randa, eux aussi une source de courage et d’inspiration. Encore une fois : merci à tous !
Je ﬁnis mes remerciements et mes dédicaces par ma femme. Merci à Yasmine qui m’a accompagné durant les mois de rédaction de ce manuscrit. Sa patience et sa conﬁance en moi m’ont permis d’avancer avec assurance jusqu’au bout de cette thèse. Elle était la lumière me montrant le bout du chemin de cette aventure : la thèse.

Ceux qui par la science vont au plus haut du monde Qui par l’intelligence, scrutent le fond des cieux Ceux-là, pareils aussi à la coupe du ciel La tête renversée, vivent dans leur vertige [ Omar Khayyam ]

Author’s publication list
International Conference Papers
SDR’2012 Raﬁk Zitouni, Stefan Ataman, Marie Mathian, and Laurent George. “IEEE 802.15.4 transceiver for the 868/915 MHz band using Software Deﬁned Radio”. In: Proceedings of Wireless Innovation Forum SDR’12 abs/1304.8028 (2012)
CyberC’2013 Raﬁk Zitouni, Stefan Ataman, and Laurent George. “RF Measurements of the RFX 900 and RFX 2400 Daughter Boards with the USRP N210 Driven by the GNU Radio Software”. In: Proceedings of 5ths International Conference on Cyber-Enabled Distributed Computing and Knowledge Discovery. IEEE, Oct. 2013, pages 490–494. isbn: 978-0-7695-5106-7
SSD’2015 Raﬁk Zitouni and Stefan Ataman. “An empirical model of the SBX daughter board output power driven by USRP N210 and GNU Radio based Software Deﬁned Radio”. In: Proceedings of 12th Multi-Conference on Systems, Signals and Devices SSD’15. IEEE, Mar. 2015
SDR’2015 Raﬁk Zitouni, Laurent George, and Yacine Abouda. “A Dynamic Spectrum Access on SDR for IEEE 802.15.4e networks”. In: Proceedings of Wireless Innovation Forum SDR’15 (Mar. 2015)
M&N’2015 Raﬁk Zitouni, Stefan Ataman, Mathian Marie, and Laurent George. “Radio Frequency Measurements on a SBX Daughter Board using GNU Radio and USRP N-210”. In: Proceedings of 3rd IEEE International Workshop on Measurements and Networking 2015. IEEE, Oct. 2015
Posters in International Conferences
GR’2015 Raﬁk Zitouni, Stefan Ataman, and Laurent George. “Radio Frequency Measurements on SBX Daughter Boards using GNU Radio/USRP N-210”. In: GNU Radio 2015 conference (Aug. 2015)

4

Author’s publication list

Résumé étendu de la Thèse
Résumé
Ce résumé étendu récapitule l’essentiel des travaux réalisés dans le cadre de cette thèse intitulée "Radio Logicielle pour des Réseaux de Capteurs Sans ﬁls Cognitifs : Un standard IEEE 802.15.4 reconﬁgurable". Cette thèse s’intéresse au problème de la reconﬁguration des paramètres radios de la couche PHYsique (PHY) des Réseaux de Capteurs Sans Fils (RCSFs) et en particulier à la problématique de la rareté du spectre radiofréquence. Notre solution est basée sur une Radio Logicielle (RL). Nous avons analysé et évalué une plate-forme RL aﬁn de réaliser cette solution. Nous avons implémenté sur cette plate-forme des spéciﬁcations IEEE 802.15.4 pour la bande de fréquences 868/915 MHz. Cette nouvelle implémentation a été détaillée conjointement avec celle pour la bande de fréquence 2.4 GHz. En outre, nous avons introduit une radio cognitive déﬁnie par un Accès Dynamique au Spectre (ADS) à deux bandes de fréquences 868/915 MHz et 2.4 GHz. Un ADS a amélioré signiﬁcativement la robustesse de communication des paquets de données. Ce résultat ainsi que la caractérisation de la plate-forme contribuent à la réalisation de nouvelles solutions basées sur une RL.
1 Introduction et objectifs
Le nombre croissant d’applications basées sur les RCSFs a conduit les industriels à concevoir ces réseaux avec une couche PHY suivant le standard IEEE 802.15.4 [16] [17]. Un des problèmes de cette couche est la reconﬁguration de ses paramètres radios tels que la bande de fréquence ou la technique de modulation. La source de ce problème est liée à la nature physique de cette couche et à la nécessité de conformité au standard. De plus, le nombre croissant de réseaux sans ﬁls et de technologies radios conduit à une rareté du spectre radiofréquence. En outre, la communauté de recherche traite ces problèmes ainsi que d’autres en rapport avec la couche PHY en se basant généralement sur des outils de simulation.
Une RL est une solution émergente d’expérimentation réelle de transmissions sans ﬁls. Elle intéresse à la fois les industriels et la communauté de recherche, puisqu’elle permet de déﬁnir les paramètres et les fonctions d’une radio en logiciel à la place du matériel (c.-à-d. puce électronique). Ces paramètres peuvent être la bande de fréquence, le type de modulation et la puissance radio d’émission [10]. La reconﬁgurabilité est parmi les principaux avantages d’une RL. Étant donné cet avantage, un nombre croissant de plates-formes, d’architectures et de standards ont été proposés dans la littérature. Dans cette thèse, nous présentons un état de l’art sur

6

Résumé étendu de la Thèse

la radio logicielle. Nous nous intéressons principalement à des solutions performantes et simple à mettre en oeuvre.
L’Universal Software Radio Peripheral (USRP) de Ettus Research [34] et l’outil logiciel GNU Radio [72] constituent tous les deux une plate-forme RL basée sur une architecture avec un processeur générique (ou General Purpose Processor (GPP)). L’USRP/GNU Radio est facilement accessible et avec des performances radiofréquences élevées (disposant d’une large bande de fréquence et d’un taux d’échantillonnage élevé). La GNU Radio est un logiciel libre permettant l’implémentation (ou le prototypage) d’une radio à l’aide d’un ordinateur hôte disposant d’un GPP. Une implémentation se présente sous la forme de chaînes de blocs de communication (ou graphes de ﬂux) pour un émetteur et un récepteur radio. Un USRP est un périphérique qui porte des cartes ﬁlles permettant à un graphe de ﬂux GNU Radio de recevoir un signal en bande de base et de transmettre un signal modulé. Dans la littérature [35] [36] [37] [82] [83], la plate-forme USRP/GNU Radio a été utilisée pour expérimenter des solutions dans la recherche sans une connaissance à priori des performances radios. Notre thèse propose une analyse minutieuse de la plate-forme. En eﬀet, nous proposons une évaluation des performances des cartes ﬁlles des USRPs [2] [3].
Le standard IEEE 802.15.4 [16][17] spéciﬁe plusieurs couches PHYs en fonction de la bande de fréquence et de la modulation. Les spéciﬁcations pour la bande de fréquences Industrial Scientiﬁc Medical (ISM) à 2.4 GHz avec la modulation OﬀsetQuadtrature Phase Shift Keying (O-QPSK) ont été implémentées sous la GNU Radio/USRP [35]. Cette implémentation a été testée et trouvée fonctionnelle dans la littérature. Par contre, nos premiers tests ont montré certaines diﬃcultés à recevoir et à transmettre des paquets de données. Notre thèse présente une rétro-ingénierie de cette implémentation. Notre objectif est de détailler les chaînes de l’émetteur et du récepteur radio. L’émission doit être décrite de la génération des paquets de données jusqu’à leurs transmissions sous forme d’un signal modulé. De même, la réception doit être détaillée de la réception d’un signal en bande de base, en passant par une démodulation et en ﬁnissant par une construction des paquets.
Plusieurs couches PHY spéciﬁées dans le standard 802.15.4 ne sont explorées ni par l’industrie ni par la communauté de recherche. La couche PHY pour la bande de fréquence 868/915 MHz permet une portée de transmission plus grande que celle pour la bande 2.4 GHz [1]. Cette thèse présente une nouvelle implémentation en radio logicielle pour la bande 868/915 MHz.
Une radio cognitive est un concept proposé comme une solution au problème de la rareté du spectre radiofréquence. Ce concept est réalisé concrètement par une écoute de spectre et un ADS. Dans la bande de fréquence ISM 2.4 GHz, un RCSF basé sur le standard 802.15.4 partage cette bande avec d’autres réseaux, par exemple IEEE 802.11 b/g (WiFi). Le problème d’interférence des canaux de ces réseaux conduit à un manque de robustesse des communications radios. Bien que la nouvelle version 802.15.4e [17] propose un nouveau mécanisme de saut de fréquence (ou canaux),

2. État de l’art sur la Radio Logicielle

7

ce mécanisme déﬁnit en avance des valeurs statiques (ou pseudo aléatoires) à ces fréquences. Dans cette thèse, nous introduisons une nouvelle solution radio cognitive réalisée avec un ADS et une écoute de spectre basée sur une détection d’énergie. Notre ADS est eﬀectuée à travers les deux bandes de fréquences 2.4 GHz et 868/915 MHz avec une reconﬁguration des chaînes d’émission et de réception.
Ce résumé étendu est organisé en quatre principales parties. La Section 2 présente une brève présentation de notre état de l’art sur la radio logicielle. L’analyse de la GNU Radio et les mesures expérimentales sur des cartes ﬁlles des USRPs sont présentées, respectivement dans Section 3 et Section 4. Les implémentations radio logicielles, en suivant le standard IEEE 802.15.4, sont décrites dans la Section 5. Un réseau de capteurs sans ﬁl cognitif basé sur le 802.15.4 est détaillé dans la Section 6. Nous ﬁnissons notre résumé par une conclusion et des perspectives.

2 État de l’art sur la Radio Logicielle
Notre objectif est de découvrir les solutions radios logicielles qui permettent une réalisation en logiciel des nœuds d’un RCSF basé sur le standard IEEE 802.15.4. Nous avons dressé un état de l’art sur les solutions existantes dans la littérature.
Une architecture typique d’une RL est composée de trois parties : Une partie RadioFréquence (RF) de front-end, une partie de Fréquence Intermédiaire (FI) et une dernière pour un traitement en bande de base (voir Figure 2.2) [39]. La partie RF permet la réception et l’émission d’un signal en bande de base via des antennes. La partie FI est introduite dans cette architecture générale, puisque le Convertisseur Analogique Numérique (A/N) nécessite une puissance de calcul et une fréquence d’échantillonnage élevées. En général, cette conversion peut être accomplie par un Field Programmable Gate Array (FPGA), par exemple dans un USRP. La dernière partie de traitement en bande de base remplace des fonctionnalités analogiques par d’autres numériques. Des technologies programmables permettent ce remplacement par exemple en utilisant un FPGA, un Processeur de traitement de signal (ou Digital Signal Processor (DSP)) ou un GPP.
La reconﬁgurabilité est la principale propriété de cette architecture. Elle permet à un émetteur ou à un récepteur radio de changer ces paramètres (fréquence) et fonctions (modulations) en logiciel. Ce changement est eﬀectué par un concepteur radio ou par la radio elle-même (c.-à-d. en-ligne ou durant l’exécution). La portabilité et l’interopérabilité sont aussi parmi les avantages d’une telle architecture. La portabilité est déﬁnie par la mobilité de traitement des formes d’ondes d’une plateforme matérielle à une autre. L’interopérabilité est la possibilité d’interconnecter des technologies et des réseaux sans ﬁls via la couche PHY. Par ailleurs, l’optimisation des performances des dispositifs matériels comportant les trois parties d’une RL représente un enjeu majeur. Le traitement en bande de base peut être accompli via un Application Speciﬁc Integrated Circuit (ASIC). Ce dernier est préféré pour un

8

Résumé étendu de la Thèse

calcul eﬃcace sur une puce miniaturisée, mais au détriment de la ﬂexibilité [42]. Un FPGA, un DSP ou un GPP oﬀrent plus de ﬂexibilité. Le choix de ces dispositifs matériels et leur disposition (centralisée et distribuée) peut impacter la facilité de la prise en main d’une RL. La programmation peut se faire avec des langages de haut niveau dans un GPP et un DSP alors qu’elle est en Very high speed integrated circuit Hardware Description Language (VHDL) avec un FPGA. Par conséquent, un nombre important d’architectures et de plates-formes sont proposées dans la littérature.
L’architecture de communication logicielle Software Communication Architecture (SCA) [44] et le système radio reconﬁgurable Reconﬁgurable Radio System (RRS) [49] sont les principales architectures qui tentent de standardiser l’usage d’une RL. La première se base sur une architecture distribuée de type Common Object Request Broker Architecture (CORBA) [44]. La deuxième réutilise une plate-forme GNU Radio/USRP modiﬁée [49].
Nous avons suggéré une classiﬁcation des radios logicielles adaptées aux périphériques embarqués. Deux classes ont été déﬁnies: l’une basée sur un GPP et une deuxième basée sur un matériel reconﬁgurable [52][53]. Le dernier désigne l’utilisation d’un FPGA ou une architecture granulaire (en anglais coarse-grained architecture). Le développement logiciel en utilisant un matériel reconﬁgurable peut être lent avec des langages de programmation comme le VHDL. Par contre, un GPP permet un portage facile d’applications radios programmées en langage de haut niveau, par exemple en C++, Python, C, etc. Un ordinateur hôte est facilement accessible par une grande communauté d’usagers. Par conséquent, contrairement à l’utilisation d’un FPGA, un ordinateur hôte permet un prototypage rapide d’une RL. Il est à noter qu’une architecture peut se baser sur la combinaison d’un FPGA et d’un GPP. Un FPGA peut être dédié aux fonctions lourdes en puissance de calcul de la partie FI, et un GPP pour un traitement en bande de base. Un exemple d’une telle combinaison est la GNU Radio/USRP (voir la prochaine Section).
Dans notre état de l’art, nous avons synthétisé deux classiﬁcations de radios logicielles [54] [55] : une classiﬁcation qui prend en compte le modèle de programmation et une deuxième qui considère le matériel utilisé pour le traitement en bande de base. Les tableaux 2.1 et 2.2 récapitulent les classes avec un nombre de solutions radio logicielles. De plus, nous avons compté plus de soixante solutions et plates-formes radio logicielles (une sélection est illustrée dans le tableau 2.3). Nous avons déterminé deux principaux paramètres de performances pour le choix d’une plate-forme. Il s’agit du taux d’échantillonnage et de la bande passante de radiofréquence d’un matériel front-end d’une plate-forme. Dans notre état de l’art, les valeurs de ces paramètres sont parmi les plus élevées pour un périphérique USRP [34] quand nous les comparons avec les autres solutions matérielles. Ce périphérique peut couvrir une bande de fréquence allant de 4 MHz à 6 GHz avec un taux d’échantillonnage allant jusqu’à 400 MS/s (Mega Samples per second). En outre, un USRP peut être connecté avec un GPP. Ce dernier, en exécutant des programmes GNU Radio, réalise une RL. La

3. Analyse de la plate-forme Radio Logicielle USRP/GNU Radio

9

GNU Radio est un logiciel libre facilement accessible sur le réseau Internet. À travers notre étude théorique, nous avons caractérisés les limites du matériel pour l’obtention d’une RL pure. La partie de FI de l’architecture générale est nécessaire pour la conversion numérique analogique (N/A) et surtout pour la conversion analogique numérique (A/N). La reconﬁguration d’une radio (ou la ﬂexibilité) a été identiﬁée comme l’avantage principal de cette architecture.
Cette partie de la thèse nous a permis de comparer les performances des platesformes permettant le prototypage/implémentation d’une RL. Une plate-forme basée sur un GPP oﬀre un accès facile à ses ressources logicielles et matérielles. La GNU Radio/USRP a montré, en plus de son architecture basée sur un GPP, des performances radios élevées par rapport aux autres plates-formes existantes. Néanmoins, ces performances n’ont pas été explorées par la communauté de recherche. De plus, cette plate-forme n’a pas été suﬃsamment documentée pour faciliter sa prise en main.

3 Analyse de la plate-forme Radio Logicielle US-
RP/GNU Radio
Le but de cette section est de résumer le Chapitre 3 consacré à l’architecture logicielle et matérielle de l’USRP/GNU Radio. Nous avons établi notre analyse en nous basant sur notre recherche bibliographique et notre rétro-ingénierie de la plate-forme. Par analogie avec l’architecture générale, le GPP en exécutant un graphe de ﬂux GNU Radio représente la partie bande de base. Les fonctions des deux parties de FI et de front-end radiofréquence sont assurées par un USRP. Ce dernier est disponible en plusieurs versions avec diﬀérents performances. De même, diﬀérentes liaisons physiques sont possibles avec un ordinateur hôte (ou un GPP). Dans nos travaux d’expérimentations et d’implémentations, nous avons utilisé les deux versions USRP 1 et USRP N210. Le Tableau 3.1 récapitule les performances de ces deux USRPs.
La GNU Radio est exécutée par un ordinateur hôte. Une implémentation sous la GNU Radio reprend la conception de Mitola [39] qui consiste à déﬁnir une RL sous forme d’une chaîne de blocs. Chaque bloc permet une fonction de traitement de signal ou de données, de modulation et de démodulation numérique, etc. Ces fonctions sont disponibles dans une boîte à outils avec une possibilité d’intégrer de nouveaux blocs. Une chaîne de réception ou d’émission radio est décrite par un graphe de ﬂux. Un graphe de ﬂux est exécuté par un GPP. Il traite en entrée un signal en bande de base et génère en sortie un signal modulé. Il s’agit de l’interconnexion d’un ensemble de blocs logiciels. Ces derniers sont programmés, généralement en C++ et connectés via un script Python. La pile des langages de programmation a été détaillée avec sept couches dans la Figure 3.1. L’implémentation d’une RL se base principalement sur la maîtrise des deux langages Python et C++. Les blocs possèdent des ports en entrée, en sortie ou en entrée et en sortie. Les entrées et les sorties des blocs

10

Résumé étendu de la Thèse

sont des échantillons (ou Samples en anglais) ayant diﬀérents types de données, par exemple Char, Short, Complex, etc. Ces types déﬁnissent les tailles des échantillons et indiquent les types de ports d’entrée et de sortie d’un bloc. Le design d’un bloc se fait par une instanciation d’objet en C++ de quatre classes : gr_sync_block, interpolator, gr_sync_decimator et gr_block. Un bloc peut aussi être créé en instanciant un objet bloc de la classe gr.hier_block2. La connexion des blocs peut se faire facilement avec l’interface graphique de la GNU Radio. Des arcs connectent les blocs à condition que les types des ports des blocs soient compatibles. Cette condition permet à un ﬂux numérique (une succession d’échantillons) de traverser ces blocs. En programmation, un graphe de ﬂux peut être dérivé de deux classes : top_block du module gr ou std_top_block du module stdgui2 (voir Figure 3.4). Un graphe de ﬂux est exécuté soit via une commande sur un terminal ou via l’interface graphique. Pour éviter un temps de calcul supplémentaire nécessaire à l’aﬃchage, il est recommandé d’utiliser un terminal de commande tout en évitant aussi les commandes d’aﬃchage.
La GNU Radio est dotée d’un ordonnanceur qui ordonnance l’exécution des blocs en permettant une gestion de l’écoulement des échantillons du ﬂux à travers ses blocs. Notre débogage de graphes de ﬂux nous a montré l’existence de deux types d’ordonnanceurs : Single Threaded Scheduler (STS) et Thread-Per-Block Scheduler (TPS). Ce résultat est conﬁrmé dans la littérature [40]. Le premier ordonnanceur alloue un seul thread à un graphe de ﬂux. Par contre, le deuxième, comme son nom l’indique, alloue pour chaque bloc un thread d’exécution.
Aﬁn de réduire et d’uniformiser le temps d’exécution des blocs à travers les diﬀérents types de processeur, une solution Single Instruction Multiple Data (SIMD) a été proposée dans [77]. Cette solution est appelée Vector Optimazed Libraray of Kernels (VOLK). Elle permet à un bloc d’exécuter une seule instruction avec des vecteurs d’échantillons en entrée. La diﬃculté du VOLK réside dans la gestion des tailles des vecteurs avec la variation des temps d’inter-arrivée des échantillons.
Nous avons analysé les performances d’une implémentation radio logicielle sous GNU Radio/USRP. Ces performances dépendent du délai (ou latency) et du débit d’écoulement du ﬂux (ou throughput). Le délai est engendré par la séparation via un lien physique entre l’ordinateur hôte qui exécute un graphe de ﬂux et l’USRP. Ce délai est dû à la nature des graphes (une succession de blocs séparés). Pour réduire ce délai, des buﬀers sont intégrés entre les blocs logiciels et les composants matériels (entre les deux convertisseurs A/N, N/A et le FPGA, entre un USRP et un GPP). La Figure 3.10 schématise l’existence de buﬀers entre ces diﬀérents composants.
Le recours à des buﬀers introduit la notion de débit d’écoulement qui est déﬁni par le nombre d’échantillons passant par un buﬀer durant une unité de temps. L’eﬀet du délai et du débit sont pris en compte en premier lieu par l’ordonnanceur. Cet eﬀet peut aussi être traité en imposant un paramètre de délai pour chaque bloc ou pour tout le graphe de ﬂux [80]. De plus, des outils d’estimation du temps d’exécution des blocs sont proposés par la communauté [41]. Il s’agit d’un compteur de performances

4. Mesures de performances radios sur des cartes ﬁlles des USRPs 11
(Performance counters et ControlPort). Ces deux outils sont utiles pour le débogage d’un graphe de ﬂux et la détection des blocs provoquant le plus de temps de calcul. Dans le chapitre 3 l’architecture générale d’un USRP a été proposée en se basant sur la littérature [34] (voir Figure 3.8). La carte mère d’un USRP porte un FPGA, des cartes ﬁlles et convertisseurs A/N et N/A. Le rôle du FPGA est principalement de convertir la fréquence du signal en entrée en une fréquence adaptée au contrôleur de la liaison physique avec le GPP. Les cartes ﬁlles (en anglais daughter boards) sont les front-ends radio-fréquence de la radio logicielle. La bande de fréquence couverte est parmi les principaux paramètres d’une carte ﬁlle (voir Table 3.2). Un USRP est reconnu par un pilote logiciel appelé l’USRP Hardware Driver (UHD). Ce dernier permet l’initialisation des paramètres radio par exemple : gain, fréquence centrale, taux d’échantillonnage, etc.
Notre analyse nous a apporté une compréhension de l’architecture logicielle de la GNU Radio. Les langages de programmation ont été organisés en couches pour plus de clarté. Nous avons mis l’accent sur la méthode à suivre pour implémenter une chaine de communication radio. Une implémentation radio logicielle est une interconnexion de blocs logiciels ou un graphe de ﬂux. Nous avons aussi identiﬁé les techniques d’ordonnancement d’exécution de ces blocs. Cet ordonnanceur peut proﬁter des outils comme le VOLK et de la présence de buﬀers entre les blocs logiciels. Les sources de génération de délai au niveau logiciel et matériel ont été identiﬁées. Par contre, les performances radiofréquences de l’architecture USRP n’ont pas été mesurées d’une façon précise. En particulier, la partie front-end de radiofréquence ou les cartes ﬁlles d’un USRP.
4 Mesures de performances radios sur des cartes ﬁlles des USRPs
Les travaux du Chapitre 4 sont motivés par l’obtention de résultats inattendus lors de tests eﬀectués en utilisant des cartes ﬁlles des USRPs. L’interprétation de certains résultats a été diﬃcile en raison du manque d’informations précises sur ces cartes. L’objectif de nos tests a été d’estimer le rapport signal sur bruit (ou Signal-to-Noise Ratio (SNR)) via un bloc de la GNU Radio. Cette dernière comporte déjà des estimateurs proposés dans la littérature [84] [85]. Nous avons simulé en boucle fermée une transmission via un canal radio. Ensuite, nous avons calculé des valeurs estimées du SNR (voir Figure 4.3). En se basant sur les résultats obtenus, un estimateur a été choisi pour calculer le Bit Error Rate (BER) en fonction du SNR (BER est l’erreur en bit) pour une modulation/démodulation Binary Phase-Shift Keying (BPSK) simulée et expérimentée en réel. Les résultats obtenu par simulation ont été en accord avec la théorie (voir Figure 4.5). Par contre, l’expérimentation réelle avec une carte ﬁlle RFX 2400 a donné des résultats non cohérents. La Figure 4.7 montre un nuage de points au-dessus de la limite théorique. Ce nuage de points a été obtenu avec

12

Résumé étendu de la Thèse

des valeurs de BER élevées pour des puissances radios de sortie faibles et vice-versa. Ce résultat a été interprété par l’inégalité entre la valeur de la puissance ﬁxée dans un graphe de ﬂux et la vraie puissance radio de sortie. Par ailleurs, Ettus Research [34] annonce des informations non détaillées de la puissance de sortie des cartes. La Figure 4.8 aﬃche les bandes passantes radiofréquence annoncées dans [34]. En outre, les travaux ayant traité les performances des USRPs dans [87] [88] ne se sont pas intéressés aux paramètres : bandes de fréquences et puissance de sortie des cartes ﬁlles. Cependant, nos travaux publiés dans [2] et [3] sont les premiers à avoir reporté des mesures sur ces deux paramètres. Notre caractérisation des performances des cartes ﬁlles est basée sur une approche expérimentale. L’objectif a été de calculer précisément pour des cartes ﬁlles les bandes de fréquences couvertes et la linéarité de puissance de sortie. Par conséquent, une puissance en sortie d’une carte a été mesurée pour des valeurs de fréquence centrale et de puissance ﬁxées dans un graphe de ﬂux. Les mesures ont été accomplies via deux outils : avec un analyseur de spectre et en utilisant la GNU Radio elle-même. Ces outils interceptent le signal en bande de base généré par un graphe de ﬂux source. Nous nous sommes intéressés aux cartes couvrant des bandes ISM et des bandes spéciﬁées dans le standard IEEE 802.15.4. Les cartes ﬁlles explorées par nos mesures sont la RFX 2450, la RFX 900, la SBX et l’USRP B210 qui couvrent respectivement les bandes de fréquences [2.3 GHz, 2.9 MHz], [750 MHz, 1.050 GHz], [400 MHz, 4.4 GHz] et [70 MHz, 6 Ghz]. Ces intervalles sont annoncés par Ettus Research dans [34] (voir aussi Figure 4.8). Dans les mesures accomplies via un analyseur de spectre, nous avons utilisé un oscilloscope LeCroy 640 Zi [89] (voir Figure 4.9). Ce dernier a été connecté via un câble coaxial [90] à un USRP N210 qui a porté les cartes RFX 2450, RFX 900 et SBX. La carte USRP B210 a été connectée directement à l’oscilloscope, puisque cette carte porte à la fois une carte mère et une carte ﬁlle. Par ailleurs, un graphe de ﬂux source a été implémenté avec la possibilité de générer deux types de signaux : un signal sinusoïdal à bande étroite (ou porteuse) et un signal modulé BPSK (voir Figure 4.10). Dans ce graphe de ﬂux, la puissance de ces signaux peut être ajustée via deux paramètres : DAC et UHDG. Le DAC est déﬁni dans un bloc séparé du graphe de ﬂux. Le deuxième paramètre UHDG est un gain radio déﬁni dans le dernier bloc d’un graphe appelé USRP puits. Ces deux paramètres peuvent être modiﬁés par l’utilisateur. Nous avons établi la relation quadratique espérée entre la puissance mesurée réelle et la valeur du DAC introduite via le graphe de ﬂux (voir équation (4.6)). Les résultats de la linéarité de puissance de sortie en fonction des valeurs de DAC ont été obtenus pour les deux signaux : BPSK modulé et sinusoïdal. Cette linéarité est meilleure avec une carte RFX 2400 qu’une carte RFX 900 (voir Figures 4.12, 4.13 et 4.15). La relation quadratique espérée (équation (4.6)) est vériﬁée pour la carte RFX 2400 et elle dévie légèrement avec une carte RFX 900. Les deux cartes RFX 2400 et RFX 900 couvrent respectivement seulement 24 % et 18 % des bandes de fréquences annoncées par Ettus Research. Précisément, une carte RFX 900 couvrant une bande

4. Mesures de performances radios sur des cartes ﬁlles des USRPs 13
est de 72 MHz dans une fenêtre de puissance entre 0 et -30 dB contrairement aux 300 MHz annoncés. De plus, pour une carte RFX 2400 et dans la même fenêtre de puissance cette bande est de 168 MHz au lieu de 600 MHz. Ces résultats sont reportés dans les courbes des Figures 4.11 et 4.14. Pour les deux cartes SBX et l’USRP B210, les bandes de fréquences sont bien égales à celles annoncées. Néanmoins, la puissance de sortie diminue avec des valeurs de fréquences centrales élevées (voir les Figures 4.16 et Figures 4.22). La courbe obtenue dans la Figure 4.16 pour la carte SBX suit une forme modélisable par un modèle analytique. Par ailleurs, l’UHDG a été identiﬁé comme un ampliﬁcateur supplémentaire pour les deux cartes SBX et USRP B210, son augmentation devrait se faire avec précaution. En eﬀet, nous avons observé une distorsion du signal et une émission de puissance sur des fréquences harmoniques au-delà d’une valeur seuil de l’UHDG (voir Figures 4.18 et 4.19). Ces deux phénomènes ont été caractérisés par le calcul d’un Total Harmonic Distortion (THD). La Figure 4.17 montre des courbes des valeurs mesurées de THD en fonction des puissances de sortie sur des harmoniques avec l’augmentation de l’UHDG. Étant donné la forme modélisable des courbes obtenues pour des cartes SBX, nous avons eﬀectué des mesures complémentaires sur d’autres cartes (au total quatre). Les résultats obtenus nous ont permis de proposer un modèle empirique par interpolation (voir Figures 4.24, 4.25, 4.26 et 4.27). Il s’agit de la déﬁnition d’une fonction qui prédit la puissance de sortie en fonction des variables du DAC, de l’UHDG et de la fréquence centrale. Ce modèle a été simpliﬁé pour permettre sa réutilisation facile par la communauté ou pour son implémentation sous la GNU Radio (voir formule 4.11). La deuxième partie des mesures a été accomplie uniquement avec des graphes de ﬂux. L’objectif est la caractérisation de la puissance d’une carte par un graphe de ﬂux en recevant une porteuse générée également par un graphe de ﬂux. Pour cela, nous avons réutilisé le même graphe de ﬂux source en émission. En réception, nous avons implémenté un graphe de ﬂux capable de calculer l’énergie reçue sur une fréquence en utilisant une densité spectrale de puissance. Nous nous sommes limités dans ces mesures à l’usage des cartes RFX 2400 et SBX. En eﬀet, une carte SBX a été utilisée en sortie et des cartes SBX et RFX 2400 en entrée. Les résultats obtenus, et ce pour les deux cartes, montrent l’eﬀet du paramètre UHDG du récepteur (voir Figure 4.23). L’ampliﬁcateur sature avec un eﬀet inverse de perte de puissance sur des fréquences harmoniques, si la valeur de l’UHDG est supérieure à 30 dB. Nous avons apporté de nouvelles informations sur les performances d’un USRP. Ces informations ont contribué à la maîtrise de la réaction des cartes ﬁlles. Particulièrement, pour des implémentations radio logicielles sur la plate-forme USRP/GNU Radio.

14

Résumé étendu de la Thèse

5 Implémentations Radio Logicielles pour les
RCSFs basés IEEE 802.15.4
Notre objectif est de présenter le standard IEEE 802.15.4 en première étape et après de le traduire sous forme d’implémentations radio logicielle. Nous avons présenté deux implémentations de deux couches PHYs pour les deux bandes de fréquences 2.4 GHz et 868/915 MHz. Nous avons détaillé les spéciﬁcations ou les attributs de ces deux couches en deux parties : des spéciﬁcations communes et d’autres propres à chaque bande. Le format d’un paquet et le type d’étalement de spectre Direct Sequence Spread Spectrum (DSSS) sont les deux spéciﬁcations communes. L’occupation du spectre, les séquences Pseudo Aléatoires (PAs) du DSSS ainsi que la modulation sont des attributs propres à chaque couche. La modulation pour la couche de la bande 2.4 GHz est l’O-QPSK, alors que c’est la Diﬀerential-Phase Shift Keying (D-BPSK) dans la bande 868/915 MHz. Les plans d’allocation des canaux (ou fréquences centrales), les séquences PAs sont récapitulés dans Figures 5.1, Figure 5.2 et Tableaux 5.2, 5.3.
La couche de la bande 2.4 GHz a été implémentée sous la GNU Radio/USRP et présentée dans [35] [36]. Dans la littérature, nous n’avons pas trouvé de détails sur les graphes de ﬂux représentant l’émetteur et le récepteur GNU Radio. De plus, au début de notre exploration, nous avons observé certaines diﬃcultés en testant ces graphes de ﬂux. Cependant, notre travail a apporté le maximum de détails sur les paramètres de conﬁguration des graphes de ﬂux. Ces détails ont servi, en partie, à proposer une nouvelle implémentation pour la couche PHY de la bande 868/915 MHz.
Les Figures 5.3 et 5.4 reportent respectivement les graphes de ﬂux de l’émetteur et du récepteur de la couche PHY 2.4 GHz. L’émetteur est décrit allant du bloc de génération de paquets jusqu’au bloc puits d’envoi d’un signal modulé en O-QPSK. Le récepteur représente l’opération inverse commençant par une démodulation O-QPSK et ﬁnissant par une construction de paquets. Cette dernière étape est détaillée sous forme d’un algorithme divisé en trois sous-parties. La recherche du début ou du préambule de paquet est la première partie (voir l’Algorithme 1). La deuxième partie est la recherche et la construction de l’entête de paquet, elle est présentée dans l’Algorithme 2. La dernière étape compacte les fragments d’octets en donnant des paquets insérés dans une ﬁle d’attente. Les instructions de condition des trois algorithmes contrôlent la compatibilité du ﬂux d’octets décodé avec la séquence PA correspondante (voir Tableau 5.2). Notre nouvelle implémentation est basée, principalement, sur la rétro-ingénierie de celle de la bande 2.4 GHz. Les graphes de ﬂux de l’émetteur et du récepteur sont présentés respectivement dans la Figure 5.5 et la Figure 5.6 [1]. L’émetteur génère des paquets et construit une constellation des symboles en D-BPSK tout en suivant un étalement de spectre DSSS. Ce dernier reprend la séquence PA spéciﬁée par le standard pour la bande 868/915 MHz (voir Tableau 5.3). Inversement, le récepteur démodule le signal en première étape avec

6. RCSF cognitif basé sur le standard IEEE 802.15.4

15

un démodulateur BPSK. Le décodage diﬀérentiel est retardé pour la dernière étape de décodage des paquets pour construire à la ﬁn un démodulateur D-BPSK. Le décodeur de paquets reprend le même principe de celui de la bande 2.4 GHz à quelques diﬀérences. La première partie de recherche du préambule construit des bits diﬀéremment en fonction de la séquence PA correspondante tout en appliquant un décodage diﬀérentiel. La construction d’entête et le compactage d’octets sont aussi repris avec l’usage de la séquence PA correspondante. Le fonctionnement des graphes des ﬂux dans la bande 2.4 GHz a été testé via deux communications réelles de paquets de données. La première communication expérimente une émission et une réception entre les graphes de ﬂux (ou USRP/GNU Radio conﬁgurations). Nous avons mesuré le taux de réussite d’envoi de paquet (Packet Success Rate (PSR)) en ﬁxant l’ensemble des paramètres logiciels et matériels nécessaires. Ce taux varie en fonction de la taille des paquets (voir Figure 5.7). Nous avons trouvé qu’une augmentation de ce taux est liée aux taux d’échantillonnage à la réception/émission. La deuxième communication utilise des nœuds capteurs (ou motes Telos B et Raven stiks) et les graphes de ﬂux de l’émetteur et du récepteur. Nous avons réussi à échanger des paquets en réception et en émission avec les nœuds capteurs. Les implémentations pour la bande 868/915 MHz ont été testées avec deux USRP 1 pilotées par les graphes de ﬂux. Nous avons mesuré le taux d’erreur en bit et en paquet d’une communication (voir Figures 5.9 et 5.10). Une constellation des symboles a été obtenue dans la Figure 5.9.2. La perte de paquet augmente dans le cas d’un déphasage entre l’émetteur et le récepteur. En eﬀet, cette désynchronisation peut être provoquée par deux sources : le déséquilibre entre les temps de calcul des graphes de ﬂux et la gestion des buﬀers entre GNU Radio et USRP. Malgré ces diﬃcultés et l’environnent indoor bruité des expérimentations, nos implémentations sont fonctionnelles.

6 RCSF cognitif basé sur le standard IEEE 802.15.4
Le problème de la rareté du spectre radiofréquence est une conséquence principale de la régulation et la rigidité des standards de télécommunication. La bande ISM est déﬁnie libre pour de nombreuses applications. Un réseau de capteurs sans ﬁl basé sur le standard IEEE 802.15.4 partage la bande 2.4 GHz avec d’autres réseaux IEEE 802.11 b/g et IEEE 802.15.1. Les canaux de ces réseaux se chevauchent comme présentés dans la Figure 6.1. De plus, même si la nouvelle version du standard IEEE 802.15.4e [17] déﬁnie un mécanisme de saut de fréquences (ou saut de canal), les valeurs de ces fréquences sont statiques une fois attribuées. Cependant, un réseau de capteurs sans ﬁl cognitif apporte une nouvelle solution au problème de la rareté du spectre.
Une radio cognitive existe concrètement si la radio peut écouter le spectre radio

16

Résumé étendu de la Thèse

et peut aussi accéder dynamiquement et en ligne à d’autres bandes de fréquences. Notre ADS suit un modèle ouvert de partage (ou en anglais spectrum common). Ce modèle est celui où tous les réseaux ont les mêmes droits en accédant à une bande de fréquences sans licence. Nous avons considéré un RCSF comme un Utilisateur Secondaire (US) et les autres réseaux comme des Utilisateurs Primaires (UPs). Les deux implémentations pour les 2.4 GHz et 868/915 MHz bandes de fréquences ont été réutilisées.
Notre RCSF cognitif est composé d’un émetteur et d’un récepteur, où chacun est composé d’un nombre de graphes de ﬂux. Le spectre radiofréquence comprend les deux bandes 2.4 GHz et 868/915 MHz. Par conséquent, le ADS peut conduire à un changement de graphe de ﬂux de réception et d’émission. Cependant, le récepteur US est obtenu avec cinq graphes de ﬂux (voir Figure 6.3). Il comporte un détecteur d’énergie, un récepteur/émetteur de messages avec un démodulateur/modulateur Gaussian Minimum Shift Keying (GMSK) et les deux récepteurs pour les deux bandes de fréquences 2.4 GHz et 868/915 MHz. L’émetteur quant à lui comporte les émetteurs correspondants aux bandes de fréquences pour les mêmes graphes de ﬂux de modulateur/démodulateur GMSK (voir Figure 6.4). L’écoute du spectre est basée sur une détection d’énergie eﬀectuée uniquement par le récepteur. Dans notre conﬁguration de radio logicielle, l’UP est un modulateur Orthogonal FrequencyDivision Multiplexing (OFDM) de signal généré aléatoirement (voir Figure 6.5). Cet UP simule la modulation OFDM ou le perturbateur de notre réseau US (ou IEEE 802.15.4).
Notre détecteur d’énergie réutilise le graphe de ﬂux proposé dans [113]. Ce dernier a été adapté et intégré au récepteur de l’US (ou IEEE 802.15.4). Le principe de la détection est basé sur l’estimation de la moyenne d’une densité spectrale de puissance de sortie (voir Figure 6.6). Il s’agit de recevoir un ﬂux de signal et de le transformer en vecteurs de 512 échantillons complexes pour une fréquence donnée. Ensuite, chaque vecteur est traité dans une fenêtre Balkman-Harris avec une Transformée de Fourrier Rapide (ou Fast Fourier Transform (FFT)). Cette fenêtre se déplace aﬁn de balayer une bande de fréquence. L’énergie détectée sur une fréquence centrale est donnée par l’équation (6.1).
La sélection dynamique de fréquence porteuse est accomplie après l’exécution d’un algorithme de coordination par échange de messages. Cet algorithme est inspiré des requêtes automatiques de répétition (ou Automatique Repeat reQuest (ARQ)). Les Algorithmes 5 et 6 sont exécutés respectivement par le récepteur et l’émetteur USs. La sélection est eﬀectuée par le récepteur après la détection de l’énergie minimale sur une bande de fréquence. Un seuil minimal d’énergie est ﬁxé aﬁn d’arrêter la détection dans un temps limité. La valeur initiale de ce seuil est déﬁnie à partir des expériences de détection précédentes. L’échange de message d’acquittement de changement de fréquence est assuré via les modulateurs/démodulateurs GMSK. Cette modulation est choisie, puisque sous la GNU Radio/USRP nous avons observé un taux de PSR élevé avec une modulation GMSK. Le récepteur envoie continuellement une requête

6. RCSF cognitif basé sur le standard IEEE 802.15.4

17

avec la valeur de la fréquence sélectionnée. Entre-temps, il attend un acquittement de l’émetteur avant d’envoyer de nouveau un message de conﬁrmation indiquant qu’il est prêt à recevoir des données. Du côté de l’émetteur, l’attente est continuelle jusqu’à ce qu’il reçoive une requête. Cette réception déclenche l’envoi répétitif du message d’acquittement jusqu’à la réception d’une conﬁrmation d’aptitude à recevoir des données. Ensuite, l’émetteur déclenche l’envoi des paquets de données IEEE 802.15.4.

Nous avons réalisé une expérimentation avec trois USRP 1 dans un environnement indoor. Deux USRP 1 sont dédiés à l’émetteur et au récepteur de notre RCSF cognitif (ou US). Un USRP 1 est avantageux, puisqu’il permet le montage de deux cartes ﬁlles avec pour chacune deux sorties antenne, une pour la réception (Rx) et une deuxième pour réception/émission (Rx/Tx). Nous avons utilisé quatre cartes ﬁlles SBX. Le détecteur d’énergie et le modulateur/démodulateur GMSK occupent une carte ﬁlle avec pour chacun, respectivement, les antennes Rx et RX/Tx. Par ailleurs, l’UP (modulateur OFDM) est joué par un troisième USRP 1.

Une fréquence de communication centrale est initialisée pour commencer l’expérimentation. Ensuite, le détecteur d’énergie balaye par division de 8 MHz dans la bande de fréquence 2.4 GHz. Cette division est due à la limitation en 8 MHz de la liaison USB 2 de l’USRP 1. D’autres paramètres hors-ligne et en-ligne sont déﬁnis, respectivement, avant l’exécution et au moment de l’exécution des graphes de ﬂux. La bande passante d’un canal et le taux d’échantillonnage sont déﬁnis hors-ligne. Par contre, les paramètres en-ligne sont : la fréquence centrale, la tranche de balayage et le nombre de pistes (ou bins en anglais) d’une fenêtre FFT (voir Tableau 6.1). Une fenêtre FFT est déﬁnie par son début, sa taille et sa ﬁn calculés respectivement, par les équations (6.2), (6.3) et (6.4).

Avant d’évaluer les performances de notre ADS, une caractérisation préalable a été eﬀectuée sur ce spectre en détectant l’énergie reçue pour chaque fréquence (voir Figure 6.7 et 6.8). En eﬀet, nous avons détecté plus de pics de puissance dans la bande 2.4 GHz par rapport à la bande 868/915 MHz. Après la caractérisation, nous avons considéré deux scénarios : avec un ADS et avec une déﬁnition statique d’un canal du standard, mais les deux ont été perturbés par un PU. La robustesse de l’ADS est mesurée par le taux PSR et le taux des paquets reçus (ou Packet Received Rate (PRR)). Ce dernier mesure le nombre de paquets reçus avec erreur par rapport à la somme totale des paquets envoyés. La Figure 6.9 et la Figure 6.10 montrent, respectivement, les résultats d’une communication sans l’ADS et avec l’ADS. Une amélioration de 80 % du PSR est obtenue avec notre ADS par rapport à un accès statique.

18

Résumé étendu de la Thèse

7 Conclusion et perspectives
Après la description résumée des diﬀérentes parties de la thèse, nous rappelons les contributions de notre travail comme suit :
• Notre état de l’art a suggéré deux classes de radio logicielles pour des périphériques embarqués. Il s’agit d’une classe d’architecture avec un GPP et une autre avec un matériel reconﬁgurable. De plus, nous avons synthétisé d’autres classiﬁcations avec une étude comparative des performances des plates-formes.
• Nous avons apporté une caractérisation de la plate-forme GNU Radio/USRP. La GNU Radio a été analysée avec une description de l’architecture logicielle et du modèle en graphe de ﬂux d’une implémentation radio logicielle. Nous avons identiﬁé les techniques d’ordonnancement et les sources de délais d’exécution de ces graphes. En outre, l’architecture SIMD (ou VOLK), les outils ControlPort et compteur de performances ont été étudiés et présentés.
• Nos mesures de performance sont les premiers travaux de recherche en rapport avec les cartes ﬁlles RFX 2400, RFX 900, SBX et USRP B210 des USRPs. Les bandes de fréquences et les puissances de sorties de ces cartes ont été mesurées via une méthode expérimentale. Des cartes SBX et USRP B210 ont été trouvées avec des bandes de fréquences larges compatibles avec les intervalles annoncés par Ettus Research [34]. Néanmoins, la puissance de sortie de ces deux cartes diminue en augmentant la fréquence. Un modèle empirique reprend cette relation aﬁn de prédire la puissance de sortie d’une SBX en fonction des ampliﬁcateurs logiciels. Par ailleurs, les cartes RFX 2400 et RFX 900 couvrent, respectivement, seulement 24 % et 18 % des bandes annoncées. Ces résultats sont utiles pour l’implémentation de radios logicielles en utilisant la GNU Radio/USRP.
• Nous avons implémenté une nouvelle couche PHY possible pour un RCSF basé sur le standard IEEE 802.15.4. Des graphes de ﬂux ont été proposés pour la bande de fréquences 868/915 MHz. De plus, la couche PHY pour la bande 2.4 GHz a été détaillée via une rétro-ingénierie de son implémentation sous forme de graphes de ﬂux. Ces graphes sont fonctionnels pour ces deux bandes, puisqu’ils ont été testés via une communication réelle de paquets de données avec des nœuds capteurs.
• Nous avons proposé un ADS en exploitant les deux couches PHYs IEEE 802.15.4 implémentées. Cet ADS est l’étape la plus importante vers le développement d’un réseau de capteur sans ﬁl cognitif. Ce réseau a été considéré comme un US des deux bandes 2.4 GHz et 868/915 MHz. Nous avons réussi à assembler dans un nœud du réseau un ensemble de graphes de ﬂux : modulateurs et démodulateurs GMSK de messages, les deux implémentations pour le standard

7. Conclusion et perspectives

19

IEEE 802.15.4 et un détecteur d’énergie. La synchronisation et la coordination de changement de fréquences et de graphes de ﬂux ont été assurées via un algorithme avec échange de messages. Notre ADS a été expérimentée à travers une communication réelle de paquets dans un environnement indoor. Le PSR mesuré de cette communication est amélioré de 80 % avec notre ADS par rapport à un accès statique.
Les principales perspectives de notre thèse sont au nombre de trois :
• Nous pourrions améliorer la synchronisation des graphes de ﬂux émetteur et récepteur. Une estimation précise du temps d’exécution des blocs de graphe est possible à travers les outils : compteur de performances et ControlPort.
• Pour la couche PHY proposée, les tests peuvent être étendus à un échange de paquets avec un émetteur/récepteur matériel.
• D’autres couches PHYs du standard IEEE 802.15.4e peuvent être explorées. Nous pouvons considérer celle avec une modulation Diﬀerential-Quadtrature Phase Shift Keying (D-QPSK) et un étalement de spectre Chirp Spread Spectrum (CSS) pour la bande 2.4 GHz.

Contents

1 Introduction et objectifs . . . . . . . . . . . . . . . . . . . . . . . . . 5 2 État de l’art sur la Radio Logicielle . . . . . . . . . . . . . . . . . . . 7 3 Analyse de la plate-forme Radio Logicielle USRP/GNU Radio . . . . 9 4 Mesures de performances radios sur des cartes ﬁlles des USRPs . . . . 11 5 Implémentations Radio Logicielles pour les RCSFs basés IEEE 802.15.4 14 6 RCSF cognitif basé sur le standard IEEE 802.15.4 . . . . . . . . . . . 15 7 Conclusion et perspectives . . . . . . . . . . . . . . . . . . . . . . . . 18

1 Introduction

31

1 Historical Elements and Context . . . . . . . . . . . . . . . . . . . . . 32

2 Deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35

2.1 Software Radio and Software Deﬁned Radio . . . . . . . . . . 35

2.2 Cognitive Radio . . . . . . . . . . . . . . . . . . . . . . . . . . 35

2.2.1 Spectrum Sensing . . . . . . . . . . . . . . . . . . . . 36

2.2.2 Dynamic Spectrum Access . . . . . . . . . . . . . . . 36

2.3 Wireless Sensor Networks . . . . . . . . . . . . . . . . . . . . 37

2.3.1 IEEE 802.15.4 standard . . . . . . . . . . . . . . . . 37

3 Thesis motivations . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38

3.1 Context of WSNs . . . . . . . . . . . . . . . . . . . . . . . . . 38

3.2 Applications of WSNs and SDRs . . . . . . . . . . . . . . . . 40

4 Thesis objectives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41

4.1 SDR platform to implement standardized PHY layer of WSNs 41

4.2 Cognitive Radio for Spectrum Scarcity . . . . . . . . . . . . . 42

5 Thesis Organization and Contributions . . . . . . . . . . . . . . . . . 43

5.1 State of the art on Software Deﬁned Radio . . . . . . . . . . . 43

5.2 Analysis of GNU Radio and experimental measurements on

USRP’s Daughter boards . . . . . . . . . . . . . . . . . . . . . 44

5.3 SDR implementations of IEEE 802.15.4 standard . . . . . . . 45

5.4 Cognitive Wireless Sensor Network based on IEEE 802.15.4 . 45

2 State of the art on Software Deﬁned Radio-SDR

47

1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48

2 Typical architecture of an SDR . . . . . . . . . . . . . . . . . . . . . 48

2.1 SDR Receiver (Receiver (Rx)) . . . . . . . . . . . . . . . . . . 49

2.2 SDR Transmitter (Tx) . . . . . . . . . . . . . . . . . . . . . . 50

3 Features and Challenges of SDR . . . . . . . . . . . . . . . . . . . . . 50

3.1 Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50

3.1.1 Reconﬁgurability . . . . . . . . . . . . . . . . . . . . 50

3.1.2 Portability . . . . . . . . . . . . . . . . . . . . . . . 51

22

Contents

3.1.3 Interoperability . . . . . . . . . . . . . . . . . . . . . 51 3.2 Challenges . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
3.2.1 Handling of an SDR platform . . . . . . . . . . . . . 51 3.2.2 Hardware physical dimensions . . . . . . . . . . . . . 52 3.2.3 Radio frequency performances . . . . . . . . . . . . . 52 3.2.4 Baseband processing hardware . . . . . . . . . . . . 53 4 SDR standards and architectures . . . . . . . . . . . . . . . . . . . . 53 4.1 Software Communication Architecture SCA . . . . . . . . . . 53 4.1.1 Open Source SCA Implementation::Embedded
(OSSIE) . . . . . . . . . . . . . . . . . . . . . . . . . 54 4.2 Reconﬁgurable Radio System RRS . . . . . . . . . . . . . . . 54 5 SDR for Embedded Devices . . . . . . . . . . . . . . . . . . . . . . . 56 5.1 GPP based architecture . . . . . . . . . . . . . . . . . . . . . 56 5.2 Reconﬁgurable hardware based architecture . . . . . . . . . . 56 6 SDR classiﬁcations . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57 6.1 Programming model . . . . . . . . . . . . . . . . . . . . . . . 57 6.2 Used hardware . . . . . . . . . . . . . . . . . . . . . . . . . . 59 6.3 SDR platforms . . . . . . . . . . . . . . . . . . . . . . . . . . 61 7 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64

3 Analysis of GNU Radio and USRP SDR

65

1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66

2 GNU Radio . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66

2.1 Programming language layers . . . . . . . . . . . . . . . . . . 67

2.2 Software blocks . . . . . . . . . . . . . . . . . . . . . . . . . . 67

2.3 Flow graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69

2.4 Software scheduler . . . . . . . . . . . . . . . . . . . . . . . . 70

2.5 SIMD programming (Volk) . . . . . . . . . . . . . . . . . . . . 71

3 Universal Software Radio Peripheral . . . . . . . . . . . . . . . . . . . 72

3.1 USRP Architecture . . . . . . . . . . . . . . . . . . . . . . . . 74

3.2 Transmit and Receive Paths . . . . . . . . . . . . . . . . . . . 74

3.3 RF daughter boards . . . . . . . . . . . . . . . . . . . . . . . 75

3.4 Firmware and FPGA images . . . . . . . . . . . . . . . . . . . 75

3.5 Universal Hardware Driver (UHD) . . . . . . . . . . . . . . . 76

4 GNU Radio and USRP properties . . . . . . . . . . . . . . . . . . . . 76

4.1 Latency and throughput . . . . . . . . . . . . . . . . . . . . . 77

4.2 Buﬀers organization . . . . . . . . . . . . . . . . . . . . . . . 78

4.3 Performance counters and ControlPort . . . . . . . . . . . . . 78

5 Advantages of GNU Radio and USRP . . . . . . . . . . . . . . . . . . 79

6 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80

Contents

23

4 Radio Frequency Measurements on USRP Daughter boards

83

1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84

2 Problem statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84

2.1 An overview of BPSK modulation . . . . . . . . . . . . . . . . 85

2.1.1 The BER and SNR parameters . . . . . . . . . . . . 85

2.1.2 BER/SNR estimators on GNU Radio simulation . . 86

2.1.3 BER/SNR estimators in real experiment . . . . . . . 88

2.2 Related Works . . . . . . . . . . . . . . . . . . . . . . . . . . 90

3 Experimental approach . . . . . . . . . . . . . . . . . . . . . . . . . . 91

3.1 Hardware Setup . . . . . . . . . . . . . . . . . . . . . . . . . . 91

3.2 Software Setup . . . . . . . . . . . . . . . . . . . . . . . . . . 92

3.2.1 The expected DAC vs ouput power relationship . . . 93

4 Spectrum Analyzer measurements . . . . . . . . . . . . . . . . . . . . 93

4.1 RFX2400 Daughter board . . . . . . . . . . . . . . . . . . . . 93

4.1.1 Frequency bandwidth . . . . . . . . . . . . . . . . . 94

4.1.2 Output power versus DAC value . . . . . . . . . . . 95

4.2 RFX900 Daughter board . . . . . . . . . . . . . . . . . . . . . 95

4.2.1 Frequency bandwidth . . . . . . . . . . . . . . . . . 97

4.2.2 Output power versus DAC value . . . . . . . . . . . 97

4.3 SBX Daughter board . . . . . . . . . . . . . . . . . . . . . . . 98

4.3.1 Frequency bandwidth . . . . . . . . . . . . . . . . . 99

4.3.2 Total Harmonic Distortion (THD) . . . . . . . . . . 99

4.3.3 Output power versus DAC value . . . . . . . . . . . 101

4.4 MIMO USRP B210 . . . . . . . . . . . . . . . . . . . . . . . . 103

4.4.1 Frequency bandwidth . . . . . . . . . . . . . . . . . 104

5 Measurements through ﬂow graphs . . . . . . . . . . . . . . . . . . . 104

5.1 RFX and SBX Daughter boards . . . . . . . . . . . . . . . . . 105

6 Empirical model for SBX daughter boards . . . . . . . . . . . . . . . 106

7 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109

5 SDR implementations for IEEE 802.15.4-based WSN

113

1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114

2 Problem statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114

3 Related works . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116

4 IEEE 802.15.4 PHY layers . . . . . . . . . . . . . . . . . . . . . . . . 118

4.1 Common speciﬁcations for 868/915 MHz and 2450 MHz PHY

layers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118

4.2 2450 MHz speciﬁcations . . . . . . . . . . . . . . . . . . . . . 119

4.3 868/915 MHz speciﬁcations . . . . . . . . . . . . . . . . . . . 120

5 Software Implementations . . . . . . . . . . . . . . . . . . . . . . . . 121

5.1 Software transmitter/receiver for 2450 MHz PHY . . . . . . . 121

5.1.1 Tx ﬂow graph . . . . . . . . . . . . . . . . . . . . . . 121

24

Contents

5.1.2 Rx ﬂow graph . . . . . . . . . . . . . . . . . . . . . . 122 5.1.3 Packet decoder . . . . . . . . . . . . . . . . . . . . . 123 5.2 Software transmitter/receiver for 868/915 MHz PHY . . . . . 124 5.2.1 Tx ﬂow graph . . . . . . . . . . . . . . . . . . . . . . 127 5.2.2 Rx ﬂow graph . . . . . . . . . . . . . . . . . . . . . . 128 5.2.3 Packet decoder . . . . . . . . . . . . . . . . . . . . . 129 6 SDR communications for 2450 MHz . . . . . . . . . . . . . . . . . . . 131 6.1 Communications between two SDRs . . . . . . . . . . . . . . . 131 6.2 Communications between sensor motes and SDRs . . . . . . . 132 7 SDR communications for 868/915 MHz . . . . . . . . . . . . . . . . . 133 8 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136

6 Cognitive Wireless Sensor Network based on IEEE 802.15.4

139

1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139

2 Problem statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140

3 Related works . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142

3.0.1 Related speciﬁcations . . . . . . . . . . . . . . . . . 142

3.0.2 Related implementations . . . . . . . . . . . . . . . . 143

4 Dynamic spectrum access on GNU Radio USRP SDR . . . . . . . . . 143

4.1 Reconﬁgurable SDR settings . . . . . . . . . . . . . . . . . . . 144

4.2 Energy Detector . . . . . . . . . . . . . . . . . . . . . . . . . 146

4.3 Dynamic frequency selection . . . . . . . . . . . . . . . . . . . 146

5 Experiments and results . . . . . . . . . . . . . . . . . . . . . . . . . 148

6 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152

7 Conclusions and Future Work

153

1 Conclusions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153

2 Future Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156

Glossaries

159

Acronyms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159

Glossary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166

List of Figures
1.1 The opportunity to replace Wireless communications devices by Software Deﬁned Radio . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
1.2 The crowded frequency spectrum from 300 MHz to 3 GHz in USA [9] 34 1.3 Interaction stack of CR, SDR, DSA and SS . . . . . . . . . . . . . . . 36
2.1 Ideal architecture of a Software Radio . . . . . . . . . . . . . . . . . . 49 2.2 General architecture of SDR . . . . . . . . . . . . . . . . . . . . . . . 49 2.3 SDR receiver block diagram . . . . . . . . . . . . . . . . . . . . . . . 49 2.4 SDR transmitter block diagram . . . . . . . . . . . . . . . . . . . . . 50 2.5 Version 4 of the SCA architecture [49] . . . . . . . . . . . . . . . . . 54 2.6 ETSI architecture [51] . . . . . . . . . . . . . . . . . . . . . . . . . . 55 2.7 Hardware tasks associated with process intensity and ﬂexibility . . . . 61
3.1 Software layers of the GNU Radio . . . . . . . . . . . . . . . . . . . . 67 3.2 Source, Sink and Intermediate blocks . . . . . . . . . . . . . . . . . . 68 3.3 C++ signal processing modules . . . . . . . . . . . . . . . . . . . . . 68 3.4 Programming layers of GNU Radio implementation . . . . . . . . . . 69 3.5 An example of a ﬂow graph . . . . . . . . . . . . . . . . . . . . . . . 70 3.6 GNU Radio Software layers [78] . . . . . . . . . . . . . . . . . . . . . 70 3.7 VOLK programming model . . . . . . . . . . . . . . . . . . . . . . . 72 3.8 General USRP Architecture with a daughter board (USRP N210 with
WBX) [37] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75 3.9 UHD in GNU Radio/USRP . . . . . . . . . . . . . . . . . . . . . . . 76 3.10 Latencies between GPP, FPGA and DAC/ADC . . . . . . . . . . . . 77 3.11 Latencies between Software blocks . . . . . . . . . . . . . . . . . . . . 78 3.12 Buﬀers in GNU Radio USRP SDR . . . . . . . . . . . . . . . . . . . 78 3.13 Controlport clients with GNU Radio applications over a TCP connection 79 3.14 An example of the performance’s counters graph of a given ﬂow graph 79
4.1 Constellation diagram for BPSK modulation . . . . . . . . . . . . . . 85 4.2 Loop back ﬂow graph for SNR estimation . . . . . . . . . . . . . . . . 87 4.3 Known theoretical SNR compared to the estimated ones through GNU
Radio and python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87 4.3.1 Simple estimator of the SNR. . . . . . . . . . . . . . . . . . . 87 4.3.2 Skew estimator of the SNR. . . . . . . . . . . . . . . . . . . . 87 4.3.3 M2M4 estimator of the SNR. . . . . . . . . . . . . . . . . . . 87 4.3.4 SVR estimator of the SNR. . . . . . . . . . . . . . . . . . . . 87 4.4 Loop back ﬂow graph for BER estimation . . . . . . . . . . . . . . . 88

26

List of Figures

4.5 Compared BER versus Eb/N0 obtained under simulation and theoretical processing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
4.6 Two USRP 1 connected to a host computer which run a BPSK modulator/demodulator ﬂow graph . . . . . . . . . . . . . . . . . . . . . . 89
4.7 BER versus SNR obtained with a BPSK modulation on RFX2400 daughter board . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
4.8 Daughter boards frequency band coverage . . . . . . . . . . . . . . . 90
4.9 Experimental setup for the measurements . . . . . . . . . . . . . . . 92
4.10 A simpliﬁed sinusoidal and BPSK transmitter ﬂow graph . . . . . . . 93
4.11 Measured bandwidth of the RFX2400 daughter board. The reference level of 0 dB was taken at 2434 MHz. Units are logarithmic (dB). . . 94
4.12 The average output power of the RFX2400 versus the DAC value for 6 frequencies (unmodulated carrier). The Pout ∼ DAC2 law is closely followed. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
4.13 The average output power of the RFX2400 versus the DAC value for 3 frequencies in the cases: unmodulated carrier and BPSK transmission. The Pout ∼ DAC2 law breaks down for BPSK at DAC = 0.7. . . . . 96
4.14 Measured bandwidth of the RFX900 daughter board. The reference level of 0 dB was taken at 910 MHz. Units are logarithmic (dB). . . . 97
4.15 The average output power of RFX900 versus the DAC value at 900 MHz (unmodulated carrier). . . . . . . . . . . . . . . . . . . . . . . . 98
4.16 Measured bandwidth of the SBX daughter boards for UHDG of 0, 10, 20 dB. The small oscillation between 2.2 and 3.4 GHz is probably due to a slight mis-adaptation in the SBX board. . . . . . . . . . . . . . . 99
4.17 THD measured at carrier frequencies f1 = 600 MHz, 900 MHz and 2400 MHz. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
4.18 Time domain waveform at 600 MHz for UHDG from 10 to 40 dB. Beyond the UHD gain value of 20 dB, the waveform becomes heavily distorted. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
4.19 The measured output power for a carrier frequency f1 = 600 MHz and f1 = 900 MHz versus the UHDG. . . . . . . . . . . . . . . . . . . 102 4.19.1 f1 = 600 MHz. The second harmonic at f2 = 1800 shows a sharp increase between 20 and 30 dB, partially explaining the increase in the THD. . . . . . . . . . . . . . . . . . . . . . . . 102
4.19.2 f1 = 900 MHz. . . . . . . . . . . . . . . . . . . . . . . . . . . 102 4.20 The output power on the carrier frequency and the total output power
versus the DAC value for UHDG = 15 and UHDG = 20 dB at f1 = 900 MHz. The square law from Equation 4.6 is closely followed for a UHDG of 15 dB, however it breaks down for a gain of 20 dB and for DAC ≥ 0.7. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
4.21 A simpliﬁed sinusoidal MIMO ﬂow graph . . . . . . . . . . . . . . . . 103

List of Figures

27

4.22 The measured frequency bandwidth of the MIMO B210 USRP board for diﬀerent UHDG values . . . . . . . . . . . . . . . . . . . . . . . . 104
4.23 Output power results measured over SBX and RFX 2400 daughter boards within the GNU Radio USRP SDR . . . . . . . . . . . . . . . 106 4.23.1 Relative average of output power measured with RFX daughter board. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106 4.23.2 Relative average of output power obtained with SBX daughter boards. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
4.24 Average output power versus carrier frequency for UHDG gains of 0, 10, 20 dB for the four measured SBX boards. . . . . . . . . . . . . . 107
4.25 The average output (in mW) for the four measured SBX boards and the average output power (thick line) versus the empirical model given by Equation (4.10). . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
4.26 The average output (in mW) for the four measured SBX boards versus the empirical model Equation (4.11) (converted to mW). . . . . . . . 109
4.27 The average output power (in dB) versus the empirical model from Equation (4.11) for UHDG = 0 (lower curve), UHDG = 10 (moddle curve) and UHDG = 20 (upper curve). . . . . . . . . . . . . . . . . . 110
5.1 IEEE 802.15.4 packet structure and size . . . . . . . . . . . . . . . . 119 5.2 Channel allocation in 868/915 MHz and 2450 MHz . . . . . . . . . . 119 5.3 Transmitter (Tx) ﬂow graph for 2450 PHY layer . . . . . . . . . . . . 122 5.4 Receiver (Rx) ﬂow graph for 2450 PHY layer . . . . . . . . . . . . . . 123 5.5 Transmitter (Tx) ﬂow graph for 868/915 PHY layer . . . . . . . . . . 128 5.6 Receiver (Rx) ﬂow graph for 868/915 PHY layer . . . . . . . . . . . . 129 5.7 The PSR and received packet rates versus pocket size using SDR
implementation for 2450 MHz . . . . . . . . . . . . . . . . . . . . . . 132 5.8 TelosB and Raven sticks . . . . . . . . . . . . . . . . . . . . . . . . . 133
5.9.1 Power spectrum of our software transceiver recorded with the USRP and drawn by FFT gnuradio plot. . . . . . . . . . . . 134
5.9.2 Receiver symbol constellations. . . . . . . . . . . . . . . . . . 134 5.9 The BER versus received SNR for central frequency 868.3 MHz and
for the MFB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135 5.10 The PER versus SNR using two central frequencies 916 MHz and 868
MHz . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
6.1 Overlapping of IEEE 802.15.4 channels with that of IEEE 802.11b/g in 2450 MHz band . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
6.2 Basic cognitive cycle [15] . . . . . . . . . . . . . . . . . . . . . . . . 141 6.3 Software chain of SU receiver (Rx) . . . . . . . . . . . . . . . . . . . 145 6.4 Software chain of SU transmitter (Tx) . . . . . . . . . . . . . . . . . 145 6.5 Flow graph of PU transmitter (Tx) . . . . . . . . . . . . . . . . . . . 145 6.6 Flow graph of our energy detector based spectrum sensing . . . . . . 146

28

List of Figures

6.7 Spectrum Sensing of frequency band 2.4 GHz to 2.5 GHz . . . . . . . 149 6.8 Spectrum Sensing of frequency band 850 MHz to 950 MHz . . . . . . 150 6.9 Packet Success Rate (PSR) and Packet Received Rate (PRR) function
of spectrum distance between PU and SU without Dynamic Spectrum Access (DSA). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151 6.10 Packet Success Rate (PSR) and Packet Received Rate (PRR) function of spectrum distance between PU and SU with DSA. . . . . . . . . . 152

List of Tables
2.1 SDR classiﬁcation refereed to a programming model . . . . . . . . . . 59 2.2 Synthesised classiﬁcation of SDR hardware given in [56] based on the
DSP architecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60 2.3 Non-exhaustive list of Software Deﬁned Radio (SDR) platforms . . . 63
3.1 USRPs and their performances [37] . . . . . . . . . . . . . . . . . . . 74 3.2 Some daughter boards and their performances [37] . . . . . . . . . . . 76
4.1 Output Power at high frequencies and high UHDG values . . . . . . . 101
5.1 Synthesized speciﬁcations of IEEE 802.15.4 [19], [20] . . . . . . . . . 115 5.2 Symbol-to-chip mapping for the 2.4 GHz band . . . . . . . . . . . . . 120 5.3 Symbol-to-chip mapping for the 868/915 MHz band . . . . . . . . . . 121 5.4 Parameters of packet transmissions between two SDRs . . . . . . . . 131
6.1 Parameters of energy detector . . . . . . . . . . . . . . . . . . . . . . 149

Chapter 1
Introduction
The fundamental problem of communication is that of reproducing at one point, either exactly or approximately, a message selected at another point.
Claude Shannon
Contents
1 Historical Elements and Context . . . . . . . . . . . . . . . . 32 2 Deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
2.1 Software Radio and Software Deﬁned Radio . . . . . . . . . . 35 2.2 Cognitive Radio . . . . . . . . . . . . . . . . . . . . . . . . . 35 2.3 Wireless Sensor Networks . . . . . . . . . . . . . . . . . . . . 37 3 Thesis motivations . . . . . . . . . . . . . . . . . . . . . . . . . 38 3.1 Context of WSNs . . . . . . . . . . . . . . . . . . . . . . . . . 38 3.2 Applications of WSNs and SDRs . . . . . . . . . . . . . . . . 40 4 Thesis objectives . . . . . . . . . . . . . . . . . . . . . . . . . . 41 4.1 SDR platform to implement standardized PHY layer of WSNs 41 4.2 Cognitive Radio for Spectrum Scarcity . . . . . . . . . . . . . 42 5 Thesis Organization and Contributions . . . . . . . . . . . . 43 5.1 State of the art on Software Deﬁned Radio . . . . . . . . . . 43 5.2 Analysis of GNU Radio and experimental measurements on
USRP’s Daughter boards . . . . . . . . . . . . . . . . . . . . 44 5.3 SDR implementations of IEEE 802.15.4 standard . . . . . . . 45 5.4 Cognitive Wireless Sensor Network based on IEEE 802.15.4 . 45

Chapter 1. Introduction





    



  
  


 


  
 

Figure 1.1: The opportunity to replace Wireless communications devices by Software Deﬁned Radio
1 Historical Elements and Context
The birth of wireless technology is traced back to an equation published by James Maxwell around 1865 [7], which caused Heinrich Hertz to prove the existence of electromagnetic waves. Around the beginning of the 20th century, Marconi established the ﬁrst long-distance communication via a radio telegraph. During the following ﬁve decades, analog radio communication was brought to perfection with diﬀerent analog modulations. Shannon and Nyquist launched a big change in radio development since they publish the Nyquist-Shannon sampling theorem [8]. This theorem states that a perfect signal reconstruction is possible when the sampling rate (or sampling frequency) is at least twice the signal bandwidth being sampled. The digital signal processing used in data transmission is a result of transistors and integrated circuits on chip computing. It ensures a radio link or wireless connections between electronic devices. Commonly, the radio interconnection of these devices (or nodes) are the basis of wireless networks.
The wireless networks support several applications in our modern life, for example at home, oﬃce and car. Each network answers to particular end-user needs, e.g. internet connection, mobile phone communications and home automation, etc. In order to answer to some questions related to networking; standard organizations and groups have been formed such as the Institute of Electrical and Electronics Engineers (IEEE), the Internet Engineering Task Force (IETF) and the International Telecommunication Union (ITU). They impose speciﬁcations in order to ensure the interoperability between developed wireless devices.
32

33
Figure 1.1 shows the growing number of wireless networks and technologies over the last twenty years. The end-user expectations, industrial constraints and market opportunities are the main driving force of this signiﬁcant progress. Diverse applications can be supported, such as voice, video, and data communications. Each one needs an appropriate hardware air-interface supporting speciﬁc radio techniques and protocols. In fact, each application has its packet structures, data types, and signal processing techniques, and each radio has to communicate and decode signals using a dedicated circuitry, e.g. one Smartphone contains 3G, 4G, GSM, Bluetooth and Wiﬁ modules. In addition, hardware manufacturers wish to develop quickly and cheaper new wireless technologies. Moreover, radio modulation techniques are static, since they are implemented in hardware; neither radio designer nor the radio itself can change these techniques without replacing the hardware. The physical layer (PHY layer) of wireless networks uses these hardware radios, and cope with their limitations. Furthermore, with the high number of networks and technologies, the radio-frequency spectrum is scarce and radio communications can interfere and leading to a radio performances degradation. As shown in Figure 1.2, the radio-frequency spectrum in USA is crowded by the large number of wireless technologies and networks.
Wireless Sensor Networks (WSN) is a particular case with high number of applications. It also requires self-awareness of its environment and self-adapting of its radio parameters to improve its performances.
Form the above limitations, a virtual deﬁnition of radio transceivers (transmitter and receiver) could be an suitable solution. The objective is to substitute the signal processing objects and operation with software running on computer machine. However, writing a set of programs for reproduce signal processing is more eﬃcient, since software can be customized more easily than hardware. Thus, the ideal solution for an industrial or a standard organization is to have existing wireless technologies deﬁned in software running a top a common hardware. As shown in Figure 1.1, Software Deﬁned Radio (SDR) can substitute a traditional hardware radio by a software one.
33

Chapter 1. Introduction

  #$ 


     
Figure 1.2: The crowded frequency spectrum from 300 MHz to 3 GHz in USA [9]

&
 

' (


 " 
 % 
  
 
 

&
 

' (



  
 
 %




' (
 %




 

  %& 1" ,% % 
' %
 %%




23345%' 6

' 4% 
  *!*

' (
  %  

  % 4  

% !4  

' 4% 4  

' 4% 
   % 4

 *!*

 

'  4

  

 4% 

'    

%  %  

' 4% 
  *!*

'  4   

%  4% 

'    

%  %  

'


 % 
% 
   

' (
 %






 ',

&
 


 % 

&
 

' (


' (


 % 








 


#$

&
  &
 

%' (


%' (


%' (


%' (


%' (


&
 




%' (


&
 

%' (


%' (


&
 




 


 
 
 
 
 


&
 
' 0  
 
%' (


(   
      52  73

(   
  %  %7589

%' (
 #* % #+%!* #* % ##!*


 % 


  ',



(   

 %  %8:;5

&
  &
 
&
  &
 
&
 
&
 
&
  &
  &
 
&
  &
  &
  &
  &
 

' (


(  %

  
  %;795

' (



 


' (




  

' (
 

' (


(

  


%' (
 %' (

 " 
 %' (
 %' (

%' (
  " 
 %' (

%' (
 ' (



      





 




&
 

%' (


' (


%' (


&
 

%' (


' (


&
 

&
 





   


  
 
 " 
 
   
 
 



 !  

 



  




   


  
 


  
 
 






 



  



 !

 

  

 " 
 % 
  
 
 

* !

&
 

' (



  
 

&
 

' (
 %))

&* % 

&
 

' (
 %))

%' (
 %#* % #+%!*%#* % ##!*

%


 %%







 % 

 ',

 %   

%' (

#* % #+%!*
#* % ##!*

%' (

 #+%!*% ##!*

&*  #+

&
 % #+%!*  ##!*
&
 % #+%!*  ##!*

%' (
 %  #+%-% ##!*

%' (
  #+%-% ##!*

&*   

&
 

' (
 %))

' (
 %!$ % #+

' (
 %


 % 


  
 
 




 


  ""


 
 


 

'
 
 




 % 

 " 
 
  
 
 

' (
 %




 





 

'
 
 



 ', 


 % 

 " 
 
  
 
 

' (
 %




 

'.  


 

'
 
 

  


 % 

 " 
 
  
 
 

' (
 %




 

' (
 %


  


 %  
 % 

 ',  ',

' (
 %




 

  %   %

'


 % 


*!*

&
 

'







 % 

'







 % 


 % 

 ',

' (
 %))

'


 % 


*!*

&*

&
 

&
 

' (


 %


 %  ' (


&
 

' (


&
 

' (


&
 

' (
 %




 

&
 

' (


&
  ' (



  
   
    

 %




 



' (
 ' (


&
 

&
 

' (
 %




 

&
 
 !%/%0%! +
' (

 !%/%0%! +


  
   
    

 %




 



 %     *%

' (
 ))

&
 

#$

#$




 


' (


* !




 


' (


' (
 ' (





 


' (
 )) &
 

&
 

(

  







* !

'. 

&*

&*

(

  
%%




&
 

(

  







* !

'. 

&*

&*




% 
 

'"

'"

#$

* !

* !

' (


&
 


 

'
 
 




 % 

' (
 %




 


 

'
 
  ' (
 %







 %   

' (
 )) &
 

' (
 ))

&
 


 

 
 

 

 

 

 
 





 


&
 

  
 
' (
 ))


*   ', !#+
% 
% !   

 %   
* ! '


 




 " 
 
  
 
 


  
 
* !
' 
 
' 
 
 
 
 

 " 
 
  
 
 





  
 
 




 " 


 


  
 
 

34

35
2 Deﬁnitions
Before giving the motivations behind this thesis and its contributions, we introduce the primary involved concepts.
2.1 Software Radio and Software Deﬁned Radio
Software Radio (SR) is a set of technologies for deﬁning radio transceiver parameters and functions in software, including carrier frequency, modulation bandwidth and frequency/space/time/code agility [10] [11] [12]. An ideal SR technology refers to the complete software control of the entire system. The aim of SR is to have an analog conversion only at antennas, ensuring the support for a wide frequency band.
SDR is a realizable implementation of Software Radio, as deﬁned above; it is a reconﬁgurable radio, in which the radio functionalities are deﬁned as much as possible in software. The SDR should provide a radio architecture which allows us changing these functionalities in real-time. The formal deﬁnition of SDR is given by ITU [13] as:
"A radio transmitter and/or receiver employing a technology that allows the RF Radio Frequency (RF) operating parameters including, but not limited to, frequency
range, modulation type, or output power to be set or altered by software."
Mitola [12] argues for the substitution of chains of circuitry signal processing systems by software processing blocks. We give more details about that objective in the next chapter.
2.2 Cognitive Radio
The SDR capabilities provide an opportunity for a system designer to build a new intelligent radio system with diﬀerent functions. The Cognitive Radio (CR) is a conceptual layer over SDR. It is an abstraction layer to program the SDR satisfying application and user requirements. CR intends to describe an intelligent radio that can autonomously make decisions using Radio Frequency environment information. The intelligence of the CR is deﬁned by the level of self-awareness to the environment and user requirements. The Federal Communication Commission (FCC) introduces it as:
"a radio that can change its transmitter parameters based on the environment in which it operates." [14]
In the research community, Haykin [15] deﬁnes CR as a radio capable of being aware of its surroundings, learning, and adaptively change its operating parameters in real-time. According to this deﬁnition, the objective is to provide reliable wireless communications, most of the time, anywhere, and spectrally eﬃcient. The cognitive
35


   





Chapter 1. Introduction

  
   
  
Figure 1.3: Interaction stack of CR, SDR, DSA and SS
entity is a node in a network managed locally or globally depending on the problem deﬁnition. In this thesis, we consider the network as a unique entity.
2.2.1 Spectrum Sensing Spectrum Sensing (SS) is a very important component in order to establish a cognitive radio. It is a mechanism to get awareness about the spectrum usage in a geographical area. The mechanism consists in detecting radio frequency activities in a given spectrum. By default, only licensed users (or Primary Users (PUs)) are speciﬁed to occupy a spectrum. Opportunistic users (or Secondary Users (SUs)) accomplish a spectrum sensing for cognitive radio operations. The conventional spectrum sensing exploits only three dimensions of the spectrum space: frequency, time, and space. Commonly, it is treated as a detection and an estimation of the signal problem.
2.2.2 Dynamic Spectrum Access Dynamic Spectrum Access (DSA) is also an important operation in a cognitive radio. It is the spectrum sharing paradigm that allows SUs to solve the ineﬃciency of spectrum usage. The Dynamic Spectrum Access Networks (DySPAN) [16] standards committee claims that:
"DSA is real time adjustment of spectrum utilization in response to changing circumstance and objectives".
In fact, SUs use the unused frequency spectrum based on returned information of spectrum sensing.
We summarize the interaction of CR with SDR, DSA and SS by a conceptual stack shown in Figure 1.3. The base of Cognitive Radio is Software Deﬁned Radio allowing Dynamic Spectrum Access and Spectrum Sensing operations.
36

37
2.3 Wireless Sensor Networks
A Wireless Sensor Network (WSN) consists of distributed wireless nodes used to measure and communicate physical information [17]. The nodes can measure, process and communicate sensed data to a sink node or a base station through a wireless ad-hoc network1. The sensor nodes communicate their data via radio in a single or multiple hops manner. Generally, they are deployed in a hostile environment and typically for event-driven applications. When an event occurs, the source nodes sense, generate and communicate data packets. WSNs applications are constrained by the characteristics of sensor nodes, which are limited in power processing, memory resources and in their residual energy.
Commonly, every network is deﬁned by its conceptual stack of layers or Open Systems Interconnection (OSI) model. Seven layers features an OSI model: Physical (PHY), Link (with Medium Access Control (MAC) sub-layer), Network, Transport, Session, Presentation and Application [18]. Their main objectives are to ensure the interoperability of diverse networks and the modularity of development. WSN can be featured by mainly four layers, PHY, MAC, Network and Application. Of course, the application layer covers the upper ones of the OSI model. Each layer serves the upper one, by performing techniques and/or protocols, which are commonly standardized by competent organizations. IEEE, ITU, IETF are well-known standard organizations.
2.3.1 IEEE 802.15.4 standard
The suﬃx number of each IEEE standard deﬁnes a working group (or committee) on a particular network, e.g. 802.11 for Wiﬁ and 802.15.1 for Bluetooth networks and 802.15.4 for WSN. IEEE 802.15.4 is a standard speciﬁed for PHY and MAC layers of Low-rate Wireless Personal Area Network (LR-WPAN). The IEEE is an association which approves speciﬁcations of several communication protocols.
The IEEE 802.15.4 standard is designed for data communication devices using low data-rate, low-power, and low-complexity short-range radio frequency (RF) transmissions in a wireless personal area network (WPAN). However, many WSN implement standard speciﬁcations, regarding node’s capabilities. The IEEE 802.15.4 has been enhanced from the ﬁrst version of 2003 [19] to that of 2012 IEEE 802.15.4e [20]. The main contribution of this last version is introducing a channel-hopping mechanism in addition to old speciﬁcations of the standard.
Zigbee is only an example of a suitable product available commercially. Zigbee Alliance organization proposes the two network and application layers, above the IEEE 802.15.4 standard. Obviously, other protocols can be deﬁned for speciﬁc applications, such as IEEE 802.15.5 standard [21], WirelessHART [22], ISA100 [23] and 6LoWPAN [24].
1The nodes of the network forward data dynamically based on the network connectivity
37

Chapter 1. Introduction
3 Thesis motivations
The motivations are primarily related to the WSN and SDR issues. We regroup both issues and motivations from the context of WSNs to the interesting applications of WSNs and SDRs.
3.1 Context of WSNs
Several research works deal with network layer issues for Wireless Sensor Networks. Data routing under energy constraints and node positioning in an indoor environment are two active research problems [25] [26]. Some solutions have been proposed based on PHY layer parameters. For the data routing problem, the objective is to deﬁne for each node an eﬃcient metric. The latter can be based on nodes residual-energy and energy consumed for each communication mode, i.e. transmission, reception and idle mode. In general, the eﬃciency of the data routing is measured through simulators, e.g. NS-2 simulator, OPNET, OMNET, etc. However, the obtained results depend on the ability to manipulate available PHY parameters, in particular the energy model. Numerous energy consumption models have been deﬁned, each one, for a speciﬁc simulator [27]. The problem of node localization in an indoor environment has been addressed in some works using Received Signal Strength Indication (RSSI) parameter [26]. The latter can be calculated by each sensor node in a real world network. Each node estimates the distance between its position and those of other neighboring nodes. The nodes calculate this distance when they receive a signal, and after they estimate its output power. Commonly, the obtained positions are with notable variations due to the interference, fading and multi-path in an indoor environment [28]. The eﬀectiveness of the calculated positions is related to the measured output power, which is deﬁned by default in the hardware transceiver of nodes.
These two research problems, i.e. energy-aware data routing and localization in WSN, showed that the PHY layer’s parameters are, at the same time, essential and useful for OSI model’s upper layers. The output power of a transmitted signal is managed by the PHY layer. Since it features the node’s energy consumption, its capture by the network layer helps deﬁning eﬃcient routing metrics. The PHY layer can also exploit information passed by the network layer. If the requested data rate is low, then the PHY layer can choose an adapted digital modulation. To realize this inter layer communication Cross layer concept has been proposed [29]. The idea behind the Cross Layer design is to break down the rigid separation between the OSI’s layers. The drawback of this design is the technology dependency which means that the designed architecture is not portable to multiple technologies. Furthermore, software platforms are needed to test and to implement this architecture.
Diverse software tools have been proposed to establish a model for PHY layer parameters of WSNs. A Simulator is a traditional and simple possibility to design
38

39
and to emulate wireless hardware and transmission environment e.g. MATLAB with Simulink, NS-2, OPNET, and OMNET , etc. Commonly, they are the base of tests and validation of proposed solutions for networking problems. These solutions tested on a simulator, cannot be neither reproduced nor veriﬁed without real-world examples. In addition, several simulators are optimistic when they model network environment, such as the channel model between network’s nodes. In simulation, we assume that the inter-node communications are ensured without possible changes of digital signal processing techniques. From the point of view of problem complexity and interoperability, it is more eﬃcient to isolate problems by layers. But if the solution needs only a little modiﬁcation at another layer, it would be more eﬃcient to facilitate layer interactions. For example, if we deal with the data rate improvement at the network layer, nodes queue management and routing path optimization could be possible solutions. Whereas this problem can be solved only by changing the digital modulation, e.g. data rate can be improved at least 6 times with 64Quadrature Amplitude Modulation (QAM) instead of Binary Phase-Shift Keying (BPSK) modulation. Furthermore, the sponsors of research and development projects often criticize fundamental research, mostly if its proposal is not realistic and without real-world tests [30].
Standards help ensuring product functionality, compatibility and facilitate interoperability. A good example of the power of standardization is the GSM mobile. This technology has been deployed world-wide [31]. As seen in Section 2.3.1, IEEE 802.15.4 is the defacto standard for WSNs. It addresses general requirements of WSNs, such as energy and processing limitation of sensor nodes. However, all node’s manufacturers must follow one standard instead of developing new proprietary techniques. But the applications of WSNs are diverse with speciﬁc requirements. To test a standard adaptation or exploration, the manufacturer requires passing through a manufacturing process. In addition, standards evolve gradually from a ﬁrst version to an improved one. For example, 802.15.4e is a new version of the IEEE 802.15.4 including additional speciﬁcations. Thus, the challenge is to ﬁnd a tool able to explore these speciﬁcations faster and cheaper.
The frequency scarcity mentioned in Section 1 is also a problem for WSNs. Currently, Industrial Scientiﬁc Medical (ISM) available frequency bands for WSN are shared with many other wireless communication standards and technologies, such as IEEE 802.15.1, IEEE 802.11b/g/n and Microwave oven. As we have explained above, standard organizations specify a carrier frequency in those frequency bands. A carrier frequency (or central frequency )deﬁnes a channel of communication between network nodes. The value in Hertz of that frequency is speciﬁed statically even if its selection can be done dynamically. However, these values should be chosen also dynamically to guarantee more robustness to spectrum perturbations. Of course, central frequencies are ﬁxed and integrated in the PHY layer of WSN.
The research community of wireless networks is interested in the SDR opportunity to explore PHY layer parameters in real time. These parameters are implemented
39

Chapter 1. Introduction
in software to oﬀer more ﬂexibility for possible functions tests and experiments. The researcher can adjust, quite easily, some parameters. Thus, these opportunities could be explored throughout new proposals solving some research issues, and complementary knowledge could be acquired in addition to existing experiences. In addition, I think that we have more chances to convince industrial companies to sponsor research projects, when we oﬀer real-world tests rather than simulations. Hence, we can lead our research and prototyping works on well performed and convincing SDR platform for real profs of concepts.
3.2 Applications of WSNs and SDRs
The SDR emergent technology allows researchers and manufacturers to build real time experiments and realistic characterizations. It also tries to meet to requirements raised by researchers, hobbyists, developers and manufacturers. These requirements can be summarized by fast and less costly access to PHY layer techniques and parameters, such as radio modulation and central frequency. In addition, the SDR usage is adapted to a rapid evolution of user applications. Some wireless communication standards are not able to follow permanently commercial needs. For example, users of 3G smart-phones are not able to beneﬁt from a 4G even if mobile operators oﬀer a 4G service. Hence, a standard deﬁned in software is more attractive to upgrade its speciﬁcations than a costly hardware replacement.
Several applications can beneﬁt from SDR. In military, the Joint Tactical Radio Systems (JTRS) project is an SDR based solution for soldier to soldier communications under radio systems heterogeneity. Other conﬁdential projects are based on GNU Radio [32] [32] software despite its open-source aspect. They are funded by Department of Defence (DoD) in USA and Thales in France. However, the SDR’s business market evolves gradually, it will reach 27.3 $ billion by 2020, according to ASDReports [33]. The major actors are the companies of aerospace, defense and transportation manufacturers.
The open-source propriety of some SDR platforms allows the hobbyists and scientists to develop applications under General Public License (GPL). It results in the appearance of diverse projects from simple radio broadcast transceivers to aerospace receivers. For example, we can obtain easily a source code of Radio Data System (RDS) [34] receiver on GNU Radio. Similarly, satellite communications can be performed using International Sun/Earth Explorer 3 (ISEE-3) [35] software. The latter allows the user to control an old NASA (National Aeronautics and Space Administration) satellite. We can also receive the Automatic Dependent Surveillance ADS-B signal for airplanes localization [36].
SDR addresses multi-standard challenges of mobile phone applications. An increasing number of cellular, broadcast and multimedia standards push manufacturers, such as Intel, to propose new mobile SDR-based devices. The objective is to quickly adapt mobile devices to the rapid growth of mobile system technologies, e.g. 2G,
40

41
3G, 4G and 5G. WSNs are playing a key role in several scenarios such as healthcare, agriculture,
environment monitoring, and smart metering. Some manufacturer companies try to replace wired sensors by wireless ones to reduce the weight of machines, e.g. planes, trains. Thus, the energy consumption and the cost of such machines are reduced. We can also quote smart buildings, cities, transports, etc. where each application needs a WSN. A new paradigm called “Internet of Things” (IoT) [24] integrates WSNs as a key element where nodes join the Internet network dynamically, and use it to collaborate and accomplish speciﬁc tasks. For example, 6LoWPAN/IPv6 technology [24] has been developed to integrate IP-based sensor networks.
4 Thesis objectives
We can summarize the objectives of the thesis as follows: We specify an SDR platform adapted to WSNs and we address the problem of spectrum scarcity via a cognitive radio.
4.1 SDR platform to implement standardized PHY layer of WSNs
Some PHY layer’s parameters of wireless networks are easily accessible through SDR, such as output power, modulation, frequency spectrum. To realize software transmitter/receiver chains for a given wireless technology, we need a software and hardware SDR platform. Numerous SDR platforms have been proposed for general and particular applications. It is useful to classify these platforms by analyzing their properties and performances. The goal of study existing architectures is to ﬁnd one, adapted to implement the PHY layer of IEEE 802.15.4. A comparative study throughout numerous platforms and architectures is necessarily to select this adapted SDR platform.
Existing SDR platforms based on General Purpose Processor (GPP) or a combination of GPP and Digital Signal Processor (DSP), are relatively inexpensive. Since the programming can be written in high level languages (C, C++, python), several open source projects have been developed. GNU Radio software with Universal Software Radio Peripheral (USRP) [37] SDR platform has been considered by the researcher community as a suitable solution for rapid development and prototyping. Its main advantage is that it is open-source. An open-source software often suﬀers from a lack of rigor in source program writing and organization. Thus, the analysis of software and hardware architecture is needed to provide more information about the manner to prototype an SDR transmitter/receiver.
USRP is also an open-source hardware proposed by Ettus Research [37]. It is the front end of the GNU Radio USRP based SDR. Its main parameters interacting with
41

Chapter 1. Introduction
GNU Radio software are frequency and output power. The unknown performances of this hardware, requires a deep analysis which can be done through an experimental approach. The objective is to see if the announced performances of some parameters, i.e. frequency bandwidth and output power conform to speciﬁcations [37]. The characterization of the hardware can be obtained with an experimental plan. The research can be carefully carried, and the measurements can be obtained under controlled conditions. In general, the measured parameters can be controlled independently and an empirical model, can be also formulated to predict parameters’ behaviors. Such characterization of the USRP is essential to realize a powerful prototype.
The possibility to customize (with scalability issues) the IEEE 802.15.4 standard motivates its prototyping via an SDR implementation. Furthermore, not all the standard speciﬁcations have been implemented by manufacturers of sensor nodes. However, it is interesting to have these speciﬁcation in software to facilitate their upgrading. In the literature we can ﬁnd some SDR realizations for IEEE 802.15.4 standard on GNU Radio USRP SDR [38] [39] [40] and others on diﬀerent SDR platforms [41]. That of Thomas Schmid [38] has been proposed for 2450 MHz frequency band.
Reverse engineering process or back engineering allows an engineer and a researcher to extract a knowledge or design information from existing prototypes. In our case, the objective is to disassemble an already proposed SDR prototype for 2450 MHz frequency [38]. SDR transmitter and receiver steps should be explained from data generation to baseband signal transmissions and vice versa. Furthermore, our aim is to reuse some source codes and implement a new prototype for 868/915 MHz frequency band of the IEEE 802.15.4 standard. Note that this band oﬀers a wider coverage for network devices compared to the frequency band of 2450 MHz. These two SDR prototypes for two particular bands lead us to think about a Cognitive Radio.
4.2 Cognitive Radio for Spectrum Scarcity
ISM frequency band for WSN based on IEEE 802.15.4 is shared with many other communication standards and technologies, such as IEEE 802.15.1, IEEE 802.11b/g/n and Microwave ovens. The coexistence of these technologies in the same frequency band degrades the transmission performances. The packet collisions at MAC layer and signal interference at physical layer are the main sources of performance degradation. Frequency band overlapping can be avoided by an intelligent use of three types of diversity, namely frequency, space and time. The agile use of frequency spectrum and transmission parameters of sensor nodes can be insured with their software transceivers.
Cognitive Wireless Sensor Network is a new solution. Primarily, it has been proposed as an answer to frequency scarcity issue. The growth of the number of
42

43
applications and the standard rigidity is a fertile ground for this solution. In some geographical areas over the world, for example, in America and Europe, the spectrum frequency is crowded and wireless technologies can share the same frequency band. Traditional radio deﬁnes static carrier frequencies (or channels) for each network or technology. For example, only 16 and 13 channels are respectively available for IEEE 802.15.4 and IEEE 802.11 networks in 2450 MHz frequency band. If these channels interfere, only a static deﬁnition of these channels is possible. By contrast, over a software radio, more ﬂexibility can be ensured, especially by a dynamic change of channels deﬁnition, i.e. a channel can take any central frequency in a frequency band. Such changes can improve at the same time interference avoidance and packet success rate. The communication context needs to be analyzed before a dynamic spectrum access. Spectrum sensing and dynamic spectrum access are possibles operations which can be implemented on SDR platform.
We have seen, in Section 2.2, that the cognitive radio is a high level of abstraction of software radio. It involves two operations: Spectrum Sensing (SS) and Dynamic Spectrum Access (DSA). We have also mentioned that IEEE 802.15.4 deﬁnes numerous speciﬁcations, each one for a particular frequency band. Based on these two operations DSA and SS, we would deﬁne Cognitive Radio for WSNs. We can also deal with that using real world communications, since the cognitive radio has been largely addressed but with theoretical works. Analyzing all the available resources within GNU Radio USRP SDR, we can realize proofs of concept of cognitive WSN on this SDR.
5 Thesis Organization and Contributions
This dissertation is organized in four main parts. Chapter 2 presents the state of the art on Software Deﬁned Radio. Analysis of GNU Radio and experimental measurements on USRP hardware are presented in Chapter 3 and 4. SDR implementations of IEEE 802.15.4 standard are described in Chapter 5. A Cognitive Wireless Sensor Network based IEEE 802.15.4 is detailed in Chapter 6. We conclude the thesis with ﬁnal remarks and suggestions for further works in Chapter 7.
5.1 State of the art on Software Deﬁned Radio
We start by deﬁning, featuring and classifying existing Software Deﬁned Radios. We put the light on the general architecture of an SDR transmitter and receiver as well as its advantages. We can summarize this architecture in three parts: the radio frequency front-end part, the intermediate frequency and the baseband processing part. The two ﬁrst parts cannot be obtained in software regarding some processing constraints, which are explained in Chapter 2. The second part can be featured by a chain of blocks programmed and executed on speciﬁc architecture. After that, we discuss the advantages of an SDR. The reconﬁgurability is its main feature. The
43

Chapter 1. Introduction
software part of an SDR can be easily reconﬁgured autonomously or by a designer. We show also the limits of the SDR performances as well as its constraints. We also notice the large panel of SDR technology platforms. Since we are interested in implementing WSN physical layer on an SDR, we propose to classify the possible SDR platforms into two classes: The GPP based architecture and the reconﬁgurable hardware-based architecture. This classiﬁcation allowed us to present a general one which is based on hardware and programming model of SDRs. We end Chapter 2 by comparing the announced performances for most used SDR platforms. The GNU Radio and USRP SDR promote more ﬂexibility and high level programming languages, as well as a high covered frequency band.A diﬀerence between their announced performances and the observed ones led us to analyze in details the GNU Radio and USRP SDR in Chapter 3 and Chapter 4.
5.2 Analysis of GNU Radio and experimental measurements on USRP’s Daughter boards
We propose to analyze the architecture of the GNU Radio USRP SDR since it is an open-source platform. One drawback of an open-source platform’s is the lack of an accurate and detailed documentation. However, we describe this SDR from bottom to top starting from USRP to GNU Radio. The USRP’s architecture handles two parts: the radio frequency front end and the intermediate frequency. One USRP version can carry up to four daughter boards and several antennas. The daughter boards are the radio frequency interface between antennas and the USRP motherboard. In Chapter 3, we summarize the diﬀerent versions of the USRP and daughter boards as well as their properties. We concentrate our study on those which are used in our thesis. We show that the radio frequency bandwidth, and the output power of the SDR can be aﬀected by the daughter boards behavior. Furthermore, we detail how the USRP’s motherboard interacts with GNU Radio throughout a particular Universal Hardware Driver (UHD).
GNU Radio software provides signal and data processing blocks, which construct the transmitter and receiver chains or ﬂow graphs. It is based on the Mitola’s [10] thought as brieﬂy deﬁned in Section 2.1. Its usage in our research works is also motivated in the previous sections. We characterize the software architecture describing the stack of programming languages. Python simplicity helps the radio designer to construct communication chains, which are called ﬂow graphs. The C++ language supported by GPP architecture permits to develop fast processing blocks. We summarize the C++ source code object oriented architecture by presenting its main classes to generate ﬂow graphs. In addition, we approve the result obtained by Chiang et .al [42] towards the two types of schedulers: single thread and Thread Per block Scheduler (TPS). The debugging of the ﬂow graphs’ programs can be performed easily knowing the scheduler approach. We also report an abstract of the last modiﬁcations to improve the processing time of blocks using SIMD architecture
44

45
(or VOLK). Before summarizing the advantages of GNU Radio and USRP SDR, we discuss the trade-oﬀs between its performances and its features. In fact, we precise the sources of processing latency between hardware and software. The processing time within each block of a given ﬂow graph can be estimated using Performance counters and ControlPort tools, which are proposed in [43]. We explain their operating principle regarding their importance for program debugging, processing synchronization and processing optimization, .e.g we need to know which block spends more time than others.
In Chapter 4, we measure, throughout experiments, two main parameters: the frequency bandwidth and the output power of some USRP’s daughter boards. We select the RFX2400, RFX900, SBX and the MIMO B210 board. We motivate the experimental approach by performing loop-back GNU Radio simulations. We discuss the estimated quality of BPSK communication using a traditional BER/SNR parameter. Although the communication is in the GNU Radio loop-back, we show that the BER/SNR deviates slightly from expected theoretical results. We also show a similar behavior using a USRP and an RFX 2400 daughter board. We prove that this behavior is partly due to daughter boards’ output power and frequency bandwidth. We feature this insuﬃciency throughout curves for each selected daughter board. We choose SBX daughter board’s measurements for a deep analysis regarding its large frequency bandwidth. We construct an empirical model drown upon the obtained results,. This model is simple and can be implemented to calibrate and predict the output power at each central frequency under the covered bandwidth.
5.3 SDR implementations of IEEE 802.15.4 standard
This part contains a documented reverse engineering process of existing SDR transmitter/receiver, and it reports a new one. Both are based on IEEE 802.15.4 standard speciﬁcations. Existing one reproduces the speciﬁcations of the worldwide ISM frequency band of 2450 MHz. We bring more details about transmitter and receiver ﬂow graphs compared to that available in the literature [38]. Furthermore, we formulate the packet decoding operation in pseudo code algorithms. Then we propose a new implementation of the IEEE 802.15.4 for a frequency band of 868/915 MHz. In addition to the ﬂow graphs, we bring more details about the setup of USRP parameters. We achieve real-world communications between true hardware transceivers of WSNs and SDR implementations. The particularity of our work is the ability to measure two diﬀerent parameters in PHY and network layers.
5.4 Cognitive Wireless Sensor Network based on IEEE 802.15.4
In chapter 6, we realize a ﬁrst step toward a cognitive wireless sensor network. We propose a Dynamic Spectrum Access drawn upon the two implemented SDR for the
45

Chapter 1. Introduction frequency bands of 868/915 MHz and 2450 MHz of IEEE 802.15.4. For that, we use a Spectrum Sensing technique to quantify the quality of a central frequency under disturbed transmissions. We propose a message exchange algorithm to synchronize transmitter and receiver in the same central frequency. Then, we detail the SDR settings for each node. We show the interest of using DSA through experiments in an indoor environment. Under a list of setup parameters, the DSA improves by 80 % the packet success rate in a one to one communication.
46

Chapter 2
State of the art on Software Deﬁned Radio-SDR
Is it possible to replace all processing devices by software?
Me
Contents
1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48 2 Typical architecture of an SDR . . . . . . . . . . . . . . . . . 48
2.1 SDR Receiver (Receiver (Rx)) . . . . . . . . . . . . . . . . . 49 2.2 SDR Transmitter (Tx) . . . . . . . . . . . . . . . . . . . . . . 50 3 Features and Challenges of SDR . . . . . . . . . . . . . . . . 50 3.1 Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50 3.2 Challenges . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51 4 SDR standards and architectures . . . . . . . . . . . . . . . . 53 4.1 Software Communication Architecture SCA . . . . . . . . . . 53 4.2 Reconﬁgurable Radio System RRS . . . . . . . . . . . . . . . 54 5 SDR for Embedded Devices . . . . . . . . . . . . . . . . . . . 56 5.1 GPP based architecture . . . . . . . . . . . . . . . . . . . . . 56 5.2 Reconﬁgurable hardware based architecture . . . . . . . . . . 56 6 SDR classiﬁcations . . . . . . . . . . . . . . . . . . . . . . . . . 57 6.1 Programming model . . . . . . . . . . . . . . . . . . . . . . . 57 6.2 Used hardware . . . . . . . . . . . . . . . . . . . . . . . . . . 59 6.3 SDR platforms . . . . . . . . . . . . . . . . . . . . . . . . . . 61 7 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64

Chapter 2. State of the art on Software Deﬁned Radio-SDR
1 Introduction
This chapter introduces a feasible design of SDR based on Transmitter (Tx) and Rx chains. It shows detailed architectural diagrams for both radio transmission and reception. It highlights the limits of software deﬁnition of hardware radio. However, the SDRs present several advantages for industrial users and researchers in wireless communications. Indeed, a lot of hardware/software platforms and architecture have been developed. And some standards have also been proposed to harmonize existing SDRs. These SDRs must be compared and classiﬁed considering their architectures, properties and performances. This comparative study facilitates the selection of a suitable SDR platform. The time and cost to build software transmitter and receiver are the main parameters to select an SDR platform.
2 Typical architecture of an SDR
Mitola describes an ideal Software Radio in his paper [10]. He recommends that, a Digital to Analog Converter (DAC) and an Analog to Digital Converter (ADC) are respectively at the closest proximity to antennas of transmitter and receiver chains. Mitola assumes that the communication chain is achieved by a set of software blocks which perform signal or data processing functions, such as signal generation and modulation/demodulation functions (see Figure 2.1).
Figure 2.2 highlights a classical SDR architecture [10]. The ﬁrst part is Radio Frequency (RF) Front End (FE). It receives or transmits a baseband signal through an input and output antenna. An Intermediate Frequency (IF) part is introduced since the processing capabilities of an ADC are slower than the Software Deﬁned Radio (SDR) function expectations. This leads to the impossibility for ADCs and DACs to cope up with high-frequency signals. The ADC requires a high-sampling rate, high-power consumption, and a reduced frequency bandwidth [44]. Thus, an intermediate Frequency (IF) part is used to ensure a pragmatic Software Radio or Software Deﬁned Radio. The IF section selects a bandwidth and shifts it from RF to an Intermediate section. It is considered as a brake of the SDR domain, as it is limited in sampling rate and a frequency bandwidth. In addition, it accomplishes a channelization, i.e. choose a speciﬁc central frequency, which cannot be performed at a Radio Frequency (RF) Front End (FE). In the last section, the baseband processing replaces analog functionalities by digital ones. Programmable-processing technologies perform this function using, for example, Field Programmable Gate Array (FPGA), Digital Signal Processor (DSP), General Purpose Processor (GPP), Programmable System-on-Chip (SoC) and other application speciﬁc-processing entities e.g. Application Speciﬁc Integrated Circuit (ASIC). The following section allows us to understand the several steps of Tx/Rx chains.
48

49


          
     
  

Figure 2.1: Ideal architecture of a Software Radio





  


   

 

    

Figure 2.2: General architecture of SDR

2.1 SDR Receiver (Rx)
Figure 2.3 shows a general SDR Rx, starting with a RF tuner which converts analog RF signal to analog IF frequency. Then, the ADC digitizes the IF thereby converting it into digital samples. These samples enter to a Digital Down Conversion (DDC) which could be a monolithic single chip or an FPGA. A DDC decimates a data stream to a lower sampling rate and adapts a stream to a lower speed processor. It contains a digital mixer, a digital local oscillator, and a Finite Input Response (FIR) lowpass ﬁlter. The digital mixer and the local oscillator translate IF samples down to a baseband signal. The primary function of FIR low-pass ﬁlter is to limit the signal bandwidth. The DSP performs a demodulation, decoding, and other processing tasks via software radio programs [45].

 !


   


 

  !

  "#!

  
  
 



 







$!%&

"#!

Figure 2.3: SDR receiver block diagram

49

Chapter 2. State of the art on Software Deﬁned Radio-SDR


  !"  
 


   
 


   



   




   

  



  # $ 






   


Figure 2.4: SDR transmitter block diagram

2.2 SDR Transmitter (Tx)
Similarly to Rx, Figure 2.4 shows SDR Tx chain. Tx ﬁrstly generates a digital baseband signal of a transmission chain. Digital Up Converter (DUC) interpolates a baseband signal and up-converts it to an intermediate frequency band. Then DAC converts a digital IF samples into an IF analog signal. The RF Upconverter that follows, converts an IF analog signal to RF frequencies. Finally, a power ampliﬁer boosts the signal energy into the antenna [45].

3 Features and Challenges of SDR
The wireless transmission has multiple requirements and properties depending on user expectations and hardware performances. Some advantages are reported in the ﬁrst chapter and in Section 2. In this section, we report features and challenges of SDR based transmissions.
3.1 Features
The features of a software deﬁned radio are for diﬀerent types of application as follows:
• Reconﬁgurability,
• Portability,
• Interoperability,
3.1.1 Reconﬁgurability The behavior of traditional radio transceivers is static and deﬁned by a manufacturer. It cannot be changed by the transceivers’ designer or by itself. Thus, devices (or nodes) of wireless networks handle only speciﬁc applications. A reconﬁgurable system has the ability to dynamically change the transceiver behavior. Since all blocks of communication chains are in software, a simple modiﬁcation is possible during, before
50

51
or after a transmission. For an SDR designer, modifying these chains should be performed transparently. However, wireless communication standards implemented in SDR can be maintained only by changing software. For an SDR itself, a dynamic auto conﬁguration is interesting, since it brings cognitive radio capabilities [44].
3.1.2 Portability
The portability refers to the waveform mobility. From end user point of view, it is the ability to implement and migrate waveform processing from one SDR platform to another. From end-user view, migration should be carried out with a maximum of transparency. This means that waveform processing should be possible on another platform without rewriting the whole application. However, some speciﬁc architecture of SDR deﬁnes its components as software programming objects. In this case, a waveform can be handled by one of these objects. For example, Software Communication Architecture (SCA) details an object oriented architecture which is based on a transport mechanism of waveform components mapped on DSPs and FPGAs [46] (see Section 4). Nevertheless, portability requires a correct migration from and to a new platform without information losses. In addition, hardware performances should be the same when changing the hardware platform or the programming language.
3.1.3 Interoperability
The interoperability or radio bridging enables heterogeneous radio networks to inter operate by dissimulating their diﬀerences. The challenge is to have a multi-standard, multiband and an open radio system. Traditionally, a radio transceiver is limited to communications only with nodes that share the same radio properties. The latter could be waveform, frequency band, modulation type and data communication protocol. However, a radio bridge acts as a translator between heterogeneous transceivers. It receives a signal encoded in one format and retransmits it following another speciﬁcation. Primarily, the interoperability is addressed in military applications [47].
3.2 Challenges
In section 2, we saw that the main SDR challenge is to overcome the limited processing power. Consequently, Intermediate Frequency part (see Section 2) is unavoidable to get an SDR processing look like Software Radio. In this section, other challenges of SDR solution are addressed.
3.2.1 Handling of an SDR platform
Numerous SDR platforms have been developed in the last decade with diﬀerent integration levels of hardware and software architecture. For software-designer,
51

Chapter 2. State of the art on Software Deﬁned Radio-SDR
high-level programming could be an easy way to handle software, but at the expense of a high hardware physical dimensions. Furthermore, the type of the architecture, i.e. distributed or centralized, is an important element to understand how to use diﬀerent components. A centralized architecture could be easier to manage than a distributed one. For example, the SCA [46] is distributed and interoperability is guaranteed via Common Object Request Broker Architecture (CORBA) middleware. Understanding software architecture and programming with CORBA require more eﬀorts than programming on a host computer. In CORBA, the software/hardware object locations of architecture are hidden to designers. Whereas, programming on host computer is more simple, since all objects are present in the same physical place. GNU Radio and Universal Software Radio Peripheral (USRP) [37] follow a centralized architecture with a host computer programming. On GNU Radio software, mastering high-level programming languages is required to construct software communication chains. In fact, source codes are written in C++ and Python and most of the time not commented (lack of comments) making them hard to understand. In addition, these codes are commonly generated by a machine. RF performances of USRP hardware, which is connected to GNU Radio are not documented. Thus, implementations on USRP and GNU Radio can be time consuming. In spite of these drawbacks, this platform presents several advantages which will be discussed in the next Chapter.
3.2.2 Hardware physical dimensions
Physical dimensions issue comes from the need to integrate SDRs in constrained applications, such as WSNs applications. It aﬀects SDR capabilities, especially, power processing and energy autonomy. Commonly, it depends on the hardware front-end size and on the baseband processing software. Signal processing is a greedy operation, and it is performed at various stages of the transmitting and receiving chains. Thus, the capabilities of baseband processing part can be considered as a reference to deﬁne hardware dimensions and programming languages of an SDR platform. In the case of a GPP conﬁguration, a high-level programming language on a host computer is preferred by designers. Thus, the platform is cumbersome and less usable for Wireless Sensor Networks (WSNs). In the case of an interoperable architecture like SCA [46], a middleware manages several technologies, e.g. FPGA, DSP, and GPP, etc. Actually, SDR nodes for WSNs is a futuristic technology, regarding constraints of one SDR.
3.2.3 Radio frequency performances
We have shown in Section 2 the general architecture of an SDR, IF is the bottleneck of an ideal SDR. In fact, SDR performances depend on hardware’s computational resources and front end design. Dedicated purpose and non programmable chips oﬀer high-performances, but they are avoided, since they are limited in terms of
52

53
ﬂexibility. However, an IF or a baseband ﬁlter sets the analog bandwidth from a minimum to a maximum frequency. Furthermore, ADCs and DACs deﬁne SDR’s sampling rate or a processing bandwidth.
3.2.4 Baseband processing hardware
Several hardware components of baseband processing could match with SDR requirements. ASIC is not a reconﬁgurable processing component, but it is useful when eﬃcient processing is preferred [44]. However, an FPGA is an alternative to an ASIC. It rapidly reconﬁgures any waveform component through a speciﬁc program. Hence, it is a preferred choice for an environment with real time constraints, particularly when an application needs some permanent connectivity. Furthermore, an FPGA requires signiﬁcant energy and produces unpleasant heat for a handheld SDR.
A host computer simpliﬁes the reconﬁguration of baseband signal processing. It runs SDR’s source codes over GPPs. The Operating System (OS) of host computers creates an abstraction layer over a GPP by running diﬀerent applications. In fact, the OS handles software programs with little or no knowledge of underlying hardware management [48]. The memory manager of such architecture also combines numerous programs without a special care on Random-Access Memory (RAM) of software development.
DSPs are similar to GPPs, since they can be programmed with a high-level language such as C or C++ for processing and running under an Operating System (OS). However, the diﬀerence comes from instructions set and on memory management. The instructions of a DSP are dedicated to a particular application.
4 SDR standards and architectures
In this chapter, we quote a list of existing Software Deﬁned Radios. This list is organized in standards and architectures. Furthermore, they are classiﬁed, regarding main parameters, i.e. baseband programming languages and front-end hardware.
4.1 Software Communication Architecture SCA
Software Communication Architecture (SCA) is an open and common architecture allowing a designer to deﬁne hardware and software elements running on Joint Tactical Radio Systems (JTRS) SDR [46]. Software radio programs are deﬁned to process waveforms in diﬀerent layers while CORBA ensures interactions among them [48]. For an embedded application, CORBA is greedy in processing power and in memory resources. Hence, the focus of embedded SDR community shifted away from CORBA. Architecture improvements have been made by SDR forums and by the Object Management Group (OMG). The objective was to simplify the architecture
53

Chapter 2. State of the art on Software Deﬁned Radio-SDR
Figure 2.5: Version 4 of the SCA architecture [49]
and to separate the SCA and waveform components from the operating environment (see Figure 2.5).
The latest speciﬁcations of the SCA in versions 2, 3 and 4 discuss the use of an FPGA [49]. As explained in Section 3.2.4, an FPGA is more reconﬁgurable and has a higher processing power than a DSP or an ASIC. The FPGA can accomplish digital processing of the IF and that of the baseband processing part of an SDR. It can also performs speciﬁc processing such as cryptography algorithms. Figure 2.5 shows the main parts of the SCA architecture: Operating environment, SCA Core Framework and Waveform. The SDR’s core framework handles all underling software responsible for running waveform processing.
4.1.1 Open Source SCA Implementation::Embedded (OSSIE) OSSIE is an open-source SDR and Object Oriented SCA architecture [50]. It is implemented over a CORBA middleware working on a Linux operating system and carried out by Intel or Advanced Micro Devices (AMD) based computer. The core framework of OSSIE contains signal-processing components and software interfaces based on CORBA. The objective behind OSSIE is to reduce the designer’s learning curve of the SCA and the cognitive radio. Furthermore, for a proof of concepts, SDR prototyping can be faster than other software architecture. However, CORBA requires a lot of memory resources, and the objects communicate with fewer throughput. In fact, SCA performances depend on the object size, since several objects have to be exchanged within the SCA [44].
4.2 Reconﬁgurable Radio System RRS
European Telecommunication Standards Institute (ETSI) introduces a Reconﬁgurable Radio System (RRS) for mobile phone networks [51]. This architecture is more specialized than the SCA architecture. It speciﬁes the required
54

55
Figure 2.6: ETSI architecture [51]
radio resources and interfaces. Figure 2.6 shows interactions between diﬀerent abstract managers of the architecture. The conﬁguration manager installs radio implementation in radio computers and updates radio parameters. The Radio Connection Manager interacts with designer or inter-implementation requests to activate radio implementations or to switch among them. The multi-radio controller anticipates interoperability problems by scheduling simultaneous spectrum requests. Finally, the resources manager controls the allocation of radio hardware resources, such as spectrum or hardware devices, according to the application importance.
RRS test bed is the only SDR platform found in the literature following the ETSI speciﬁcations. It is a modiﬁed USRP and GNU Radio based SDR, dedicated to security research for military applications. Next chapter gives more details about the USRP and GNU radio platform.
55

Chapter 2. State of the art on Software Deﬁned Radio-SDR
5 SDR for Embedded Devices
In the literature, there is neither a general architecture nor a standard proposed for embedded devices or wireless sensor nodes. The design of a such SDR is constrained by the application type and hardware capabilities. From our state of the art we can notice two main architectures:
• GPP based architecture
• Reconﬁgurable hardware based architecture
5.1 GPP based architecture
The GPP base architecture is the case of platforms such as GNU Radio/USRP [37] [37] and Sora platforms [52]. The GPP receives/generates baseband signal replacing a DSP in Tx and Rx SDR architectures shown in Figures 2.3 and Figure 2.4. The SDR implementations, prototypes or realization are designed at a GPP using high-level programming languages. Commonly, the research community simply considers these prototypes as SDRs, software transmitters/receivers or software transceivers.
The SDRs based on host computers are more accessible than other possible SDR architectures. The developing and debugging become easier, especially with the collaboration of a high number of users. Furthermore, the GPP power processing can be signiﬁcantly increased by integrating a multicore in a monolithic processor. These cores can coherently handle a distribution of waveform processing blocks [52]. Thus, prototyping of OSI’s physical layer is simpliﬁed and eﬃcient using GPPs.
Multi core GPP based SDR architecture is less deterministic than those combined with an FPGA or a DSP. Moreover, without a speciﬁc processing device, reliability decreases. The FPGA oﬀers a good ratio between real time processing and reconﬁgurability. It can thus be used to accomplish high-power processing. What’s more, the GPP handles software frameworks for waveform processing. An example of such architecture is that of USRP and GNU Radio SDR.
A DSP can replace an FPGA if the GPP coordinates the assigned signal processing operations among programmable DSPs. However, for an SDR designer, the advantage is to have a possibility to build separately DSP programs and execute them on Multi Processors System on Chips (MPSoC). Table 2.1 presents some DSP based SDRs [53]
5.2 Reconﬁgurable hardware based architecture
In order to beneﬁt from the ﬂexibility and the high performances of dedicated hardware, the entire radio communication stacks can be implemented on an FPGA. Hardware synthesizer tools should be used, for example Register Transfer Level (RTL) [54]. These tools allow a designer to implement a hardware conception, but
56

57
with an extra time needed to handle the associated programming languages, e.g. Very high speed integrated circuit Hardware Description Language (VHDL).
An SDR can be implemented via an Intellectual Propriety (IP) core, which is data or logic blocks. Ideally, an IP core should be entirely portable and easily inserted into marketed technologies. However, IPs are expensive and consume a lot of logic resources as well as require powerful hardware [45]. Furthermore, coarsegrained reconﬁgurable architecture consists of a large number of function units interconnected through an embedded network. Comparing this architecture to an FPGA, the advantage is low in terms of power consumption and time needed to set up the platform. Therefore, the gate-level reconﬁgurability is limited, but with a large increase in hardware eﬃciency [55].
6 SDR classiﬁcations
In the literature, several classiﬁcations can be found in [56] and [57]. SDRs have been classiﬁed by considering hardware architecture and programming model. Our objective is to synthetize these classiﬁcations throughout comparative tables. Table 2.1 synthesizes Dardaillon et .al work [57]. It contains a classiﬁed SDRs function of a programming model.
6.1 Programming model
From the programmer’s point of view, the architecture has a crucial impact on programming models and tools. Six classes are proposed in [57]:
• GPP General Purpose Processor approach
• Coprocessor
• Processor centric approach
• Conﬁgurable units approach
• Programmable blocks approach
• Distributed approach
The SDR based GPPclass uses a computer processor as a computing platform, with programming at a high-level for more ﬂexibility. However, high-energy consumption is proportional to a high demand of hardware resources. Thus, the GPP approach is improved by integrating a coprocessor to perform heavy processing and to reduce energy consumption. In this case, a GPP is associated to an FPGA (or DSP), chip rate accelerators or coarse-grained cores. The processor’s centric approach increases the SDR eﬃciency. For example, a dedicated processor like an Acron RISC
57

Chapter 2. State of the art on Software Deﬁned Radio-SDR
Machine (ARM) can be used for the signal-processing part. This approach guarantees high programmability but reduces ﬂexibility from its speciﬁc architecture. The conﬁgurable units are proposed to oﬀer lower energy consumption by substituting DSPs with reconﬁgurable processors. Programmable blocks refer to an FPGA based architecture. They provide programmability with a great ﬂexibility to create tailored architecture. Finally, a distributed approach distinguishes signal-processing cores or a distributed asynchronous array from simple processors.

Classes GPP approach
Coprocessor approach
Processor-centric approach
Conﬁgurable units approach

Name USRP [37]
QuickSilver (QS1R) [58] Microsoft SORA [59] RTL-SDR [60]
SDR4All [61] KUAR Kansas University Agile Radio
Texas Instrument SDR Imec ADRES 2
Hiveﬂex
Infeneon MuSic
Sansblaster
SODA University of Michigan ARDBEG Tomahawk (University of Dresden) Imec BEAR: The evolution of Imec ADRES CEA Magali chip

Programming C++, Python (GNU Radio) SDRMAX pre-build
SORA SDK pre-build
SDR# Pre-built and limited use of GNU Radio C++, Matlab VHDL1 implementation or GNU radio ﬂow CHDL or MATLAB Simulink C on DRESC compiler HiveCC SDK
C and ASM
ANSI C on didecated compiler C programming language C programming language C programming language, MATLAB
C programming language, ASM

Hardware GPP
GPP
GPP
GPP
GPP FPGA
Programmable DSP GPP, ADRES accelerator HiveFlex accelerator ARM processor, DSP ARM processor, Sandblaster cores ARM processor, DSP Tensilica RISC3 processor, DSP ARM processor, ASIP4, veterbi accelerator ARM processor, coarse grain reconﬁgurable cores Merphisto

1VHDL 2Architecture for Dynamically Reconﬁgurable Embedded Systems (ADRES) 3Reduced Instruction Set Computing (RISC) 4Application-Speciﬁc Instruction-set Processor (ASIP)

58

59

Programmable blocks approach

Distributed

ap-

proach

EURECOM ExpressMIMO (reconﬁgurable FPGA ) XiSystem
WARP (Rice University) WINC2R (Rutgers University)
Lytech Picochip
CEA Genepy

C programming language
C programming language VHDL
C++, python (GNU Radio)
Simulink, MATLAB C programming language C programming language, ASM

FPGA

PiCoGA FPGA

Xilinx

Virtex

FPGA

FPGA, Soft Core

Processors and ac-

celerators

FPGA

Matrix of small

cores

Coarse grained

based on Mag-

ali with ARM

processor

Table 2.1: SDR classiﬁcation refereed to a programming model

6.2 Used hardware
As shown in Table 2.2 SDRs can be categorized in three classes [56]:
• Coarse-grained reconﬁgurable
• Processor centred architecture
• Multi core and multi thread architecture
The ﬁrst class is based on reconﬁgurable hardware, whereas the second one consists of DSP-centred and accelerator-assisted architecture. Although an SDR baseband processing can be done by a GPP or an FPGA, the general-purpose DSP appears to be the most used solution for embedded systems. The processor centred architecture is based on an ASIP, a DSP and many-cores SDRs. The DSPs exploit a native date and a parallelism instruction level of radio kernels. In some cases, they are assisted by accelerators, e.g. ASIC in LeoCore SDR [62]. Some SDR platforms are based on splitting a bigger task into smaller ones and distribute them among the cores. Behind the task’s distribution, power consumption is reduced to an acceptable level, e.g. SODA [63]. In Section 5.2, we explained that coarse-grained reconﬁgurable architecture oﬀers more ﬂexibility than processor centric architectures. For example, we can cite ADRES, HERS and CREMA platforms (see table 2.2).

Architecture

Name

Programming
59

Hardware

Chapter 2. State of the art on Software Deﬁned Radio-SDR

Coarse-grained reconﬁgurable
Processor centred architecture
Multi core and multi thread architecture

Montium
BUTTER and CREMA HERS EURECOM ExpressMIMO Imec ADRES
Leocore Sandblaster Connx BBE EVP Embedded Vector Processor SODA Signal processing On demand architecture Tomahawk MPSoc MuSIC
Imec BEAR

Montium Sensation Suite Simulator and Editor. Language used is Montium Conﬁguration Design Language (CDL) VHDL
FireTool for C language extensions C programming language ADRESC compiler with ANSI C Coresoninc developer studio C language
TIE language, C++ language EVP-C compler
C compiler generated by OptimoDE’s Framework, Matlab C model supported C compiler
MuSIC speciﬁc C compiler to support SIMD 5 C extensions Matlab and C programming language

Chameleon SoC

SoftCore, CREMA is
synthesized on FPGA SoftCore

FPGA

ADRES

processor,

ASIP, FlexFec processor

Network on Chip Noc
Multi-Core and MultiThread processor Tensilica Xtensa processor ASIC

Imagine Processors and IBM Cell Processor

Two Tensilica processors, ASIP Two Tensilica processors, ASIP
ARM processor for control and three ASIPs

Table 2.2: Synthesised classiﬁcation of SDR hardware given in [56] based on the DSP architecture

5Single Instruction Multiple Data (SIMD)
60

 


   

61
  Figure 2.7: Hardware tasks associated with process intensity and ﬂexibility
6.3 SDR platforms
SDR platforms are software and hardware toolkits that allow the designer to construct an SDR prototype or implementation. Of course, an implementation can consist of separated transmitter or receiver. It is also possible to gather transmitter and receiver giving an SDR transceiver.
Figure 2.7 shows the main signal processing tasks associated to an SDR implementation. They are on two vertical and horizontal axis. Intensity of processing is associated to the vertical axis and ﬂexibility to the horizontal one. The degree of highly repetitive and rather primitive operations denotes the process intensity. Flexibility refers to the uniqueness/variability of the processing and how likely the function may have to be customized for any speciﬁc application. Figure 2.7 illustrates the degree of ﬂexibility vs the processing intensity. In the upper left of this ﬁgure we ﬁnd hardware structures for real time operations, such as ADC, DAC and DDCs that can be done by ASICs. In the lower right of this Figure, we ﬁnd other tasks, such as analysis and decision tasks that need more ﬂexibility, and can be accomplished by DSPs and GPPs.
We notice the existence of a large panel of SDR technology platforms. More than sixty platforms could be counted over the world in 2014. Table 2.3 summarizes a non exhaustive list of research commercial and open source projects SDR technologies. Numerous SDR platforms are proposed with diﬀerent RF performances, programming languages and hardware architecture. The sampling rate and the covered frequency range are two primary parameters which deﬁne the capabilities of an SDR implementation. Compared to other SDRs, the USRP brings high performances. It
61

Chapter 2. State of the art on Software Deﬁned Radio-SDR is proposed by Ettus Rsearch [37] in diﬀerent versions . Its frequency range grows up to 6 GHz with a DAC and ADC sampling rate up to 400 Mega Samples Per Second (MSPS) and 100 MSPS, respectively. Furthermore, baseband processing is handled via a GPP which executes a software toolkit.
The announced performances of the USRP led to the development of those software toolkit. Particularly, GNU Radio [32] has been developed to drive the USRP despite existing general software, such as Simulink MATLAB and LabView. The GNU Radio is an open-source software used to drive not only the USRP, but also some other SDR hardware (e.g. HackRF [64] and Nutaq ZeptoSDR [65]). However, several communication standards and prototypes have been implemented on GNU Radio and USRP (i.e. IEEE 802.15.4, IEEE 802.11a, IEEE 802.11p, Automatic Dependent Surveillance-Broadcast (ADS-B) and Hight Deﬁnition Television (HDTV) etc). Of course, the SDR based USRP and GNU Radio will be detailed deeply in the next chapter.
62

63 63

Name
USRP family [37]
Microsoft SORA [59] SDR4all [66] UDPSDR-HF1 [67] Realtek RTL2832U DVBT tuner RDP-100 [68]
BladeRF [69]
Bitshark Express RX [70] FlexRadio SDR1000 [71] Matchstiq [72]
NI Flex RIO [73] HackRF [64]

Architecture GPP + FPGA

GPP

GPP + FPGA

FPGA

CMOS6 + GPP and Audio card FPGA + PowerPc

FPGA

+

ARM proces-

sor

FPGA + GPP

DSP
GPP and FPGA
FPGA
GPGA and GPP

Software and Programming GNU Radio
SORA SDK
MATLAB
BeMicro SDR Pre-build, Limited GNU Radio Pre-build
Pre-build
Kit
Pre-build (PowerSDR) Prebuild SDK
NI LabView Matlab GNU Radio

Frequency Sampling rate range

Up to 6 GHz
2.4 GHz-5 GHz 400 MHz 4 GHz 100 KHz 30 MHz 52 MHz2200 MHz

Up to 100 MS/s (Rx) and Up to 400 MS/s (Tx) according to their version 40 MS/s-44MS/s
20 MS/s, 200 MS/s
80 MS/s
2.8 MS/s

RX 0-125 MHz; Tx 0200MHz 300 MHz3.8 GHz

Rx-250 MS/s; TX800 MS/s
40 MS/s

300 MHz - 105 MS/s (Rx only) 4 GHz

12 KHz 60 MHz 300 MHz 3.8 GHz

Not indicated 40 MS/s

200 MHz4.4 GHz 30 MHz - 6 GHz

1.6 GS/s 20 MS/s

connecting mechanism Gigabit Ethernet, USB2, USB3 and PCIe depending on their version PCI USB USB USB
PCI
USB 3.0 SS
PCIe
Parallel port USB
PXI Express x4 USB

OS

Applications

Windows, General Linux and tions Mac

Applica-

Windows General applica-

tions

WINDOWS, General applica-

LINUX

tions

Windows Military and Com-

mercial applications

Windows, Amateur radio

Linux and

Mac

Embedded General applica-

System

tions

Windows, Amateur Radio, ReLinux, Mac search

Windows and Linux
Windows

GSM,

iDEN,

CDMA2K, UMTS,

TD-SCDMA

Amateur radio

Windows, Linux and Mac Windows
Windows, Linux and Mac

General tions
General tions General tions

applica-
applicaapplica-

Table 2.3: Non-exhaustive list of SDR platforms

Chapter 2. State of the art on Software Deﬁned Radio-SDR
7 Summary
Through a theoretical study, diﬀerences between a pure SR and Software Deﬁned Radio have been detailed. A limitation of a pure Software Radio is the intermediate frequency part, since DAC and ADC sample at a low-rate with high-power consumption. The hardware dimensions and radio-frequency performances are also other constraints for SDR implementations. Flexibility is the main opportunity of the SDR. The radio parameters can be changed easily by the radio designer or by the radio itself.
We established a survey of SDR standards, architecture and platforms. We focused on existing SDR architectures proposed for embedded devices. We showed two approaches: reconﬁgurable hardware architecture and GPP based architecture. The latter brings more facility with high level programming languages. Then, we expanded our survey to the classes of SDRs considering their programming model and hardware. We analyzed most important SDR platforms. From the performed study, we have chosen an open source GNU Radio/USRP platform as it provides, open-source high level languages with a well established community.
64

Chapter 3
Analysis of GNU Radio and USRP SDR
Most software today is very much like an Egyptian pyramid with millions of bricks piled on top of each other, with no structural integrity, but just done by brute force and thousands of slaves.
Alan Kay
Contents
1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66 2 GNU Radio . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
2.1 Programming language layers . . . . . . . . . . . . . . . . . . 67 2.2 Software blocks . . . . . . . . . . . . . . . . . . . . . . . . . . 67 2.3 Flow graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 2.4 Software scheduler . . . . . . . . . . . . . . . . . . . . . . . . 70 2.5 SIMD programming (Volk) . . . . . . . . . . . . . . . . . . . 71 3 Universal Software Radio Peripheral . . . . . . . . . . . . . . 72 3.1 USRP Architecture . . . . . . . . . . . . . . . . . . . . . . . . 74 3.2 Transmit and Receive Paths . . . . . . . . . . . . . . . . . . . 74 3.3 RF daughter boards . . . . . . . . . . . . . . . . . . . . . . . 75 3.4 Firmware and FPGA images . . . . . . . . . . . . . . . . . . 75 3.5 Universal Hardware Driver (UHD) . . . . . . . . . . . . . . . 76 4 GNU Radio and USRP properties . . . . . . . . . . . . . . . 76 4.1 Latency and throughput . . . . . . . . . . . . . . . . . . . . . 77 4.2 Buﬀers organization . . . . . . . . . . . . . . . . . . . . . . . 78 4.3 Performance counters and ControlPort . . . . . . . . . . . . . 78 5 Advantages of GNU Radio and USRP . . . . . . . . . . . . . 79

Chapter 3. Analysis of GNU Radio and USRP SDR
6 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
1 Introduction
An SDR platform architecture based on General-Purpose Processor (GPP) or a combination of GPP and DSP is relatively inexpensive. It is advantageous in terms of programming environment and tools. Thus, several open source projects have been developed by the community of researchers, hobbyists and industries. As shown in chapter 2, the GNU Radio and USRP are suitable for rapid implementation of wireless networks’ speciﬁcations. In this chapter, this platform is described from top to down, starting from GNU Radio to Universal Software Radio Peripheral (USRP).
The GNU Radio toolkit can be downloaded via the Internet, and a USRP can be purchased around 800 euros from Ettus Research. However, the biggest diﬃculty in an open-source software is the rigor in program writing throughout upgrading GNU Radio versions, i.e. change name of objects and methods. In most cases, these changes are not commented, and programmers need more time to adjust radio programs from old versions to new ones. In addition, the performances of SDRs might depend on both: Software/Hardware processing units and links, e.g. PCI, USB, Ethernet, etc, between these units. Hence, the analysis is needed to provide programmers with more information about software/hardware organization. Especially, we need to estimate the delay between two processing units. The analysis comes from the state of the art, and from reverse engineering performed through several experiments on the platform.
2 GNU Radio
GNU Radio is an open-source project toolkit for building software radios that run on (General Purpose Processor (GPP)) [74]. The project was founded by Eric Blossom in early 2000, and revived by Thomas Rondeau in 2010. It can be used with readily-available low-cost external RF hardware to create software-deﬁned radios, i.e. USRP, or without hardware in a simulated environment. It is widely used in hobbyist, academic and commercial environments to support both wireless communications research and real-world radio systems. Furthermore, the GNU Radio can be supported by Windows, Linux and Mac OS.
Based on the philosophy of Mitola [10], the toolkit provides signal processing blocks for modulation, demodulation, ﬁltering and various data processing operations. In addition, new blocks can be easily added to the toolkit. Furthermore, a software radio program can be created by connecting these blocks to form ﬂow graphs. Each
66

67
Figure 3.1: Software layers of the GNU Radio
block can be developed in Python or C++ programming languages. In section 2.3, we explain how to use these blocks to form ﬂow graphs (or software radio programs).
2.1 Programming language layers
Figure 3.1 depicts the programming language layers of the GNU Radio. Processing blocks are written in C++ and then connected through a Python script. These C++ blocks are integrated in python script via an interface compiler called a Simpliﬁed Wrapper and Interface Generator (SWIG). To create a ﬂow graph, we can use a graphical user interface called gnuradio-companion or directly via a python code. In this case, an EXtensible Markup Language (XML) code describes C++ blocks to facilitate the visibility of the graph’s blocks. The XML script is interpreted to a python code via the cheetah1 tool. Finally, a Verilog HDL layer can be used to conﬁgure the Field Programmable Gate Array (FPGA) of a USRP board.
Recently, a new layer of QT programming language has been added to these layers. A graphical user interface of some blocks, such as the Fast Fourier Transform (FFT) sink or the IQ (In and Quadrature) constellation, can be imported from QT package [75].
We note that several GNU Radio versions have been published in Git (git) repository of the GNU radio project. In each version, users can add new blocks or update old ones. Usually, the Python and the C++ codes are the most updated source codes, since they are the kernel of the toolkit.
2.2 Software blocks
From the previous sections, we can see that the blocks are the basic data structure of a GNU Radio system. They are connected to construct directional ﬂow graphs. A stream of samples ﬂows through the blocks from a source block to a sink block and vice versa. Generally, C++ is suitable for signal processing functions that need
1http://www.cheetahtemplate.org/
67

Chapter 3. Analysis of GNU Radio and USRP SDR

Figure 3.2: Source, Sink and Intermediate blocks

 

     

    

 


        

      

   

      

    
Figure 3.3: C++ signal processing modules

a short time response. Hence, Input/output streams are processed at high level without loss of stream’s samples. For example, signal modulation and demodulation, equalization and Fourier’s analysis have been implemented in C++. Data processing blocks, such as vector source or message generator, can be written in Python.
The type of data samples is commonly complex ﬂoats or interleaved ﬂoats. A ﬁrst part is treated as real, and a second as imaginary part. In this case, the size of each sample is up to 8 bytes. Other sizes exist in order to represent Float (4 bytes), Short ( 2 bytes integer values) and Char ( 1 byte integer values). At a deﬁnition of a given block, a new type can be created from the predeﬁned blocks. For example, vector types are deﬁned to deal with a ﬁxed number of samples. These types are useful, since they deﬁne one or several input and output ports of a block. As shown in Figure 3.2, source and sink blocks have only one side with ports, the output for sources and the input for sinks.
The design is object oriented based on a hierarchical organization with inheritance propriety [76]. It allows a community of GNU Radio to contribute easily and to change class diagrams. Figure 3.3 shows some modules of C++ signal processing classes. It was summarized from the Doxygen documentation of the project.
Signal processing blocks can be either synchronous or asynchronous. Synchronous
68

69


 

   
Figure 3.4: Programming layers of GNU Radio implementation
blocks need an integer relationship between the sample rate at input and output ports. Usually, they are derived from classes gr_sync_block, gr_sync_ interpolator and gr_sync_decimator. Asynchronous blocks are directly derived from gr_block. Blocks are usually written in C++ while a work function is the main function which processes an input ﬂow. Furthermore, it is possible to wrap up several blocks into a higher level block. This can be done in Python by deriving a class from gr.hier_block2.
2.3 Flow graphs
The designer can create a ﬂow graph in two ways, through a GUI interface called Gnu Radio Companion (GRC) or python code. In GRC panel list, blocks are organized in groups, regarding their functions. For example, modulators are grouped in one drop-down list which contains AM, FM, Phase modulators. Furthermore, blocks dragand-drop is possible for fast and easy block’s handling. Through Python, designers of ﬂow graphs need a deep knowledge about class diagram and how to instantiate new blocks. Figure 3.5 shows an example of GUI ﬂow graph’s representation. The three blocks are connected by edges from an audio source to a Wav File sink. Two blocks can be connected if the type of the source block’s output, and the destination block’s input is the same. For example, ﬂoat is the type of both the output of the audio source and the input of the low-pass ﬁlter (see Figure 3.5).
Flow graphs are derived from two possible classes: the class top_block of the module gr, or std_top_block of the module stdgui2. The diﬀerence between two possibilities depends on application requirements. If ﬂow graphs are executed on console, gr module is imported from gnuradio package. Otherwise, when designers
69

Chapter 3. Analysis of GNU Radio and USRP SDR
Figure 3.5: An example of a ﬂow graph

 
     
   
Figure 3.6: GNU Radio Software layers [78]
need an FFT Graphical User Interface (GUI) in order to analyze a spectrum, the stdgui2 is imported from gnuradio.wxgui (see Figure 3.4).
Actually, ﬂow graphs are only built in Python, whereas to get them in a pure C++ is more eﬃcient for embedded devices. However, some works are carried on handling GNU Radio for embedded architecture. In [77], Finite Input Response (FIR) ﬁlter block has been mapped on Zynq based FPGA architecture.
2.4 Software scheduler
Figure 3.6 shows that a scheduler is at the heart of GNU Radio functioning. It interacts with C++ methods by managing blocks executions, and samples ﬂow between them. Precisely, it is assisted by customized forecast() method, which deﬁnes the number of input samples required to produce a given output number of samples. In addition, the scheduler triggers block processing through general_work or work functions.
From ﬂow graph debugging, we found two types of scheduler: single threaded scheduler and Thread-Per-block Scheduler (TPS). This result is conﬁrmed in the literature by Chiang et al. [42].
By calling each block’s executor, the Single Threaded Scheduler (STS) allocates 70

71
only one thread for each ﬂow graph. It scans through the ﬂow graph from source to sink looking for a block with suﬃcient input data and available output buﬀer (see section 3.10). When it ﬁnds an eligible block, it schedules the block for processing. Then, it continues with the next block. When it reaches the sink, it resumes at the source block. The scheduler is essentially a cyclic poller, calling each block in turn to perform its processing function, always cycling in the same order.
GNU Radio new versions (from 3.3.0) use TPS scheduler, which allocates a distinct thread for each block’s execution. There is no global scheduling among blocks at runtime. A block’s associated thread loops until GNU Radio code is terminated. In each loop, the thread ﬁrst calls a block executor, which checks whether this block has suﬃcient input data and available output buﬀer. In this case, the executor calls the work function for current data processing. After that, it notiﬁes neighbor block(s) on its status changes. Otherwise, this block waits for status change of its neighbor(s), and then checks its status again. Following the above mechanism, all the blocks in a ﬂow graph together process incoming data stream.
We discovered the two types of schedulers by debugging C++ source codes of ﬂow graphs. The open source Data Display Debugger (DDD 2) has been used. It is a graphical front end of the command-line debugger Gnu Project DeBugger (GDB 3).
2.5 SIMD programming (Volk)
Not far from a scheduler, the parallel programming architecture like Single Instruction Multiple-Data (SIMD) allows a programmer to perform one operation on multiple data points simultaneously. Commonly, signal processing blocks need more eﬃciency and processing time. SIMD is a solution to run faster a signal processing application.
Vector Optimization Library of Kernels (VOLK) has recently been proposed to support SIMD on GNU Radio [79]. It deals with code optimization within diﬀerent SIMD architectures. For example, a SIMD architecture on x86, ARM and AMD are diﬀerent. With Streaming SIMD Extensions (SSE), NEON and 3DNow! are dedicated to x86 processor, ARM and AMD, respectively. The VOLK’s objective is to ensure the same processing time even if the programmer changes processor. Furthermore, VOLK provides a signiﬁcant speed-up to signal processing blocks. In fact, the VOLK is a platform-agnostic interface (or an API) called kernel for each conceptual execution unit subject to SIMD vectorization. It has a set of proto-kernels designed for particular platforms, SIMD architecture versions, or run-time conditions.
When we analyzed the programming model of VOLK, we found three conceptual objects: kernels, archs and machines. The kernel is a C++ header ﬁle (extension .h) containing deﬁnitions of its proto-kernels which are static C++ inline functions. The arch is an abstraction for any hardware speciﬁc property. For a compiler, an arch corresponds to one or several ﬂags, such as -msse3 ﬂag in a command line of GCC
2http://www.gnu.org/software/ddd/ 3http://www.gnu.org/software/gdb/gdb.html
71

Chapter 3. Analysis of GNU Radio and USRP SDR

      

  
 



   
machine-arch 1
  
proto kernelr 1 proto kernelr n

 
arch 1 : macro arch n : macro

Figure 3.7: VOLK programming model

compilation [79]. For processor, an arch describes ﬁrmware attributes enabling the processor to execute a machine code of particular assembly instruction. Each arch corresponds to a VOLK macro and is an entry in an XML ﬁle. Finally, a VOLK machine is an abstraction of SIMD architecture for a processor. It describes the various architectural and software attributes required for a processor to run binaries within a shared object. The machine set is deﬁned in an XML ﬁle, and it can be considered as a list of archs. The VOLK’s position is between assembler and kernel of a host-computer’s OS (see Figure 3.7).
Two primary conditions, buﬀer alignment and correctness, must be veriﬁed by a VOLK based block. The alignment is deﬁned by buﬀer requirements for vector loads and vector stores. For example, in an SSE architecture, processing block needs 4 ﬂoat per SSE register. However, forcing an output multiple can keep input and output buﬀers aligned to SIMD architecture requirements. As we have seen in Section 2.4, scheduler is involved in buﬀer management, since it passes suﬃcient data to produce output-multiple items. The VOLK ensures that all proto-kernels have the same behavior on a given machine. In addition, the Quality Assurance (QA) is a programming code used by designers to measure a behavior variance.
Dynamic arrival times of samples from source blocks are diﬃcult to manage for the VOLK mechanism. When a number of input samples is not proportional to the output requirement, a sample processing is delayed. In fact, GNU Radio ﬂow graphs keep wait remaining samples until enough samples are received ensuring alignment requirements. In the case of a signiﬁcant inter-arrival time of samples, we then experience signiﬁcant latency.

3 Universal Software Radio Peripheral
Universal Software Radio Peripheral (USRP) is the most common hardware platform to receive/transmit analog signals for SDR. It has been developed by Ettus Research [37] under GPL license to serve as a digital baseband and IF section of a radio communication system. For the time being, there are four USRPs versions available
72

73

on the market, categorized according to their connecting mechanism to a host computer and to their hardware performances.
Table 3.1 shows the versions (series) those we have used further in our work, i.e. Serial (USRP 1 and USRP B210), Ethernet (USRP N210) and Embedded (E110). The X series remain unused, since it is the newest version. All these versions can be connected to a host computer via multiple high speed interfaces, e.g. Peripheral Component Interconnect express (PCIe), dual 10 GigE, dual 1 GigE.
From the previous classiﬁcations, USRP hardware belongs to the GPP based architecture. The waveform-speciﬁc processing, such as modulation and demodulation can be executed on a host computer. A USRP consists of a mother board which can carry up to four daughter boards, depending on their versions. For example, USRP 1 can contain four Basic Rx/Tx daughter boards. In fact, the mother board holds analog interfaces connected to DACs and ADCs. In addition, it holds an FPGA which accomplishes high-speed general-purpose operations, i.e. digital up and down conversion, decimation and interpolation.
The performances of a USRP depend on frequency coverage and on analog bandwidth of daughter boards. Analog bandwidth is a useful bandwidth between an RF port and an IF/baseband interface of an RF channel. Typically, the analog bandwidth is set by IF or baseband ﬁlters on the daughter board. These ﬁlters are designed to avoid aliasing when paired with a USRP motherboard with ADC/DAC sample rates. Table 3.2 shows the announced analog RF coverage of some daughter boards.

Bus series
Networked series
Embedded series

Name USRP 1

Host sam- ADC ple rate rate

8 MS/s

64 MS/s

USRP B200 and B210 USRP N200 and N210

61.44 MS/s 50 MS/s

61.44 MS/s 100 MS/s

Quad Receiver QR 210 USRP E100 and E110

50 MS/s 4 MS/s

120 MS/s 64 MS/s

DAC rate 128 MS/s
61.44 MS/s 400 MS/s
120 MS/s
128 MS/s

Host Connection USB
USB 3.0
GigaBit Ethernet
1 and 10 Gigabit Ethernet OMAP 4 GPMC 5

RF bandwidth
Deﬁned by a daughter boards placed in 2 slot MIMO card, 70 MHz-6 GHz Deﬁned by a daughter boards placed in 1 slot 700 MHz to 4 GHz
Deﬁned by a daughter boards placed in 1 space

4Open Multimedia Applications Platform (OMAP) 5Group Policy Managment Console (GPMC)

73

Chapter 3. Analysis of GNU Radio and USRP SDR

X series

USRP E100 50 MS/s and E110

200 MS/s

200 MS/s

PCIe, dual 10 GigE, dual 1 GigE

Deﬁned by a daughter boards placed in 2 slots

Table 3.1: USRPs and their performances [37]

3.1 USRP Architecture
There is no general architecture proposed by Ettus Research for USRPs [37]. We can consider the architecture of an USRP N210 mounted with WBX daughter boards as a general one. Due to the numerous versions of USRPs, there is no general architecture. A USRP requires an RF front end, mixers, ﬁlters, oscillators and ampliﬁers, to translate the signal from the RF domain to the complex baseband or IF signals (see ﬁgure 3.8). As explained in Section 2.1, the baseband of IF signals are sampled by ADCs, and the obtained digital samples are clocked into the FPGA. The latter provides down-conversion, which includes ﬁne-frequency tuning and several ﬁlters for decimation [37]. After decimating and through the host interface, raw samples (or data) are streamed to a host computer. The reverse process is applied to the transmission chain. Figure 3.8 presents a schematic organization of the USRP N210 from and toward a host computer. This organization can be considered as the general USRP architecture.
The bandwidth of a USRP device is a function of the analog and the FPGA processing bandwidth and the GPP bandwidth. The minimum of these three bandwidths is the system bandwidth. Thus, care should also be taken to prevent the analog bandwidth to be wider than the ADC/DAC sample rate of any device. For example, the USRP 1 has an Altera Cyclone FPGA with 64 MS/s dual ADC and 128 MS/s dual DAC. This USRP allows a host computer to receive/transmit data through a USB 2.0 connection. Since the sample rate of a USB 2.0 is limited to 8 MS/s then the bandwidth of the USRP 1 is only 8 MS/s.
3.2 Transmit and Receive Paths
Over GPP, radio application generates complex baseband, i.e. In and Quadrature signal components. This signal is sent to the USRP through USB, Ethernet or PCI Express. It is interpolated and digitally up-converted to IF by Digital Up Converters (DUCs) on an analog device. Then, DAC converts a digital signal into analog one and the RF daughter board takes over. Note that DUC is not performed by an FPGA (see Figure 3.8). However, the unique signal processing blocks of the transmitter in the FPGA are the Cascaded Integrator-Comb (CIC) interpolators [37]. The performances of the USRP DACs are recalled in Table 3.1.
74

75

* #
)* " 

!!

'(

)

* # "  !!

'(

,

!" #



$% &$%

!"

#



 





$% &$%






             

+

Figure 3.8: General USRP Architecture with a daughter board (USRP N210 with WBX) [37]
In the receiver path, the daughter boards down convert an RF signal to a baseband. The signal is sampled and converted to a digital stream through the ADC (see Figure 3.8). This stream is transferred to the FPGA which down converts (DDC) the received signal from IF to the baseband. Furthermore, the FPGA decimates the signal samples to adapt the sample rate to the data rate of the communication interface, i.e. Gigabit Ethernet or USB bus. Thus, the resulting signal is a complex baseband signal (waveform) at a given frequency, and the data rates are low enough to be transferred to the GPP.
3.3 RF daughter boards
RF daughter boards are the RF front end in a transmission chain of the USRP GNU Radio SDR. The USRP mother board can hold up to four slots, depending on USRP version, e.g. USRP N210 up to two, USRP 1 up to four. These slots allow us to plug in up to 2 basic receiver/transmiter daughter boards [80]. Primarily, the frequency tuning is accomplished in two steps. In the daughter board through PhaseLocked Loop (PLL) and via DDC. In an FPGA, the phase generator in Numerically Controlled Oscillator (NCO) is clocked at a frequency of the FPGA, e.g. 64 MHz in a USRP 1. Table 3.2 lists some daughter boards and their performances.

3.4 Firmware and FPGA images
Each USRP device must be loaded with special ﬁrmware and FPGA images. The methods of loading images into the device vary among device version. In a USRP 1, USRP-B and USRP-X, the host will automatically load the ﬁrmware and FPGA
75

Chapter 3. Analysis of GNU Radio and USRP SDR

Daughter board RFX 2400 RFX 900 SBX CBX WBX

Frequency coverage 2300 MHz-2900 MHz 750 MHz- 1050 MHz 400 MHz - 4.4 GHz
1.2 GHz - 6 GHz 50 MHz - 2.2 GHz

Analog bandwidth Not speciﬁed Not speciﬁed 40 MHz 40 MHz 40 MHz

Table 3.2: Some daughter boards and their performances [37]

 




 
 
 
  



Figure 3.9: UHD in GNU Radio/USRP
image at run time. By contrast, the user must manually write ﬁrmware images onto the USRP 2 Secure Digital (SD) card. In USRP N series, designer programs an image into on-board storage, which then is automatically loaded at runtime. FPGA image is written in the VHDL language (see section 2.1).
3.5 Universal Hardware Driver (UHD)
UHD is a hardware driver library for all USRP versions and daughter boards. It provides a consistent Application Program Interface (API). It can be used as UHD driver standalone with other applications, such as Labview and Simulink. UHD ﬁnds devices on a USRP system and instantiates a device object in GNU Radio toolkit. It also allows the designer to update the desired parameters. The UHD sets/gets radio properties (e.g. gain, amplitude, center frequency, sample rate, and time) and transmits samples by using Operating System (OS) read() and write() operations. The UHD creates a sending or receiving stream between the host computer and the FPGA in the USRP to send and receive samples from/to the USRP. UHD also supports control and management messages such as Overﬂow, Stream command error (Rx path), Underﬂow and Sequence error (Tx path) [81]. UHD functionalities are wrapped into radio application, e.g. GNU Radio, by using USRP source and sink blocks (see Figure 3.9).
4 GNU Radio and USRP properties
Diﬀerent operating systems and software applications can be executed on a GPP architecture. Hence, software radio applications might behave diﬀerently, and their performances can become diﬃcult to predict by a designer. In particular, the problem
76

77

   

   



 

 

 

   



Figure 3.10: Latencies between GPP, FPGA and DAC/ADC

of identifying sources of a high latency and low throughput in communication chains is diﬃcult. In this section, we discuss GNU Radio and USRP features and performances trade-oﬀs.

4.1 Latency and throughput
The beneﬁts of a GPP based architecture is associated to trade-oﬀ in performances. Typically, latency is the most undesirable drawback if processing chains with separated components. This latency comes from two sources: hardware and software setups. At hardware level, a latency is produced by the hardware link between the GPP and DAC/ADC. The delay between an FPGA and DAC/ADC is small compared to that between GPP and DAC/ADC. In fact, the latency depends on the link technology, i.e. USB, Gigabit Ethernet, PCI Express (see Figure 3.10). Thus, to deal with a hardware latency and data is buﬀered in the both directions from and to GPP.
At software level, additional latency is introduced by the scheduling and buﬀering of individual processing blocks (see Figure 3.11). Typically, block processing function is a function that reads a data stream from memory, processes it, and stores the output back to memory. Latency of processing blocks is not negligible, considering that it sums-up throughout a whole ﬂow graph. Usually, buﬀer sizes are increased to limit the frequency of memory read/write operations. If the buﬀer size is small, then the data are sliced to chunks and the number of read /write operations increase. Thus, latency is increased across the ﬂow graph since the relationship between buﬀer sizes and latency is typically proportional.
The throughput of a given buﬀer is the number of sample passing through the buﬀer time unit. The throughput of a block characterizes how fast an input signal can be processed. If the block’s throughput is smaller than the latency generated in acquiring the samples to process, then the thread handling processing can either handle some other block’s processing or sleep waiting.
To overcome the drawback of data buﬀering at GPP level, an FPGA can be proposed to interconnect processing blocks. However, this solution needs a soft-core processor to implement or to synthesize ﬂow graphs in VHDL. GNU Radio addresses this problem by providing a possibility to impose a latency parameter individually, for each processing block or for all ﬂow graphs [82].
77

Chapter 3. Analysis of GNU Radio and USRP SDR

    

    


   
 






  

 

   
 

Figure 3.11: Latencies between Software blocks 



  

 





 

Figure 3.12: Buﬀers in GNU Radio USRP SDR

4.2 Buﬀers organization
The previous section motivates us to identify all types of buﬀers in the GNU Radio USRP SDR. We start from GNU Radio down to USRP hardware. The ﬁrst buﬀer is that between signal processing blocks. The second is before Kernel bus driver. It allows GNU Radio to wait for suﬃcient data to generate a packet (USB, Ethernet or GPMC (General-Purpose Memory Controller) packets). The third buﬀer is the internal bus controller buﬀer on the USRP mother board. Finally, the FPGA buﬀer gets samples before processing them. Figure 3.12 summarizes all the buﬀers involved in a GNU Radio USRP SDR.

4.3 Performance counters and ControlPort
In order to estimate the processing time within each block, Thomas Rondeau et .al [43] introduce two inspection tools: ControlPort and Performance counters. The objective of these tools is to measure the work time of each block running in a GNU Radio ﬂow graph. These tools allow a designer to ﬁnd which block causes the maximum delay and try to optimize it at run time.
ControlPort is a GNU Radio tool that creates an integrated remote procedure or call interface to GNU Radio ﬂow graphs [43]. It enables us to debug without requiring extra debug streams. Any GNU Radio block can register interfaces with ControlPort. Through these interfaces, ControlPort client interacts with the GNU Radio application, i.e. query and update properties of blocks. The general form of these interfaces is a "set" and/or "get" functions to adjust or query the state of a GNU Radio block’s parameter. Figure 3.13 shows two ControlPort blocks with GNU Radio applications.
78

79




     

     
   

Figure 3.13: Controlport clients with GNU Radio applications over a TCP connection
 
 


 
 
Figure 3.14: An example of the performance’s counters graph of a given ﬂow graph
Performance Counters are a way to generating performance measurements for each block running a GNU Radio ﬂow graph. These counters keep track of various states of each block that can then be used for analyzing the performance and behavior of a running ﬂowgraph. A speciﬁc package is launched by a designer to represent the GNU Radio ﬂow graph over ControlPort. It constructs a graph of nodes (see Figure 3.14), which represents blocks and where edges are the buﬀers between blocks. The size of each node is proportional to the work time while the darkness of an edge is a function of buﬀers ﬁlling [43].
5 Advantages of GNU Radio and USRP
The GNU Radio has several advantages that we can summarize as follows: • GNU Radio allows a designer to process in real time a signal stream (or waveform). Furthermore, the radio program can be simulated in a loop back.
• Over 100 blocks are available to easily develop new standards and applications as well as wireless networks.
• Python language is relatively easy to master. It describes processing steps throughout successive and connected blocks.
• Thanks to a Python script, a data ﬂow can reach a maximum rate under processing blocks.
79

Chapter 3. Analysis of GNU Radio and USRP SDR
• The community of GNU Radio’s designers is large. The toolkit can be carried out by a simple host computer on Linux, Windows and Mac.
• A ﬂow graph (or communication chain) can be reconﬁgured even at run time. Several parameters of signal processing can be changed, such as frequency, power and sampling rates.
We can summarize some advantages of USRPs as follows :
• USRP is an open source hardware.
• It oﬀers more ﬂexibility to develop several applications with high level programming languages.
• It is compatible with Linux (2.6 kernel, any distribution), Mac OSX (PPC and Intel), Windows XP/2000, NetBSD and FreeBSD (Berkeley Software Distribution).
• An embedded SDR can be implemented with embedded version of USRP such as USRP E100 and E110.
• With Rx/Tx daughter boards, USRP can cover a large frequency band from 4 MHz to 6 GHz.
6 Summary
The USRP and GNU Radio GPP based SDR have been detailed. It is a well established open-source SDR platform. It allows a radio designer to prototype/implement a SDR transmitter/receiver. A prototype or an implementation requires a USRP to receive/transmit a radio signal. The latter is transformed to a digital stream and processed by ﬂow graphs executed on host computer.
The GNU Radio’s architecture has been analyzed by describing the programming language layers. It supports interesting and numerous signal/data processing functions, materialized by software blocks. These blocks are primarily developed in C++ and they are connected to deﬁne ﬂow graphs or radio applications. The design of the GNU Radio is an object oriented with a vast class hierarchy. The SDR designer can use and instantiate the blocks as modules via a graphical user interface. However, for advanced use and evolutive modiﬁcation, the designer needs more time to understand the class dependency and to master the C++ programming language.
The scheduler is a kernel of the executed ﬂow graph. It can be of two types: single threaded scheduler and Thread-Per-Block Scheduler (TPS). The objective of the latest scheduler is to reduce the latency and improve the throughput of a ﬂow graph at GPP level. Furthermore, blocks can be accelerated by programming them using Volk’s library, which is based on SIMD architecture. Outside a block, data
80

81 stream is buﬀered in several levels of the GPP based SDR architecture. The buﬀers are not only between software blocks; a buﬀer is needed between OS kernel and GNU Radio. Hence, performance counters and ControlPort are proposed to estimate the processing delay within blocks and among them.
A general architecture of a USRP hardware composed of two parts: the mother board and a number of daughter boards. FPGA is irreplaceable across diﬀerent USRP versions, since it accomplishes high-speed general-purpose operations. In the other side, the RF Front End or daughter boards deﬁne the frequency coverage for software applications at GPP level. However, technical information remains unexplored, especially, output power and the RF bandwidth of daughter boards. Thus, this unknown behavior leads us to carry a deep analysis of some daughter boards in the next chapter.
81

Chapter 4
Radio Frequency Measurements on USRP Daughter boards
No man’s knowledge can go beyond his experience.
John Locke
Contents
1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84 2 Problem statement . . . . . . . . . . . . . . . . . . . . . . . . 84
2.1 An overview of BPSK modulation . . . . . . . . . . . . . . . 85 2.2 Related Works . . . . . . . . . . . . . . . . . . . . . . . . . . 90 3 Experimental approach . . . . . . . . . . . . . . . . . . . . . . 91 3.1 Hardware Setup . . . . . . . . . . . . . . . . . . . . . . . . . 91 3.2 Software Setup . . . . . . . . . . . . . . . . . . . . . . . . . . 92 4 Spectrum Analyzer measurements . . . . . . . . . . . . . . . 93 4.1 RFX2400 Daughter board . . . . . . . . . . . . . . . . . . . . 93 4.2 RFX900 Daughter board . . . . . . . . . . . . . . . . . . . . 95 4.3 SBX Daughter board . . . . . . . . . . . . . . . . . . . . . . . 98 4.4 MIMO USRP B210 . . . . . . . . . . . . . . . . . . . . . . . 103 5 Measurements through ﬂow graphs . . . . . . . . . . . . . . . 104 5.1 RFX and SBX Daughter boards . . . . . . . . . . . . . . . . 105 6 Empirical model for SBX daughter boards . . . . . . . . . . 106 7 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109

Chapter 4. Radio Frequency Measurements on USRP Daughter boards
1 Introduction
Before performing a real implementation of wireless communications on a speciﬁc SDR platform, we would like to analyze performances of USRP daughter boards. More precisely, we would like to evaluate how these boards answer to GNU Radio commands? This question came from our ﬁrst experiment when we were trying to get Bit Error Rate (BER)/Signal-to-Noise Ratio (SNR) parameters from a simple Binary Phase-Shift Keying (BPSK) modulation/demodulation. The RFX2400, SBX, RFX900 and B210 daughter boards are widely used to test and to validate research works [83] [84] while their RF performances have not been reported through the literature in conjunction with GNU Radio.
In this chapter, we adopt an experimental approach in order to test and to evaluate these performances. Thus, measurements are carried out via two tools: spectrum analyzer and GNU Radio itself. The obtained results are highlighted and discussed thoroughly. Furthermore, a new accurate empirical model is proposed, which is based on these results. Its usefulness comes from the possibility to predict the daughter board’s output-power versus ﬂow graph parameters.
2 Problem statement
The ﬁrst stage of our exploration of the GNU Radio and USRP SDR, we have done simple digital and analog communications, such as an FM receiver/transmitter, an Automatic Dependent Surveillance-Broadcast (ADS-B) receiver, and a simple Fast Fourier Transform (FFT) or a spectrum analyzer. In addition, some digital modulations have been performed. For example, digital transmission of bits’ frame through BPSK modulation has been accomplished. Over GNU Radio, two ﬂow graphs can be constructed by using all in one modulator/demodulator block or connected elementary blocks. With both techniques, we observed that transmission was functional but very sensitive to the adjustment of ﬂow graphs and USRP parameters.
The usability of the chosen SDR can be shown via these tests, but without a precise information about RF front end behavior. Commonly, daughter boards’ output power and covered frequency bandwidth are useful information to feature. Furthermore, the behavior of ﬂow graphs has not been featured when a ﬂow graph controls these parameters. Particularly, UHD parameters of a USRP source and sink block are not documented. Thus, UHD Gain and Frequency parameters can be another aspect to clarify their impact via our experiments.
This section shows some results obtained when we implemented a BPSK modulator, motivating advanced tests and measurements.
84

85

Figure 4.1: Constellation diagram for BPSK modulation

2.1 An overview of BPSK modulation
BPSK is a simple and robust digital modulation compared to other Phase Shift modulations. The robustness of BPSK comes from the diﬃculty to alter a demodulator decision. In the constellation diagram depicted in Figure 4.1, we distinguish without diﬃculty the symbols (points) in the complex plane. The real and imaginary axes are termed the In-phase and Quadrature axis. The two possible signals correspond to two bits, 0 and 1 , respectively, separated by a phase shift of π radians on the In-phase axis (see Figure 4.1). This yields to two phases, 0 and π, in the speciﬁc form with the following signals over a time t:

s0 =

2Eb Tb

cos(2πfct

+

π)

=

−

2Eb Tb

cos(2πfct)

(4.1)

where :

s1 =

2Eb Tb

cos(2πfct)

(4.2)

• fc is the central frequency of the carrier wave cos(2πfct)

•

2Eb Tb

is the energy ratio per bit divided by time period Tb

The previous formulas simply highlight the simplicity of the modulation. A more detailed study of BPSK modulation can be found in [85] and [86].

2.1.1 The BER and SNR parameters

Bit Error Rate (BER) is a common parameter used to evaluate a digital modulation. It is a non linear function of the Signal to Noise Ratio (SNR). A bit error occurs whenever the transmitted bit and the corresponding received bit do not match; this is a random event depending on the noise level. Let n denote the number of bit errors observed in a sequence of bits of length N [86]. The BER is deﬁned as:

BER

=

lim
N →∞

n N

(4.3)

The SNR is a dimensionless parameter. It is measured at the receiver and

represents the ratio of the average power of the received signal (i.e., channel output)

over the average power of noise measured at the receiver input. It is a common

85

Chapter 4. Radio Frequency Measurements on USRP Daughter boards

practice to express the SNR in decibels (dBs), which deﬁned as 10 times the logarithm (in base 10) of the power ratio. For example, signal-to noise ratios of 10, 100, and 1000 are 10, 20, and 30 dBs, respectively. The SNR can be used to measure the quality of analog systems [86].
In communication systems, a received signal x(t) can be modeled as the sum of the desired signal, s(t), and a narrowband noise signal, n(t):

x(t) = s(t) + n(t)

(4.4)

The signal quality is the ratio of the variances of the desired and undesired signals [87]. On this basis, the signal-to-noise ratio is formally deﬁned by:

SNR

=

10.

log10

 σs2(t)  σn2(t)

 

(4.5)

2.1.2 BER/SNR estimators on GNU Radio simulation
It is diﬃcult to implement a real time SNR estimator. The estimation depends on the modulation scheme, channel model and synchronization. It requires more time of design than other signal processing blocks. A receiver and a transmitter must be synchronized. We primarily need three synchronization: frequency, timing, and phase. For each one, the issue is to have a reactive change of SNR’s values. In the literature [88], we can ﬁnd a number of estimators but without real computational possibilities.
Tom Rondeau [89] has implemented four estimators on GNU Radio, based on the works published in [88]. Primarily, they are dedicated to Multiple Phase Shift Keying signals and an Additive White Gaussian Noise (AWGN) channel. They inherit from one GNU radio block, and they are named the "simple," "skew," "M2M4," and "SVR" estimators. The M2M4 and SVR estimators are inspired from [88].
To highlight the diﬀerence between the four estimators, we performed loopback GNU Radio simulations. The simulation’s purpose is to evaluate the SNR estimators. The SNR is calculated via both techniques: a direct processing and python code. Apparently, the ﬂow graph needs high processing, since it involves several programming layers. The two techniques are compared to a reference: the expected theoretical SNR.
The SNR estimator ﬂow graph is depicted in Figure 4.2. It contains an SNR block which handles four estimator types adapted to an MPSK signal. A ﬁrst block is a vector source, which generates a data bit stream. Then, White Gaussian Noise (AWGN) channel which carries a stream to the SNR estimator. Before ﬂow graph execution, one SNR type can be selected, i.e. "simple," "skew," "M2M4," and "SVR". Finally, null sink drops the processed stream.
Figure 4.3 presents four curves of an estimated SNR from -5 dB to 30 dB. For each estimator "Simple", "Skew", "M2M4" and "SVR", the obtained values are depicted in

86

87



  

  




   

 
 

 

Figure 4.2: Loop back ﬂow graph for SNR estimation

Estimated SNR

35

SNR Estimators

Known

30

Python

GNU Radio

25

20

15

10

5

0

−5−5

0

5

10

15

20

25

30

SNR (dB)

4.3.1: Simple estimator of the SNR.

Estimated SNR

35

SNR Estimators

Known

30

Python

GNU Radio

25

20

15

10 5

0 −5

−10−5

0

5

10

15

20

25

30

SNR (dB)

4.3.2: Skew estimator of the SNR.

Estimated SNR

35

SNR Estimators

Known

30

Python

GNU Radio

25

20

15

10 5

0 −5

−10−5

0

5

10

15

20

25

30

SNR (dB)

4.3.3: M2M4 estimator of the SNR.

Estimated SNR

40

SNR Estimators

Known

Python

30

GNU Radio

20

10

0

−10

−20−5

0

5

10

15

20

25

30

SNR (dB)

4.3.4: SVR estimator of the SNR.

Figure 4.3: Known theoretical SNR compared to the estimated ones through GNU Radio and python

Figure 4.3.1 4.3.2 4.3.3 4.3.4, respectively. The SNR is calculated by each estimator using a GNU Radio ﬂow graph and using a Python program. The obtained results are compared to a linear function of expected SNR values. Higher than 5 dB, the four estimators behave the same near the theoretical results. For SNR values less than 5 dB, the estimator’s results are diﬀerent from each other. The values of "Simple" estimator can be calibrated above 5 dB. By contrast, the three remaining estimators present a harsh variation. Hence, the "Simple" estimator can be selected to perform a real time transmission.
Similarly to the SNR estimator, BER block can calculate the BER by comparing
87

Chapter 4. Radio Frequency Measurements on USRP Daughter boards



  

  








  



  



 

 

   


  





Figure 4.4: Loop back ﬂow graph for BER estimation

BER

BER Simulation

10-2

Theoretical

Simulated

10-4

10-6

10-8

10-10

10-12

10-14

10-16 0

2

4

6

8

10

12

14

16

Eb/N0 (dB)

Figure 4.5: Compared BER versus Eb/N0 obtained under simulation and theoretical processing

the demodulated vector stream with a vector source. Figure 4.4 shows a corresponding ﬂow graph with a BPSK modulator/demodulator and a Gaussian Noise channel. The results of the simulation are compared to the theoretical ones. They are depicted in Figure 4.5. The BER is calculated versus Eb/N0 (the energy per bit to noise power spectral density ratio). The curve of BER versus Eb/N0 obtained by simulation matches that which is theoretically calculated as shown in Figure 4.5. The simulation results deviate slightly from the theoretical ones when output power is high. This result can be explained by an extra processing time needed by the ﬂow graph.
2.1.3 BER/SNR estimators in real experiment
We focus in our experiments on a Hardware (Hw) setup with two USRP 1 connected to a host computer. Each one carries an RFX 2400 daughter board (see Figure 4.6). The two USRPs are within an indoor environment, and they are separated by a distance of 1m. The SNR as function of the BER are obtained using BPSK modulator/demodulator ﬂow graph. The software implementation of the BPSK modulators is detailed in the next chapter when we report our implementation of
88

89
Figure 4.6: Two USRP 1 connected to a host computer which run a BPSK modulator/demodulator ﬂow graph
Figure 4.7: BER versus SNR obtained with a BPSK modulation on RFX2400 daughter board
the IEEE 802.15.4 speciﬁcations. The USRP 1 contains two RFX2400 daughter boards for a receiver and transmitter. Through a transmitter ﬂow graph, the signal is ampliﬁed by sweeping an interval of possible output powers.
Figure 4.7 shows the estimated SNR/BER and a Matched Filter Bound (MFB) curve in red. The SNR is estimated using Simple SNR estimator in black [89] [88]. In another hand, BER is calculated by comparing the demodulated bits sequence with the known expected one. MFB curve is the theoretical threshold of the SNR/BER. It can be calculated via Matlab tool [90]. The transmitter ampliﬁes the signal strength through the GNU Radio ﬂow graph. The ampliﬁer is handled by a software parameter called DAC. It is implemented in GNU Radio block and it will be detailed in Section 3.2. Consequently, the receiver’s ﬂow graph measures the SNR and BER. However, the measurements reported for each output power must be accomplished in the same conditions i.e. same distance between the two USRP 1 and ﬁxed carrier frequency.
89

Chapter 4. Radio Frequency Measurements on USRP Daughter boards

   
  
   

   
Figure 4.8: Daughter boards frequency band coverage
Results of BER depending on SNR give a scatter plot above the MFB. The obtained points do not exceed the MFB limit, so the SNR estimator is useful even though the shape of results is not linear. This non-linearity can be explained by the non-equalized power ampliﬁer. Since the analog ampliﬁer is handled by Front End Radio frequency, so we suspect its miss-behavior. Hence, the daughter board’s ampliﬁer should be analyzed via real time experiments and through several radio-frequency measurements.
2.2 Related Works
Before presenting our experimental method, we give a brief state of the art about works dealing with daughter boards’ performances.
Ettus research [37] claims that the selection of an RF daughter board is made solely on the application requirements for frequency coverage. For example, the RFX2400 and SBX boards are good candidates. They cover the Industrial Scientiﬁc Medical (ISM) frequency band of 2.4 GHz for applications of wireless sensor networks. Figure 4.8 depicts graphics, which sums up the frequency coverage of these daughter boards. Even though the manufacturer has announced these frequency bands, the maximum output power remains unknown under each band.
Some recent results dealing with performance evaluations of the N 210 USRP have been published in [91]. In this work, the frequency stability and the phase diﬀerences have been measured between two SBX daughter boards carried by USRP N210. The authors concluded that the carrier frequency is suﬃciently stable and that the phase error can be a neglected. Other performance evaluations are given in [56], where the USRPs 2 were used at the data packet level. Through this work a measure of communication delay, jitter and throughput of wireless transmissions is achieved. In [92], the authors objective is to evaluate the cooperative diversity in a cellular network via USRP experimental. Their results showed the problem
90

91
of output-power variation from one USRP to another. As a solution, the authors proposed to calibrate manually the transmission power, each USPR needing to be attached to a spectrum analyzer. Neither the USRP series, nor the daughter board was speciﬁed. The lack of details makes the reusability of their results diﬃcult.
Our published work [2] is the ﬁrst work dealing with frequency bandwidths characterization of USRP daughter boards. Our RF measurements published in [2] and [3] are organized into four sections:
• RFX2400 daughter board
• RFX900 daughter board
• SBX daughter board
• Multiple-Input and Multiple-Output (MIMO) USRP B 210
3 Experimental approach
Our experiments are based on an empirical method that arbitrates between several hypotheses. The objective is to verify the hypotheses announced by the daughter boards’ manufacturer, i.e. Ettus Research, particularly the frequency bandwidth and output power parameters of some daughter boards. Furthermore, we analyze the linearity of the output power depending on ampliﬁer values of a ﬂow graph.
3.1 Hardware Setup
As mentioned in Section 3, the USRP N210 provides higher-bandwidth and higherdynamic processing range capabilities than the other USRP versions. The USRP architecture includes a Spartan 3A-DSP 3400 FPGA from Xilinx, 100 Mega Samples Per Second (MSPS) dual ADC, 400 MSPS dual DAC and Gigabit Ethernet connectivity to stream data to and from host processors. A modular design allows the USRP N210 to operate from DC to 6 GHz, while an expansion port allows multiple USRP N210 series devices to be synchronized and used in an MIMO [37] conﬁguration. An optional GPS Disciplined Oscillator (GPSDO) module can also be used to discipline the USRP N210 reference clock within 0:01 parts per million (ppm) of the worldwide GPS standard. The USRP N210 can stream up to 50 MSPS, to and from host applications. Users can implement custom functions in the FPGA, or in the on-board 32-bit RISC softcore. The USRP N210 provides a larger FPGA than other USRP series, being able to run applications demanding additional logic, memory and DSP resources. The FPGA also oﬀers the potential to process up to 100 MSPS in both transmit and receive directions. The FPGA ﬁrmware can be reloaded through the Gigabit Ethernet interface.
91

Chapter 4. Radio Frequency Measurements on USRP Daughter boards
Figure 4.9: Experimental setup for the measurements
In Figure 4.9, we depict the hardware setup used in our measurements. A host computer is connected to a USPR N210 SDR via a Gigabit Ethernet Switch. The host computer uses a Linux distribution (UBUNTU 12.04 LTS)OS (Operating System) powered by an Intel Core i5-2400 CPU, clocked at 3,10 GHz and an RAM memory of 8 GB. The oscilloscope (spectrum analyzer) used in our measurements was a LeCroy 640 Zi [93] series oscilloscope, having an input bandwidth from 400 to 4000 MHz and having a sampling rate of up to 40 GS/s. The oscilloscope was directly connected to a TX/RX terminal of daughter boards through a high-frequency coaxial cable from ATEM 404-0202-xxxxA [94].
3.2 Software Setup
Two ﬂow graphs have been implemented on GNU Radio toolkit: BPSK and sine-wave generator (see Figure 4.21). The BPSK is considered as a black box. The ﬂow graph of this modulator was already shown in Section 2.1. The second ﬂow graph is a source of a sinusoidal signal. For both ﬂow graphs and before the USRP Hardware Driver (UHD) sink, a complex stream is fed through an ampliﬁer block called gr.multiply_const_cc (see Figure 4.21). This block multiplies the two components of a complex input by an ampliﬁer DAC parameter. The latter can be represented in ﬂoating point for more precision in the interval [0; 1]. In Figure 4.21, only one of the two ﬁrst blocks, i.e. Sinusoidal signal source and BPSK modulator, is activated at one time, to generate the baseband signal. BPSK modulator is launched in order to analyze the diﬀerence between a modulated and an unmodulated signal output. In this case, the transmitter generates a scrambled bit stream of 0 and 1 with a bit
92

93

   
 /

 
 
   
01    
   !  " 
  !

01


 

    

$ 
.

# 

 $ 
%"$  &' !(

$ 
.

$ 
.

)*% ) + 
% "    +  
$  , " -.+.

Figure 4.10: A simpliﬁed sinusoidal and BPSK transmitter ﬂow graph

rate of 250 Kbits/s The data brought after the measurements was subsequently processed and dis-
played using the Matlab R2012a software package from Mathworks Inc [90]. We focused on two parameters of interest of the daughter boards: their output RF bandwidth and the average output power versus the DAC value.

3.2.1 The expected DAC vs ouput power relationship
This DAC value parameter from GNU Radio is supposed to control the signal output amplitude of the device. Therefore, we expect the following relation:

Pout = DAC2 · P0

(4.6)

where · signiﬁes the statistical average of the output signal (since it is supposed to
be ergodic) and P0 is a reference power level. In the new version of the GNU Radio, we have 0 ≤ DAC ≤ 1. The central carrier frequency of each daughter board (f0) was tuned in software according to their advertised frequency range.

4 Spectrum Analyzer measurements
4.1 RFX2400 Daughter board
RFX2400 is a daughter board transceiver designed to operate in the 2.4 GHz ISM band. It can be connected with a wide range of USRP devices. The RFX2400 provides a typical power output of 50 mW, and noise ﬁgure1 of 8 dB [37]. It uses independent local oscillators for the transmit and receive chains and is MIMO capable. The advertised operational bandwidth is from 2300 MHz to 2900 MHz in both Tx/Rx modes [37].
The output of RFX2400 daughter board was measured thoroughly for frequencies in the range of 2350-2550 MHz. We also measured the frequency intervals 2300-2350
1Figure Noise: It is a numerical characteristic of a radio receiver that indicates how much its sensitivity to an incoming signal is decreased by the eﬀects of its internal noise
93

Chapter 4. Radio Frequency Measurements on USRP Daughter boards

0

−10

Average Output Power (log units)

−20

−30

−40

−50

−60 2350

2400

2450 frequency (MHz)

2500

2550

Figure 4.11: Measured bandwidth of the RFX2400 daughter board. The reference level of 0 dB was taken at 2434 MHz. Units are logarithmic (dB).

and 2550-2600 MHz. Nonetheless, the output levels were extremely low, therefore we focused only on the frequency interval discussed in this section.

4.1.1 Frequency bandwidth
The bandwidths of the daughter boards were measured by generating, with GNU Radio, a sinusoidal non-modulated carrier. Through the ﬂow graph of Figure 4.21, the Sinusoidal signal source is activated and generates a carrier at central frequency f0. Daughter board’s Tx terminal receives the signal in its input from GNU Radio and transmits it via Tx antenna output. A high-frequency coaxial cable then carries signal to the spectrum analyzer.
The measurements are performed with a ﬁxed DAC value of 1 i.e. the maximum power output. The obtained results swept through the advertised bandwidth, recording enough values in order to completely characterize the device’s bandwidth. In Figure 4.11 the output power curves (in logarithmic units), setting the reference power to the maximum measured value, i.e. the maximum output power is set to 0 dB and all the other values from our graphics are negative in dB. We found the maximum value to be at 2434 MHz.
The measured −3 dB bandwidth is B3dB = 2480.5 − 2407.6 = 72.9 MHz. If we accept a −10 dB attenuation, the bandwidth is 2390 − 2499 MHz (109 MHz) and for a −30 dB attenuation we have a bandwidth of 2359 − 2527 (168 MHz).
Furthermore, for the case of DAC = 0.5 the found −3 dB bandwidth is equal to B3dB = 2481.24 − 2399.52 = 81.72 MHz. This bandwidth is slightly bigger than our result for DAC = 1.0. Thus, the advertised bandwidth of 600 MHz (2300 − 2900
94

95
MHz) is largely overstated.
4.1.2 Output power versus DAC value
The average power versus the DAC value was computed via two methods. In the ﬁrst one, we created a custom function on the oscilloscope that computes the average of the squared amplitudes of the input samples i.e. Pt ∼ vi2 t where vi represents the ith input sample and · t represents time average. In order to have stable values, a supplementary averaging over 1000 oscilloscope sweeps was implemented. We used our ﬂow graph shown in Figure 4.21 to generate a sinusoidal non-modulated signal and swept the DAC value from 0.1 to 1.0 in increments of 0.05 (we assumed that for DAC = 0.0, the residual output power is small enough to be ignored), each time recording the output power in the daughteroard Tx terminal.
The second method was based on the Spectrum Analyser software package installed on the LeCroy WaveRunner 640 Zi oscilloscope. The recorded spectral measurements were converted from dBm to linear power units and summed over a bandwidth of 2 MHz around the central frequency in the case of an unmodulated carrier and over a bandwidth of 5 MHz in the case of BPSK modulation. Therefore, the second estimator can be written as Pf = f 10PdBm(f)/10, where PdBm(f ) is the vector of spectral power samples given by LeCroy’s Spectrum Analyzer and f sweeps all the samples from the measured bandwidth. We performed the same measurements over the bandwidths of 10, 15 and 30 MHz and found no signiﬁcant diﬀerences, which was the expected results since our signal is either a very peaked Dirac-like function (when we generate an unmodulated carrier) or has a bandwidth under 1 MHz (when using the BPSK benchmark).
In Figure 4.12 we depict the average power versus the DAC value for 6 diﬀerent frequencies. The expected Pout ∼ DAC2 law is quite valid throughout the whole range of the DAC parameter. Considering again the spectral power graphic results (Figure 4.11) we note that the spectral amplitudes for the 6 frequencies from Figure 4.12 are, in decreasing order, as follows: 2460, 2450, 2470, 2480, 2490 and 2500 MHz. This order can be found in Figure 4.12, where the curve corresponding to 2460 MHz is the top one while the one corresponding to 2500 MHz is the bottom one.
A major change is noted when using a BPSK modulation instead of the unmodulated carrier frequency. In Figure 4.13 we plot on the same graphic the average powers for both unmodulated and BPSK modulated signals. For a DAC value around 0.7, the Pout ∼ DAC2 law breaks down for all BPSK curves. We can explain this phenomenon by the large peak-to-average ratio of the BPSK modulation [86].
4.2 RFX900 Daughter board
This transceiver daughter board is intended to operate in the 900 MHz band. It connects to all USRP SDR devices, making it a popular choice. It has a typical power output of 200 mW, and noise ﬁgure of 8 dB. The cellular and 902 − 928 MHz
95

