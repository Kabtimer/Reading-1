Statistics and Machine Learning in Python
Release 0.2
Edouard Duchesnay, Tommy L√∂fstedt
May 16, 2019

CONTENTS

1 Introduction

1

1.1 Python ecosystem for data-science . . . . . . . . . . . . . . . . . . . . . . . . . . 1

1.2 Introduction to Machine Learning . . . . . . . . . . . . . . . . . . . . . . . . . . 5

1.3 Data analysis methodology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6

2 Python language

9

2.1 Basic operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9

2.2 Data types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10

2.3 Execution control statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16

2.4 Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18

2.5 List comprehensions, iterators, etc. . . . . . . . . . . . . . . . . . . . . . . . . . . 20

2.6 Regular expression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21

2.7 System programming . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22

2.8 Scripts and argument parsing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28

2.9 Networking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29

2.10 Modules and packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29

2.11 Object Oriented Programming (OOP) . . . . . . . . . . . . . . . . . . . . . . . . 30

2.12 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31

3 ScientiÔ¨Åc Python

33

3.1 Numpy: arrays and matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33

3.2 Pandas: data manipulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40

3.3 Matplotlib: data visualization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52

4 Statistics

67

4.1 Univariate statistics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67

4.2 Lab 1: Brain volumes study . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103

4.3 Multivariate statistics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114

4.4 Time Series in python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126

5 Machine Learning

143

5.1 Dimension reduction and feature extraction . . . . . . . . . . . . . . . . . . . . . 143

5.2 Clustering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158

5.3 Linear methods for regression . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166

5.4 Linear classiÔ¨Åcation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180

5.5 Non linear learning algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197

5.6 Resampling Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201

6 Indices and tables

215

i

ii

CHAPTER
ONE
INTRODUCTION
1.1 Python ecosystem for data-science
1.1.1 Python language
‚Ä¢ Interpreted ‚Ä¢ Garbage collector (do not prevent from memory leak) ‚Ä¢ Dynamically-typed language (Java is statically typed)
1.1.2 Anaconda
Anaconda is a python distribution that ships most of python tools and libraries Installation
1. Download anaconda (Python 3.x) http://continuum.io/downloads 2. Install it, on Linux bash Anaconda3-2.4.1-Linux-x86_64.sh 3. Add anaconda path in your PATH variable in your .bashrc Ô¨Åle: export PATH="${HOME}/anaconda3/bin:$PATH" Managing with ‚Äò‚Äòconda‚Äò‚Äò Update conda package and environment manager to current version conda update conda Install additional packages. Those commands install qt back-end (Fix a temporary issue to run spyder) conda install pyqt conda install PyOpenGL conda update --all Install seaborn for graphics
1

Statistics and Machine Learning in Python, Release 0.2
conda install seaborn # install a specific version from anaconda chanel conda install -c anaconda pyqt=4.11.4
List installed packages
conda list
Search available packages
conda search pyqt conda search scikit-learn
Environments ‚Ä¢ A conda environment is a directory that contains a speciÔ¨Åc collection of conda packages that you have installed. ‚Ä¢ Control packages environment for a speciÔ¨Åc purpose: collaborating with someone else, delivering an application to your client, ‚Ä¢ Switch between environments
List of all environments :: conda info ‚Äìenvs
1. Create new environment 2. Activate 3. Install new package
conda create --name test # Or conda env create -f environment.yml source activate test conda info --envs conda list conda search -f numpy conda install numpy
Miniconda Anaconda without the collection of (>700) packages. With Miniconda you download only the packages you want with the conda command: conda install PACKAGENAME
1. Download anaconda (Python 3.x) https://conda.io/miniconda.html 2. Install it, on Linux
bash Miniconda3-latest-Linux-x86_64.sh
3. Add anaconda path in your PATH variable in your .bashrc Ô¨Åle:
export PATH=${HOME}/miniconda3/bin:$PATH
4. Install required packages

2

Chapter 1. Introduction

Statistics and Machine Learning in Python, Release 0.2

conda install -y scipy conda install -y pandas conda install -y matplotlib conda install -y statsmodels conda install -y scikit-learn conda install -y sqlite conda install -y spyder conda install -y jupyter

1.1.3 Commands
python: python interpreter. On the dos/unix command line execute wholes Ô¨Åle: python file.py
Interactive mode: python
Quite with CTL-D ipython: advanced interactive python interpreter: ipython
Quite with CTL-D pip alternative for packages management (update -U in user directory --user): pip install -U --user seaborn
For neuroimaging: pip install -U --user nibabel pip install -U --user nilearn
spyder: IDE (integrated development environment): ‚Ä¢ Syntax highlighting. ‚Ä¢ Code introspection for code completion (use TAB). ‚Ä¢ Support for multiple Python consoles (including IPython). ‚Ä¢ Explore and edit variables from a GUI. ‚Ä¢ Debugging. ‚Ä¢ Navigate in code (go to function deÔ¨Ånition) CTL.
3 or 4 panels:
text editor help/variable explorer ipython interpreter
Shortcuts: - F9 run line/selection

1.1. Python ecosystem for data-science

3

Statistics and Machine Learning in Python, Release 0.2

1.1.4 Libraries

scipy.org: https://www.scipy.org/docs.html
Numpy: Basic numerical operation. Matrix operation plus some basic solvers.:
import numpy as np X = np.array([[1, 2], [3, 4]]) #v = np.array([1, 2]).reshape((2, 1)) v = np.array([1, 2]) np.dot(X, v) # no broadcasting X * v # broadcasting np.dot(v, X) X - X.mean(axis=0)
Scipy: general scientiÔ¨Åc libraries with advanced solver:
import scipy import scipy.linalg scipy.linalg.svd(X, full_matrices=False)
Matplotlib: visualization:
import numpy as np import matplotlib.pyplot as plt #%matplotlib qt x = np.linspace(0, 10, 50) sinus = np.sin(x) plt.plot(x, sinus) plt.show()
Pandas: Manipulation of structured data (tables). input/output excel Ô¨Åles, etc.
Statsmodel: Advanced statistics
Scikit-learn: Machine learning

li-

Arrays

brary Num.

I/O

Numpy X

Scipy

Pan-

das

Stat-

mod-

els

Scikit-

learn

data, Structured comp, data, I/O
X

Solvers: Solvers: basic advanced

X

X

X

Stats: basic
X
X

Stats: advanced
X

Machine learning
X

4

Chapter 1. Introduction

Statistics and Machine Learning in Python, Release 0.2
1.2 Introduction to Machine Learning
1.2.1 Machine learning within data science

Machine learning covers two main types of data analysis:
1. Exploratory analysis: Unsupervised learning. Discover the structure within the data. E.g.: Experience (in years in a company) and salary are correlated.
2. Predictive analysis: Supervised learning. This is sometimes described as ‚Äúlearn from the past to predict the future‚Äù. Scenario: a company wants to detect potential future clients among a base of prospects. Retrospective data analysis: we go through the data constituted of previous prospected companies, with their characteristics (size, domain, localization, etc. . . ). Some of these companies became clients, others did not. The question is, can we possibly predict which of the new companies are more likely to become clients, based on their characteristics based on previous observations? In this example, the training data consists of a set of n training samples. Each sample, Ì†µÌ±•Ì†µÌ±ñ, is a vector of p input features (company characteristics) and a target feature (Ì†µÌ±¶Ì†µÌ±ñ ‚àà {Ì†µÌ±å Ì†µÌ±íÌ†µÌ±†, Ì†µÌ±Å Ì†µÌ±ú} (whether they became a client or not).

1.2.2 IT/computing science tools
‚Ä¢ High Performance Computing (HPC) ‚Ä¢ Data Ô¨Çow, data base, Ô¨Åle I/O, etc.

1.2. Introduction to Machine Learning

5

Statistics and Machine Learning in Python, Release 0.2

‚Ä¢ Python: the programming language. ‚Ä¢ Numpy: python library particularly useful for handling of raw numerical data (matrices,
mathematical operations). ‚Ä¢ Pandas: input/output, manipulation structured data (tables).
1.2.3 Statistics and applied mathematics
‚Ä¢ Linear model. ‚Ä¢ Non parametric statistics. ‚Ä¢ Linear algebra: matrix operations, inversion, eigenvalues.

1.3 Data analysis methodology

1. Formalize customer‚Äôs needs into a learning problem:
‚Ä¢ A target variable: supervised problem.
‚Äì Target is qualitative: classiÔ¨Åcation.
‚Äì Target is quantitative: regression.
‚Ä¢ No target variable: unsupervised problem
‚Äì Vizualisation of high-dimensional samples: PCA, manifolds learning, etc.
‚Äì Finding groups of samples (hidden structure): clustering.
2. Ask question about the datasets
‚Ä¢ Number of samples
‚Ä¢ Number of variables, types of each variable.
3. DeÔ¨Åne the sample
‚Ä¢ For prospective study formalize the experimental design: inclusion/exlusion criteria. The conditions that deÔ¨Åne the acquisition of the dataset.
‚Ä¢ For retrospective study formalize the experimental design: inclusion/exlusion criteria. The conditions that deÔ¨Åne the selection of the dataset.
4. In a document formalize (i) the project objectives; (ii) the required learning dataset (more speciÔ¨Åcally the input data and the target variables); (iii) The conditions that deÔ¨Åne the acquisition of the dataset. In this document, warn the customer that the learned algorithms may not work on new data acquired under different condition.
5. Read the learning dataset.
6. (i) Sanity check (basic descriptive statistics); (ii) data cleaning (impute missing data, recoding); Final Quality Control (QC) perform descriptive statistics and think ! (remove possible confounding variable, etc.).
7. Explore data (visualization, PCA) and perform basic univariate statistics for association between the target an input variables.
8. Perform more complex multivariate-machine learning.

6

Chapter 1. Introduction

Statistics and Machine Learning in Python, Release 0.2
9. Model validation using a left-out-sample strategy (cross-validation, etc.). 10. Apply on new data.

1.3. Data analysis methodology

7

Statistics and Machine Learning in Python, Release 0.2

8

Chapter 1. Introduction

CHAPTER
TWO
PYTHON LANGUAGE

Note: Click here to download the full example code
Source Kevin Markham https://github.com/justmarkham/python-reference Import libraries ‚Äî‚Äî‚Äî‚Äî‚Äî-
# generic import of math module import math math.sqrt(25)
# import a function from math import sqrt sqrt(25) # no longer have to reference the module
# import multiple functions at once from math import cos, floor
# import all functions in a module (generally discouraged) # from os import *
# define an alias import numpy as np
# show all functions in math module content = dir(math)

2.1 Basic operations

# Numbers 10 + 4 10 - 4 10 * 4 10 ** 4 10 / 4 10 / float(4) 5%4

# add (returns 14) # subtract (returns 6) # multiply (returns 40) # exponent (returns 10000) # divide (returns 2 because both types are int ) # divide (returns 2.5) # modulo (returns 1) - also known as the remainder

10 / 4 10 // 4

# true division (returns 2.5) # floor division (returns 2)

(continues on next page)

9

Statistics and Machine Learning in Python, Release 0.2
(continued from previous page)
# Boolean operations # comparisons (these return True) 5>3 5 >= 3 5 != 3 5 == 5
# boolean operations (these return True) 5 > 3 and 6 > 3 5 > 3 or 5 < 3 not False False or not False and True # evaluation order: not, and, or

2.2 Data types

# determine the type of an object

type(2)

# returns int

type(2.0)

# returns float

type( two ) # returns str

type(True)

# returns bool

type(None)

# returns NoneType

# check if an object is of a given type

isinstance(2.0, int)

# returns False

isinstance(2.0, (int, float)) # returns True

# convert an object to a given type float(2) int(2.9) str(2.9)

# zero, None, and empty containers are converted to False bool(0) bool(None) bool( ) # empty string bool([]) # empty list bool({}) # empty dictionary

# non-empty containers and non-zeros are converted to True bool(2) bool( two ) bool([2])

2.2.1 Lists
Different objects categorized along a certain ordered sequence, lists are ordered, iterable, mutable (adding or removing objects changes the list size), can contain multiple data types .. chunk-chap13-001

10

Chapter 2. Python language

Statistics and Machine Learning in Python, Release 0.2

# create an empty list (two ways) empty_list = [] empty_list = list()

# create a list simpsons = [ homer , marge , bart ]

# examine a list simpsons[0] # print element 0 ( homer ) len(simpsons) # returns the length (3)

# modify a list (does not return the list)

simpsons.append( lisa )

# append element to end

simpsons.extend([ itchy , scratchy ]) # append multiple elements to end

simpsons.insert(0, maggie )

# insert element at index 0 (shifts everything‚ê£

Àì‚Üíright)

simpsons.remove( bart )

# searches for first instance and removes it

simpsons.pop(0)

# removes element 0 and returns it

del simpsons[0]

# removes element 0 (does not return it)

simpsons[0] = krusty

# replace element 0

# concatenate lists (slower than extend method) neighbors = simpsons + [ ned , rod , todd ]

# find elements in a list simpsons.count( lisa ) simpsons.index( itchy )

# counts the number of instances # returns index of first instance

# list slicing [start:end:stride]

weekdays = [ mon , tues , wed , thurs , fri ]

weekdays[0]

# element 0

weekdays[0:3]

# elements 0, 1, 2

weekdays[:3]

# elements 0, 1, 2

weekdays[3:]

# elements 3, 4

weekdays[-1]

# last element (element 4)

weekdays[::2]

# every 2nd element (0, 2, 4)

weekdays[::-1]

# backwards (4, 3, 2, 1, 0)

# alternative method for returning the list backwards list(reversed(weekdays))

# sort a list in place (modifies but does not return the list)

simpsons.sort()

simpsons.sort(reverse=True) # sort in reverse

simpsons.sort(key=len)

# sort by a key

# return a sorted list (but does not modify the original list) sorted(simpsons) sorted(simpsons, reverse=True) sorted(simpsons, key=len)

# create a second reference to the same list

num = [1, 2, 3]

same_num = num

same_num[0] = 0

# modifies both num and same_num

# copy a list (three ways)

(continues on next page)

2.2. Data types

11

Statistics and Machine Learning in Python, Release 0.2

new_num = num.copy() new_num = num[:] new_num = list(num)

(continued from previous page)

# examine objects

id(num) == id(same_num) # returns True

id(num) == id(new_num) # returns False

num is same_num

# returns True

num is new_num

# returns False

num == same_num

# returns True

num == new_num

# returns True (their contents are equivalent)

# conatenate +, replicate * [1, 2, 3] + [4, 5, 6] ["a"] * 2 + ["b"] * 3

2.2.2 Tuples

Like lists, but their size cannot change: ordered, iterable, immutable, can contain multiple data types

# create a tuple digits = (0, 1, two ) digits = tuple([0, 1, two ]) zero = (0,)

# create a tuple directly # create a tuple from a list # trailing comma is required to indicate it s a tuple

# examine a tuple digits[2] len(digits) digits.count(0) digits.index(1)

# returns two # returns 3 # counts the number of instances of that value (1) # returns the index of the first instance of that value (1)

# elements of a tuple cannot be modified

# digits[2] = 2

# throws an error

# concatenate tuples digits = digits + (3, 4)

# create a single tuple with elements repeated (also works with lists)

(3, 4) * 2

# returns (3, 4, 3, 4)

# tuple unpacking bart = ( male , 10, simpson ) # create a tuple

2.2.3 Strings

A sequence of characters, they are iterable, immutable

# create a string s = str(42) s = I like you

# convert another data type into a string

(continues on next page)

12

Chapter 2. Python language

Statistics and Machine Learning in Python, Release 0.2

# examine a string

s[0]

# returns I

len(s)

# returns 10

(continued from previous page)

# string slicing like lists

s[:6]

# returns

s[7:]

# returns

s[-1]

# returns

I like you u

# basic string methods (does not modify the original string)

s.lower()

# returns i like you

s.upper()

# returns I LIKE YOU

s.startswith( I ) # returns True

s.endswith( you ) # returns True

s.isdigit()

# returns False (returns True if every character in the string is a‚ê£

Àì‚Üídigit)

s.find( like )

# returns index of first occurrence (2), but doesn t support regex

s.find( hate )

# returns -1 since not found

s.replace( like , love ) # replaces all instances of like with love

# split a string into a list of substrings separated by a delimiter

s.split( )

# returns [ I , like , you ]

s.split()

# same thing

s2 = a, an, the

s2.split( , )

# returns [ a , an , the ]

# join a list of strings into one string using a delimiter stooges = [ larry , curly , moe ]
.join(stooges) # returns larry curly moe

# concatenate strings

s3 = The meaning of life is

s4 = 42

s3 + + s4

# returns The meaning of life is 42

s3 + + str(42) # same thing

# remove whitespace from start and end of a string

s5 = ham and cheese

s5.strip()

# returns ham and cheese

# string substitutions: all of these return raining cats and dogs

raining %s and %s % ( cats , dogs )

# old way

raining {} and {} .format( cats , dogs )

# new way

raining {arg1} and {arg2} .format(arg1= cats ,arg2= dogs ) # named arguments

# string formatting

# more examples: http://mkaz.com/2012/10/10/python-string-format/

pi is {:.2f} .format(3.14159)

# returns pi is 3.14

2.2.4 Strings 2/2
Normal strings allow for escaped characters print( first line\nsecond line )

2.2. Data types

13

Statistics and Machine Learning in Python, Release 0.2

Out: first line second line
raw strings treat backslashes as literal characters print(r first line\nfirst line )
Out: first line\nfirst line
sequece of bytes are not strings, should be decoded before some operations s = b first line\nsecond line print(s) print(s.decode( utf-8 ).split())
Out: b first line\nsecond line [ first , line , second , line ]

2.2.5 Dictionaries

Dictionaries are structures which can contain multiple data types, and is ordered with key-value pairs: for each (unique) key, the dictionary outputs one value. Keys can be strings, numbers, or tuples, while the corresponding values can be any Python object. Dictionaries are: unordered, iterable, mutable
# create an empty dictionary (two ways) empty_dict = {} empty_dict = dict()

# create a dictionary (two ways) family = { dad : homer , mom : marge , size :6} family = dict(dad= homer , mom= marge , size=6)

# convert a list of tuples into a dictionary list_of_tuples = [( dad , homer ), ( mom , marge ), ( size , 6)] family = dict(list_of_tuples)

# examine a dictionary

family[ dad ]

# returns homer

len(family)

# returns 3

family.keys()

# returns list: [ dad , mom , size ]

family.values() # returns list: [ homer , marge , 6]

family.items()

# returns list of tuples:

# [( dad , homer ), ( mom , marge ), ( size , 6)]

mom in family # returns True

marge in family # returns False (only checks keys)

# modify a dictionary (does not return the dictionary)

(continues on next page)

14

Chapter 2. Python language

Statistics and Machine Learning in Python, Release 0.2

(continued from previous page)

family[ cat ] = snowball

# add a new entry

family[ cat ] = snowball ii

# edit an existing entry

del family[ cat ]

# delete an entry

family[ kids ] = [ bart , lisa ]

# value can be a list

family.pop( dad )

# removes an entry and returns the value ( homer )

family.update({ baby : maggie , grandpa : abe }) # add multiple entries

# accessing values more safely with get

family[ mom ]

# returns marge

family.get( mom )

# same thing

try:

family[ grandma ]

# throws an error

except KeyError as e:

print("Error", e)

family.get( grandma )

# returns None

family.get( grandma , not found ) # returns not found (the default)

# accessing a list element within a dictionary

family[ kids ][0]

# returns bart

family[ kids ].remove( lisa )

# removes lisa

# string substitution using a dictionary youngest child is %(baby)s % family # returns youngest child is maggie

Out: Error grandma

2.2.6 Sets

Like dictionaries, but with unique keys only (no corresponding values). They are: unordered, iterable, mutable, can contain multiple data types made up of unique elements (strings, numbers, or tuples)
# create an empty set empty_set = set()

# create a set

languages = { python , r , java }

# create a set directly

snakes = set([ cobra , viper , python ]) # create a set from a list

# examine a set len(languages) python in languages

# returns 3 # returns True

# set operations languages & snakes languages | snakes languages - snakes snakes - languages

# returns intersection: { python } # returns union: { cobra , r , java , viper , # returns set difference: { r , java } # returns set difference: { cobra , viper }

python }

# modify a set (does not return the set)

languages.add( sql )

# add a new element

(continues on next page)

2.2. Data types

15

Statistics and Machine Learning in Python, Release 0.2

(continued from previous page)

languages.add( r )

# try to add an existing element (ignored, no error)

languages.remove( java ) # remove an element

try:

languages.remove( c )

# try to remove a non-existing element (throws an error)

except KeyError as e:

print("Error", e)

languages.discard( c )

# removes an element if present, but ignored otherwise

languages.pop()

# removes and returns an arbitrary element

languages.clear()

# removes all elements

languages.update( go , spark ) # add multiple elements (can also pass a list or set)

# get a sorted list of unique elements from a list sorted(set([9, 0, 2, 1, 0])) # returns [0, 1, 2, 9]

Out: Error c

2.3 Execution control statements
2.3.1 Conditional statements
x=3 # if statement if x > 0:
print( positive )
# if/else statement if x > 0:
print( positive ) else:
print( zero or negative )
# if/elif/else statement if x > 0:
print( positive ) elif x == 0:
print( zero ) else:
print( negative )
# single-line if statement (sometimes discouraged) if x > 0: print( positive )
# single-line if/else statement (sometimes discouraged) # known as a ternary operator positive if x > 0 else zero or negative
Out:
positive positive
16

(continues on next page)
Chapter 2. Python language

Statistics and Machine Learning in Python, Release 0.2

positive positive

(continued from previous page)

2.3.2 Loops

Loops are a set of instructions which repeat until termination conditions are met. This can include iterating through all values in an object, go through a range of values, etc

# range returns a list of integers

range(0, 3) # returns [0, 1, 2]: includes first value but excludes second value

range(3)

# same thing: starting at zero is the default

range(0, 5, 2) # returns [0, 2, 4]: third argument specifies the stride

# for loop (not recommended) fruits = [ apple , banana , for i in range(len(fruits)):
print(fruits[i].upper())

cherry ]

# alternative for loop (recommended style) for fruit in fruits:
print(fruit.upper())

# use range when iterating over a large sequence to avoid actually creating the integer‚ê£ Àì‚Üílist in memory for i in range(10**6):
pass

# iterate through two things at once (using tuple unpacking) family = { dad : homer , mom : marge , size :6} for key, value in family.items():
print(key, value)

# use enumerate if you need to access the index value within the loop for index, fruit in enumerate(fruits):
print(index, fruit)

# for/else loop for fruit in fruits:
if fruit == banana : print("Found the banana!") break # exit the loop and skip the else block
else: # this block executes ONLY if the for loop completes without hitting print("Can t find the banana")

break

# while loop

count = 0

while count < 5:

print("This will print 5 times")

count += 1

# equivalent to count = count + 1

Out:

2.3. Execution control statements

17

Statistics and Machine Learning in Python, Release 0.2

APPLE BANANA CHERRY APPLE BANANA CHERRY dad homer mom marge size 6 0 apple 1 banana 2 cherry Can t find the banana Found the banana! This will print 5 times This will print 5 times This will print 5 times This will print 5 times This will print 5 times
2.3.3 Exceptions handling
dct = dict(a=[1, 2], b=[4, 5])
key = c try:
dct[key] except:
print("Key %s is missing. Add it with empty value" % key) dct[ c ] = []
print(dct)
Out:
Key c is missing. Add it with empty value { a : [1, 2], b : [4, 5], c : []}

2.4 Functions

Functions are sets of instructions launched when called upon, they can have multiple input values and a return value
# define a function with no arguments and no return values def print_text():
print( this is text )

# call the function print_text()

# define a function with one argument and no return values def print_this(x):

(continues on next page)

18

Chapter 2. Python language

Statistics and Machine Learning in Python, Release 0.2

print(x)

(continued from previous page)

# call the function

print_this(3)

# prints 3

n = print_this(3) # prints 3, but doesn t assign 3 to n

# because the function has no return statement

# define a function with one argument and one return value def square_this(x):
return x ** 2

# include an optional docstring to describe the effect of a function def square_this(x):
"""Return the square of a number.""" return x ** 2

# call the function square_this(3) var = square_this(3)

# prints 9 # assigns 9 to var, but does not print 9

# default arguments def power_this(x, power=2):
return x ** power

power_this(2) # 4 power_this(2, 3) # 8

# use pass as a placeholder if you haven t written the function body def stub():
pass

# return two values from a single function def min_max(nums):
return min(nums), max(nums)

# return values can be assigned to a single variable as a tuple

nums = [1, 2, 3]

min_max_num = min_max(nums)

# min_max_num = (1, 3)

# return values can be assigned into multiple variables using tuple unpacking min_num, max_num = min_max(nums) # min_num = 1, max_num = 3

Out:
this is text 3 3

2.4. Functions

19

Statistics and Machine Learning in Python, Release 0.2

2.5 List comprehensions, iterators, etc.

2.5.1 List comprehensions

Process which affects whole lists without iterating through loops. For more: http:// python-3-patterns-idioms-test.readthedocs.io/en/latest/Comprehensions.html
# for loop to create a list of cubes nums = [1, 2, 3, 4, 5] cubes = [] for num in nums:
cubes.append(num**3)

# equivalent list comprehension cubes = [num**3 for num in nums]

# [1, 8, 27, 64, 125]

# for loop to create a list of cubes of even numbers cubes_of_even = [] for num in nums:
if num % 2 == 0: cubes_of_even.append(num**3)

# equivalent list comprehension # syntax: [expression for variable in iterable if condition] cubes_of_even = [num**3 for num in nums if num % 2 == 0] # [8, 64]

# for loop to cube even numbers and square odd numbers cubes_and_squares = [] for num in nums:
if num % 2 == 0: cubes_and_squares.append(num**3)
else: cubes_and_squares.append(num**2)

# equivalent list comprehension (using a ternary expression) # syntax: [true_condition if condition else false_condition for variable in iterable] cubes_and_squares = [num**3 if num % 2 == 0 else num**2 for num in nums] # [1, 8, 9,‚ê£ Àì‚Üí64, 25]

# for loop to flatten a 2d-matrix matrix = [[1, 2], [3, 4]] items = [] for row in matrix:
for item in row: items.append(item)

# equivalent list comprehension items = [item for row in matrix
for item in row]

# [1, 2, 3, 4]

# set comprehension fruits = [ apple , banana , cherry ] unique_lengths = {len(fruit) for fruit in fruits}

# {5, 6}

# dictionary comprehension fruit_lengths = {fruit:len(fruit) for fruit in fruits} Àì‚Üí : 6, cherry : 6}

# { apple : 5, banana (continues on next page)

20

Chapter 2. Python language

Statistics and Machine Learning in Python, Release 0.2
(continued from previous page)

2.6 Regular expression

1. Compile Regular expression with a patetrn
import re
# 1. compile Regular expression with a patetrn regex = re.compile("^.+(sub-.+)_(ses-.+)_(mod-.+)")
2. Match compiled RE on string Capture the pattern anyprefixsub-<subj id>_ses-<session id>_<modality> strings = ["abcsub-033_ses-01_mod-mri", "defsub-044_ses-01_mod-mri", "ghisub-055_ses-02_ Àì‚Üímod-ctscan" ] print([regex.findall(s)[0] for s in strings])
Out: [( sub-033 , ses-01 , mod-mri ), ( sub-044 , ses-01 , mod-mri ), ( sub-055 , ses-02 , Àì‚Üí mod-ctscan )]
Match methods on compiled regular expression

Method/Attribute match(string) search(string) Ô¨Åndall(string) Ô¨Ånditer(string)

Purpose Determine if the RE matches at the beginning of the string. Scan through a string, looking for any location where this RE matches. Find all substrings where the RE matches, and returns them as a list. Find all substrings where the RE matches, and returns them as an iterator.

2. Replace compiled RE on string
regex = re.compile("(sub-[^_]+)") # match (sub-...)_ print([regex.sub("SUB-", s) for s in strings])

regex.sub("SUB-", "toto")

Out: [ abcSUB-_ses-01_mod-mri , defSUB-_ses-01_mod-mri , ghiSUB-_ses-02_mod-ctscan ]

Replace all non-alphanumeric characters in a string re.sub( [^0-9a-zA-Z]+ , , h^&ell .,|o w]{+orld )

2.6. Regular expression

21

Statistics and Machine Learning in Python, Release 0.2
2.7 System programming
2.7.1 Operating system interfaces (os)
import os
Current working directory # Get the current working directory cwd = os.getcwd() print(cwd) # Set the current working directory os.chdir(cwd)
Out: /home/edouard/git/pystatsml/python_lang
Temporary directory import tempfile tmpdir = tempfile.gettempdir()
Join paths mytmpdir = os.path.join(tmpdir, "foobar") # list containing the names of the entries in the directory given by path. os.listdir(tmpdir)
Create a directory if not os.path.exists(mytmpdir):
os.mkdir(mytmpdir) os.makedirs(os.path.join(tmpdir, "foobar", "plop", "toto"), exist_ok=True)

2.7.2 File input/output
filename = os.path.join(mytmpdir, "myfile.txt") print(filename)
# Write lines = ["Dans python tout est bon", "Enfin, presque"]
## write line by line fd = open(filename, "w") fd.write(lines[0] + "\n") fd.write(lines[1]+ "\n") fd.close()
22

(continues on next page)
Chapter 2. Python language

Statistics and Machine Learning in Python, Release 0.2

## use a context manager to automatically close your file with open(filename, w ) as f:
for line in lines: f.write(line + \n )

(continued from previous page)

# Read ## read one line at a time (entire file does not have to fit into memory) f = open(filename, "r") f.readline() # one string per line (including newlines) f.readline() # next line f.close()

## read one line at a time (entire file does not have to fit into memory) f = open(filename, r ) f.readline() # one string per line (including newlines) f.readline() # next line f.close()

## read the whole file at once, return a list of lines f = open(filename, r ) f.readlines() # one list, each line is one string f.close()

## use list comprehension to duplicate readlines without reading entire file at once f = open(filename, r ) [line for line in f] f.close()

## use a context manager to automatically close your file with open(filename, r ) as f:
lines = [line for line in f]

Out: /tmp/foobar/myfile.txt

2.7.3 Explore, list directories
Walk
import os
WD = os.path.join(os.environ["HOME"], "git", "pystatsml", "datasets")
for dirpath, dirnames, filenames in os.walk(WD): print(dirpath, dirnames, filenames)
Out:
/home/edouard/git/pystatsml/datasets [ brain_volumes ] [ multiTimeline.csv , Advertising. Àì‚Üícsv , salary_table.csv , birthwt.txt , default of credit card clients.xls , Àì‚Üí eurodist.csv , birthwt.csv , iris.csv , readme.rst , s_curve.csv ] /home/edouard/git/pystatsml/datasets/brain_volumes [] [ brain_volumes.xlsx , gm.csv , Àì‚Üí brain_volumes.csv , wm.csv , demo.csv , csf.csv ]

2.7. System programming

23

Statistics and Machine Learning in Python, Release 0.2
glob, basename and Ô¨Åle extension
import glob
filenames = glob.glob(os.path.join(os.environ["HOME"], "git", "pystatsml", "datasets", "*", "tissue-*.csv"))
# take basename then remove extension basenames = [os.path.splitext(os.path.basename(f))[0] for f in filenames] print(basenames)
Out: []
shutil - High-level Ô¨Åle operations
import shutil
src = os.path.join(tmpdir, "foobar", "myfile.txt") dst = os.path.join(tmpdir, "foobar", "plop", "myfile.txt") print("copy %s to %s" % (src, dst))
shutil.copy(src, dst)
print("File %s exists ?" % dst, os.path.exists(dst))
src = os.path.join(tmpdir, "foobar", "plop") dst = os.path.join(tmpdir, "plop2") print("copy tree %s under %s" % (src, dst))
try: shutil.copytree(src, dst)
shutil.rmtree(dst)
shutil.move(src, dst) except (FileExistsError, FileNotFoundError) as e:
pass
Out: copy /tmp/foobar/myfile.txt to /tmp/foobar/plop/myfile.txt File /tmp/foobar/plop/myfile.txt exists ? True copy tree /tmp/foobar/plop under /tmp/plop2
2.7.4 Command execution with subprocess
‚Ä¢ For more advanced use cases, the underlying Popen interface can be used directly. ‚Ä¢ Run the command described by args. ‚Ä¢ Wait for command to complete ‚Ä¢ return a CompletedProcess instance.

24

Chapter 2. Python language

Statistics and Machine Learning in Python, Release 0.2

‚Ä¢ Does not capture stdout or stderr by default. To do so, pass PIPE for the stdout and/or stderr arguments.
import subprocess
# doesn t capture output p = subprocess.run(["ls", "-l"]) print(p.returncode)
# Run through the shell. subprocess.run("ls -l", shell=True)
# Capture output out = subprocess.run(["ls", "-a", "/"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT) # out.stdout is a sequence of bytes that should be decoded into a utf-8 string print(out.stdout.decode( utf-8 ).split("\n")[:5])
Out:
0 [ . , .. , bin , boot , cdrom ]

2.7.5 Multiprocessing and multithreading
Process A process is a name given to a program instance that has been loaded into memory and managed by the operating system. Process = address space + execution context (thread of control) Process address space (segments):
‚Ä¢ Code. ‚Ä¢ Data (static/global). ‚Ä¢ Heap (dynamic memory allocation). ‚Ä¢ Stack. Execution context: ‚Ä¢ Data registers. ‚Ä¢ Stack pointer (SP). ‚Ä¢ Program counter (PC). ‚Ä¢ Working Registers. OS Scheduling of processes: context switching (ie. save/load Execution context) Pros/cons ‚Ä¢ Context switching expensive. ‚Ä¢ (potentially) complex data sharing (not necessary true). ‚Ä¢ Cooperating processes - no need for memory protection (separate address
spaces).

2.7. System programming

25

Statistics and Machine Learning in Python, Release 0.2
‚Ä¢ Relevant for parrallel computation with memory allocation.
Threads
‚Ä¢ Threads share the same address space (Data registers): access to code, heap and (global) data.
‚Ä¢ Separate execution stack, PC and Working Registers.
Pros/cons
‚Ä¢ Faster context switching only SP, PC and Working Registers.
‚Ä¢ Can exploit Ô¨Åne-grain concurrency
‚Ä¢ Simple data sharing through the shared address space.
‚Ä¢ Precautions have to be taken or two threads will write to the same memory at the same time. This is what the global interpreter lock (GIL) is for.
‚Ä¢ Relevant for GUI, I/O (Network, disk) concurrent operation
In Python ‚Ä¢ The threading module uses threads. ‚Ä¢ The multiprocessing module uses processes.
Multithreading
import time import threading
def list_append(count, sign=1, out_list=None): if out_list is None: out_list = list() for i in range(count): out_list.append(sign * i) sum(out_list) # do some computation return out_list
size = 10000 # Number of numbers to add
out_list = list() # result is a simple list thread1 = threading.Thread(target=list_append, args=(size, 1, out_list, )) thread2 = threading.Thread(target=list_append, args=(size, -1, out_list, ))
startime = time.time() # Will execute both in parallel thread1.start() thread2.start() # Joins threads back to the parent process thread1.join() thread2.join() print("Threading ellapsed time ", time.time() - startime)
print(out_list[:10])
Out:

26

Chapter 2. Python language

Statistics and Machine Learning in Python, Release 0.2
Threading ellapsed time 1.685194492340088 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
Multiprocessing
import multiprocessing
# Sharing requires specific mecanism out_list1 = multiprocessing.Manager().list() p1 = multiprocessing.Process(target=list_append, args=(size, 1, None)) out_list2 = multiprocessing.Manager().list() p2 = multiprocessing.Process(target=list_append, args=(size, -1, None))
startime = time.time() p1.start() p2.start() p1.join() p2.join() print("Multiprocessing ellapsed time ", time.time() - startime)
# print(out_list[:10]) is not availlable
Out:
Multiprocessing ellapsed time 0.38483119010925293
Sharing object between process with Managers Managers provide a way to create data which can be shared between different processes, including sharing over a network between processes running on different machines. A manager object controls a server process which manages shared objects.
import multiprocessing import time
size = int(size / 100) # Number of numbers to add
# Sharing requires specific mecanism out_list = multiprocessing.Manager().list() p1 = multiprocessing.Process(target=list_append, args=(size, 1, out_list)) p2 = multiprocessing.Process(target=list_append, args=(size, -1, out_list))
startime = time.time()
p1.start() p2.start()
p1.join() p2.join()
print(out_list[:10])
print("Multiprocessing with shared object ellapsed time ", time.time() - startime)
Out:

2.7. System programming

27

Statistics and Machine Learning in Python, Release 0.2

[0, 0, 1, -1, 2, -2, 3, -3, 4, -4] Multiprocessing with shared object ellapsed time 1.1143779754638672

2.8 Scripts and argument parsing

Example, the word count script

import os import os.path import argparse import re import pandas as pd

if __name__ == "__main__": # parse command line options output = "word_count.csv" parser = argparse.ArgumentParser() parser.add_argument( -i , --input , help= list of input files. , nargs= + , type=str) parser.add_argument( -o , --output , help= output csv file (default %s) type=str, default=output) options = parser.parse_args()

% output,

if options.input is None : parser.print_help() raise SystemExit("Error: input files are missing")
else: filenames = [f for f in options.input if os.path.isfile(f)]

# Match words regex = re.compile("[a-zA-Z]+")

count = dict() for filename in filenames:
fd = open(filename, "r") for line in fd:
for word in regex.findall(line.lower()): if not word in count: count[word] = 1 else: count[word] += 1

fd = open(options.output, "w")

# Pandas df = pd.DataFrame([[k, count[k]] for k in count], columns=["word", "count"]) df.to_csv(options.output, index=False)

28

Chapter 2. Python language

2.9 Networking
# TODO

Statistics and Machine Learning in Python, Release 0.2

2.9.1 FTP

# Full FTP features with ftplib import ftplib ftp = ftplib.FTP("ftp.cea.fr") ftp.login() ftp.cwd( /pub/unati/people/educhesnay/pystatml ) ftp.retrlines( LIST )
fd = open(os.path.join(tmpdir, "README.md"), "wb") ftp.retrbinary( RETR README.md , fd.write) fd.close() ftp.quit()
# File download urllib import urllib.request ftp_url = ftp://ftp.cea.fr/pub/unati/people/educhesnay/pystatml/README.md urllib.request.urlretrieve(ftp_url, os.path.join(tmpdir, "README2.md"))

Out:

-rw-r--r-- 1 ftp

ftp

1282 Apr 15 22:33 README.md

-rw-r--r-- 1 ftp

ftp

6301451 Mar 14 00:29‚ê£

Àì‚ÜíStatisticsMachineLearningPythonDraft.pdf

2.9.2 HTTP
# TODO

2.9.3 Sockets
# TODO

2.9.4 xmlrpc
# TODO

2.10 Modules and packages

A module is a Python Ô¨Åle. A package is a directory which MUST contain a special Ô¨Åle called __init__.py
To import, extend variable PYTHONPATH:

2.9. Networking

29

Statistics and Machine Learning in Python, Release 0.2

export PYTHONPATH=path_to_parent_python_module:${PYTHONPATH}
Or
import sys sys.path.append("path_to_parent_python_module")
The __init__.py Ô¨Åle can be empty. But you can set which modules the package exports as the API, while keeping other modules internal, by overriding the __all__ variable, like so: parentmodule/__init__.py Ô¨Åle: from . import submodule1 from . import submodule2
from .submodule3 import function1 from .submodule3 import function2
__all__ = ["submodule1", "submodule2", "function1", "function2"]
User can import:
import parentmodule.submodule1 import parentmodule.function1
Python Unit Testing

2.11 Object Oriented Programming (OOP)

Sources ‚Ä¢ http://python-textbok.readthedocs.org/en/latest/Object_Oriented_Programming.html
Principles ‚Ä¢ Encapsulate data (attributes) and code (methods) into objects. ‚Ä¢ Class = template or blueprint that can be used to create objects. ‚Ä¢ An object is a speciÔ¨Åc instance of a class. ‚Ä¢ Inheritance: OOP allows classes to inherit commonly used state and behaviour from other classes. Reduce code duplication ‚Ä¢ Polymorphism: (usually obtained through polymorphism) calling code is agnostic as to whether an object belongs to a parent class or one of its descendants (abstraction, modularity). The same method called on 2 objects of 2 different classes will behave differently.

import math

class Shape2D: def area(self): raise NotImplementedError()

# __init__ is a special method called the constructor

(continues on next page)

30

Chapter 2. Python language

Statistics and Machine Learning in Python, Release 0.2

# Inheritance + Encapsulation class Square(Shape2D):
def __init__(self, width): self.width = width
def area(self): return self.width ** 2
class Disk(Shape2D): def __init__(self, radius): self.radius = radius
def area(self): return math.pi * self.radius ** 2
shapes = [Square(2), Disk(3)]
# Polymorphism print([s.area() for s in shapes])
s = Shape2D() try:
s.area() except NotImplementedError as e:
print("NotImplementedError")
Out:
[4, 28.274333882308138] NotImplementedError

(continued from previous page)

2.12 Exercises
2.12.1 Exercise 1: functions
Create a function that acts as a simple calulator If the operation is not speciÔ¨Åed, default to addition If the operation is misspeciÔ¨Åed, return an prompt message Ex: calc(4,5,"multiply") returns 20 Ex: calc(3,5) returns 8 Ex: calc(1, 2, "something") returns error message
2.12.2 Exercise 2: functions + list + loop
Given a list of numbers, return a list where all adjacent duplicate elements have been reduced to a single element. Ex: [1, 2, 2, 3, 2] returns [1, 2, 3, 2]. You may create a new list or modify the passed in list. Remove all duplicate values (adjacent or not) Ex: [1, 2, 2, 3, 2] returns [1, 2, 3]

2.12. Exercises

31

Statistics and Machine Learning in Python, Release 0.2
2.12.3 Exercise 3: File I/O
1. Copy/paste the BSD 4 clause license (https://en.wikipedia.org/wiki/BSD_licenses) into a text Ô¨Åle. Read, the Ô¨Åle and count the occurrences of each word within the Ô¨Åle. Store the words‚Äô occurrence number in a dictionary. 2. Write an executable python command count_words.py that parse a list of input Ô¨Åles provided after --input parameter. The dictionary of occurrence is save in a csv Ô¨Åle provides by --output. with default value word_count.csv. Use: - open - regular expression - argparse (https://docs. python.org/3/howto/argparse.html)
2.12.4 Exercise 4: OOP
1. Create a class Employee with 2 attributes provided in the constructor: name, years_of_service. With one method salary with is obtained by 1500 + 100 * years_of_service.
2. Create a subclass Manager which redeÔ¨Åne salary method 2500 + 120 * years_of_service. 3. Create a small dictionary-nosed database where the key is the employee‚Äôs name. Populate
the database with: samples = Employee(‚Äòlucy‚Äô, 3), Employee(‚Äòjohn‚Äô, 1), Manager(‚Äòjulie‚Äô, 10), Manager(‚Äòpaul‚Äô, 3) 4. Return a table of made name, salary rows, i.e. a list of list [[name, salary]] 5. Compute the average salary Total running time of the script: ( 0 minutes 4.315 seconds)

32

Chapter 2. Python language

CHAPTER
THREE
SCIENTIFIC PYTHON

Note: Click here to download the full example code

3.1 Numpy: arrays and matrices
NumPy is an extension to the Python programming language, adding support for large, multidimensional (numerical) arrays and matrices, along with a large library of high-level mathematical functions to operate on these arrays. Sources:
‚Ä¢ Kevin Markham: https://github.com/justmarkham
import numpy as np

3.1.1 Create arrays

Create ndarrays from lists. note: every element must be the same type (will be converted if possible)

data1 = [1, 2, 3, 4, 5] arr1 = np.array(data1) data2 = [range(1, 5), range(5, 9)] arr2 = np.array(data2) arr2.tolist()

# list # 1d array # list of lists # 2d array # convert array back to list

create special arrays
np.zeros(10) np.zeros((3, 6)) np.ones(10) np.linspace(0, 1, 5) np.logspace(0, 3, 4)

# 0 to 1 (inclusive) with 5 points # 10^0 to 10^3 (inclusive) with 4 points

arange is like range, except it returns an array (not a list)
int_array = np.arange(5) float_array = int_array.astype(float)

33

Statistics and Machine Learning in Python, Release 0.2

3.1.2 Examining arrays

arr1.dtype arr2.dtype arr2.ndim arr2.shape arr2.size len(arr2)

# float64 # int32 #2 # (2, 4) - axis 0 is rows, axis 1 is columns # 8 - total number of elements # 2 - size of first dimension (aka axis)

3.1.3 Reshaping
arr = np.arange(10, dtype=float).reshape((2, 5)) print(arr.shape) print(arr.reshape(5, 2))
Out:
(2, 5) [[0. 1.] [2. 3.] [4. 5.] [6. 7.] [8. 9.]]
Add an axis
a = np.array([0, 1]) a_col = a[:, np.newaxis] print(a_col) #or a_col = a[:, None]
Out:
[[0] [1]]
Transpose
print(a_col.T)
Out:
[[0 1]]
Flatten: always returns a Ô¨Çat copy of the orriginal array
arr_flt = arr.flatten() arr_flt[0] = 33 print(arr_flt) print(arr)
Out:

34

Chapter 3. ScientiÔ¨Åc Python

Statistics and Machine Learning in Python, Release 0.2

[33. 1. 2. 3. 4. 5. 6. 7. 8. 9.] [[0. 1. 2. 3. 4.] [5. 6. 7. 8. 9.]]
Ravel: returns a view of the original array whenever possible.
arr_flt = arr.ravel() arr_flt[0] = 33 print(arr_flt) print(arr)
Out:
[33. 1. 2. 3. 4. 5. 6. 7. 8. 9.] [[33. 1. 2. 3. 4.] [ 5. 6. 7. 8. 9.]]

3.1.4 Stack arrays
Stack Ô¨Çat arrays in columns
a = np.array([0, 1]) b = np.array([2, 3])
ab = np.stack((a, b)).T print(ab)
# or np.hstack((a[:, None], b[:, None]))
Out:
[[0 2] [1 3]]

3.1.5 Selection

Single item

arr = np.arange(10, dtype=float).reshape((2, 5))

arr[0] arr[0, 3] arr[0][3]

# 0th element (slices like a list) # row 0, column 3: returns 4 # alternative syntax

Slicing Syntax: start:stop:step with start (default 0) stop (default last) step (default 1)

3.1. Numpy: arrays and matrices

35

Statistics and Machine Learning in Python, Release 0.2

arr[0, :]

# row 0: returns 1d array ([1, 2, 3, 4])

arr[:, 0]

# column 0: returns 1d array ([1, 5])

arr[:, :2] # columns strictly before index 2 (2 first columns)

arr[:, 2:] # columns after index 2 included

arr2 = arr[:, 1:4] # columns between index 1 (included) and 4 (excluded)

print(arr2)

Out:
[[1. 2. 3.] [6. 7. 8.]]

Slicing returns a view (not a copy)
arr2[0, 0] = 33 print(arr2) print(arr)

Out:

[[33. 2. [ 6. 7. [[ 0. 33. [ 5. 6.

3.] 8.]] 2. 3. 7. 8.

4.] 9.]]

Row 0: reverse order
print(arr[0, ::-1])
# The rule of thumb here can be: in the context of lvalue indexing (i.e. the indices are‚ê£ Àì‚Üíplaced in the left hand side value of an assignment), no view or copy of the array is‚ê£ Àì‚Üícreated (because there is no need to). However, with regular values, the above rules‚ê£ Àì‚Üífor creating views does apply.

Out: [ 4. 3. 2. 33. 0.]

Fancy indexing: Integer or boolean array indexing

Fancy indexing returns a copy not a view.

Integer array indexing

arr2 = arr[:, [1,2,3]] print(arr2) arr2[0, 0] = 44 print(arr2) print(arr)

# return a copy

Out:
[[33. 2. 3.] [ 6. 7. 8.]]

36

(continues on next page)
Chapter 3. ScientiÔ¨Åc Python

Statistics and Machine Learning in Python, Release 0.2

[[44. 2. [ 6. 7. [[ 0. 33. [ 5. 6.

3.] 8.]] 2. 3. 7. 8.

4.] 9.]]

(continued from previous page)

Boolean arrays indexing
arr2 = arr[arr > 5] # return a copy
print(arr2) arr2[0] = 44 print(arr2) print(arr)

Out:
[33. 6. 7. 8. 9.] [44. 6. 7. 8. 9.] [[ 0. 33. 2. 3. 4.] [ 5. 6. 7. 8. 9.]]

However, In the context of lvalue indexing (left hand side value of an assignment) Fancy authorizes the modiÔ¨Åcation of the original array
arr[arr > 5] = 0 print(arr)

Out:
[[0. 0. 2. 3. 4.] [5. 0. 0. 0. 0.]]

Boolean arrays indexing continues

names = np.array([ Bob , Joe , Will , Bob ])

names == Bob

# returns a boolean array

names[names != Bob ]

# logical selection

(names == Bob ) | (names == Will ) # keywords "and/or" don t work with boolean arrays

names[names != Bob ] = Joe

# assign based on a logical selection

np.unique(names)

# set function

3.1.6 Vectorized operations

nums = np.arange(5)

nums * 10

# multiply each element by 10

nums = np.sqrt(nums)

# square root of each element

np.ceil(nums)

# also floor, rint (round to nearest int)

np.isnan(nums)

# checks for NaN

nums + np.arange(5)

# add element-wise

np.maximum(nums, np.array([1, -2, 3, -4, 5])) # compare element-wise

# Compute Euclidean distance between 2 vectors vec1 = np.random.randn(10)

(continues on next page)

3.1. Numpy: arrays and matrices

37

Statistics and Machine Learning in Python, Release 0.2

vec2 = np.random.randn(10) dist = np.sqrt(np.sum((vec1 - vec2) ** 2))

# math and stats

rnd = np.random.randn(4, 2) # random normals in 4x2 array

rnd.mean()

rnd.std()

rnd.argmin()

# index of minimum element

rnd.sum()

rnd.sum(axis=0)

# sum of columns

rnd.sum(axis=1)

# sum of rows

# methods for boolean arrays

(rnd > 0).sum()

# counts number of positive values

(rnd > 0).any()

# checks if any value is True

(rnd > 0).all()

# checks if all values are True

# random numbers

np.random.seed(12234)

# Set the seed

np.random.rand(2, 3)

# 2 x 3 matrix in [0, 1]

np.random.randn(10)

# random normals (mean 0, sd 1)

np.random.randint(0, 2, 10) # 10 randomly picked 0 or 1

(continued from previous page)

3.1.7 Broadcasting
Sources: https://docs.scipy.org/doc/numpy-1.13.0/user/basics.broadcasting.html Implicit conversion to allow operations on arrays of different sizes. - The smaller array is stretched or ‚Äúbroadcasted‚Äù across the larger array so that they have compatible shapes. - Fast vectorized operation in C instead of Python. - No needless copies.
Rules
Starting with the trailing axis and working backward, Numpy compares arrays dimensions. ‚Ä¢ If two dimensions are equal then continues ‚Ä¢ If one of the operand has dimension 1 stretches it to match the largest one ‚Ä¢ When one of the shapes runs out of dimensions (because it has less dimensions than the other shape), Numpy will use 1 in the comparison process until the other shape‚Äôs dimensions run out as well.
a = np.array([[ 0, 0, 0], [10, 10, 10], [20, 20, 20], [30, 30, 30]])
b = np.array([0, 1, 2])
print(a + b)
Out:

38

Chapter 3. ScientiÔ¨Åc Python

Statistics and Machine Learning in Python, Release 0.2

Fig. 1: Source: http://www.scipy-lectures.org

3.1. Numpy: arrays and matrices

39

Statistics and Machine Learning in Python, Release 0.2

[[ 0 1 2] [10 11 12] [20 21 22] [30 31 32]]

Examples Shapes of operands A, B and result:

A

(2d array): 5 x 4

B

(1d array):

1

Result (2d array): 5 x 4

A

(2d array): 5 x 4

B

(1d array):

4

Result (2d array): 5 x 4

A

(3d array): 15 x 3 x 5

B

(3d array): 15 x 1 x 5

Result (3d array): 15 x 3 x 5

A

(3d array): 15 x 3 x 5

B

(2d array):

3x5

Result (3d array): 15 x 3 x 5

A

(3d array): 15 x 3 x 5

B

(2d array):

3x1

Result (3d array): 15 x 3 x 5

3.1.8 Exercises
Given the array: X = np.random.randn(4, 2) # random normals in 4x2 array
‚Ä¢ For each column Ô¨Ånd the row index of the minimum value. ‚Ä¢ Write a function standardize(X) that return an array whose columns are centered and
scaled (by std-dev). Total running time of the script: ( 0 minutes 0.037 seconds)
Note: Click here to download the full example code

3.2 Pandas: data manipulation
It is often said that 80% of data analysis is spent on the cleaning and small, but important, aspect of data manipulation and cleaning with Pandas. Sources:
‚Ä¢ Kevin Markham: https://github.com/justmarkham

40

Chapter 3. ScientiÔ¨Åc Python

Statistics and Machine Learning in Python, Release 0.2

‚Ä¢ Pandas doc: http://pandas.pydata.org/pandas-docs/stable/index.html
Data structures
‚Ä¢ Series is a one-dimensional labeled array capable of holding any data type (integers, strings, Ô¨Çoating point numbers, Python objects, etc.). The axis labels are collectively referred to as the index. The basic method to create a Series is to call pd.Series([1,3,5,np.nan,6,8])
‚Ä¢ DataFrame is a 2-dimensional labeled data structure with columns of potentially different types. You can think of it like a spreadsheet or SQL table, or a dict of Series objects. It stems from the R data.frame() object.
from __future__ import print_function
import pandas as pd import numpy as np import matplotlib.pyplot as plt

3.2.1 Create DataFrame

columns = [ name , age , gender , job ]
user1 = pd.DataFrame([[ alice , 19, "F", "student"], [ john , 26, "M", "student"]],
columns=columns)
user2 = pd.DataFrame([[ eric , 22, "M", "student"], [ paul , 58, "F", "manager"]],
columns=columns)
user3 = pd.DataFrame(dict(name=[ peter , julie ], age=[33, 44], gender=[ M , F ], job=[ engineer , scientist ]))
print(user3)

Out:

name age gender 0 peter 33 1 julie 44

job M engineer F scientist

3.2.2 Combining DataFrames
Concatenate DataFrame
user1.append(user2) users = pd.concat([user1, user2, user3]) print(users)
Out:

3.2. Pandas: data manipulation

41

Statistics and Machine Learning in Python, Release 0.2

name age gender 0 alice 19 1 john 26 0 eric 22 1 paul 58 0 peter 33 1 julie 44

job F student M student M student F manager M engineer F scientist

Join DataFrame

user4 = pd.DataFrame(dict(name=[ alice , john , eric , julie ], height=[165, 180, 175, 171]))
print(user4)

Out:
name height 0 alice 165 1 john 180 2 eric 175 3 julie 171

Use intersection of keys from both frames merge_inter = pd.merge(users, user4, on="name") print(merge_inter)

Out:

name age gender 0 alice 19 1 john 26 2 eric 22 3 julie 44

job height F student 165 M student 180 M student 175 F scientist 171

Use union of keys from both frames
users = pd.merge(users, user4, on="name", how= outer ) print(users)

Out:

name age gender 0 alice 19 1 john 26 2 eric 22 3 paul 58 4 peter 33 5 julie 44

job height F student 165.0 M student 180.0 M student 175.0 F manager NaN M engineer NaN F scientist 171.0

Reshaping by pivoting

‚ÄúUnpivots‚Äù a DataFrame from wide format to long (stacked) format,

42

Chapter 3. ScientiÔ¨Åc Python

Statistics and Machine Learning in Python, Release 0.2

staked = pd.melt(users, id_vars="name", var_name="variable", value_name="value") print(staked)

Out:

name variable

value

0 alice

age

19

1 john

age

26

2 eric

age

22

3 paul

age

58

4 peter

age

33

5 julie

age

44

6 alice gender

F

7 john gender

M

8 eric gender

M

9 paul gender

F

10 peter gender

M

11 julie gender

F

12 alice

job student

13 john

job student

14 eric

job student

15 paul

job manager

16 peter

job engineer

17 julie

job scientist

18 alice height

165

19 john height

180

20 eric height

175

21 paul height

NaN

22 peter height

NaN

23 julie height

171

‚Äúpivots‚Äù a DataFrame from long (stacked) format to wide format, print(staked.pivot(index= name , columns= variable , values= value ))

Out:

variable age gender height

name

alice 19

F 165

eric

22

M 175

john

26

M 180

julie 44

F 171

paul

58

F NaN

peter 33

M NaN

job
student student student scientist manager engineer

3.2.3 Summarizing

# examine the users data

users type(users) users.head() users.tail()

# print the first 30 and last 30 rows # DataFrame # print the first 5 rows # print the last 5 rows

3.2. Pandas: data manipulation

(continues on next page)
43

Statistics and Machine Learning in Python, Release 0.2

(continued from previous page)

users.index users.columns users.dtypes users.shape users.values users.info()

# "the index" (aka "the labels") # column names (which is "an index") # data types of each column # number of rows and columns # underlying numpy array # concise summary (includes memory usage as of pandas 0.15.0)

Out:

<class pandas.core.frame.DataFrame >

Int64Index: 6 entries, 0 to 5

Data columns (total 5 columns):

name

6 non-null object

age

6 non-null int64

gender 6 non-null object

job

6 non-null object

height 4 non-null float64

dtypes: float64(1), int64(1), object(3)

memory usage: 288.0+ bytes

3.2.4 Columns selection

users[ gender ] type(users[ gender ]) users.gender

# select one column # Series # select one column using the DataFrame

# select multiple columns users[[ age , gender ]] my_cols = [ age , gender ] users[my_cols] type(users[my_cols])

# select two columns # or, create a list... # ...and use that list to select columns # DataFrame

3.2.5 Rows selection (basic)
iloc is strictly integer position based
df = users.copy() df.iloc[0] # first row df.iloc[0, 0] # first item of first row df.iloc[0, 0] = 55
for i in range(users.shape[0]): row = df.iloc[i] row.age *= 100 # setting a copy, and not the original frame data.
print(df) # df is not modified
Out:

44

Chapter 3. ScientiÔ¨Åc Python

Statistics and Machine Learning in Python, Release 0.2

name age gender 0 55 19 1 john 26 2 eric 22 3 paul 58 4 peter 33 5 julie 44

job height F student 165.0 M student 180.0 M student 175.0 F manager NaN M engineer NaN F scientist 171.0

ix supports mixed integer and label based access.

df = users.copy()

df.ix[0]

# first row

df.ix[0, "age"] # first item of first row

df.ix[0, "age"] = 55

for i in range(df.shape[0]): df.ix[i, "age"] *= 10

print(df) # df is modified

Out:

name age gender 0 alice 550 1 john 260 2 eric 220 3 paul 580 4 peter 330 5 julie 440

job height F student 165.0 M student 180.0 M student 175.0 F manager NaN M engineer NaN F scientist 171.0

3.2.6 Rows selection (Ô¨Åltering)

simple logical Ô¨Åltering

users[users.age < 20] young_bool = users.age < 20 young = users[young_bool] users[users.age < 20].job print(young)

# only show users with age < 20 # or, create a Series of booleans...
# ...and use that Series to filter rows # select one column from the filtered results

Out:

name age gender

job height

0 alice 19

F student 165.0

Advanced logical Ô¨Åltering

users[users.age < 20][[ age , job ]]

# select multiple columns

users[(users.age > 20) & (users.gender == M )] # use multiple conditions

users[users.job.isin([ student , engineer ])] # filter specific values

3.2. Pandas: data manipulation

45

Statistics and Machine Learning in Python, Release 0.2

3.2.7 Sorting

df = users.copy()

df.age.sort_values()

# only works for a Series

df.sort_values(by= age )

# sort rows by a specific column

df.sort_values(by= age , ascending=False) # use descending order instead

df.sort_values(by=[ job , age ])

# sort by multiple columns

df.sort_values(by=[ job , age ], inplace=True) # modify df

print(df)

Out:

name age gender 4 peter 33 3 paul 58 5 julie 44 0 alice 19 2 eric 22 1 john 26

job height M engineer NaN F manager NaN F scientist 171.0 F student 165.0 M student 175.0 M student 180.0

3.2.8 Descriptive statistics

Summarize all numeric columns print(df.describe())

Out:

age count mean std min 25% 50% 75% max

height 6.000000 33.666667 14.895189 19.000000 23.000000 29.500000 41.250000 58.000000

4.000000 172.750000
6.344289 165.000000 169.500000 173.000000 176.250000 180.000000

Summarize all columns
print(df.describe(include= all )) print(df.describe(include=[ object ])) # limit to one (or more) types

Out:

name count unique top freq mean std

age gender

6 6.000000

6

NaN

john

NaN

1

NaN

NaN 33.666667

NaN 14.895189

job

height

6

6 4.000000

2

4

NaN

F student

NaN

3

3

NaN

NaN

NaN 172.750000

NaN

NaN 6.344289

(continues on next page)

46

Chapter 3. ScientiÔ¨Åc Python

Statistics and Machine Learning in Python, Release 0.2

min 25% 50% 75% max
count unique top freq

NaN 19.000000 NaN

NaN 23.000000 NaN

NaN 29.500000 NaN

NaN 41.250000 NaN

NaN 58.000000 NaN

name gender

job

6

6

6

6

2

4

john

F student

1

3

3

NaN 165.000000 NaN 169.500000 NaN 173.000000 NaN 176.250000 NaN 180.000000

(continued from previous page)

Statistics per group (groupby) print(df.groupby("job").mean()) print(df.groupby("job")["age"].mean()) print(df.groupby("job").describe(include= all ))

Out:

age

height

job

engineer 33.000000

NaN

manager 58.000000

NaN

scientist 44.000000 171.000000

student 22.333333 173.333333

job

engineer 33.000000

manager

58.000000

scientist 44.000000

student

22.333333

Name: age, dtype: float64

name

age

‚ê£

Àì‚Üí ... gender

height

count unique top freq mean std min 25% 50% 75% max count unique top‚ê£

Àì‚Üífreq ... 25% 50% 75% max count unique top freq

mean

std min ‚ê£

Àì‚Üí25% 50% 75% max

job

‚ê£

Àì‚Üí ...

engineer

1

1 peter 1 NaN NaN NaN NaN NaN NaN NaN 1.0 NaN NaN ‚ê£

Àì‚ÜíNaN ... NaN NaN NaN NaN 0.0 NaN NaN NaN

NaN

NaN NaN ‚ê£

Àì‚ÜíNaN NaN NaN NaN

manager

1

1 paul 1 NaN NaN NaN NaN NaN NaN NaN 1.0 NaN NaN ‚ê£

Àì‚ÜíNaN ... NaN NaN NaN NaN 0.0 NaN NaN NaN

NaN

NaN NaN ‚ê£

Àì‚ÜíNaN NaN NaN NaN

scientist 1

1 julie 1 NaN NaN NaN NaN NaN NaN NaN 1.0 NaN NaN ‚ê£

Àì‚ÜíNaN ... NaN NaN NaN NaN 1.0 NaN NaN NaN 171.000000

NaN 171.0 171.

Àì‚Üí0 171.0 171.0 171.0

student

3

3 john 1 NaN NaN NaN NaN NaN NaN NaN 3.0 NaN NaN ‚ê£

Àì‚ÜíNaN ... NaN NaN NaN NaN 3.0 NaN NaN NaN 173.333333 7.637626 165.0 170.

Àì‚Üí0 175.0 177.5 180.0

[4 rows x 44 columns]

Groupby in a loop

3.2. Pandas: data manipulation

47

Statistics and Machine Learning in Python, Release 0.2

for grp, data in df.groupby("job"): print(grp, data)

Out:

engineer name age gender

job height

4 peter 33

M engineer NaN

manager name age gender

job height

3 paul 58

F manager NaN

scientist name age gender

job height

5 julie 44

F scientist 171.0

student name age gender

job height

0 alice 19

F student 165.0

2 eric 22

M student 175.0

1 john 26

M student 180.0

3.2.9 Quality check

Remove duplicate data

df = users.append(df.iloc[0], ignore_index=True)

print(df.duplicated())

# Series of booleans

# (True if a row is identical to a previous row)

df.duplicated().sum()

# count of duplicates

df[df.duplicated()]

# only show duplicates

df.age.duplicated()

# check a single column for duplicates

df.duplicated([ age , gender ]).sum() # specify columns for finding duplicates

df = df.drop_duplicates()

# drop duplicate rows

Out:
0 False 1 False 2 False 3 False 4 False 5 False 6 True dtype: bool

Missing data

# Missing values are often just excluded df = users.copy()

df.describe(include= all )

# excludes missing values

# find missing values in a Series

df.height.isnull()

# True if NaN, False otherwise

df.height.notnull()

# False if NaN, True otherwise

df[df.height.notnull()]

# only show rows where age is not NaN

(continues on next page)

48

Chapter 3. ScientiÔ¨Åc Python

Statistics and Machine Learning in Python, Release 0.2

df.height.isnull().sum() # count the missing values

# find missing values in a DataFrame

df.isnull()

# DataFrame of booleans

df.isnull().sum()

# calculate the sum of each column

(continued from previous page)

Strategy 1: drop missing values

df.dropna() df.dropna(how= all )

# drop a row if ANY values are missing # drop a row only if ALL values are missing

Strategy 2: Ô¨Åll in missing values
df.height.mean() df = users.copy() df.ix[df.height.isnull(), "height"] = df["height"].mean()
print(df)

Out:

name age gender 0 alice 19 1 john 26 2 eric 22 3 paul 58 4 peter 33 5 julie 44

job height F student 165.00 M student 180.00 M student 175.00 F manager 172.75 M engineer 172.75 F scientist 171.00

3.2.10 Rename values
df = users.copy() print(df.columns) df.columns = [ age , genre , travail , nom , taille ]
df.travail = df.travail.map({ student : etudiant , manager : manager , engineer : ingenieur , scientist : scientific })
# assert df.travail.isnull().sum() == 0

df[ travail ].str.contains("etu|inge") Out: Index([ name , age , gender , job , height ], dtype= object )

3.2.11 Dealing with outliers
size = pd.Series(np.random.normal(loc=175, size=20, scale=10)) # Corrupt the first 3 measures size[:3] += 500

3.2. Pandas: data manipulation

49

Statistics and Machine Learning in Python, Release 0.2
Based on parametric statistics: use the mean
Assume random variable follows the normal distribution Exclude data outside 3 standarddeviations: - Probability that a sample lies within 1 sd: 68.27% - Probability that a sample lies within 3 sd: 99.73% (68.27 + 2 * 15.73) size_outlr_mean = size.copy() size_outlr_mean[((size - size.mean()).abs() > 3 * size.std())] = size.mean() print(size_outlr_mean.mean())
Out: 248.48963819938044
Based on non-parametric statistics: use the median
Median absolute deviation (MAD), based on the median, is a robust non-parametric statistics. https://en.wikipedia.org/wiki/Median_absolute_deviation mad = 1.4826 * np.median(np.abs(size - size.median())) size_outlr_mad = size.copy() size_outlr_mad[((size - size.median()).abs() > 3 * mad)] = size.median() print(size_outlr_mad.mean(), size_outlr_mad.median())
Out: 173.80000467192673 178.7023568870694
3.2.12 File I/O
csv
import tempfile, os.path tmpdir = tempfile.gettempdir() csv_filename = os.path.join(tmpdir, "users.csv") users.to_csv(csv_filename, index=False) other = pd.read_csv(csv_filename)
Read csv from url
url = https://raw.github.com/neurospin/pystatsml/master/datasets/salary_table.csv salary = pd.read_csv(url)
Excel

50

Chapter 3. ScientiÔ¨Åc Python

Statistics and Machine Learning in Python, Release 0.2

xls_filename = os.path.join(tmpdir, "users.xlsx") users.to_excel(xls_filename, sheet_name= users , index=False)
pd.read_excel(xls_filename, sheetname= users )
# Multiple sheets with pd.ExcelWriter(xls_filename) as writer:
users.to_excel(writer, sheet_name= users , index=False) df.to_excel(writer, sheet_name= salary , index=False)
pd.read_excel(xls_filename, sheetname= users ) pd.read_excel(xls_filename, sheetname= salary )

SQL (SQLite)

import pandas as pd import sqlite3
db_filename = os.path.join(tmpdir, "users.db")

Connect conn = sqlite3.connect(db_filename)

Creating tables with pandas
url = https://raw.github.com/neurospin/pystatsml/master/datasets/salary_table.csv salary = pd.read_csv(url)
salary.to_sql("salary", conn, if_exists="replace")

Push modiÔ¨Åcations
cur = conn.cursor() values = (100, 14000, 5, Bachelor , N ) cur.execute("insert into salary values (?, ?, ?, ?, ?)", values) conn.commit()

Reading results into a pandas DataFrame
salary_sql = pd.read_sql_query("select * from salary;", conn) print(salary_sql.head())
pd.read_sql_query("select * from salary;", conn).tail() pd.read_sql_query( select * from salary where salary>25000; , conn) pd.read_sql_query( select * from salary where experience=16; , conn) pd.read_sql_query( select * from salary where education="Master"; , conn)

Out:

index salary experience education management

0

0 13876

1 Bachelor

Y

1

1 11608

1

Ph.D

N

2

2 18701

1

Ph.D

Y

(continues on next page)

3.2. Pandas: data manipulation

51

Statistics and Machine Learning in Python, Release 0.2

3

3 11283

4

4 11767

1 Master

N

1

Ph.D

N

(continued from previous page)

3.2.13 Exercises

Data Frame

1. Read the iris dataset at ‚Äòhttps://github.com/neurospin/pystatsml/tree/master/datasets/ iris.csv‚Äô

2. Print column names

3. Get numerical columns
4. For each species compute the mean of numerical columns and store it in a stats table like:

species sepal_length sepal_width petal_length petal_width

0

setosa

5.006

3.428

1.462

0.246

1 versicolor

5.936

2.770

4.260

1.326

2 virginica

6.588

2.974

5.552

2.026

Missing data
Add some missing data to the previous table users:
df = users.copy() df.ix[[0, 2], "age"] = None df.ix[[1, 3], "gender"] = None
1. Write a function fillmissing_with_mean(df) that Ô¨Åll all missing value of numerical column with the mean of the current columns.
2. Save the original users and ‚Äúimputed‚Äù frame in a single excel Ô¨Åle ‚Äúusers.xlsx‚Äù with 2 sheets: original, imputed.
Total running time of the script: ( 0 minutes 1.826 seconds)

3.3 Matplotlib: data visualization
Sources - Nicolas P. Rougier: http://www.labri.fr/perso/nrougier/teaching/matplotlib - https: //www.kaggle.com/benhamner/d/uciml/iris/python-data-visualizations

3.3.1 Basic plots
import numpy as np import matplotlib.pyplot as plt # inline plot (for jupyter)
52

(continues on next page)
Chapter 3. ScientiÔ¨Åc Python

%matplotlib inline
x = np.linspace(0, 10, 50) sinus = np.sin(x)
plt.plot(x, sinus) plt.show()

Statistics and Machine Learning in Python, Release 0.2
(continued from previous page)

plt.plot(x, sinus, "o") plt.show() # use plt.plot to get color / marker abbreviations

3.3. Matplotlib: data visualization

53

Statistics and Machine Learning in Python, Release 0.2
# Rapid multiplot
cosinus = np.cos(x) plt.plot(x, sinus, "-b", x, sinus, "ob", x, cosinus, "-r", x, cosinus, "or") plt.xlabel( this is x! ) plt.ylabel( this is y! ) plt.title( My First Plot ) plt.show()

# Step by step plt.plot(x, sinus, label= sinus , color= blue , linestyle= -- , linewidth=2) plt.plot(x, cosinus, label= cosinus , color= red , linestyle= - , linewidth=2) plt.legend() plt.show()

54

Chapter 3. ScientiÔ¨Åc Python

Statistics and Machine Learning in Python, Release 0.2

3.3.2 Scatter (2D) plots
Load dataset
import pandas as pd try:
salary = pd.read_csv("../datasets/salary_table.csv") except:
url = https://raw.github.com/neurospin/pystatsml/master/datasets/salary_table.csv salary = pd.read_csv(url)
df = salary
Simple scatter with colors
colors = colors_edu = { Bachelor : r , Master : g , Ph.D : blue } plt.scatter(df[ experience ], df[ salary ], c=df[ education ].apply(lambda x: colors[x]),‚ê£ Àì‚Üís=100)
<matplotlib.collections.PathCollection at 0x7fa627ddb438>

3.3. Matplotlib: data visualization

55

Statistics and Machine Learning in Python, Release 0.2

Scatter plot with colors and symbols
## Figure size plt.figure(figsize=(6,5))
## Define colors / sumbols manually symbols_manag = dict(Y= * , N= . ) colors_edu = { Bachelor : r , Master : g , Ph.D : blue }
## group by education x management => 6 groups for values, d in salary.groupby([ education , management ]):
edu, manager = values plt.scatter(d[ experience ], d[ salary ], marker=symbols_manag[manager], color=colors_ Àì‚Üíedu[edu],
s=150, label=manager+"/"+edu)
## Set labels plt.xlabel( Experience ) plt.ylabel( Salary ) plt.legend(loc=4) # lower right plt.show()

56

Chapter 3. ScientiÔ¨Åc Python

Statistics and Machine Learning in Python, Release 0.2

3.3.3 Saving Figures
### bitmap format plt.plot(x, sinus) plt.savefig("sinus.png") plt.close()
# Prefer vectorial format (SVG: Scalable Vector Graphics) can be edited with # Inkscape, Adobe Illustrator, Blender, etc. plt.plot(x, sinus) plt.savefig("sinus.svg") plt.close()
# Or pdf plt.plot(x, sinus) plt.savefig("sinus.pdf") plt.close()
3.3.4 Seaborn
Sources: - http://stanford.edu/~mwaskom/software/seaborn - https://elitedatascience.com/ python-seaborn-tutorial
If needed, install using: pip install -U --user seaborn

3.3. Matplotlib: data visualization

57

Statistics and Machine Learning in Python, Release 0.2
Boxplot Box plots are non-parametric: they display variation in samples of a statistical population without making any assumptions of the underlying statistical distribution.

Fig. 2: title import seaborn as sns sns.boxplot(x="education", y="salary", hue="management", data=salary) <matplotlib.axes._subplots.AxesSubplot at 0x7fa62372cb70>

58

Chapter 3. ScientiÔ¨Åc Python

Statistics and Machine Learning in Python, Release 0.2

sns.boxplot(x="management", y="salary", hue="education", data=salary) sns.stripplot(x="management", y="salary", hue="education", data=salary, jitter=True,‚ê£ Àì‚Üídodge=True, linewidth=1)# Jitter and split options separate datapoints according to‚ê£ Àì‚Üígroup"
<matplotlib.axes._subplots.AxesSubplot at 0x7fa623680780>

### Density plot with one Ô¨Ågure containing multiple axis One Ô¨Ågure can contain several axis, whose contain the graphic elements

3.3. Matplotlib: data visualization

59

Statistics and Machine Learning in Python, Release 0.2
# Set up the matplotlib figure: 3 x 1 axis
f, axes = plt.subplots(3, 1, figsize=(9, 9), sharex=True)
i=0 for edu, d in salary.groupby([ education ]):
sns.distplot(d.salary[d.management == "Y"], color="b", bins=10, label="Manager",‚ê£ Àì‚Üíax=axes[i])
sns.distplot(d.salary[d.management == "N"], color="r", bins=10, label="Employee",‚ê£ Àì‚Üíax=axes[i])
axes[i].set_title(edu) axes[i].set_ylabel( Density ) i += 1 ax = plt.legend()

60

Chapter 3. ScientiÔ¨Åc Python

Statistics and Machine Learning in Python, Release 0.2 Violin plot (distribution) ax = sns.violinplot(x="salary", data=salary)

Tune bandwidth ax = sns.violinplot(x="salary", data=salary, bw=.15)

ax = sns.violinplot(x="management", y="salary", hue="education", data=salary)

3.3. Matplotlib: data visualization

61

Statistics and Machine Learning in Python, Release 0.2

Tips dataset One waiter recorded information about each tip he received over a period of a few months working in one restaurant. He collected several variables:
import seaborn as sns #sns.set(style="whitegrid") tips = sns.load_dataset("tips") print(tips.head())
ax = sns.violinplot(x=tips["total_bill"])

total_bill tip sex smoker day time size

0

16.99 1.01 Female No Sun Dinner 2

1

10.34 1.66 Male No Sun Dinner 3

2

21.01 3.50 Male No Sun Dinner 3

3

23.68 3.31 Male No Sun Dinner 2

4

24.59 3.61 Female No Sun Dinner 4

62

Chapter 3. ScientiÔ¨Åc Python

Statistics and Machine Learning in Python, Release 0.2

Group by day ax = sns.violinplot(x="day", y="total_bill", data=tips, palette="muted")

Group by day and color by time (lunch vs dinner)
ax = sns.violinplot(x="day", y="total_bill", hue="time", data=tips, palette="muted",‚ê£ Àì‚Üísplit=True)

3.3. Matplotlib: data visualization

63

Statistics and Machine Learning in Python, Release 0.2
Pairwise scatter plots g = sns.PairGrid(salary, hue="management") g.map_diag(plt.hist) g.map_offdiag(plt.scatter) ax = g.add_legend()

64

Chapter 3. ScientiÔ¨Åc Python

Statistics and Machine Learning in Python, Release 0.2

3.3.5 Time series
import seaborn as sns sns.set(style="darkgrid")
# Load an example dataset with long-form data fmri = sns.load_dataset("fmri")
# Plot the responses for different events and regions

ax = sns.pointplot(x="timepoint", y="signal",

hue="region", style="event",

data=fmri)

# version 0.9

# sns.lineplot(x="timepoint", y="signal",

#

hue="region", style="event",

#

data=fmri)

3.3. Matplotlib: data visualization

65

Statistics and Machine Learning in Python, Release 0.2

66

Chapter 3. ScientiÔ¨Åc Python

CHAPTER
FOUR
STATISTICS

4.1 Univariate statistics
Basics univariate statistics are required to explore dataset: ‚Ä¢ Discover associations between a variable of interest and potential predictors. It is strongly recommended to start with simple univariate methods before moving to complex multivariate predictors. ‚Ä¢ Assess the prediction performances of machine learning predictors. ‚Ä¢ Most of the univariate statistics are based on the linear model which is one of the main model in machine learning.
4.1.1 Estimators of the main statistical measures
Mean
Properties of the expected value operator E(¬∑) of a random variable Ì†µÌ±ã

Ì†µÌ∞∏(Ì†µÌ±ã + Ì†µÌ±ê) = Ì†µÌ∞∏(Ì†µÌ±ã) + Ì†µÌ±ê Ì†µÌ∞∏(Ì†µÌ±ã + Ì†µÌ±å ) = Ì†µÌ∞∏(Ì†µÌ±ã) + Ì†µÌ∞∏(Ì†µÌ±å )
Ì†µÌ∞∏(Ì†µÌ±éÌ†µÌ±ã) = Ì†µÌ±éÌ†µÌ∞∏(Ì†µÌ±ã)

The estimator Ì†µ¬ØÌ±• on a sample of size Ì†µÌ±õ: Ì†µÌ±• = Ì†µÌ±•1, ..., Ì†µÌ±•Ì†µÌ±õ is given by

1 ‚àëÔ∏Å

Ì†µ¬ØÌ±• = Ì†µÌ±õ

Ì†µÌ±•Ì†µÌ±ñ

Ì†µÌ±ñ

Ì†µ¬ØÌ±• is itself a random variable with properties:

‚Ä¢ Ì†µÌ∞∏(Ì†µ¬ØÌ±•) = Ì†µ¬ØÌ±•,

‚Ä¢

Ì†µÌ±â Ì†µÌ±éÌ†µÌ±ü(Ì†µ¬ØÌ±•) =

Ì†µÌ±â

Ì†µÌ±éÌ†µÌ±ü(Ì†µÌ±ã Ì†µÌ±õ

)

.

Variance

Ì†µÌ±â Ì†µÌ±éÌ†µÌ±ü(Ì†µÌ±ã) = Ì†µÌ∞∏((Ì†µÌ±ã ‚àí Ì†µÌ∞∏(Ì†µÌ±ã))2) = Ì†µÌ∞∏(Ì†µÌ±ã2) ‚àí (Ì†µÌ∞∏(Ì†µÌ±ã))2

(4.1) (4.2) (4.3)

67

Statistics and Machine Learning in Python, Release 0.2

The estimator is

Ì†µÌºéÌ†µ2Ì±•

=

Ì†µÌ±õ

1 ‚àí

1

‚àëÔ∏Å (Ì†µÌ±•Ì†µÌ±ñ

‚àí

Ì†µ¬ØÌ±•)2

Ì†µÌ±ñ

Note here the subtracted 1 degree of freedom (df) in the divisor. In standard statistical practice, Ì†µÌ±ëÌ†µÌ±ì = 1 provides an unbiased estimator of the variance of a hypothetical inÔ¨Ånite population. With Ì†µÌ±ëÌ†µÌ±ì = 0 it instead provides a maximum likelihood estimate of the variance for normally distributed variables.

Standard deviation
‚àöÔ∏Ä Ì†µÌ±ÜÌ†µÌ±°Ì†µÌ±ë(Ì†µÌ±ã) = Ì†µÌ±â Ì†µÌ±éÌ†µÌ±ü(Ì†µÌ±ã) The estimator is simply Ì†µÌºéÌ†µÌ±• = ‚àöÔ∏ÄÌ†µÌºéÌ†µ2Ì±•.

Covariance

Ì†µÌ∞∂Ì†µÌ±úÌ†µÌ±£(Ì†µÌ±ã, Ì†µÌ±å ) = Ì†µÌ∞∏((Ì†µÌ±ã ‚àí Ì†µÌ∞∏(Ì†µÌ±ã))(Ì†µÌ±å ‚àí Ì†µÌ∞∏(Ì†µÌ±å ))) = Ì†µÌ∞∏(Ì†µÌ±ãÌ†µÌ±å ) ‚àí Ì†µÌ∞∏(Ì†µÌ±ã)Ì†µÌ∞∏(Ì†µÌ±å ).

Properties:

Cov(Ì†µÌ±ã, Ì†µÌ±ã) = Var(Ì†µÌ±ã) Cov(Ì†µÌ±ã, Ì†µÌ±å ) = Cov(Ì†µÌ±å, Ì†µÌ±ã) Cov(Ì†µÌ±êÌ†µÌ±ã, Ì†µÌ±å ) = Ì†µÌ±ê Cov(Ì†µÌ±ã, Ì†µÌ±å ) Cov(Ì†µÌ±ã + Ì†µÌ±ê, Ì†µÌ±å ) = Cov(Ì†µÌ±ã, Ì†µÌ±å )

The estimator with Ì†µÌ±ëÌ†µÌ±ì = 1 is

1 ‚àëÔ∏Å Ì†µÌºéÌ†µÌ±•Ì†µÌ±¶ = Ì†µÌ±õ ‚àí 1 (Ì†µÌ±•Ì†µÌ±ñ ‚àí Ì†µ¬ØÌ±•)(Ì†µÌ±¶Ì†µÌ±ñ ‚àí Ì†µ¬ØÌ±¶).
Ì†µÌ±ñ

Correlation The estimator is

Ì†µÌ∞∂Ì†µÌ±úÌ†µÌ±£(Ì†µÌ±ã, Ì†µÌ±å ) Ì†µÌ∞∂Ì†µÌ±úÌ†µÌ±ü(Ì†µÌ±ã, Ì†µÌ±å ) =
Ì†µÌ±ÜÌ†µÌ±°Ì†µÌ±ë(Ì†µÌ±ã)Ì†µÌ±ÜÌ†µÌ±°Ì†µÌ±ë(Ì†µÌ±å )

Ì†µÌºåÌ†µÌ±•Ì†µÌ±¶

=

Ì†µÌºéÌ†µÌ±•Ì†µÌ±¶ . Ì†µÌºéÌ†µÌ±•Ì†µÌºéÌ†µÌ±¶

Standard Error (SE)
The standard error (SE) is the standard deviation (of the sampling distribution) of a statistic: Ì†µÌ±Ü Ì†µÌ±°Ì†µÌ±ë(Ì†µÌ±ã )
Ì†µÌ±ÜÌ†µÌ∞∏(Ì†µÌ±ã) = ‚àö . Ì†µÌ±õ
It is most commonly considered for the mean with the estimator $

Ì†µÌ±ÜÌ†µÌ∞∏(Ì†µ¬ØÌ±•) = Ì†µÌºéÌ†µ¬ØÌ±• = ‚àöÌ†µÌºéÌ†µÌ±• . Ì†µÌ±õ

(4.4) (4.5)

68

Chapter 4. Statistics

Statistics and Machine Learning in Python, Release 0.2
Exercises
‚Ä¢ Generate 2 random samples: Ì†µÌ±• ‚àº Ì†µÌ±Å (1.78, 0.1) and Ì†µÌ±¶ ‚àº Ì†µÌ±Å (1.66, 0.1), both of size 10. ‚Ä¢ Compute Ì†µ¬ØÌ±•, Ì†µÌºéÌ†µÌ±•, Ì†µÌºéÌ†µÌ±•Ì†µÌ±¶ (xbar, xvar, xycov) using only the np.sum() operation. Explore
the np. module to Ô¨Ånd out which numpy functions performs the same computations and compare them (using assert) with your previous results.
4.1.2 Main distributions
Normal distribution
The normal distribution, noted Ì†µÌ≤© (Ì†µÌºá, Ì†µÌºé) with parameters: Ì†µÌºá mean (location) and Ì†µÌºé > 0 std-dev. Estimators: Ì†µ¬ØÌ±• and Ì†µÌºéÌ†µÌ±•. The normal distribution, noted Ì†µÌ±öÌ†µÌ±éÌ†µÌ±°‚ÑéÌ†µÌ±êÌ†µÌ±éÌ†µÌ±ôÌ†µÌ±Å , is useful because of the central limit theorem (CLT) which states that: given certain conditions, the arithmetic mean of a sufÔ¨Åciently large number of iterates of independent random variables, each with a well-deÔ¨Åned expected value and well-deÔ¨Åned variance, will be approximately normally distributed, regardless of the underlying distribution.
import numpy as np import matplotlib.pyplot as plt from scipy.stats import norm %matplotlib inline
mu = 0 # mean variance = 2 #variance sigma = np.sqrt(variance) #standard deviation\n", x = np.linspace(mu-3*variance,mu+3*variance, 100) plt.plot(x, norm.pdf(x, mu, sigma))
[<matplotlib.lines.Line2D at 0x7f6f2a4dae48>]

4.1. Univariate statistics

69

Statistics and Machine Learning in Python, Release 0.2

The Chi-Square distribution

The chi-square or Ì†µÌºí2Ì†µÌ±õ distribution with Ì†µÌ±õ degrees of freedom (df) is the distribution of a sum of the squares of Ì†µÌ±õ independent standard normal random variables Ì†µÌ≤© (0, 1). Let Ì†µÌ±ã ‚àº Ì†µÌ≤© (Ì†µÌºá, Ì†µÌºé2), then, Ì†µÌ±ç = (Ì†µÌ±ã ‚àí Ì†µÌºá)/Ì†µÌºé ‚àº Ì†µÌ≤© (0, 1), then:

‚Ä¢ The squared standard Ì†µÌ±ç2 ‚àº Ì†µÌºí21 (one df).

‚Ä¢

The distribution of sum of squares of Ì†µÌ±õ normal random variables:

‚àëÔ∏ÄÌ†µÌ±õ
Ì†µÌ±ñ

Ì†µÌ±çÌ†µ2Ì±ñ

‚àº Ì†µÌºí2Ì†µÌ±õ

The sum of two Ì†µÌºí2 RV with Ì†µÌ±ù and Ì†µÌ±û df is a Ì†µÌºí2 RV with Ì†µÌ±ù + Ì†µÌ±û df. This is useful when sum-

ming/subtracting sum of squares.

The Ì†µÌºí2-distribution is used to model errors measured as sum of squares or the distribution of the sample variance.

The Fisher‚Äôs F-distribution
The Ì†µÌ∞π -distribution, Ì†µÌ∞πÌ†µÌ±õ,Ì†µÌ±ù, with Ì†µÌ±õ and Ì†µÌ±ù degrees of freedom is the ratio of two independent Ì†µÌºí2 variables. Let Ì†µÌ±ã ‚àº Ì†µÌºí2Ì†µÌ±õ and Ì†µÌ±å ‚àº Ì†µÌºí2Ì†µÌ±ù then:
Ì†µÌ±ã/Ì†µÌ±õ Ì†µÌ∞πÌ†µÌ±õ,Ì†µÌ±ù = Ì†µÌ±å /Ì†µÌ±ù
The Ì†µÌ∞π -distribution plays a central role in hypothesis testing answering the question: Are two variances equals?, is the ratio or two errors signiÔ¨Åcantly large ?.
import numpy as np from scipy.stats import f import matplotlib.pyplot as plt %matplotlib inline
fvalues = np.linspace(.1, 5, 100)
# pdf(x, df1, df2): Probability density function at x of F. plt.plot(fvalues, f.pdf(fvalues, 1, 30), b- , label="F(1, 30)") plt.plot(fvalues, f.pdf(fvalues, 5, 30), r- , label="F(5, 30)") plt.legend()
# cdf(x, df1, df2): Cumulative distribution function of F. # ie. proba_at_f_inf_3 = f.cdf(3, 1, 30) # P(F(1,30) < 3)
# ppf(q, df1, df2): Percent point function (inverse of cdf) at q of F. f_at_proba_inf_95 = f.ppf(.95, 1, 30) # q such P(F(1,30) < .95) assert f.cdf(f_at_proba_inf_95, 1, 30) == .95
# sf(x, df1, df2): Survival function (1 - cdf) at x of F. proba_at_f_sup_3 = f.sf(3, 1, 30) # P(F(1,30) > 3) assert proba_at_f_inf_3 + proba_at_f_sup_3 == 1
# p-value: P(F(1, 30)) < 0.05 low_proba_fvalues = fvalues[fvalues > f_at_proba_inf_95] plt.fill_between(low_proba_fvalues, 0, f.pdf(low_proba_fvalues, 1, 30),
alpha=.8, label="P < 0.05") plt.show()

70

Chapter 4. Statistics

Statistics and Machine Learning in Python, Release 0.2

The Student‚Äôs Ì†µÌ±°-distribution
Let Ì†µÌ±Ä ‚àº Ì†µÌ≤© (0, 1) and Ì†µÌ±â ‚àº Ì†µÌºí2Ì†µÌ±õ. The Ì†µÌ±°-distribution, Ì†µÌ±áÌ†µÌ±õ, with Ì†µÌ±õ degrees of freedom is the ratio: Ì†µÌ±Ä
Ì†µÌ±áÌ†µÌ±õ = ‚àöÔ∏ÄÌ†µÌ±â /Ì†µÌ±õ
The distribution of the difference between an estimated parameter and its true (or assumed) value divided by the standard deviation of the estimated parameter (standard error) follow a Ì†µÌ±°-distribution. Is this parameters different from a given value?

4.1.3 Hypothesis Testing

Examples ‚Ä¢ Test a proportion: Biased coin ? 200 heads have been found over 300 Ô¨Çips, is it coins biased ? ‚Ä¢ Test the association between two variables. ‚Äì Exemple height and sex: In a sample of 25 individuals (15 females, 10 males), is female height is different from male height ? ‚Äì Exemple age and arterial hypertension: In a sample of 25 individuals is age height correlated with arterial hypertension ?
Steps 1. Model the data 2. Fit: estimate the model parameters (frequency, mean, correlation, regression coeÔ¨Åcient) 3. Compute a test statistic from model the parameters. 4. Formulate the null hypothesis: What would be the (distribution of the) test statistic if the observations are the result of pure chance.

4.1. Univariate statistics

71

Statistics and Machine Learning in Python, Release 0.2

5. Compute the probability (Ì†µÌ±ù-value) to obtain a larger value for the test statistic by chance (under the null hypothesis).

Flip coin: SimpliÔ¨Åed example
Biased coin ? 2 heads have been found over 3 Ô¨Çips, is it coins biased ? 1. Model the data: number of heads follow a Binomial disctribution. 2. Compute model parameters: N=3, P = the frequency of number of heads over the number of Ô¨Çip: 2/3. 3. Compute a test statistic, same as frequency. 4. Under the null hypothesis the distribution of the number of tail is:

1 2 3 count #heads

0

H

1

H

1

H1

HH

2

H

H2

HH2

HHH3

8 possibles conÔ¨Ågurations, probabilities of differents values for Ì†µÌ±ù are: Ì†µÌ±• measure the number of success.
‚Ä¢ Ì†µÌ±É (Ì†µÌ±• = 0) = 1/8
‚Ä¢ Ì†µÌ±É (Ì†µÌ±• = 1) = 3/8
‚Ä¢ Ì†µÌ±É (Ì†µÌ±• = 2) = 3/8
‚Ä¢ Ì†µÌ±É (Ì†µÌ±• = 3) = 1/8
plt.bar([0, 1, 2, 3], [1/8, 3/8, 3/8, 1/8], width=0.9) _ = plt.xticks([0, 1, 2, 3], [0, 1, 2, 3]) plt.xlabel("Distribution of the number of head over 3 flip under the null hypothesis")

Text(0.5, 0, Distribution of the number of head over 3 flip under the null hypothesis )

72

Chapter 4. Statistics

Statistics and Machine Learning in Python, Release 0.2

3. Compute the probability (Ì†µÌ±ù-value) to observe a value larger or equal that 2 under the null hypothesis ? This probability is the Ì†µÌ±ù-value:
Ì†µÌ±É (Ì†µÌ±• ‚â• 2|Ì†µÌ∞ª0) = Ì†µÌ±É (Ì†µÌ±• = 2) + Ì†µÌ±É (Ì†µÌ±• = 3) = 3/8 + 1/8 = 4/8 = 1/2

Flip coin: Real Example

Biased coin ? 60 heads have been found over 100 Ô¨Çips, is it coins biased ?

1. Model the data: number of heads follow a Binomial disctribution.

2. Compute model parameters: N=100, P=60/100.

3. Compute a test statistic, same as frequency.

4. Compute a test statistic: 60/100.

5. Under the null hypothesis the distribution of the number of tail (Ì†µÌ±ò) follow the binomial distribution of parameters N=100, P=0.5:

Ì†µÌ±É Ì†µÌ±ü(Ì†µÌ±ã

=

Ì†µÌ±ò|Ì†µÌ∞ª0)

=

Ì†µÌ±É Ì†µÌ±ü(Ì†µÌ±ã

=

Ì†µÌ±ò|Ì†µÌ±õ

=

100,

Ì†µÌ±ù

=

0.5)

=

(Ô∏Ç100)Ô∏Ç0.5Ì†µÌ±ò(1 Ì†µÌ±ò

‚àí

0.5)(100‚àíÌ†µÌ±ò).

Ì†µÌ±É (Ì†µÌ±ã

=

Ì†µÌ±ò

‚â•

60|Ì†µÌ∞ª0)

=

100
‚àëÔ∏Å

(Ô∏Ç100)Ô∏Ç0.5Ì†µÌ±ò(1 ‚àí 0.5)(100‚àíÌ†µÌ±ò) Ì†µÌ±ò

Ì†µÌ±ò=60

=

1

‚àí

60
‚àëÔ∏Å

(Ô∏Ç100)Ô∏Ç0.5Ì†µÌ±ò(1

‚àí

0.5)(100‚àíÌ†µÌ±ò),

the

cumulative

distribution

function.

Ì†µÌ±ò

Ì†µÌ±ò=1

Use tabulated binomial distribution

4.1. Univariate statistics

73

Statistics and Machine Learning in Python, Release 0.2
import scipy.stats import matplotlib.pyplot as plt
#tobs = 2.39687663116 # assume the t-value succes = np.linspace(30, 70, 41) plt.plot(succes, scipy.stats.binom.pmf(succes, 100, 0.5), b- , label="Binomial(100, 0.5) Àì‚Üí") upper_succes_tvalues = succes[succes > 60] plt.fill_between(upper_succes_tvalues, 0, scipy.stats.binom.pmf(upper_succes_tvalues, 100, Àì‚Üí 0.5), alpha=.8, label="p-value") _ = plt.legend()
pval = 1 - scipy.stats.binom.cdf(60, 100, 0.5) print(pval)
0.01760010010885238

Random sampling of the Binomial distribution under the null hypothesis
sccess_h0 = scipy.stats.binom.rvs(100, 0.5, size=10000, random_state=4)
#sccess_h0 = np.array([) for i in range(5000)]) import seaborn as sns _ = sns.distplot(sccess_h0, hist=False)
pval_rnd = np.sum(sccess_h0 >= 60) / (len(sccess_h0) + 1) print("P-value using monte-carlo sampling of the Binomial distribution under H0=", pval_ Àì‚Üírnd)
P-value using monte-carlo sampling of the Binomial distribution under H0= 0. Àì‚Üí025897410258974102

74

Chapter 4. Statistics

Statistics and Machine Learning in Python, Release 0.2

One sample Ì†µÌ±°-test
The one-sample Ì†µÌ±°-test is used to determine whether a sample comes from a population with a speciÔ¨Åc mean. For example you want to test if the average height of a population is 1.75 Ì†µÌ±ö. 1 Model the data Assume that height is normally distributed: Ì†µÌ±ã ‚àº Ì†µÌ≤© (Ì†µÌºá, Ì†µÌºé), ie:

heightÌ†µÌ±ñ = average height over the population + errorÌ†µÌ±ñ Ì†µÌ±•Ì†µÌ±ñ = Ì†µ¬ØÌ±• + Ì†µÌºÄÌ†µÌ±ñ

(4.6) (4.7)

The Ì†µÌºÄÌ†µÌ±ñ are called the residuals
2 Fit: estimate the model parameters
Ì†µ¬ØÌ±•, Ì†µÌ±†Ì†µÌ±• are the estimators of Ì†µÌºá, Ì†µÌºé.
3 Compute a test statistic
In testing the null hypothesis that the population mean is equal to a speciÔ¨Åed value Ì†µÌºá0 = 1.75, one uses the statistic:
Ì†µÌ±° = Ì†µ¬ØÌ±• ‚àí‚àöÌ†µÌºá0 Ì†µÌ±†Ì†µÌ±•/ Ì†µÌ±õ
Remarks: Although the parent population does not need to be normally distributed, the distribution of the population of sample means, Ì†µÌ±•, is assumed to be normal. By the central limit theorem, if the sampling of the parent population is independent then the sample means will be approximately normal.
4 Compute the probability of the test statistic under the null hypotheis. This require to have the distribution of the t statistic under Ì†µÌ∞ª0.

4.1. Univariate statistics

75

Statistics and Machine Learning in Python, Release 0.2
Example
Given the following samples, we will test whether its true mean is 1.75. Warning, when computing the std or the variance, set ddof=1. The default value, ddof=0, leads to the biased estimator of the variance.
import numpy as np
x= [ 1.83, 1.83, 1.73, 1.82, 1.83, 1.73, 1.99, 1.85, 1.68, 1.87]
xbar = np.mean(x) # sample mean mu0 = 1.75 # hypothesized value s = np.std(x, ddof=1) # sample standard deviation n = len(x) # sample size
tobs = (xbar - mu0) / (s / np.sqrt(n)) print(tobs)
2.3968766311585883
The :math:‚Äòp‚Äò-value is the probability to observe a value Ì†µÌ±° more extreme than the observed one Ì†µÌ±°Ì†µÌ±úÌ†µÌ±èÌ†µÌ±† under the null hypothesis Ì†µÌ∞ª0: Ì†µÌ±É (Ì†µÌ±° > Ì†µÌ±°Ì†µÌ±úÌ†µÌ±èÌ†µÌ±†|Ì†µÌ∞ª0)
import scipy.stats as stats import matplotlib.pyplot as plt
#tobs = 2.39687663116 # assume the t-value tvalues = np.linspace(-10, 10, 100) plt.plot(tvalues, stats.t.pdf(tvalues, n-1), b- , label="T(n-1)") upper_tval_tvalues = tvalues[tvalues > tobs] plt.fill_between(upper_tval_tvalues, 0, stats.t.pdf(upper_tval_tvalues, n-1), alpha=.8,‚ê£ Àì‚Üílabel="p-value") _ = plt.legend()

76

Chapter 4. Statistics

Statistics and Machine Learning in Python, Release 0.2
4.1.4 Testing pairwise associations
Univariate statistical analysis: explore association betweens pairs of variables. ‚Ä¢ In statistics, a categorical variable or factor is a variable that can take on one of a limited, and usually Ô¨Åxed, number of possible values, thus assigning each individual to a particular group or ‚Äúcategory‚Äù. The levels are the possibles values of the variable. Number of levels = 2: binomial; Number of levels > 2: multinomial. There is no intrinsic ordering to the categories. For example, gender is a categorical variable having two categories (male and female) and there is no intrinsic ordering to the categories. For example, Sex (Female, Male), Hair color (blonde, brown, etc.). ‚Ä¢ An ordinal variable is a categorical variable with a clear ordering of the levels. For example: drinks per day (none, small, medium and high). ‚Ä¢ A continuous or quantitative variable Ì†µÌ±• ‚àà R is one that can take any value in a range of possible values, possibly inÔ¨Ånite. E.g.: salary, experience in years, weight.
What statistical test should I use? See: http://www.ats.ucla.edu/stat/mult_pkg/whatstat/

Fig. 1: Statistical tests ### Pearson correlation test: test association between two quantitative variables

4.1. Univariate statistics

77

Statistics and Machine Learning in Python, Release 0.2

Test the correlation coefÔ¨Åcient of two quantitative variables. The test calculates a Pearson correlation coefÔ¨Åcient and the Ì†µÌ±ù-value for testing non-correlation.

Let Ì†µÌ±• and Ì†µÌ±¶ two quantitative variables, where Ì†µÌ±õ samples were obeserved. The linear correlation coeÔ¨Åcient is deÔ¨Åned as :

Ì†µÌ±ü

=

‚àëÔ∏ÄÌ†µÌ†µÌ±ñÌ±õ=1(Ì†µÌ±•Ì†µÌ±ñ ‚àí Ì†µ¬ØÌ±•)(Ì†µÌ±¶Ì†µÌ±ñ ‚àí Ì†µ¬ØÌ±¶)

‚àöÔ∏Ä‚àëÔ∏ÄÌ†µÌ±õ
Ì†µÌ±ñ=1

(Ì†µÌ±•Ì†µÌ±ñ

‚àí

Ì†µ¬ØÌ±•)2‚àöÔ∏Ä‚àëÔ∏ÄÌ†µÌ†µÌ±ñÌ±õ=1(Ì†µÌ±¶Ì†µÌ±ñ

. ‚àí Ì†µ¬ØÌ±¶)2

Under

Ì†µÌ∞ª0,

the

test

statistic

Ì†µÌ±°

=

‚àö Ì†µÌ±õ

‚àí

2

‚àö Ì†µÌ±ü 1‚àíÌ†µÌ±ü2

follow

Student

distribution

with

Ì†µÌ±õ ‚àí 2

degrees

of

freedom.

import numpy as np
import scipy.stats as stats n = 50 x = np.random.normal(size=n) y = 2 * x + np.random.normal(size=n)

# Compute with scipy cor, pval = stats.pearsonr(x, y)

Two sample (Student) Ì†µÌ±°-test: compare two means

Fig. 2: Two-sample model
The two-sample Ì†µÌ±°-test (Snedecor and Cochran, 1989) is used to determine if two population means are equal. There are several variations on this test. If data are paired (e.g. 2 measures, before and after treatment for each individual) use the one-sample Ì†µÌ±°-test of the difference. The variances of the two samples may be assumed to be equal (a.k.a. homoscedasticity) or unequal (a.k.a. heteroscedasticity).

1. Model the data
Assume that the two random variables are normally distributed: Ì†µÌ±¶1 ‚àº Ì†µÌ≤© (Ì†µÌºá1, Ì†µÌºé1), Ì†µÌ±¶2 ‚àº Ì†µÌ≤© (Ì†µÌºá2, Ì†µÌºé2).

2. Fit: estimate the model parameters Estimate means and variances: Ì†µ¬ØÌ±¶1, Ì†µÌ±†2Ì†µÌ±¶1, Ì†µ¬ØÌ±¶2, Ì†µÌ±†2Ì†µÌ±¶2.

78

Chapter 4. Statistics

Statistics and Machine Learning in Python, Release 0.2

3. Ì†µÌ±°-test The general principle is

difference of means Ì†µÌ±° =
its standard error = Ì†µ¬ØÌ±¶1 ‚àí Ì†µ¬ØÌ±¶2
Ì†µÌ±†Ì†µ¬ØÌ±¶1‚àíÌ†µ¬ØÌ±¶2
Since Ì†µÌ±¶1 and Ì†µÌ±¶2 are independant:

(4.8) (4.9)

Ì†µÌ±†2Ì†µ¬ØÌ±¶1‚àíÌ†µ¬ØÌ±¶2

=

Ì†µÌ±†2Ì†µ¬ØÌ±¶1

+ Ì†µÌ±†2Ì†µ¬ØÌ±¶2

=

Ì†µÌ±†2Ì†µÌ±¶1 Ì†µÌ±õ1

+

Ì†µÌ±†2Ì†µÌ±¶2 Ì†µÌ±õ2

thus

‚àöÔ∏É

Ì†µÌ±†Ì†µ¬ØÌ±¶1‚àíÌ†µ¬ØÌ±¶2 =

Ì†µÌ±†2Ì†µÌ±¶1 + Ì†µÌ±†2Ì†µÌ±¶2 Ì†µÌ±õ1 Ì†µÌ±õ2

(4.10) (4.11) (4.12)

Equal or unequal sample sizes, unequal variances (Welch‚Äôs Ì†µÌ±°-test)

Welch‚Äôs Ì†µÌ±°-test deÔ¨Ånes the Ì†µÌ±° statistic as

Ì†µÌ±° = Ì†µ¬ØÌ±¶1 ‚àí Ì†µ¬ØÌ±¶2 .

‚àöÔ∏Å Ì†µÌ±†2Ì†µÌ±¶1
Ì†µÌ±õ1

+

Ì†µÌ±†2Ì†µÌ±¶2 Ì†µÌ±õ2

To compute the Ì†µÌ±ù-value one needs the degrees of freedom associated with this variance estimate. It is approximated using the Welch‚ÄìSatterthwaite equation:

(Ô∏Ç Ì†µÌ±†2Ì†µÌ±¶1
Ì†µÌ±õ1

+

Ì†µÌ±†2Ì†µÌ±¶2 )Ô∏Ç2
Ì†µÌ±õ2

Ì†µÌºà

‚âà

Ì†µÌ±†4Ì†µÌ±¶1 Ì†µÌ±õ21(Ì†µÌ±õ1‚àí1)

+

Ì†µÌ±†4Ì†µÌ±¶2 Ì†µÌ±õ22(Ì†µÌ±õ2‚àí1)

.

Equal or unequal sample sizes, equal variances

If we assume equal variance (ie, Ì†µÌ±†2Ì†µÌ±¶1 = Ì†µÌ±†2Ì†µÌ±¶1 = Ì†µÌ±†2), where Ì†µÌ±†2 is an estimator of the common variance of the two samples:

Ì†µÌ±†2 = Ì†µÌ±†2Ì†µÌ±¶1 (Ì†µÌ±õ1 ‚àí 1) + Ì†µÌ±†2Ì†µÌ±¶2 (Ì†µÌ±õ2 ‚àí 1) Ì†µÌ±õ1 + Ì†µÌ±õ2 ‚àí 2

=

‚àëÔ∏ÄÌ†µÌ±õ1
Ì†µÌ±ñ

(Ì†µÌ±¶1Ì†µÌ±ñ

‚àí

Ì†µ¬ØÌ±¶1)2

+

‚àëÔ∏ÄÌ†µÌ±õ2
Ì†µÌ±ó

(Ì†µÌ±¶2Ì†µÌ±ó

‚àí

Ì†µ¬ØÌ±¶2)2

(Ì†µÌ±õ1 ‚àí 1) + (Ì†µÌ±õ2 ‚àí 1)

then

‚àöÔ∏É

Ì†µÌ±†2 Ì†µÌ±†2 ‚àöÔ∏Ç 1 1

Ì†µÌ±†Ì†µ¬ØÌ±¶1‚àíÌ†µ¬ØÌ±¶2 =

+ = Ì†µÌ±† +

Ì†µÌ±õ1 Ì†µÌ±õ2

Ì†µÌ±õ1 Ì†µÌ±õ2

4.1. Univariate statistics

(4.13) (4.14)
79

Statistics and Machine Learning in Python, Release 0.2

Therefore, the Ì†µÌ±° statistic, that is used to test whether the means are different is:

Ì†µÌ±° =

Ì†µ¬ØÌ±¶1 ‚àí Ì†µ¬ØÌ±¶2 ‚àöÔ∏Å

,

Ì†µÌ±† ¬∑

1 Ì†µÌ±õ1

+

1 Ì†µÌ±õ2

Equal sample sizes, equal variances

If we simplify the problem assuming equal samples of size Ì†µÌ±õ1 = Ì†µÌ±õ2 = Ì†µÌ±õ we get

Ì†µÌ±°

=

Ì†µ¬ØÌ±¶1

‚àí ‚àö

Ì†µ¬ØÌ±¶2

¬∑

‚àö Ì†µÌ±õ

Ì†µÌ±† 2

‚àö

‚âà effect size ¬∑ Ì†µÌ±õ

difference of means

‚àö

‚âà

¬∑ Ì†µÌ±õ

standard deviation of the noise

(4.15) (4.16) (4.17)

Example

Given the following two samples, test whether their means are equal using the standard t-test, assuming equal variance.
import scipy.stats as stats
height = np.array([ 1.83, 1.83, 1.73, 1.82, 1.83, 1.73, 1.99, 1.85, 1.68, 1.87, 1.66, 1.71, 1.73, 1.64, 1.70, 1.60, 1.79, 1.73, 1.62, 1.77])
grp = np.array(["M"] * 10 + ["F"] * 10)
# Compute with scipy print(stats.ttest_ind(height[grp == "M"], height[grp == "F"], equal_var=True))
Ttest_indResult(statistic=3.5511519888466885, pvalue=0.00228208937112721)

ANOVA Ì†µÌ∞π -test (quantitative ~ categorial (>2 levels))
Analysis of variance (ANOVA) provides a statistical test of whether or not the means of several groups are equal, and therefore generalizes the Ì†µÌ±°-test to more than two groups. ANOVAs are useful for comparing (testing) three or more means (groups or variables) for statistical signiÔ¨Åcance. It is conceptually similar to multiple two-sample Ì†µÌ±°-tests, but is less conservative.
Here we will consider one-way ANOVA with one independent variable, ie one-way anova.
Wikipedia:
‚Ä¢ Test if any group is on average superior, or inferior, to the others versus the null hypothesis that all four strategies yield the same mean response
‚Ä¢ Detect any of several possible differences.
‚Ä¢ The advantage of the ANOVA Ì†µÌ∞π -test is that we do not need to pre-specify which strategies are to be compared, and we do not need to adjust for making multiple comparisons.

80

Chapter 4. Statistics

Statistics and Machine Learning in Python, Release 0.2

‚Ä¢ The disadvantage of the ANOVA Ì†µÌ∞π -test is that if we reject the null hypothesis, we do not know which strategies can be said to be signiÔ¨Åcantly different from the others.
1. Model the data
A company has applied three marketing strategies to three samples of customers in order increase their business volume. The marketing is asking whether the strategies led to different increases of business volume. Let Ì†µÌ±¶1, Ì†µÌ±¶2 and Ì†µÌ±¶3 be the three samples of business volume increase. Here we assume that the three populations were sampled from three random variables that are normally distributed. I.e., Ì†µÌ±å1 ‚àº Ì†µÌ±Å (Ì†µÌºá1, Ì†µÌºé1), Ì†µÌ±å2 ‚àº Ì†µÌ±Å (Ì†µÌºá2, Ì†µÌºé2) and Ì†µÌ±å3 ‚àº Ì†µÌ±Å (Ì†µÌºá3, Ì†µÌºé3).
2. Fit: estimate the model parameters
Estimate means and variances: Ì†µ¬ØÌ±¶Ì†µÌ±ñ, Ì†µÌºéÌ†µÌ±ñ, ‚àÄÌ†µÌ±ñ ‚àà {1, 2, 3}.
3. Ì†µÌ∞π -test
The formula for the one-way ANOVA F-test statistic is

Explained variance Ì†µÌ∞π =
Unexplained variance

=

Between-group variability Within-group variability

=

Ì†µÌ±†2Ì†µÌ∞µ Ì†µÌ±†2Ì†µÌ±ä

.

(4.18) (4.19)

The ‚Äúexplained variance‚Äù, or ‚Äúbetween-group variability‚Äù is

Ì†µÌ±†2Ì†µÌ∞µ = ‚àëÔ∏Å Ì†µÌ±õÌ†µÌ±ñ(Ì†µ¬ØÌ±¶Ì†µÌ±ñ¬∑ ‚àí Ì†µ¬ØÌ±¶)2/(Ì†µÌ∞æ ‚àí 1),
Ì†µÌ±ñ

where Ì†µ¬ØÌ±¶Ì†µÌ±ñ¬∑ denotes the sample mean in the Ì†µÌ±ñth group, Ì†µÌ±õÌ†µÌ±ñ is the number of observations in the Ì†µÌ±ñth group, Ì†µ¬ØÌ±¶ denotes the overall mean of the data, and Ì†µÌ∞æ denotes the number of groups.

The ‚Äúunexplained variance‚Äù, or ‚Äúwithin-group variability‚Äù is

Ì†µÌ±†2Ì†µÌ±ä

=

‚àëÔ∏Å (Ì†µÌ±¶Ì†µÌ±ñÌ†µÌ±ó

‚àí

Ì†µ¬ØÌ±¶Ì†µÌ±ñ¬∑)2/(Ì†µÌ±Å

‚àí Ì†µÌ∞æ),

Ì†µÌ±ñÌ†µÌ±ó

where Ì†µÌ±¶Ì†µÌ±ñÌ†µÌ±ó is the Ì†µÌ±óth observation in the Ì†µÌ±ñth out of Ì†µÌ∞æ groups and Ì†µÌ±Å is the overall sample size. This Ì†µÌ∞π -statistic follows the Ì†µÌ∞π -distribution with Ì†µÌ∞æ ‚àí 1 and Ì†µÌ±Å ‚àí Ì†µÌ∞æ degrees of freedom under the null hypothesis. The statistic will be large if the between-group variability is large relative to the within-group variability, which is unlikely to happen if the population means of the groups all have the same value.
Note that when there are only two groups for the one-way ANOVA F-test, Ì†µÌ∞π = Ì†µÌ±°2 where Ì†µÌ±° is the Student‚Äôs Ì†µÌ±° statistic.

4.1. Univariate statistics

81

Statistics and Machine Learning in Python, Release 0.2

Chi-square, Ì†µÌºí2 (categorial ~ categorial)
Computes the chi-square, Ì†µÌºí2, statistic and Ì†µÌ±ù-value for the hypothesis test of independence of frequencies in the observed contingency table (cross-table). The observed frequencies are tested against an expected contingency table obtained by computing expected frequencies based on the marginal sums under the assumption of independence.
Example: 20 participants: 10 exposed to some chemical product and 10 non exposed (exposed = 1 or 0). Among the 20 participants 10 had cancer 10 not (cancer = 1 or 0). Ì†µÌºí2 tests the association between those two variables.
import numpy as np import pandas as pd import scipy.stats as stats
# Dataset: # 15 samples: # 10 first exposed exposed = np.array([1] * 10 + [0] * 10) # 8 first with cancer, 10 without, the last two with. cancer = np.array([1] * 8 + [0] * 10 + [1] * 2)
crosstab = pd.crosstab(exposed, cancer, rownames=[ exposed ], colnames=[ cancer ])
print("Observed table:") print("---------------") print(crosstab)
chi2, pval, dof, expected = stats.chi2_contingency(crosstab) print("Statistics:") print("-----------") print("Chi2 = %f, pval = %f" % (chi2, pval)) print("Expected table:") print("---------------") print(expected)

Observed table:

---------------

cancer 0 1

exposed

0

82

1

28

Statistics:

-----------

Chi2 = 5.000000, pval = 0.025347

Expected table:

---------------

[[5. 5.]

[5. 5.]]

Computing expected cross-table
# Compute expected cross-table based on proportion exposed_marg = crosstab.sum(axis=0) exposed_freq = exposed_marg / exposed_marg.sum()

(continues on next page)

82

Chapter 4. Statistics

Statistics and Machine Learning in Python, Release 0.2

cancer_marg = crosstab.sum(axis=1) cancer_freq = cancer_marg / cancer_marg.sum()
print( Exposed frequency? Yes: %.2f % exposed_freq[0], No: %.2f % exposed_freq[1])
print( Cancer frequency? Yes: %.2f % cancer_freq[0], No: %.2f % cancer_freq[1])
print( Expected frequencies: ) print(np.outer(exposed_freq, cancer_freq))
print( Expected cross-table (frequencies * N): ) print(np.outer(exposed_freq, cancer_freq) * len(exposed))
Exposed frequency? Yes: 0.50 No: 0.50 Cancer frequency? Yes: 0.50 No: 0.50 Expected frequencies: [[0.25 0.25] [0.25 0.25]] Expected cross-table (frequencies * N): [[5. 5.] [5. 5.]]

(continued from previous page)

4.1.5 Non-parametric test of pairwise associations
### Spearman rank-order correlation (quantitative ~ quantitative)
The Spearman correlation is a non-parametric measure of the monotonicity of the relationship between two datasets.
When to use it? Observe the data distribution: - presence of outliers - the distribution of the residuals is not Gaussian.
Like other correlation coefÔ¨Åcients, this one varies between -1 and +1 with 0 implying no correlation. Correlations of -1 or +1 imply an exact monotonic relationship. Positive correlations imply that as Ì†µÌ±• increases, so does Ì†µÌ±¶. Negative correlations imply that as Ì†µÌ±• increases, Ì†µÌ±¶ decreases.
import numpy as np import scipy.stats as stats import matplotlib.pyplot as plt
x = np.array([44.4, 45.9, 41.9, 53.3, 44.7, 44.1, 50.7, 45.2, 46, 47, 48, 60.1]) y = np.array([2.6, 3.1, 2.5, 5.0, 3.6, 4.0, 5.2, 2.8, 4, 4.1, 4.5, 3.8])
plt.plot(x, y, "bo")
# Non-Parametric Spearman cor, pval = stats.spearmanr(x, y) print("Non-Parametric Spearman cor test, cor: %.4f, pval: %.4f" % (cor, pval))
# "Parametric Pearson cor test cor, pval = stats.pearsonr(x, y) print("Parametric Pearson cor test: cor: %.4f, pval: %.4f" % (cor, pval))

4.1. Univariate statistics

83

Statistics and Machine Learning in Python, Release 0.2
Non-Parametric Spearman cor test, cor: 0.7110, pval: 0.0095 Parametric Pearson cor test: cor: 0.5263, pval: 0.0788

Wilcoxon signed-rank test (quantitative ~ cte)

Source: https://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test
The Wilcoxon signed-rank test is a non-parametric statistical hypothesis test used when comparing two related samples, matched samples, or repeated measurements on a single sample to assess whether their population mean ranks differ (i.e. it is a paired difference test). It is equivalent to one-sample test of the difference of paired samples.
It can be used as an alternative to the paired Student‚Äôs Ì†µÌ±°-test, Ì†µÌ±°-test for matched pairs, or the Ì†µÌ±°test for dependent samples when the population cannot be assumed to be normally distributed.
When to use it? Observe the data distribution: - presence of outliers - the distribution of the residuals is not Gaussian
It has a lower sensitivity compared to Ì†µÌ±°-test. May be problematic to use when the sample size is small.
Null hypothesis Ì†µÌ∞ª0: difference between the pairs follows a symmetric distribution around zero.
import scipy.stats as stats n = 20 # Buisness Volume time 0 bv0 = np.random.normal(loc=3, scale=.1, size=n) # Buisness Volume time 1 bv1 = bv0 + 0.1 + np.random.normal(loc=0, scale=.1, size=n)

# create an outlier bv1[0] -= 10

# Paired t-test

(continues on next page)

84

Chapter 4. Statistics

Statistics and Machine Learning in Python, Release 0.2

print(stats.ttest_rel(bv0, bv1))
# Wilcoxon print(stats.wilcoxon(bv0, bv1))

(continued from previous page)

Ttest_relResult(statistic=0.7821450892478711, pvalue=0.4437681541620575) WilcoxonResult(statistic=35.0, pvalue=0.008967599455194583)

Mann‚ÄìWhitney Ì†µÌ±à test (quantitative ~ categorial (2 levels))
In statistics, the Mann‚ÄìWhitney Ì†µÌ±à test (also called the Mann‚ÄìWhitney‚ÄìWilcoxon, Wilcoxon rank-sum test or Wilcoxon‚ÄìMann‚ÄìWhitney test) is a nonparametric test of the null hypothesis that two samples come from the same population against an alternative hypothesis, especially that a particular population tends to have larger values than the other.
It can be applied on unknown distributions contrary to e.g. a Ì†µÌ±°-test that has to be applied only on normal distributions, and it is nearly as efÔ¨Åcient as the Ì†µÌ±°-test on normal distributions.
import scipy.stats as stats n = 20 # Buismess Volume group 0 bv0 = np.random.normal(loc=1, scale=.1, size=n)
# Buismess Volume group 1 bv1 = np.random.normal(loc=1.2, scale=.1, size=n)
# create an outlier bv1[0] -= 10
# Two-samples t-test print(stats.ttest_ind(bv0, bv1))
# Wilcoxon print(stats.mannwhitneyu(bv0, bv1))
Ttest_indResult(statistic=0.6725314683035514, pvalue=0.505314623871812) MannwhitneyuResult(statistic=67.0, pvalue=0.0001690974050146689)

4.1.6 Linear model

Given Ì†µÌ±õ random samples (Ì†µÌ±¶Ì†µÌ±ñ, Ì†µÌ±•1Ì†µÌ±ñ, . . . , Ì†µÌ±•Ì†µÌ±ùÌ†µÌ±ñ), Ì†µÌ±ñ = 1, . . . , Ì†µÌ±õ, the linear regression models the relation between the observations Ì†µÌ±¶Ì†µÌ±ñ and the independent variables Ì†µÌ±•Ì†µÌ†µÌ±ñÌ±ù is formulated as
Ì†µÌ±¶Ì†µÌ±ñ = Ì†µÌªΩ0 + Ì†µÌªΩ1Ì†µÌ±•1Ì†µÌ±ñ + ¬∑ ¬∑ ¬∑ + Ì†µÌªΩÌ†µÌ±ùÌ†µÌ±•Ì†µÌ±ùÌ†µÌ±ñ + Ì†µÌºÄÌ†µÌ±ñ Ì†µÌ±ñ = 1, . . . , Ì†µÌ±õ
‚Ä¢ The Ì†µÌªΩ‚Äôs are the model parameters, ie, the regression coeÔ¨Åcients. ‚Ä¢ Ì†µÌªΩ0 is the intercept or the bias. ‚Ä¢ Ì†µÌºÄÌ†µÌ±ñ are the residuals. ‚Ä¢ An independent variable (IV). It is a variable that stands alone and isn‚Äôt changed by
the other variables you are trying to measure. For example, someone‚Äôs age might be an

4.1. Univariate statistics

85

Statistics and Machine Learning in Python, Release 0.2

Fig. 3: Linear model
independent variable. Other factors (such as what they eat, how much they go to school, how much television they watch) aren‚Äôt going to change a person‚Äôs age. In fact, when you are looking for some kind of relationship between variables you are trying to see if the independent variable causes some kind of change in the other variables, or dependent variables. In Machine Learning, these variables are also called the predictors.
‚Ä¢ A dependent variable. It is something that depends on other factors. For example, a test score could be a dependent variable because it could change depending on several factors such as how much you studied, how much sleep you got the night before you took the test, or even how hungry you were when you took it. Usually when you are looking for a relationship between two things you are trying to Ô¨Ånd out what makes the dependent variable change the way it does. In Machine Learning this variable is called a target variable.
Simple regression: test association between two quantitative variables
Using the dataset ‚Äúsalary‚Äù, explore the association between the dependant variable (e.g. Salary) and the independent variable (e.g.: Experience is quantitative).
import pandas as pd import matplotlib.pyplot as plt %matplotlib inline
url = https://raw.github.com/neurospin/pystatsml/master/datasets/salary_table.csv salary = pd.read_csv(url)

1. Model the data

Model the data on some hypothesis e.g.: salary is a linear function of the experience.

more generally

salaryÌ†µÌ±ñ = Ì†µÌªΩ experienceÌ†µÌ±ñ + Ì†µÌªΩ0 + Ì†µÌºñÌ†µÌ±ñ,

Ì†µÌ±¶Ì†µÌ±ñ = Ì†µÌªΩ Ì†µÌ±•Ì†µÌ±ñ + Ì†µÌªΩ0 + Ì†µÌºñÌ†µÌ±ñ

‚Ä¢ Ì†µÌªΩ: the slope or coefÔ¨Åcient or parameter of the model, ‚Ä¢ Ì†µÌªΩ0: the intercept or bias is the second parameter of the model,

86

Chapter 4. Statistics

Statistics and Machine Learning in Python, Release 0.2

‚Ä¢ Ì†µÌºñÌ†µÌ±ñ: is the Ì†µÌ±ñth error, or residual with Ì†µÌºñ ‚àº Ì†µÌ≤© (0, Ì†µÌºé2). The simple regression is equivalent to the Pearson correlation.

2. Fit: estimate the model parameters

The goal it so estimate Ì†µÌªΩ, Ì†µÌªΩ0 and Ì†µÌºé2.

Minimizes the mean squared error (MSE) or the Sum squared error (SSE). The so-called

Ordinary

Least

Squares

(OLS)

Ô¨Ånds

Ì†µÌªΩ,

Ì†µÌªΩ0

that

minimizes

the

Ì†µÌ±ÜÌ†µÌ±ÜÌ†µÌ∞∏

=

‚àëÔ∏Ä
Ì†µÌ±ñ

Ì†µÌºñ2Ì†µÌ±ñ

Ì†µÌ±ÜÌ†µÌ±ÜÌ†µÌ∞∏

=

‚àëÔ∏Å (Ì†µÌ±¶Ì†µÌ±ñ

‚àí

Ì†µÌªΩ

Ì†µÌ±•Ì†µÌ±ñ

‚àí

Ì†µÌªΩ0)2

Ì†µÌ±ñ

Recall from calculus that an extreme point can be found by computing where the derivative is zero, i.e. to Ô¨Ånd the intercept, we perform the steps:

Ì†µÌºïÌ†µÌ±ÜÌ†µÌ±ÜÌ†µÌ∞∏ ‚àëÔ∏Å

Ì†µÌºïÌ†µÌªΩ0

=

(Ì†µÌ±¶Ì†µÌ±ñ ‚àí Ì†µÌªΩ Ì†µÌ±•Ì†µÌ±ñ ‚àí Ì†µÌªΩ0) = 0
Ì†µÌ±ñ

‚àëÔ∏Å

‚àëÔ∏Å

Ì†µÌ±¶Ì†µÌ±ñ = Ì†µÌªΩ Ì†µÌ±•Ì†µÌ±ñ + Ì†µÌ±õ Ì†µÌªΩ0

Ì†µÌ±ñ

Ì†µÌ±ñ

Ì†µÌ±õ Ì†µ¬ØÌ±¶ = Ì†µÌ±õ Ì†µÌªΩ Ì†µ¬ØÌ±• + Ì†µÌ±õ Ì†µÌªΩ0

Ì†µÌªΩ0 = Ì†µ¬ØÌ±¶ ‚àí Ì†µÌªΩ Ì†µ¬ØÌ±•

To Ô¨Ånd the regression coefÔ¨Åcient, we perform the steps:

Ì†µÌºïÌ†µÌ±ÜÌ†µÌ±ÜÌ†µÌ∞∏ ‚àëÔ∏Å

= Ì†µÌºïÌ†µÌªΩ

Ì†µÌ±•Ì†µÌ±ñ(Ì†µÌ±¶Ì†µÌ±ñ ‚àí Ì†µÌªΩ Ì†µÌ±•Ì†µÌ±ñ ‚àí Ì†µÌªΩ0) = 0

Ì†µÌ±ñ

Plug in Ì†µÌªΩ0:

‚àëÔ∏Å Ì†µÌ±•Ì†µÌ±ñ(Ì†µÌ±¶Ì†µÌ±ñ ‚àí Ì†µÌªΩ Ì†µÌ±•Ì†µÌ±ñ ‚àí Ì†µ¬ØÌ±¶ + Ì†µÌªΩÌ†µ¬ØÌ±•) = 0

Ì†µÌ±ñ

‚àëÔ∏Å

‚àëÔ∏Å

‚àëÔ∏Å

Ì†µÌ±•Ì†µÌ±ñÌ†µÌ±¶Ì†µÌ±ñ ‚àí Ì†µ¬ØÌ±¶ Ì†µÌ±•Ì†µÌ±ñ = Ì†µÌªΩ (Ì†µÌ±•Ì†µÌ±ñ ‚àí Ì†µ¬ØÌ±•)

Ì†µÌ±ñ

Ì†µÌ±ñ

Ì†µÌ±ñ

Divide both sides by Ì†µÌ±õ:

1 ‚àëÔ∏Å

1 ‚àëÔ∏Å

Ì†µÌ±õ

Ì†µÌ±•Ì†µÌ±ñÌ†µÌ±¶Ì†µÌ±ñ

‚àí

Ì†µ¬ØÌ±¶Ì†µ¬ØÌ±•

=

Ì†µÌªΩ Ì†µÌ±õ

(Ì†µÌ±•Ì†µÌ±ñ ‚àí Ì†µ¬ØÌ±•)

Ì†µÌ±ñ

Ì†µÌ±ñ

Ì†µÌªΩ

=

1 Ì†µÌ±õ

‚àëÔ∏Ä
Ì†µÌ±ñ

Ì†µÌ±•Ì†µÌ±ñÌ†µÌ±¶Ì†µÌ±ñ

‚àí

Ì†µ¬ØÌ±¶Ì†µ¬ØÌ±•

1 Ì†µÌ±õ

‚àëÔ∏ÄÌ†µÌ±ñ(Ì†µÌ±•Ì†µÌ±ñ

‚àí

Ì†µ¬ØÌ±•)

=

Ì†µÌ∞∂Ì†µÌ±úÌ†µÌ±£(Ì†µÌ±•, Ì†µÌ±¶) .
Ì†µÌ±â Ì†µÌ±éÌ†µÌ±ü(Ì†µÌ±•)

from scipy import stats
import numpy as np y, x = salary.salary, salary.experience beta, beta0, r_value, p_value, std_err = stats.linregress(x,y) print("y = %f x + %f, r: %f, r-squared: %f,\np-value: %f, std_err: %f"
% (beta, beta0, r_value, r_value**2, p_value, std_err))

print("Regression line with the scatterplot") yhat = beta * x + beta0 # regression line

(continues on next page)

4.1. Univariate statistics

87

Statistics and Machine Learning in Python, Release 0.2

plt.plot(x, yhat, r- , x, y, o ) plt.xlabel( Experience (years) ) plt.ylabel( Salary ) plt.show()
print("Using seaborn") import seaborn as sns sns.regplot(x="experience", y="salary", data=salary);

(continued from previous page)

y = 491.486913 x + 13584.043803, r: 0.538886, r-squared: 0.290398, p-value: 0.000112, std_err: 115.823381 Regression line with the scatterplot

Using seaborn 88

Chapter 4. Statistics

Statistics and Machine Learning in Python, Release 0.2

3. Ì†µÌ∞π -Test
3.1 Goodness of Ô¨Åt
The goodness of Ô¨Åt of a statistical model describes how well it Ô¨Åts a set of observations. Measures of goodness of Ô¨Åt typically summarize the discrepancy between observed values and the values expected under the model in question. We will consider the explained variance also known as the coefÔ¨Åcient of determination, denoted Ì†µÌ±Ö2 pronounced R-squared. The total sum of squares, Ì†µÌ±ÜÌ†µÌ±Ütot is the sum of the sum of squares explained by the regression, Ì†µÌ±ÜÌ†µÌ±Üreg, plus the sum of squares of residuals unexplained by the regression, Ì†µÌ±ÜÌ†µÌ±Üres, also called the SSE, i.e. such that
Ì†µÌ±ÜÌ†µÌ±Ütot = Ì†µÌ±ÜÌ†µÌ±Üreg + Ì†µÌ±ÜÌ†µÌ±Üres

Fig. 4: title

4.1. Univariate statistics

89

Statistics and Machine Learning in Python, Release 0.2

The mean of Ì†µÌ±¶ is

1 ‚àëÔ∏Å

Ì†µ¬ØÌ±¶ = Ì†µÌ±õ

Ì†µÌ±¶Ì†µÌ±ñ.

Ì†µÌ±ñ

The total sum of squares is the total squared sum of deviations from the mean of Ì†µÌ±¶, i.e.

Ì†µÌ±ÜÌ†µÌ±Ütot

=

‚àëÔ∏Å (Ì†µÌ±¶Ì†µÌ±ñ

‚àí

Ì†µ¬ØÌ±¶)2

Ì†µÌ±ñ

The regression sum of squares, also called the explained sum of squares:

Ì†µÌ±ÜÌ†µÌ±Üreg

=

‚àëÔ∏Å (Ì†µÀÜÌ±¶Ì†µÌ±ñ

‚àí

Ì†µ¬ØÌ±¶)2,

Ì†µÌ±ñ

where Ì†µÀÜÌ±¶Ì†µÌ±ñ = Ì†µÌªΩÌ†µÌ±•Ì†µÌ±ñ + Ì†µÌªΩ0 is the estimated value of salary Ì†µÀÜÌ±¶Ì†µÌ±ñ given a value of experience Ì†µÌ±•Ì†µÌ±ñ. The sum of squares of the residuals, also called the residual sum of squares (RSS) is:

Ì†µÌ±ÜÌ†µÌ±Üres

=

‚àëÔ∏Å (Ì†µÌ±¶Ì†µÌ±ñ

‚àí

Ì†µÀÜÌ±¶Ì†µÌ±ñ)2.

Ì†µÌ±ñ

Ì†µÌ±Ö2 is the explained sum of squares of errors. It is the variance explain by the regression divided by the total variance, i.e.

Ì†µÌ±Ö2 = explained SS = Ì†µÌ±ÜÌ†µÌ±Üreg = 1 ‚àí Ì†µÌ±ÜÌ†µÌ±ÜÌ†µÌ±üÌ†µÌ±íÌ†µÌ±† .

total SS

Ì†µÌ±ÜÌ†µÌ±ÜÌ†µÌ±°Ì†µÌ±úÌ†µÌ±°

Ì†µÌ±ÜÌ†µÌ±ÜÌ†µÌ±°Ì†µÌ±úÌ†µÌ±°

3.2 Test

Let Ì†µÀÜÌºé2 = Ì†µÌ±ÜÌ†µÌ±Üres/(Ì†µÌ±õ ‚àí 2) be an estimator of the variance of Ì†µÌºñ. The 2 in the denominator stems from the 2 estimated parameters: intercept and coefÔ¨Åcient.

‚Ä¢

Unexplained variance:

Ì†µÌ±ÜÌ†µÌ±Üres Ì†µ^Ìºé2

‚àº Ì†µÌºí2Ì†µÌ±õ‚àí2

‚Ä¢

Explained variance:

Ì†µÌ±ÜÌ†µÌ±Üreg Ì†µ^Ìºé2

‚àº Ì†µÌºí21. The single degree of freedom comes from the difference

between

Ì†µÌ±ÜÌ†µÌ±Ütot Ì†µ^Ìºé2

(‚àº

Ì†µÌºí2Ì†µÌ±õ‚àí1)

and

Ì†µÌ±ÜÌ†µÌ±Üres Ì†µ^Ìºé2

(‚àº

Ì†µÌºí2Ì†µÌ±õ‚àí2),

i.e.

(Ì†µÌ±õ

‚àí

1)

‚àí

(Ì†µÌ±õ

‚àí

2)

degree

of

freedom.

The Fisher statistics of the ratio of two variances:

Explained variance

Ì†µÌ∞π =

=

Ì†µÌ±ÜÌ†µÌ±Üreg/1

‚àº Ì†µÌ∞π (1, Ì†µÌ±õ ‚àí 2)

Unexplained variance Ì†µÌ±ÜÌ†µÌ±Üres/(Ì†µÌ±õ ‚àí 2)

Using the Ì†µÌ∞π -distribution, compute the probability of observing a value greater than Ì†µÌ∞π under Ì†µÌ∞ª0, i.e.: Ì†µÌ±É (Ì†µÌ±• > Ì†µÌ∞π |Ì†µÌ∞ª0), i.e. the survival function (1 ‚àí Cumulative Distribution Function) at Ì†µÌ±• of the given Ì†µÌ∞π -distribution.

Multiple regression Theory
Muliple Linear Regression is the most basic supervised learning algorithm. Given: a set of training data {Ì†µÌ±•1, ..., Ì†µÌ±•Ì†µÌ±Å } with corresponding targets {Ì†µÌ±¶1, ..., Ì†µÌ±¶Ì†µÌ±Å }.

90

Chapter 4. Statistics

Statistics and Machine Learning in Python, Release 0.2

In linear regression, we assume that the model that generates the data involves only a linear combination of the input variables, i.e.

Ì†µÌ±¶(Ì†µÌ±•Ì†µÌ±ñ, Ì†µÌªΩ) = Ì†µÌªΩ0 + Ì†µÌªΩ1Ì†µÌ±•1Ì†µÌ±ñ + ... + Ì†µÌªΩÌ†µÌ±É Ì†µÌ±•Ì†µÌ†µÌ±ñÌ±É ,

or, simpliÔ¨Åed

Ì†µÌ±É ‚àí1
Ì†µÌ±¶(Ì†µÌ±•Ì†µÌ±ñ, Ì†µÌªΩ) = Ì†µÌªΩ0 + ‚àëÔ∏Å Ì†µÌªΩÌ†µÌ±óÌ†µÌ±•Ì†µÌ†µÌ±ñÌ±ó.
Ì†µÌ±ó=1

Extending each sample with an intercept, Ì†µÌ±•Ì†µÌ±ñ := [1, Ì†µÌ±•Ì†µÌ±ñ] ‚àà Ì†µÌ±ÖÌ†µÌ±É +1 allows us to use a more general notation based on linear algebra and write it as a simple dot product:

Ì†µÌ±¶(Ì†µÌ±•Ì†µÌ±ñ, Ì†µÌªΩ) = Ì†µÌ±•Ì†µÌ†µÌ±ñÌ±á Ì†µÌªΩ,
where Ì†µÌªΩ ‚àà Ì†µÌ±ÖÌ†µÌ±É +1 is a vector of weights that deÔ¨Åne the Ì†µÌ±É + 1 parameters of the model. From now we have Ì†µÌ±É regressors + the intercept. Minimize the Mean Squared Error MSE loss:

Ì†µÌ±Ä Ì†µÌ±ÜÌ†µÌ∞∏(Ì†µÌªΩ)

=

1 Ì†µÌ±Å

Ì†µÌ±Å
‚àëÔ∏Å (Ì†µÌ±¶Ì†µÌ±ñ

‚àí

Ì†µÌ±¶(Ì†µÌ±•Ì†µÌ±ñ, Ì†µÌªΩ))2

=

1 Ì†µÌ±Å

Ì†µÌ±Å
‚àëÔ∏Å (Ì†µÌ±¶Ì†µÌ±ñ

‚àí

Ì†µÌ±•Ì†µÌ†µÌ±ñÌ±á Ì†µÌªΩ)2

Ì†µÌ±ñ=1

Ì†µÌ±ñ=1

Let Ì†µÌ±ã = [Ì†µÌ±•Ì†µ0Ì±á , ..., Ì†µÌ±•Ì†µÌ†µÌ±áÌ±Å ] be a Ì†µÌ±Å √ó Ì†µÌ±É + 1 matrix of Ì†µÌ±Å samples of Ì†µÌ±É input features with one column of one and let be Ì†µÌ±¶ = [Ì†µÌ±¶1, ..., Ì†µÌ±¶Ì†µÌ±Å ] be a vector of the Ì†µÌ±Å targets. Then, using linear algebra, the
mean squared error (MSE) loss can be rewritten:

Ì†µÌ±Ä Ì†µÌ±ÜÌ†µÌ∞∏(Ì†µÌªΩ)

=

1 Ì†µÌ±Å

||Ì†µÌ±¶

‚àí

Ì†µÌ±ã Ì†µÌªΩ ||22 .

The Ì†µÌªΩ that minimises the MSE can be found by:

‚àáÌ†µÌªΩ

(Ô∏Ç

1 Ì†µÌ±Å

||Ì†µÌ±¶

‚àí

Ì†µÌ±ã

Ì†µÌªΩ

||22

)Ô∏Ç

=

0

1 Ì†µÌ±Å

‚àáÌ†µÌªΩ (Ì†µÌ±¶

‚àí

Ì†µÌ±ã Ì†µÌªΩ )Ì†µÌ±á

(Ì†µÌ±¶

‚àí

Ì†µÌ±ã Ì†µÌªΩ )

=

0

1 Ì†µÌ±Å

‚àáÌ†µÌªΩ

(Ì†µÌ±¶Ì†µÌ±á

Ì†µÌ±¶

‚àí

2Ì†µÌªΩÌ†µÌ±á

Ì†µÌ±ã

Ì†µÌ±á

Ì†µÌ±¶

+

Ì†µÌªΩÌ†µÌ±ã

Ì†µÌ±á

Ì†µÌ±ã

Ì†µÌªΩ)

=

0

‚àí2Ì†µÌ±ãÌ†µÌ±á Ì†µÌ±¶ + 2Ì†µÌ±ãÌ†µÌ±á Ì†µÌ±ãÌ†µÌªΩ = 0

Ì†µÌ±ãÌ†µÌ±á Ì†µÌ±ãÌ†µÌªΩ = Ì†µÌ±ãÌ†µÌ±á Ì†µÌ±¶

Ì†µÌªΩ = (Ì†µÌ±ãÌ†µÌ±á Ì†µÌ±ã)‚àí1Ì†µÌ±ãÌ†µÌ±á Ì†µÌ±¶,

where (Ì†µÌ±ãÌ†µÌ±á Ì†µÌ±ã)‚àí1Ì†µÌ±ãÌ†µÌ±á is a pseudo inverse of Ì†µÌ±ã.

(4.20)
(4.21)
(4.22) (4.23) (4.24) (4.25)

Fit with numpy

import numpy as np from scipy import linalg np.random.seed(seed=42) # make the example reproducible
4.1. Univariate statistics

(continues on next page)
91

Statistics and Machine Learning in Python, Release 0.2

# Dataset N, P = 50, 4 X = np.random.normal(size= N * P).reshape((N, P)) ## Our model needs an intercept so we add a column of 1s: X[:, 0] = 1 print(X[:5, :])
betastar = np.array([10, 1., .5, 0.1]) e = np.random.normal(size=N) y = np.dot(X, betastar) + e
# Estimate the parameters Xpinv = linalg.pinv2(X) betahat = np.dot(Xpinv, y) print("Estimated beta:\n", betahat)

[[ 1.

-0.1382643 0.64768854 1.52302986]

[ 1.

-0.23413696 1.57921282 0.76743473]

[ 1.

0.54256004 -0.46341769 -0.46572975]

[ 1.

-1.91328024 -1.72491783 -0.56228753]

[ 1.

0.31424733 -0.90802408 -1.4123037 ]]

Estimated beta:

[10.14742501 0.57938106 0.51654653 0.17862194]

(continued from previous page)

4.1.7 Linear model with statsmodels
Sources: http://statsmodels.sourceforge.net/devel/examples/

Multiple regression Interface with Numpy

import statsmodels.api as sm
## Fit and summary: model = sm.OLS(y, X).fit() print(model.summary())
# prediction of new values ypred = model.predict(X)
# residuals + prediction == true values assert np.all(ypred + model.resid == y)

OLS Regression Results

==============================================================================

Dep. Variable:

y R-squared:

0.363

Model:

OLS Adj. R-squared:

0.322

Method:

Least Squares F-statistic:

8.748

Date:

Thu, 16 May 2019 Prob (F-statistic):

0.000106

(continues on next page)

92

Chapter 4. Statistics

Statistics and Machine Learning in Python, Release 0.2

(continued from previous page)

Time:

20:15:04 Log-Likelihood:

-71.271

No. Observations:

50 AIC:

150.5

Df Residuals:

46 BIC:

158.2

Df Model:

3

Covariance Type:

nonrobust

==============================================================================

coef std err

t

P>|t|

[0.025

0.975]

------------------------------------------------------------------------------

const

10.1474

0.150 67.520

0.000

9.845

10.450

x1

0.5794

0.160

3.623

0.001

0.258

0.901

x2

0.5165

0.151

3.425

0.001

0.213

0.820

x3

0.1786

0.144

1.240

0.221

-0.111

0.469

==============================================================================

Omnibus:

2.493 Durbin-Watson:

2.369

Prob(Omnibus):

0.288 Jarque-Bera (JB):

1.544

Skew:

0.330 Prob(JB):

0.462

Kurtosis:

3.554 Cond. No.

1.27

==============================================================================

Warnings: [1] Standard Errors assume that the covariance matrix of the errors is correctly‚ê£ Àì‚Üíspecified.

Interface with Pandas

Use R language syntax for data.frame. For an additive model: Ì†µÌ±¶Ì†µÌ±ñ = Ì†µÌªΩ0 + Ì†µÌ±•1Ì†µÌ±ñ Ì†µÌªΩ1 + Ì†µÌ±•2Ì†µÌ±ñ Ì†µÌªΩ2 + Ì†µÌºñÌ†µÌ±ñ ‚â° y ~ x1 + x2.

import statsmodels.formula.api as smfrmla

df = pd.DataFrame(np.column_stack([X, y]), columns=[ inter , print(df.columns, df.shape) # Build a model excluding the intercept, it is implicit model = smfrmla.ols("y~x1 + x2 + x3", df).fit() print(model.summary())

x1 , x2 ,

x3 ,

y ])

Index([ inter , x1 , x2 , x3 , y ], dtype= object ) (50, 5)

OLS Regression Results

==============================================================================

Dep. Variable:

y R-squared:

0.363

Model:

OLS Adj. R-squared:

0.322

Method:

Least Squares F-statistic:

8.748

Date:

Thu, 16 May 2019 Prob (F-statistic):

0.000106

Time:

20:15:04 Log-Likelihood:

-71.271

No. Observations:

50 AIC:

150.5

Df Residuals:

46 BIC:

158.2

Df Model:

3

Covariance Type:

nonrobust

==============================================================================

coef std err

t

P>|t|

[0.025

0.975]

------------------------------------------------------------------------------

Intercept 10.1474

0.150 67.520

0.000

9.845

10.450

x1

0.5794

0.160

3.623

0.001

0.258

0.901

(continues on next page)

4.1. Univariate statistics

93

Statistics and Machine Learning in Python, Release 0.2

(continued from previous page)

x2

0.5165

0.151

3.425

0.001

0.213

0.820

x3

0.1786

0.144

1.240

0.221

-0.111

0.469

==============================================================================

Omnibus:

2.493 Durbin-Watson:

2.369

Prob(Omnibus):

0.288 Jarque-Bera (JB):

1.544

Skew:

0.330 Prob(JB):

0.462

Kurtosis:

3.554 Cond. No.

1.27

==============================================================================

Warnings: [1] Standard Errors assume that the covariance matrix of the errors is correctly‚ê£ Àì‚Üíspecified.

Multiple regression with categorical independent variables or factors: Analysis of covariance (ANCOVA)
Analysis of covariance (ANCOVA) is a linear model that blends ANOVA and linear regression. ANCOVA evaluates whether population means of a dependent variable (DV) are equal across levels of a categorical independent variable (IV) often called a treatment, while statistically controlling for the effects of other quantitative or continuous variables that are not of primary interest, known as covariates (CV).
import pandas as pd import matplotlib.pyplot as plt %matplotlib inline
try: salary = pd.read_csv("../datasets/salary_table.csv")
except: url = https://raw.github.com/neurospin/pystatsml/master/datasets/salary_table.csv salary = pd.read_csv(url)

One-way AN(C)OVA

‚Ä¢ ANOVA: one categorical independent variable, i.e. one factor.
‚Ä¢ ANCOVA: ANOVA with some covariates.
import statsmodels.formula.api as smfrmla
oneway = smfrmla.ols( salary ~ management + experience , salary).fit() print(oneway.summary()) aov = sm.stats.anova_lm(oneway, typ=2) # Type 2 ANOVA DataFrame print(aov)

OLS Regression Results

==============================================================================

Dep. Variable:

salary R-squared:

0.865

Model:

OLS Adj. R-squared:

0.859

Method:

Least Squares F-statistic:

138.2

Date:

Thu, 16 May 2019 Prob (F-statistic):

1.90e-19

(continues on next page)

94

Chapter 4. Statistics

Statistics and Machine Learning in Python, Release 0.2

(continued from previous page)

Time:

20:15:04 Log-Likelihood:

-407.76

No. Observations:

46 AIC:

821.5

Df Residuals:

43 BIC:

827.0

Df Model:

2

Covariance Type:

nonrobust

===================================================================================

coef std err

t

P>|t|

[0.025

0.975]

-----------------------------------------------------------------------------------

Intercept

1.021e+04 525.999 19.411

0.000 9149.578 1.13e+04

management[T.Y] 7145.0151 527.320 13.550

0.000 6081.572 8208.458

experience

527.1081 51.106 10.314

0.000 424.042 630.174

==============================================================================

Omnibus:

11.437 Durbin-Watson:

2.193

Prob(Omnibus):

0.003 Jarque-Bera (JB):

11.260

Skew:

-1.131 Prob(JB):

0.00359

Kurtosis:

3.872 Cond. No.

22.4

==============================================================================

Warnings:

[1] Standard Errors assume that the covariance matrix of the errors is correctly‚ê£

Àì‚Üíspecified.

sum_sq df

F

PR(>F)

management 5.755739e+08 1.0 183.593466 4.054116e-17

experience 3.334992e+08 1.0 106.377768 3.349662e-13

Residual 1.348070e+08 43.0

NaN

NaN

Two-way AN(C)OVA

Ancova with two categorical independent variables, i.e. two factors.
import statsmodels.formula.api as smfrmla
twoway = smfrmla.ols( salary ~ education + management + experience , salary).fit() print(twoway.summary()) aov = sm.stats.anova_lm(twoway, typ=2) # Type 2 ANOVA DataFrame print(aov)

OLS Regression Results

==============================================================================

Dep. Variable:

salary R-squared:

0.957

Model:

OLS Adj. R-squared:

0.953

Method:

Least Squares F-statistic:

226.8

Date:

Thu, 16 May 2019 Prob (F-statistic):

2.23e-27

Time:

20:15:04 Log-Likelihood:

-381.63

No. Observations:

46 AIC:

773.3

Df Residuals:

41 BIC:

782.4

Df Model:

4

Covariance Type:

nonrobust

=======================================================================================

coef std err

t

P>|t|

[0.025

0.975]

---------------------------------------------------------------------------------------

Intercept

8035.5976 386.689 20.781

0.000 7254.663 8816.532

education[T.Master] 3144.0352 361.968

8.686

0.000 2413.025 3875.045

(continues on next page)

4.1. Univariate statistics

95

Statistics and Machine Learning in Python, Release 0.2

(continued from previous page)

education[T.Ph.D] 2996.2103 411.753

7.277

0.000 2164.659 3827.762

management[T.Y]

6883.5310 313.919 21.928

0.000 6249.559 7517.503

experience

546.1840 30.519 17.896

0.000 484.549 607.819

==============================================================================

Omnibus:

2.293 Durbin-Watson:

2.237

Prob(Omnibus):

0.318 Jarque-Bera (JB):

1.362

Skew:

-0.077 Prob(JB):

0.506

Kurtosis:

2.171 Cond. No.

33.5

==============================================================================

Warnings:

[1] Standard Errors assume that the covariance matrix of the errors is correctly‚ê£

Àì‚Üíspecified.

sum_sq df

F

PR(>F)

education 9.152624e+07 2.0 43.351589 7.672450e-11

management 5.075724e+08 1.0 480.825394 2.901444e-24

experience 3.380979e+08 1.0 320.281524 5.546313e-21

Residual 4.328072e+07 41.0

NaN

NaN

Comparing two nested models
oneway is nested within twoway. Comparing two nested models tells us if the additional predictors (i.e. education) of the full model signiÔ¨Åcantly decrease the residuals. Such comparison can be done using an Ì†µÌ∞π -test on residuals: print(twoway.compare_f_test(oneway)) # return F, pval, df
(43.35158945918107, 7.672449570495418e-11, 2.0)

Factor coding

See http://statsmodels.sourceforge.net/devel/contrasts.html
By default Pandas use ‚Äúdummy coding‚Äù. Explore:
print(twoway.model.data.param_names) print(twoway.model.data.exog[:10, :])

[ Intercept , education[T.Master] , [[1. 0. 0. 1. 1.] [1. 0. 1. 0. 1.] [1. 0. 1. 1. 1.] [1. 1. 0. 0. 1.] [1. 0. 1. 0. 1.] [1. 1. 0. 1. 2.] [1. 1. 0. 0. 2.] [1. 0. 0. 0. 2.] [1. 0. 1. 0. 2.] [1. 1. 0. 0. 3.]]

education[T.Ph.D] ,

management[T.Y] ,

experience ]

96

Chapter 4. Statistics

