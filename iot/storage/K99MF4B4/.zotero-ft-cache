Toward organic ambient intelligences ? : EMMA
Clément Duhart
To cite this version:
Clément Duhart. Toward organic ambient intelligences ? : EMMA. Artificial Intelligence [cs.AI]. Université du Havre, 2016. English. ￿NNT : 2016LEHA0035￿. ￿tel-01635625￿

HAL Id: tel-01635625 https://tel.archives-ouvertes.fr/tel-01635625
Submitted on 15 Nov 2017

HAL is a multi-disciplinary open access archive for the deposit and dissemination of scientific research documents, whether they are published or not. The documents may come from teaching and research institutions in France or abroad, or from public or private research centers.

L’archive ouverte pluridisciplinaire HAL, est destinée au dépôt et à la diffusion de documents scientifiques de niveau recherche, publiés ou non, émanant des établissements d’enseignement et de recherche français ou étrangers, des laboratoires publics ou privés.

THESE
Pour obtenir le diplôme de doctorat
Spécialité Informatique Préparée au sein de l'Université du Havre

Toward Organic Ambient Intelligences ? EMMA
Présentée et soutenue par
Clément DUHART

Mme Salima HASSAS Mr Frederic WEIS Mr Francis ROUSSEAUX Mr Joseph PARADISO Mr Laurent GEORGE Mr Cyrille BERTELLE Mr Jean-Marc LACROIX Mr David MENGA

Thèse soutenue publiquement le (date de soutenance) devant le jury composé de

Professeur Université Claude Bernard Lyon 1

CNRS

Rapporteur

Maître de Conférences Université de Rennes 1 HDR

IRISA

Rapporteur

Professeur Université de Reims

IRCAM

Examinateur

Professeur MediaLab

MIT

Examinateur

Professeur ESIEE Paris

INRIA

Examinateur

Professeur Université du Havre

LITIS

Directeur de thèse

Chercheur à Thalès Securité

Invité

Chercheur à Électricité de France (EDF)

Invité

Cyrille BERTELLE, LITIS

PhD prepared at LITIS – EA 4108 Laboratoire d’Informatique, du Traitement de l’Information et des Systèmes Université du Havre 25 Rue Philippe Lebon, 76600 Le Havre, FRANCE
PhD in collaboration with LACSC Laboratoire d’Analyse et Contrôle des Systèmes Complexes ECE Paris 37, Quai de Grenelle Paris, 75725, FRANCE
PhD in collaboration with MIT Medialab Media Art and Sciences Massachusetts Institute of Technology 75 Amherst St, Cambridge, MA 02139, USA

Les pages se tournent et ne se ressemblent pas, mais quand celle-ci est la dernière, celle qui clôt un chapitre, on y respire à travers le temps passé. Certains instants dans la vie d’un doctorant peuvent ressembler à une traversée du désert où essouﬄé, seul et désorienté, on oublie de lever les yeux pour voir la forêt qui nous entoure. Tout a commencé dans le sous-bois de l’ECE Paris, où deux chênes protecteurs, Brouaye et Rouyres ont formé l’étudiant devenu enseignant.
C’est alors que dans un coin ensoleillé, le discret marronnier Laurent George, par une coque tombée, m’indiquait la voie de la Recherche. Au loin se distinguait le cyprès Cyrille Bertelle qui me montrait l’entrée de cette forêt où j’allais pendant quatre ans cheminer. J’avançais en quête d’idées, quand David Menga, le plus haut des peupliers, m’orienta sur le sentier de l’internet des objets. Depuis la canopée, ce guide ne m’a jamais quitté.
Perdu dans mes pensées, il m’est souvent arrivé d’être rappelé à la réalité lorsque mon pas décidé croisait le destin d’une Pierre, tantôt Courbin tantôt Sauvage dans la mousse dissimulée. Quand certains jours la thèse était trop lourde à porter, j’ai pu échanger avec les Ents Faust, Worms et Fauberteau toujours enclins à m’accompagner. Plongé au cœur de cette forêt en perpétuelle régénération, j’y ai puisé des graines auprès des noisetiers Sylvain Leroy ou encore Cherrier. Ces dernières tout juste plantées ont permis aux jeunes arbustes Mardegan et Sonti de pousser.
C’est en préparant ma sortie de forêt que la liane Xiao Xiao m’a hissé vers cette ancienne contrée dont les mythes m’ont toujours hanté. J’y ai fait la rencontre de JoeP, le Baobab atypique, qui nourrit sa communauté au rythme incessant des promeneurs égarés.
Quand le vent a trop souﬄé, j’ai toujours su où m’harnacher auprès des arbres Sensei Lecouvé, Zerhat et Taieb et de leurs protégés Khalifa, Carl et bien d’autres ...
À tous ces arbres.
À mes amis qui ont su être là.
À ma famille qui a su me faire pousser droit.
À ma douce ﬁancée qui a su ne pas être jalouse d’Emma.

Author’s publication list
Peer Review Conferences and Journal
1. [DCB13] Clement Duhart, Michel Cotsaftis, and Cyrille Bertelle.
“Lightweight Distributed Adaptive Algorithm for Voting Procedures by Using Network Average Consensus”. English. In: PRIMA 2013: Principles and Practice of Multi-Agent Systems. Volume 8291. Lecture Notes in Computer Science. Springer Berlin Heidelberg, 2013, pages 421–428. isbn: 978-3-642-44926-0. doi: 10.1007/978-3-642-44927-7_30
2. [DCB14] Clement Duhart, Michel Cotsaftis, and Cyrille Bertelle.
“Wireless Sensor Network Cloud Services: Towards a Partial Delegation”. In: Proceedings of 5th International Conference on Smart Communications in Network Technologies 2014 (IEEE SaCoNeT 2014). Vilanova i la Geltru, Spain, June 2014
3. [DB14] Clement Duhart and Cyrille Bertelle. “Methodology
for Artiﬁcial Neural controllers on wireless sensor network”. In: IEEE Conference on Wireless Sensors (ICWiSE). 2014, pages 67–72. doi: 10. 1109/ICWISE.2014.7042663
4. [DB15] Clement Duhart and Cyrille Bertelle. “Toward Organic
Computing Approach for Cybernetic Responsive Environment”. In: International Journal of Ambient Systems and Applications (IJASA) 3.4 (2015). doi: DOI:10.5121/ijasa.2015.3401
Submissions
1. [DSB] Clement Duhart, Pierre Sauvage, and Cyrille Bertelle.
“A Resource Oriented Framework for Service Choreography over Wireless Sensor and Actor Networks”. In: Submission in International Journal of Wireless Information Networks (IJWI) ()
2. [May+16] Brian Mayton, Gershon Dublon, Spencer Russell, Evan
Clement Duhart F. Lynch, Vasant Ramasubramanian, Donald Derek Haddad, , Qiansheng Li, Glorianna Davenport, and Joseph A. Paradiso. “Deploying the Living Observatory: From Environmental Sensor Network to Networked Sensory Landscape”. In: Submission in ACM. 2016

Contents

I Introduction

1

1 General introduction

3

1.1 Internet of Things . . . . . . . . . . . . . . . . . . . . . . . . . . . 3

1.1.1 Business Opportunities . . . . . . . . . . . . . . . . . . . . 4

1.1.1.1 Economy, Society and Technologies . . . . . . . . 4

1.1.1.2 Many Visions Converging . . . . . . . . . . . . . 4

1.1.1.3 Current and Future Applications . . . . . . . . . 4

1.1.2 Technology Challenges . . . . . . . . . . . . . . . . . . . . 6

1.1.2.1 A Meeting of Engineering . . . . . . . . . . . . . 6

1.1.2.2 Ubiquitous Computing . . . . . . . . . . . . . . . 6

1.1.2.3 Towards Web 3.0 . . . . . . . . . . . . . . . . . . 6

1.2 Motivations of the Thesis . . . . . . . . . . . . . . . . . . . . . . . 7

1.3 Contributions and Content . . . . . . . . . . . . . . . . . . . . . . 8

2 State of the Art

9

2.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10

2.2 Wireless Sensor and Actor Networks . . . . . . . . . . . . . . . . 11

2.2.1 Connected Objects . . . . . . . . . . . . . . . . . . . . . . 12

2.2.1.1 Identiﬁcation, Sensing and Acting . . . . . . . . . 12

2.2.1.2 Energy, Computation and Communication . . . . 12

2.2.1.3 Lifetime, Design and Maintenance . . . . . . . . 13

2.2.2 IP-Based Network . . . . . . . . . . . . . . . . . . . . . . . 14

2.2.2.1 Low Power ZigBee Technologies . . . . . . . . . . 14

2.2.2.2 Network, Routing and Security . . . . . . . . . . 15

2.2.2.3 Heterogeneity and Internet Integration . . . . . . 17

2.2.3 Software Architectures . . . . . . . . . . . . . . . . . . . . 17

2.2.3.1 Data Formatting and Application Protocols . . . 18

2.2.3.2 Web Service Orchestration and Choreography . . 19

2.2.3.3 Object Abstraction and Middleware . . . . . . . 20

2.3 Ambient Intelligence . . . . . . . . . . . . . . . . . . . . . . . . . 22

2.3.1 Responsive Environment . . . . . . . . . . . . . . . . . . . 24

2.3.1.1 Event Condition Action Rules . . . . . . . . . . . 24

2.3.1.2 Action Planning . . . . . . . . . . . . . . . . . . 24

2.3.1.3 Decision Tree . . . . . . . . . . . . . . . . . . . . 24

2.3.2 Reasoning Engine . . . . . . . . . . . . . . . . . . . . . . . 25

2.3.2.1 Fuzzy Rule-Based Engine . . . . . . . . . . . . . 25

2.3.2.2 Context-Awareness System . . . . . . . . . . . . 25

2.3.2.3 Learning Techniques . . . . . . . . . . . . . . . . 25

4

Contents

2.3.3 Ambient Intelligence Architectures . . . . . . . . . . . . . 26 2.3.3.1 Autonomic Computing . . . . . . . . . . . . . . . 26 2.3.3.2 Multi-Agent System . . . . . . . . . . . . . . . . 27
2.4 Organic Computing Approach . . . . . . . . . . . . . . . . . . . . 28 2.4.1 Principles and Challenges . . . . . . . . . . . . . . . . . . 28 2.4.1.1 Trustworthy Systems . . . . . . . . . . . . . . . . 28 2.4.1.2 Self-X Properties . . . . . . . . . . . . . . . . . . 28 2.4.1.3 Design Methodology . . . . . . . . . . . . . . . . 29 2.4.2 Models and Architectures . . . . . . . . . . . . . . . . . . 29 2.4.2.1 Observer-Controller Model . . . . . . . . . . . . . 29 2.4.2.2 Multi-Scale Architecture . . . . . . . . . . . . . . 30 2.4.2.3 Evolutionary Computation . . . . . . . . . . . . . 30 2.4.3 Application Examples . . . . . . . . . . . . . . . . . . . . 31 2.4.3.1 System on Chip . . . . . . . . . . . . . . . . . . . 31 2.4.3.2 Traﬃc Lights in a Smart City . . . . . . . . . . . 32 2.4.3.3 Energy Management in Smart Homes . . . . . . . 32
2.5 Synthesis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33

Contribution: An Organic Ambient Intelligence

37

II An Organic IoT Framework

41

3 Capillar Internet Network

43

3.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44

3.2 Network Infrastructure . . . . . . . . . . . . . . . . . . . . . . . . 45

3.2.1 Wireless Sensor and Actor Networks . . . . . . . . . . . . 46

3.2.1.1 IP Connectivity: 6LoWPAN . . . . . . . . . . . . 46

3.2.1.2 Routing Protocol: RPL . . . . . . . . . . . . . . 46

3.2.1.3 Gateway: Border Edge Router . . . . . . . . . . 47

3.2.2 Home Information System . . . . . . . . . . . . . . . . . . 47

3.2.2.1 Permanent Gateway . . . . . . . . . . . . . . . . 48

3.2.2.2 Mobile Gateway . . . . . . . . . . . . . . . . . . 48

3.2.2.3 IPv6 Backbone . . . . . . . . . . . . . . . . . . . 49

3.2.3 Internet Integration . . . . . . . . . . . . . . . . . . . . . . 49

3.3 Service-Oriented Architectures . . . . . . . . . . . . . . . . . . . . 51

3.3.1 Resource-Oriented Architecture . . . . . . . . . . . . . . . 51

3.3.2 Experimental Model Analysis . . . . . . . . . . . . . . . . 52

3.3.2.1 Service Orchestration . . . . . . . . . . . . . . . . 52

3.3.2.2 Service Choreography . . . . . . . . . . . . . . . 53

3.4 Software Tool Contributions . . . . . . . . . . . . . . . . . . . . . 54

3.4.1 Active Resource Middleware . . . . . . . . . . . . . . . . . 54

Contents

5

3.4.2 Hybrid Network Simulator . . . . . . . . . . . . . . . . . . 54 3.4.3 Service Choreography Software . . . . . . . . . . . . . . . 55 3.4.4 Network Tools and Connectors . . . . . . . . . . . . . . . 55 3.5 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56

4 Active Resource Middleware

57

4.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58

4.2 Architecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59

4.2.1 System Components . . . . . . . . . . . . . . . . . . . . . 59

4.2.2 Resource File System . . . . . . . . . . . . . . . . . . . . . 60

4.2.3 COAP Web service Interface . . . . . . . . . . . . . . . . . 61

4.3 System Dynamic . . . . . . . . . . . . . . . . . . . . . . . . . . . 62

4.3.1 Basic Services . . . . . . . . . . . . . . . . . . . . . . . . . 62

4.3.1.1 Local Service . . . . . . . . . . . . . . . . . . . . 62

4.3.1.2 System Service . . . . . . . . . . . . . . . . . . . 62

4.3.1.3 Agent Service . . . . . . . . . . . . . . . . . . . . 63

4.3.1.3.1 Publish-Subscribe Agent . . . . . . . . . 63

4.3.1.3.2 Composed Agent . . . . . . . . . . . . . 64

4.3.1.3.3 Self-X Agent . . . . . . . . . . . . . . . 64

4.3.2 Computation Flows . . . . . . . . . . . . . . . . . . . . . . 65

4.3.3 Graphical Model . . . . . . . . . . . . . . . . . . . . . . . 66

4.4 Service Choreography . . . . . . . . . . . . . . . . . . . . . . . . . 67

4.4.1 Hierarchical Composition . . . . . . . . . . . . . . . . . . . 67

4.4.2 Web Service Heterogeneity . . . . . . . . . . . . . . . . . . 68

4.4.3 Name Space Security . . . . . . . . . . . . . . . . . . . . . 69

4.5 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70

5 Service Choreography Deployment

71

5.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72

5.2 Network Mapping Process . . . . . . . . . . . . . . . . . . . . . . 73

5.2.1 Stages Overview . . . . . . . . . . . . . . . . . . . . . . . 74

5.2.1.1 Functional Design . . . . . . . . . . . . . . . . . 74

5.2.1.2 Instantiation and Simulation . . . . . . . . . . . 74

5.2.1.3 Network Mapping . . . . . . . . . . . . . . . . . 75

5.2.2 Dynamic Deployment . . . . . . . . . . . . . . . . . . . . . 76

5.2.2.1 Residual Network Agents . . . . . . . . . . . . . 76

5.2.2.2 Dynamic Network Agents . . . . . . . . . . . . . 76

5.2.2.3 Self-X Agents . . . . . . . . . . . . . . . . . . . . 76

5.2.3 Deployment Process . . . . . . . . . . . . . . . . . . . . . 77

5.2.3.1 Direct Deployment . . . . . . . . . . . . . . . . . 77

5.2.3.2 Deployment Container . . . . . . . . . . . . . . . 77

5.2.3.3 Self-Deployment Container . . . . . . . . . . . . 78

6

Contents

5.3 Theoretical Background . . . . . . . . . . . . . . . . . . . . . . . 79 5.3.1 Model Deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . 79 5.3.1.1 Network . . . . . . . . . . . . . . . . . . . . . . . 79 5.3.1.2 Resources . . . . . . . . . . . . . . . . . . . . . . 79 5.3.1.3 Scopes . . . . . . . . . . . . . . . . . . . . . . . . 79 5.3.1.4 Places . . . . . . . . . . . . . . . . . . . . . . . . 80 5.3.2 Problem Formulation . . . . . . . . . . . . . . . . . . . . . 80 5.3.2.1 Knapsack Problems . . . . . . . . . . . . . . . . 80 5.3.2.2 Service Choreography Mapping . . . . . . . . . . 80 5.3.3 Pseudo-Boolean Optimization . . . . . . . . . . . . . . . . 81 5.3.3.1 Communication Cost Function . . . . . . . . . . 82 5.3.3.2 Constraint Set . . . . . . . . . . . . . . . . . . . 82
5.4 Experimental Results . . . . . . . . . . . . . . . . . . . . . . . . . 83 5.4.1 Dining Philosopher Mapping . . . . . . . . . . . . . . . . . 83 5.4.2 Deployment Evaluation . . . . . . . . . . . . . . . . . . . . 86 5.4.3 Deployment Strategy . . . . . . . . . . . . . . . . . . . . . 89
5.5 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90

III Toward Neural Intelligence

91

6 Artiﬁcial Neural Controller

93

6.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94

6.2 Neural Control Architecture . . . . . . . . . . . . . . . . . . . . . 95

6.2.1 Preliminary Analysis . . . . . . . . . . . . . . . . . . . . . 95

6.2.1.1 Artiﬁcial Neural Networks . . . . . . . . . . . . . 95

6.2.1.2 Classiﬁer Learning Complexity . . . . . . . . . . 97

6.2.2 Agent Model . . . . . . . . . . . . . . . . . . . . . . . . . 100

6.2.2.1 Behavior Classiﬁers . . . . . . . . . . . . . . . . . 101

6.2.2.2 Controller Scheduling . . . . . . . . . . . . . . . 102

6.2.2.3 Behavior Online Training . . . . . . . . . . . . . 103

6.3 Knowledge-Based Training . . . . . . . . . . . . . . . . . . . . . . 104

6.3.1 Training Data Generation . . . . . . . . . . . . . . . . . . 105

6.3.2 Inferred Knowledge Transfer . . . . . . . . . . . . . . . . . 106

6.4 EMMA System Integration . . . . . . . . . . . . . . . . . . . . . . 107

6.4.1 Controller Service . . . . . . . . . . . . . . . . . . . . . . . 108

6.4.2 Service Choreography . . . . . . . . . . . . . . . . . . . . . 109

6.4.2.1 Local Control . . . . . . . . . . . . . . . . . . . . 109

6.4.2.2 Remote Training . . . . . . . . . . . . . . . . . . 109

6.4.2.3 Initial Deployment . . . . . . . . . . . . . . . . . 109

6.5 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110

Contents

7

7 Neural Voting Procedure

111

7.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112

7.2 Voting Procedure Architecture . . . . . . . . . . . . . . . . . . . . 113

7.2.1 Theoretical Background . . . . . . . . . . . . . . . . . . . 113

7.2.1.1 Preference Model . . . . . . . . . . . . . . . . . . 113

7.2.1.2 Aggregation Process . . . . . . . . . . . . . . . . 114

7.2.1.3 Distributed Decision Rules . . . . . . . . . . . . . 114

7.2.2 Implementation Arrangements . . . . . . . . . . . . . . . . 116

7.2.2.1 Finite Time Convergence . . . . . . . . . . . . . 116

7.2.2.2 Multi-Scale Adaptive Accuracy . . . . . . . . . . 116

7.2.2.3 Voting Procedure Algorithm . . . . . . . . . . . . 117

7.3 Experimentations . . . . . . . . . . . . . . . . . . . . . . . . . . . 118

7.3.1 Execution Example . . . . . . . . . . . . . . . . . . . . . . 118

7.3.2 Time Convergence . . . . . . . . . . . . . . . . . . . . . . 123

7.3.3 Alignment Property Discussions . . . . . . . . . . . . . . . 124

7.3.3.1 Veto Policy . . . . . . . . . . . . . . . . . . . . . 124

7.3.3.2 Byzantine Threat . . . . . . . . . . . . . . . . . . 124

7.4 EMMA System Integration . . . . . . . . . . . . . . . . . . . . . . 125

7.4.1 Voting Procedure Choreography . . . . . . . . . . . . . . . 125

7.4.2 Application Scenarios . . . . . . . . . . . . . . . . . . . . . 126

7.5 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127

IV MIT Medialab Experience

129

8 Ambient Sound Recognition

131

8.1 Tidmarsh Living Observatory . . . . . . . . . . . . . . . . . . . . 132

8.1.1 Environment Sensing and Network . . . . . . . . . . . . . 132

8.1.2 Data Visualization: Cross-Reality and Soniﬁcation . . . . 133

8.1.3 Towards Wildlife Geolocalization . . . . . . . . . . . . . . 134

8.2 TidZam Contribution . . . . . . . . . . . . . . . . . . . . . . . . . 135

8.2.1 Architecture Overview . . . . . . . . . . . . . . . . . . . . 135

8.2.2 Signal Footprint Background . . . . . . . . . . . . . . . . . 136

8.3 Deep Learning Stack . . . . . . . . . . . . . . . . . . . . . . . . . 137

8.3.1 Restricted Boltzmann Machine . . . . . . . . . . . . . . . 137

8.3.2 Stacked Autoencoder . . . . . . . . . . . . . . . . . . . . . 138

8.3.3 Classiﬁer Decision Function . . . . . . . . . . . . . . . . . 139

8.4 Experimentations . . . . . . . . . . . . . . . . . . . . . . . . . . . 140

8.4.1 Wildlife Recognition . . . . . . . . . . . . . . . . . . . . . 140

8.4.2 Human Computer Interface . . . . . . . . . . . . . . . . . 141

8.4.3 Speaker Recognition . . . . . . . . . . . . . . . . . . . . . 142

8.5 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143

8

Contents

V Conclusion and perspectives

145

9 Conclusion

147

9.1 An Organic Internet of Things Framework . . . . . . . . . . . . . 148

9.2 Towards Neural Ambient Intelligence . . . . . . . . . . . . . . . . 149

9.3 Perspectives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150

Appendix

153

Glossaries

157

Acronyms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157

References

166

List of Figures
2.1 Service-oriented architecture: orchestration and choreography . . 19 2.1.1 Orchestration architecture . . . . . . . . . . . . . . . . . . 19 2.1.2 Choreography architecture . . . . . . . . . . . . . . . . . . 19
2.2 MAPE-K control loop instantiated for Ambient Intelligence (AmI). 26 2.3 Architecture for a multi-agent system for ambient intelligence. . . 27 2.4 Generic observer-controller model for organic computing. . . . . . 29 2.5 The diﬀerent scales of observer-controller architecture. . . . . . . 30
2.5.1 Centralized . . . . . . . . . . . . . . . . . . . . . . . . . . 30 2.5.2 Decentralized . . . . . . . . . . . . . . . . . . . . . . . . . 30 2.5.3 Multi-scale . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 2.6 Example of the energy management policy in a smart home. . . . 32 2.7 Thesis Overview: Environment Monitoring and Management Agent (EMMA) Architecture. . . . . . . . . . . . . . . . . . . . . . . . . 38
3.1 Illustration of a classical Internet of Things (IoT) network infrastructure. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
3.2 Sequence diagram of IPv6 LoW Power Wireless Area Networks (6LoWPAN)-RPL network establishment. . . . . . . . . . . . . . . 46
3.3 WSAN Multiple Routing RPL DAG. . . . . . . . . . . . . . . . . 47 3.4 6LoWPAN integration on a plug computer based on GNU/Linux. 48 3.5 6LoWPAN integration on a mobile phone based on Android. . . . 48 3.6 Wireless Sensor and Actor Network (WSAN) Integration in Home
Information System (HIS). . . . . . . . . . . . . . . . . . . . . . 49 3.7 HIS integration into an Internet Protocol version 4 (IPv4) hetero-
geneous multi-site infrastructure. . . . . . . . . . . . . . . . . . . 50 3.8 Service Orchestration (SO) evaluation on a random network. . . . 52 3.9 Service Choreography (SC) evaluation on a random network. . . . 53 3.10 Screenshot of the simulator plug-in emma-cooja-analysis. . . . . . 54 3.11 Screenshot of the emma-design application. . . . . . . . . . . . . . 55
4.1 EMMA middleware UML diagram. . . . . . . . . . . . . . . . . . 60 4.2 EMMA middleware resource ﬁle system schema. . . . . . . . . . . 60 4.3 EMMA node overview schema. . . . . . . . . . . . . . . . . . . . 61 4.4 Illustration of a computation ﬂows by an event chain of requests. . 65 4.5 Example of an EMMA graphical model created by a Petri network. 66 4.6 Illustration of SC composition. . . . . . . . . . . . . . . . . . . . 67 4.7 Overview of the EMMA secured architecture. . . . . . . . . . . . 69
5.1 Network mapping process for a multi-layer perceptron. . . . . . . 73

10

List of Figures

5.2 Petri network of a DNA deployment container. . . . . . . . . . . 77 5.3 Petri network of a DNA self-deployment container agent. . . . . 78 5.4 Petri network of dining philosophers in an emma-design tool. . . . 84 5.5 Dining philosopher mapping in an emma-design tool. . . . . . . . 84 5.6 Number of constraints according to the number of scopes and nodes. 85 5.7 Mapping resolution time according to the number of scopes and
nodes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85 5.8 Self-discovering agent deployment in the emma-cooja tool. . . . . 87 5.9 Composed agent deployment in the emma-cooja tool. . . . . . . . 87 5.10 Composed agent deployment time in a deep network. . . . . . . . 88 5.11 Self-deployment agent deployment time in a deep network. . . . . 88
6.1 Artiﬁcial Neural Network (ANN) complexity for linear transition functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98
6.2 ANN complexity for quadratic transition functions. . . . . . . . . 98 6.3 ANN complexity for mixed transition functions. . . . . . . . . . . 99 6.4 Scheme of a multi-classiﬁer ANN. . . . . . . . . . . . . . . . . . . 99 6.5 Model overview of an ANC . . . . . . . . . . . . . . . . . . . . . . 100 6.6 Behavior classiﬁer learning result. . . . . . . . . . . . . . . . . . . 101 6.7 ANC scheduling player example . . . . . . . . . . . . . . . . . . . 102 6.8 ANC behavioral online training . . . . . . . . . . . . . . . . . . . 103 6.9 Methodology process for ANC behavior training. . . . . . . . . . . 104 6.10 Statistical data generation based on logical rules. . . . . . . . . . 105 6.11 Knowledge extraction for associative rules’ inference. . . . . . . . 106 6.12 ANC component implementation on an ARM . . . . . . . . . . . 107
7.1 Network graph of 25 nodes randomly connected to ﬁve neighbors. 118 7.2 Initial node’s utility functions ui(0) of 25 nodes at the start of
Voting Procedures (VP). . . . . . . . . . . . . . . . . . . . . . . . 119 7.3 Proﬁle utility of each node convergence until reaching the ﬁnal
aggregated one u˙ . . . . . . . . . . . . . . . . . . . . . . . . . . . 120 7.4 Interval error ε between nodes for each proﬁle according to NAC
execution. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121 7.5 Aggregated utility function u˙ is reached for all agents according to
the last ε value. . . . . . . . . . . . . . . . . . . . . . . . . . . . 122 7.6 Number of iterations according to the number of nodes and channels
u˙ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123 7.7 Voting procedure algorithm implementation across ARM agents . 125
8.1 WSN on Tidmarsh. . . . . . . . . . . . . . . . . . . . . . . . . . . 132 8.1.1 Base station . . . . . . . . . . . . . . . . . . . . . . . . . . 132 8.1.2 Station-2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132 8.1.3 Sensor node . . . . . . . . . . . . . . . . . . . . . . . . . . 132

List of Figures

11

8.1.4 Microphone . . . . . . . . . . . . . . . . . . . . . . . . . . 132 8.2 Cross-reality to visualize in situ marsh environment evolution. . . 133
8.2.1 Unity virtual environment . . . . . . . . . . . . . . . . . . 133 8.2.2 Real environment in Tidmarsh . . . . . . . . . . . . . . . . 133 8.3 Example of the main diﬀerent categories of spectrograms (frequency between 50 Hz and 7 kHz vs. time of 500 ms) at Tidmarsh. . . . . 134 8.3.1 Human . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134 8.3.2 Blue jay . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134 8.3.3 Crow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134 8.3.4 Sparrow . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134 8.3.5 Frog . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134 8.4 TidZam architecture overview. . . . . . . . . . . . . . . . . . . . . 135 8.5 Restricted Boltzmann machine execution until thermal equilibrium.137 8.6 Two-layer feature space on a human voice signal. . . . . . . . . . . 138 8.6.1 L1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138 8.6.2 L2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138 8.7 Stacked autoencoder architecture. . . . . . . . . . . . . . . . . . . 139 8.8 Screenshot of TidZam Web administration interface. . . . . . . . . 141 8.9 Bird rendering in the (VR) based on TidZam detection. . . . . . . 141
9.1 DVS scheme and PCB for EMMA middleware (MIT Media Lab). 153 9.2 DVS platform built for EMMA middleware (MIT Medialab). . . . 154

List of Tables
2.1 Examples of platform miniaturization progress for WSAN . . . . . 13 4.1 Memory footprints of EMMA modules on the Contiki OS. . . . . 59 4.2 List of system resources on EMMA node. . . . . . . . . . . . . . . 62 4.3 WSAN challenges addressed by active resource middleware . . . . 70 6.1 ANN complexity synthesis . . . . . . . . . . . . . . . . . . . . . . 97 6.2 Resource list of ANC services. . . . . . . . . . . . . . . . . . . . . 108 6.3 Memory footprints of an ANC service on the Contiki OS. . . . . . 108 8.1 TidZam results (%) for the wildlife recognition application. . . . . 140 8.2 TidZam results (%) for the speaker recognition experimentation. . 142 9.1 TidZam classiﬁer details on wildlife recognition application. . . . . 155
List of Algorithms
6.1 Gradient descent learning algorithm . . . . . . . . . . . . . . . . . 96 7.1 Voting procedure algorithm executed on each node i. . . . . . . . . 117
Listings
4.1 Example of a periodic publish-subscribe agent. . . . . . . . . . . . 63 4.2 Example of a relay agent. . . . . . . . . . . . . . . . . . . . . . . 64 4.3 Example of a self-deployer agent. . . . . . . . . . . . . . . . . . . 64 4.4 Sequence diagram of an SC for heterogeneity management. . . . . 68

Part I Introduction

Chapter 1
General introduction
L’homme est une corde tendue entre l’animal et la Surhomme une corde au-dessus d’une abîme.
Man is a rope stretched between the animal and the Superman–a rope over an abyss.
Friedrich Nietzsche [Nie17]
Contents
1.1 Internet of Things . . . . . . . . . . . . . . . . . . . . . . . 3 1.1.1 Business Opportunities . . . . . . . . . . . . . . . . . . . 4 1.1.1.1 Economy, Society and Technologies . . . . . . . 4 1.1.1.2 Many Visions Converging . . . . . . . . . . . . . 4 1.1.1.3 Current and Future Applications . . . . . . . . . 4 1.1.2 Technology Challenges . . . . . . . . . . . . . . . . . . . . 6 1.1.2.1 A Meeting of Engineering . . . . . . . . . . . . . 6 1.1.2.2 Ubiquitous Computing . . . . . . . . . . . . . . 6 1.1.2.3 Towards Web 3.0 . . . . . . . . . . . . . . . . . . 6
1.2 Motivations of the Thesis . . . . . . . . . . . . . . . . . . 7 1.3 Contributions and Content . . . . . . . . . . . . . . . . . . 8
1.1 Internet of Things
The term Internet of Things (IoT) is used in very diﬀerent ways. Its common sense nature refers to the set of physical devices connected to the Internet. They are mainly composed of the Responsive Environments (RE) and wearable devices. On the one hand, the Internet provides its services within physical environments in which people are more and more connected. On the other hand, the Internet has become a huge database of knowledge for human being in which Artiﬁcial Intelligence (AI) already has an important place. The underlying idea is that everything will be connected to Internet, including people, things and environments, in order to help people in their daily tasks, while macro issues, such as resource sharing, should be self-managed by intelligent systems in the general interests of society.

4

Chapter 1. General introduction

1.1.1 Business Opportunities
1.1.1.1 Economy, Society and Technologies
There are a lot of possible uses, such as environmental preservation, residential protection, assistance for elderly people and augmented reality. Major technological ﬁrms predict an explosion in the development of the IoT, such as Cisco’s estimation that 50 billion objects will be connected by 2020 1. Several social aspects will be aﬀected by the incorporation of the Internet into daily environments. Moreover, this must be discreetly managed in order to facilitate its acceptance by people before intelligent systems are able to provide some kind of education in response to irrational human behaviour. For example, on a human scale, people are not conscientious in relation to their daily actions within the global environment. The promises are signiﬁcant, however, while there are a lot of technological and theoretical issues still to be solved. For example, the huge number of connected objects in the future is already forcing engineers to consider new designs in order for global energy consumption to be sustainable. This constraint has a large impact on the future connectivity between the IoT and the Internet core. Therefore, new paradigms for future applications and services using the Internet must be investigated to prepare for the arrival of the cybernetic world in the future.
1.1.1.2 Many Visions Converging
This technology will aﬀect all society domains, such as private residences, transportation, cities and industries. Therefore, a lot of diﬀerent visions will appear, reﬂecting diﬀerent interests. Aggarwal et al. [AAS13] summarize the classiﬁcation into three major groups. The Things-Oriented Vision assumes that connected objects in the future will be intrinsically heterogeneous because of the important diﬀerence in their application requirements. Meanwhile, the Internet-Oriented Vision supposes that this heterogeneity must be abstracted by a communication layer, such as the Internet Protocol (IP). Finally, the Semantic-Oriented Vision is interested in the management of the heterogeneity at a data level without any consideration for the network speciﬁcities. During the last decade, new theoretical and technical frameworks have been investigated to provide new materials relating to these diﬀerent visions. Nowadays, it is necessary to determine how they can be integrated into the same framework.
1.1.1.3 Current and Future Applications
Historically, the development of this technology has been promoted by the monitoring of structural health. Kim et al. [Kim+06] present a complete architecture
1Evans, D. The Internet of Things: How the Next Evolution of the Internet Is Changing Everything. Cisco Internet Business Solutions Group, IBSG (2011)

1.1. Internet of Things

5

to monitor the vibrations of the Golden Gate Bridge. This kind of application requires numerous sensors that are spatially distributed in the region of interest. They use wireless networks, which are less expensive and much easier to deploy. Another application concerns the preservation of heritage buildings by monitoring their evolution over time [Cer+09]. Hence, the main requirements involve the collection of time-lined data and the deﬁnition of easy deployment solutions in large spaces at low-cost. The development of smart grids represents an important challenge in terms of optimizing energy consumption around the world. The increase in world energy consumption has caused a lot of problems regarding its management in large-scale networks [YLD07]. The storage of signiﬁcant amounts of energy is diﬃcult, even if hydraulic dams temporarily address this problem. Hence, energy production should be adapted in real-time so that consumption is facilitated through the use of renewable energies. Energy providers require detailed information about local energy consumption and production through smart grids. In addition, some regulation strategies, such as preventing energy drops, require some home appliances to be turned oﬀ remotely to avert a peak in energy consumption. Finally, energy providers need real-time information to regulate energy used in multi-scale architecture at a national level as well as home appliances. This technology has been progressively applied in human environments, such as hospitals for healthcare applications [Ko+10]. The traceability of drugs, patients and personnel is a permanent issue in hospitals with possible dramatic consequences. Hence, monitoring and traceability are improved by collecting real-time information to facilitate medical coordination by central information systems. This application uses sensitive data, which must be protected to maintain patient and staﬀ privacy. Moreover, this application is itself sensitive regarding the impact upon patient health in cases of malfunctions. Therefore, the system must be safe and secure in order to protect human integrity.
Nowadays, daily environments are being studied in order to improve comfort, safety and accessibility. The ﬁrst type of environment concerns houses and other buildings where people spend most of their time. Moreover, these buildings consume a lot of energy. These places require large-scale infrastructures, which must be secure, energy eﬃcient and evolutionary. Some domotic systems are available to address these diﬀerent issues. Traditionally, a central computer manages a domotic system. Most of the time, these systems are not designed to be interoperable with other ones. Hence, the systems are limited in their evolutionary possibilities; moreover, they are dependent on manufacturers, who can stop their production and maintenance at any time. But, these systems must be deployed and maintained during the entire lifetime of the building. Therefore, applying the IoT in relation to important infrastructures requires heterogeneity to be supported at the hardware and application levels in order to ensure the sustainability of the system. The deﬁnition of standards for IoT technologies and protocols is a primary requirement.

6

Chapter 1. General introduction

1.1.2 Technology Challenges
Gubbi et al. [Gub+13] present a vision, diﬀerent architectural elements and future directions for the IoT. The architecture requires a lot of diﬀerent technologies, from the design of devices and the network to the implementation of diﬀerent services. Moreover, the emergence of new software paradigms, such as ubiquitous computing, is profoundly changing the vision of the Internet.
1.1.2.1 A Meeting of Engineering
The IoT is the meeting of diﬀerent engineering areas. The design of connected objects by manufacturers requires experts in electronic and embedded systems. The establishment of a common network must be performed by security and telecommunication experts, while service applications for end users should be designed by software engineers. Although these domains seem naturally compartmentalized, they are strongly connected; for example, they must be embedded in a single device. Hence, an important technology challenge is the deﬁnition of abstraction layers to limit the requirement of multiple expertise. Without easy solutions for designing devices, networks and applications, IoT would not exist.
1.1.2.2 Ubiquitous Computing
Ubiquitous Computing (UC), which appeared at the same time as the development of the IoT, is a concept within software engineering relating to pervasive services. Such software has the capacity to communicate with users and other software applications through any interface and in any place with any format. The leitmotif of UC is everywhere and anywhere. The services follow the users in their daily activities in order to assist and provide them with information. Hence, the software design evolves towards high-level languages in order to be not only accessible through the Internet but also proactive with regard to multiple interfaces: wearable, RE and others.
1.1.2.3 Towards Web 3.0
The extension of the Internet into the physical environment will drastically increase the number of networks around the world known as the Capillary Internet. As this huge network will collect data from appliances around the world, this raises the issue of data access. In previous decades, a similar discussion about the browsing data content concluded that the Web is very adaptable in terms of linking data together. Its concept of hypertext associates a new remote resource to a word contained in the text. This simple feature has continued with the development of Web 2.0 which adds the concept of semantic links. Nowadays, a word can refer to a set of remote resources, while browsing is dependent on the semantic context of interests, such as the Wikipedia platform. Web 3.0 could provide the features needed to link the digital and physical worlds through the concept of cross-reality.

1.2. Motivations of the Thesis

7

1.2 Motivations of the Thesis
The growing interest in the IoT is promising in terms of improving the protection of people and the environment. It should help to improve accessibility, security and comfort in the daily environment, while saving energy and other consumable resources. The term itself is new, but the referent concepts exist in science ﬁction from several years ago. Nowadays, the technologies exist, but:
What kind of Ambient Intelligence (AmI) is required and how can it be done?
The motivations of the thesis are based on the observation that several theoretical and technological activities are converging within autonomous systems. On the one hand, AI techniques are incorporated in relation to Multi Agent System (MAS) in order to design role-based agents for adaptive systems. On the other hand, the Embedded System (ES) has become more and more powerful to the extent that the entire Operating System (OS) can be hosted in a single chip. To this extent, this thesis focuses on the study of their combination in the direction of the distributed AmI. The bio-inspired proposal considers systems, such as an Artiﬁcial Organism (AO), which are composed of the diﬀerent appliances in a managed environment. This approach focuses on interaction mechanisms in order to model system intelligence instead of a programming approach. The main assumption is that the programming approach cannot support evolving features in the same way as a biological system. It depends of an initial coding style to validate the operations at a compilation step; meanwhile, an interaction model evaluates the feasibility of an operation during the process runtime, as is the case in chemical systems, in which evolving reactions are produced according to molecular interactions. More exactly, the investigations focus on the AmI design, such as a cyberbrain composed of several interacting Artiﬁcial Neural Network (ANN). Each of them corresponds to a particular cognitive function, including context learning, controlling appliances and cognitive synchronization. This autonomous cyberbrain is composed of distributed neuron groups across diﬀerent appliances in order to minimize the network communications.
The EMMA framework has not only been developed for the purpose of cyberbrain design. It oﬀers a complete solution for the IoT infrastructure to appliance manufacturers, network administrators and service providers. A set of interfaces and tools independently facilitates the development of diﬀerent system parts in order to integrate them easily into an existing IoT infrastructure. The diﬀerently used technologies are standard formats of the Internet Engineering Task Force (IETF) and the Institute of Electrical and Electronics Engineers (IEEE), allowing the EMMA system to be interconnected with Internet services and other frameworks at the appliance, network and application layer level. In addition, it is assumed that the user privacy and data security can be only preserved within fully distributed architectures in which data stays located in the managed environment.

8

Chapter 1. General introduction

1.3 Contributions and Content
• Part I introduces the concept of the Internet of Things (IoT) and Ambient Intelligence (AmI) in Chapter 1. Chapter 2 provides more details of the diﬀerent aspects of WSANs, AmIs and Organic Computings (OCs).
• Part II presents a framework contribution entitled the EMMA framework, with an introduction in Chapter 3 on the technologies used for WSANs and discussions about the impact made by centralized versus decentralized software architecture. Chapter 4 details the developed middleware based on Resource Oriented Architecture (ROA) for the choreography of Web services. Each appliance has its hard-coded services within containers, which publish data through resources. Based on an interaction model, mobile agents allow the data ﬂows to be routed between the diﬀerent appliance services in order to build Service Choreography (SC). A graphic model, based on a Petri network, allows the system to be analyzed and composed in order to design distributed AmI. Chapter 5 presents the deployment methodology, which is bio-inspired by the DNA-RNA process. A set of mobile agents forms Dynamic Network Agent (DNA) in order to deploy an Residual Network Agent (RNA) graph, according to its reactions with appliance resources.
• Part III presents two algorithms for AmI with theoretical studies and practical implementations over the distributed EMMA middleware. Chapter 6 presents an Artiﬁcial Neural Controller (ANC) to automatically drive the appliances based on empirical learning and logical rule-based descriptions. The knowledge transfer between the logical space of rules and the statistical space of data allows experts to understand, at a global level, the system operations that are encoded in Artiﬁcial Neural Network (ANN). Chapter 7 presents a Voting Procedures (VP), which synchronizes decisions between diﬀerent AmI components. This VP is fully distributed and fault-tolerant regarding time delays, switching topology and packet loss.
• Part IV presents the contribution made to the Tidmarsh Project at the MIT Media Lab. An ambient sound recognition engine entitled TidZam has been designed in order to recognize animal calls from outdoor microphones. Based on deep learning technology, the system acts as event detector to locate animals on a three-dimensional virtual environment. An additional application involving speaker recognition is also presented.
• Part V brings the current state of work contributions, with regards to the EMMA organic framework and the ﬁrst implementations of components for future neural-based Ambient Intelligence (AmI), to a close. Several perspectives are discussed in relation to general discussions about the IoT, the OC and the AmI, while some framework improvements are proposed in terms of their current limitations.

Chapter 2
State of the Art
Se méﬁer des penseurs dont l’esprit ne fonctionne qu’á partir d’une citation.
Beware of thinkers whose minds function only when they are fueled by a quotation.
Emil Michel Cioran [Cio95]
Contents
2.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . 10 2.2 Wireless Sensor and Actor Networks . . . . . . . . . . . . 11
2.2.1 Connected Objects . . . . . . . . . . . . . . . . . . . . . . 12 2.2.1.1 Identiﬁcation, Sensing and Acting . . . . . . . . 12 2.2.1.2 Energy, Computation and Communication . . . 12 2.2.1.3 Lifetime, Design and Maintenance . . . . . . . . 13
2.2.2 IP-Based Network . . . . . . . . . . . . . . . . . . . . . . 14 2.2.2.1 Low Power ZigBee Technologies . . . . . . . . . 14 2.2.2.2 Network, Routing and Security . . . . . . . . . . 15 2.2.2.3 Heterogeneity and Internet Integration . . . . . 17
2.2.3 Software Architectures . . . . . . . . . . . . . . . . . . . . 17 2.2.3.1 Data Formatting and Application Protocols . . . 18 2.2.3.2 Web Service Orchestration and Choreography . 19 2.2.3.3 Object Abstraction and Middleware . . . . . . . 20
2.3 Ambient Intelligence . . . . . . . . . . . . . . . . . . . . . 22 2.3.1 Responsive Environment . . . . . . . . . . . . . . . . . . . 24 2.3.1.1 Event Condition Action Rules . . . . . . . . . . 24 2.3.1.2 Action Planning . . . . . . . . . . . . . . . . . . 24 2.3.1.3 Decision Tree . . . . . . . . . . . . . . . . . . . . 24 2.3.2 Reasoning Engine . . . . . . . . . . . . . . . . . . . . . . 25 2.3.2.1 Fuzzy Rule-Based Engine . . . . . . . . . . . . . 25 2.3.2.2 Context-Awareness System . . . . . . . . . . . . 25 2.3.2.3 Learning Techniques . . . . . . . . . . . . . . . . 25

10

Chapter 2. State of the Art

2.3.3 Ambient Intelligence Architectures . . . . . . . . . . . . . 26 2.3.3.1 Autonomic Computing . . . . . . . . . . . . . . 26 2.3.3.2 Multi-Agent System . . . . . . . . . . . . . . . . 27
2.4 Organic Computing Approach . . . . . . . . . . . . . . . . 28 2.4.1 Principles and Challenges . . . . . . . . . . . . . . . . . . 28 2.4.1.1 Trustworthy Systems . . . . . . . . . . . . . . . 28 2.4.1.2 Self-X Properties . . . . . . . . . . . . . . . . . . 28 2.4.1.3 Design Methodology . . . . . . . . . . . . . . . . 29 2.4.2 Models and Architectures . . . . . . . . . . . . . . . . . . 29 2.4.2.1 Observer-Controller Model . . . . . . . . . . . . 29 2.4.2.2 Multi-Scale Architecture . . . . . . . . . . . . . 30 2.4.2.3 Evolutionary Computation . . . . . . . . . . . . 30 2.4.3 Application Examples . . . . . . . . . . . . . . . . . . . . 31 2.4.3.1 System on Chip . . . . . . . . . . . . . . . . . . 31 2.4.3.2 Traﬃc Lights in a Smart City . . . . . . . . . . 32 2.4.3.3 Energy Management in Smart Homes . . . . . . 32
2.5 Synthesis . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33

2.1 Introduction
The state-of-the-art technology discussed in this chapter encompasses the diﬀerent research domains relating to Wireless Sensor and Actor Networks (WSANs), Ambient Intelligences (AmIs) and Organic Computings (OCs). This chapter’s main framework is organized by a set of papers, which are brieﬂy summarized by a single paragraph, in order to present the Internet of Things (IoT) in a bottom-up approach from hardware to intelligence systems. The papers have been selected according to their impact in the relevant research community, their originality or their relevance to the main concepts presented in this thesis.
The ﬁrst two sections focus on parallel works between a WSAN and an AmI. The ﬁrst section looks at the hardware, network and programming paradigm pertinent to the construction of the IoT, whereas the second section considers the information system needed to control it intelligently. The last section presents the new paradigm of OC in order to discuss its application to the IoT. The main framework is focused on the use of distributed AmI techniques to address the challenge posed by the requirements in WSANs.

2.2. Wireless Sensor and Actor Networks

11

2.2 Wireless Sensor and Actor Networks
Wireless Sensor and Actor Network (WSAN) is a technological term referring to a group of sensors and actuators connected by a wireless medium. Sensors collect data from the physical world and the actuators operationalize actions within an environment. The control loop is composed of sensing, controlling and acting.

[Mio+12] Miorandi et al. present current and future applications of WSANs, such as in smart homes/smart cities, environmental monitoring, healthcare, smart business/inventories and security/surveillance with current enabling technologies. The authors propose a taxonomy of WSAN technology at the intersection of the embedded systems, the distributed system and the distributed intelligence. WSANs have features and issues in diﬀerent technological domains. New engineering paradigms must be invented to uncouple problems associated with electronic design, networking and information system development.

[AIM10] Atzori et al. extend the discussion around the concept of middleware. It is a piece of software inside the connected object to create a bridge between the hardware, the network and the applications. The object and network functionalities are encapsulated inside service containers in order to facilitate application design. Middleware is responsible for providing mechanisms for service composition and its management, as well as object abstractions and system sustainability (trust, privacy, integrity and security).

[AK04] Akyildiz et al. has identiﬁed several problems in the information system in relation to the coordination of actuators according to sensing events. Authors have focused on distributed models in which actor-actor communications are performed. In some situations, the action plans are dependent on successive events in diﬀerent sensors, whose execution can require several time-lined actions performed by diﬀerent actors. The information should be transmitted to all concerned actors and sensors to allow them to evaluate the situation. They have to communicate together in order to synchronize their decisions. Authors emphasize the issues around such distributed coordination to ensure the consistency of the respective action plan.

The next section presents the features and constraints of connected objects in order to understand network requirements. Connected object, as a term, refers to an autonomous device that communicates with other ones in order to manage an environment. The literature on networking focuses on the major technologies enabling the extension of the Internet inside the physical world. The last section presents some of the diﬀerent approaches to software architecture and application protocols, which will need to coexist in the future Internet of Things (IoT).

12

Chapter 2. State of the Art

2.2.1 Connected Objects
A connected object is composed of a wireless communication module, a computation unit and an electronic application layer of sensors or actuators. They are spatially distributed in the environment to form a large-scale network. Given their signiﬁcant prevalence, they must be energy eﬃcient and remotely maintainable in order to ensure a long lifetime for the system.

2.2.1.1 Identiﬁcation, Sensing and Acting
[Mio+12] Miorandi et al. identify four main roles for connected objects:
• Acting: these actively change the environment and inform the system about manual controls performed by people
• Sensing: these gather information from the environment and people’s behavior in order to synchronize their representation in the system
• Information: these inform the user about current system parameters and the state of the managed environment
• Identiﬁcation: these are used to identify an unconnected object or people using Radio Frequency IDentiﬁcation (RFID) technology

2.2.1.2 Energy, Computation and Communication
[SM11] Soua et al. discuss techniques used to save energy in a WSAN. Most applications use a large number of nodes, which are spatially distributed and function with a small battery. Given their number leads, it can be very diﬃcult to change their battery. Therefore, energy harvesting techniques are used to reload batteries, while software has been designed to decrease energy consumption. Energy is mainly consumed by the transceiver radio during data transmissions. Hence, numerous proposals have focused on the network stack in terms of reducing the protocol overhead and improving packet routing, as well as proposing protocols for the avoidance of communication collisions or highlighting the ongoing development of mechanisms relating to duty cycles for sleeping modes.

[KEW02] Krishnamachari et al. study the impact of application layers on energy consumption. They evaluate global energy-saving using data aggregation. Several producers of data are randomly distributed over a WSAN using diﬀerent models. Their data are aggregated before reaching the data gathering stage. The conclusions show that an energy gain is possible when data producers are clustered. Hence, data-centric architecture is another leverage to save energy.

2.2. Wireless Sensor and Actor Networks

13

2.2.1.3 Lifetime, Design and Maintenance
[RDT07] Rubio et al. discuss programming approaches for connected objects. Most WSANs are only deployed once and are intended to operate for a long time. Their initial programming would require update mechanisms for maintenance or functionality extension. Therefore, the design of their software must include reprogramming features. Moreover, their hardware must support remote deployment in term of networking and memory capacity because they are distributed in a large-scale network. The approaches made by components should be preferable in order to partially update the software. The network bandwidth is used less than for entire node reprogramming during data transmission and consumes less memory for the update storage.
[Bel+05] Bellis et al. proposes an implementation of a wireless sensor module based on Field-Programmable Gate Array (FPGA) technology. Instead of executing the program by a Central Processing Unit (CPU), it is hard-coded at the physical layer. The program is event-driven by its input pins, which allows the system to sleep most of the time and, therefore, save energy. Their research team is interested in the miniaturization of connected objects at the scale of a 10 mm cube. They have successfully built a 25 mm platform, which is compared with other manufacturer platforms, such as those shown in Table 2.1. It appears that this technology signiﬁcantly decreases energy consumption and platform size, while increasing the data rate of a radio transceiver. This is promising for the next generation of miniaturized connected objects.
The software technology for connected objects is still not deﬁned. The remote reprogramming is essential to maintain a long lifetime for the system. The implementation technology is evolving with the aim of reducing the size of connected objects and saving energy.

Reference CPU RAM Flash AES

TelosB Mote 8 MHz 10 Kb 48 kB No

Raven Platform 8 MHz 16 Kb
128 Kbytes No

ZigBit Module 8 MHz 8 Kb
128 Kbytes No

Atmega128rfa1 SoC 16 MHz 16 Kb
128 Kbytes Yes

Table 2.1 – Examples of platform miniaturization progress for WSAN

14

Chapter 2. State of the Art

2.2.2 IP-Based Network
[VD10] Vasseur et al. describe an overview of WSAN developments in the last decade. At the beginning, academics and industries were developing their own protocol solutions. This exploration phase was helpful for the identiﬁcation of usages, constraints and approaches. Therefore, the future IoT will be composed of diﬀerent technologies, networks and applications. A common stack of network communications has to be determined, with Internet Protocol version 6 (IPv6) as the most likely candidate.
[RN10] Rodrigues et al. present a survey of IP-based solutions for WSANs. Initially, ﬁnding a solution was considered inappropriate according to the complexity of the TCP/IP protocol and its overhead. However, the use of a proxy to translate the protocol into a heterogeneous infrastructure raises more problems regarding the single point of failure, network congestion, maintenance and scalability. Therefore, the research community has already started work on adapting IP technology for WSANs. After several implementations of IP solutions, a new standard has appeared: 6LoWPAN [SB11]. Nowadays, intensive eﬀorts are being undertaken focused on using or adapting standard protocols in line with the technological development of the Internet.
[Hog+12] Höglund et al. present an example of a 6LoWPAN application for the monitoring of energy quality in the supplier chain. Their solution monitors the amount of energy produced by the supplier and consumed by customers. Several parameters are collected in the process, such as frequency, voltage and power. Data are sent periodically to the energy management system through a 6LoWPAN mesh network. The network is auto-established with IP connectivity, with the communications performed over the Internet without an intermediate proxy. This application validates the use of such technology in industrial applications.

2.2.2.1 Low Power ZigBee Technologies
[Lay13] IEEE 802.15.4 norm is the major radio frequency technology used in relation to 6LoWPAN. It is a standard deﬁned for low power wireless technology. All its features have been designed to save energy during listening and transmission. It consumes 1,600 % less energy with a cover range of 25% compared to Wi-Fi. This norm deﬁnes the radio frequency and the Media Access Control (MAC) layer in an OSI model when building a scalable mesh network. Nowadays, numerous products use this norm, such as ZWave, Sensinode and ThingSquare. The solutions used in their software vary according to the use of the 6LoWPAN standard or a proprietary protocol.

2.2. Wireless Sensor and Actor Networks

15

2.2.2.2 Network, Routing and Security
[Dun03] Dunkel proposed, in 2003, an innovative implementation of 6LoWPAN over IEEE 802.15.4, known as uIP. As well as being very eﬃcient in terms of memory usage, its event-driven kernel, the Contiki OS, is very reactive with a low energy consumption. Many industrialists and researchers are still reliant on it to evaluate new algorithms, applications or platforms.
[JZS12] Jara et al. proposed, in 2012, another IPv6-based protocol that does not follow the 6LoWPAN standard, known as the Glowbal IP. It was implemented using the Contiki OS to replace the uIP network stack. Their motivations concerned overhead protocol reduction and easy curve learning to build WSANs and their applications. As it is not standardized, it requires a proxy to translate network exchanges between traditional networks and the Glowbal WSAN.
[RN10] Rodrigues et al. conduct a survey of previously published solutions, 6LoWPAN implementations and operating systems for WSANs. The authors conclude that the two main approaches, namely, sensor stack-based and proxybased architecture, must be merged in future WSANs. They expect that nodes will have auto-conﬁguration mechanisms that need to be partially autonomous. Meanwhile, network functionalities, such as routing and security, must be under the responsibility of a proxy-based gateway to save program memory for the node applications.
[YF04] Younis et al. propose an energy eﬃcient routing protocol for WSANs. They propose a cluster-based approach called the HEED protocol. Particular nodes are elected to route network traﬃc according to the residual energy of their battery. They demonstrate the eﬃciency of their hierarchical routing network and open a discussion about a trade-oﬀ between energy savings, accuracy and latency.
[Gun+07] Gungo et al. investigate the possibility of deﬁning a routing protocol that considers mixed metrics. Routing tables are dynamically established according to the link quality between nodes and their residual energy. This proposal validates the possibility of simultaneously addressing the objectives of the connected objects and those of networks using metric aggregation.
[SSS+10] Singh et al. present a survey on main routing protocols according to their approach and applications, such as mobile networks, hierarchical protocols, Quality of Service (QoS) protocols and multi-path protocols. They conclude that the routing protocol is inherently dependable of network topology, application and routing objectives (energy-saving, bandwidth optimization etc.).

16

Chapter 2. State of the Art

[TED10] Tsiftes et al. present an implementation on the Contiki OS of the IETF candidate for a routing protocol in 6LoWPAN. The Routing Protocol for Low power and Lossy Networks (RPL) protocol has been designed to provide a ﬂexible protocol that addresses, as much as possible, common use cases. It uses mixed metrics, customizable at the application level, to deﬁne routing path orientation over WSANs. The results of their implementation show several years of network lifetime on Tmote Sky motes. It should be noted that the Contiki OS has been implemented to easily change any layer of the uIP network stack, including the routing protocol.
[BBB08] Bojkovic et al., [PLH06] Pathan et al., [CY05] Camtepe et al. and [BN08] Boyle et al. discuss the major security issues relating to WSANs. The physical protection of systems is an intractable problem because communications are wireless and spatially distributed in an open-system environment. Therefore, the security aspects that are addressed by these authors concern communication protection through encrypted communications. As most attacks are based on the insertion of false information, communications must be encrypted and an intruder detection policy should be deﬁned. Several approaches are introduced concerning the scale of the key cryptography distribution scheme: network-keying, group- or node-keying, or pair-wise keying (between each node). All of these schemes can be applied to diﬀerent network stack layers: data link, network or application layers. According to these security schemes, the design of a secured WSAN depends on the node capacities and on the addressed threats.
[KRM13] Krentz et al. present a security framework for 6LoWPAN at the link layer. Their pair-wise key scheme, using Advanced Encryption Standard (AES), is energy eﬃcient and has a low memory footprint, in the same way that most platforms for WSANs have a dedicated AES chip. Their proposal focuses on the security protocol to protect the network against Denial of Service (DoS) attacks. As the link layer protection requires all nodes to have the same security protocol, a heterogeneous network with secured and unsecured nodes cannot coexist.
[Uki+13] Ukil et al. propose another pair-wise key scheme using AES for 6LoWPAN encryption, but one that is applied to the application layer. The authors propose a secured Constrained Application Protocol (COAP) with double authentication. It should be noted that the COAP is a candidate for the application layer according to the IETF, which increases the interest in this proposal. It is energy eﬃcient with a low memory footprint and allows the WSAN to be composed of heterogeneous nodes. Network establishment is performed identically by secured and unsecured nodes. However, the proposed protocol cannot protect against DoS attacks.

2.2. Wireless Sensor and Actor Networks

17

2.2.2.3 Heterogeneity and Internet Integration
[Del+06] Delicato et al. are interested in the architecture of WSAN applications. They warm about the risk of designing rigid WSANs in which applications are strongly coupled with hardware and the network. They insist that future usages of a WSAN cannot be predicted, as new devices and services can be added during its runtime. Moreover, in the case of failures, services must be partially maintained. This constraint implies self-adaptivity of the system. They proposes the use of Web technologies at the application level of nodes in order to introduce application ﬂexibility. Instead of designing hard-linked applications for nodes, Web services should be used on nodes to interface and share services. The data are exchanged from one Web service to another, which facilitates the management of application heterogeneity. This proposal is consistent with IP-based proposals for the network stack, while extending the scope of earlier ideas through the use of ontologies to homogenize data semantics between the nodes and other services on the Internet.
2.2.3 Software Architectures
[RDT07] Rubio et al. resume previously presented requirements about software architecture and programming approaches for WSANs. They identify that nodes and the network must have auto-conﬁguration and security mechanisms available for large-scale networks. The node software must be lightweight with reprogramming mechanisms to ensure its maintenance and evolution. WSAN applications must be coordinated and executed in real time to manage the environment. Finally, software architecture has to support application heterogeneity and a huge amount of data. The authors present several programming paradigms along with their advantages and drawbacks. There are two main kinds of architecture: data centralization and distributed applications. Both of them have to respect previously presented requirements to be practical in WSANs. Authors classify programming approaches into three categories. The node-centric approach consists of independently implementing each connected object behavior. This approach is very eﬃcient in terms of program optimization and analysis. Meanwhile, the macro behavior of a WSAN is diﬃcult to anticipate. Conversely, macro-programming determines the set of tasks assigned to each node. The data exchanges involved are fully determined to manage WSAN coordination. Although the system consistency is easily maintainable, the system overhead is important and the WSAN has to be homogeneous. The third concerns the use of a middleware, which is a trade-oﬀ between the node-centric and macro-programming approaches. The middleware provides the information and the functionalities of a WSAN to each connected object, such that they can adapt their behavior and synchronize information according to the WSAN state.

18

Chapter 2. State of the Art

2.2.3.1 Data Formatting and Application Protocols
The establishment of an homogeneous connectivity between WSANs and the Internet has implied the necessity to deﬁne a standard for a network stack for communications inside a WSAN. The data, their formatting and their semantic, however, are strongly dependent on the applications. To this extent, the following papers discuss the management of these heterogeneities in relation to the current investigation about the application protocol for 6LoWPAN.
[JMS05] Jammes et al. propose service-oriented architecture for WSANs. Each node provides a Web service interface using Devices Proﬁle for Web Service (DPWS). This protocol is a technology used on the Internet to interconnect heterogeneous Web services in order to form a distributed application. It manages data formatting and its meta-description with Extensible Markup Language (XML), its transport through Simple Object Access Protocol (SOAP) and the security layer. However, this protocol is too heavy for tiny target platforms.
[DH+10] Dawson et al. propose an Simple Measurement and Actuation Proﬁle (sMAP) to describe and format data. It is based on JavaScript Object Notation (JSON) formatting language, which is lighter than XML. sMAP is a data proﬁle that deﬁnes a set of attributes and objects to exchange data in a WSAN. The main idea is to uncouple the data format and its semantics from the data transfer protocol. Hence, according to the application, and independently of the data, the application protocol can be selected.
[KDD11] Kovatsch et al. present their implementation of a COAP protocol on the Contiki OS. It is the application protocol candidate of IETF for 6LoWPAN. Similar to the Hyper Text Transfer Protocol (HTTP), it is used in REpresentational State Transfer (RESTFUL) architecture to facilitate Web service management. Each set of data is encapsulated in a resource with its own representation proﬁle. Hence, traditional HTTP requests retrieve data or manage them directly on the node. Additional mechanisms are added in COAP, such as data block fragmentation or a publish-subscribe engine to facilitate Web service composition.
[HJ08] Huang et al. present their designed architecture for managing data heterogeneity using ontologies. All data are collected on a gateway to be stored in an Resource Description Framework (RDF) semantic database. Therefore, all data can be managed similarly and independently of their formatting and meta-description language.

2.2. Wireless Sensor and Actor Networks

19

2.2.3.2 Web Service Orchestration and Choreography
[KLD12] Kovatsch et al. present their gateway platform to manage a WSAN known as Actinium. Each object has a proxy object inside the framework, which is synchronized with the real connected object through the WSAN. In this orchestration architecture, each object communicates only with the gateway, as illustrated in Figure 2.1.1. This kind of architecture has signiﬁcant limitations regarding network congestion on routers around the gateway in large-scale networks. However, this proposal is very innovative due to its use of mobile and scripted applications. Instead of developing hard-coded applications executed on the gateway, they use Node.JS scripts to build applications. They are executed in an independent container in order to manage applications through resource utilization. The authors consider applications, such as any data, which are managed in the same way as any connected object providing a service.
[Che+13; Che+11] Cherrier et al. have worked on choreography architecture in which services of connected objects communicate directly together, as illustrated in Figure 2.1.2. The gateway conﬁgures node services to send requests directly to the concerned service. When an event occurs on a sensor, the node processes a small treatment locally to send a request to another mote. Successive requests are sent over the WSAN to execute operations on actuators or treatments on other nodes. This event diﬀusion over the network is stopped when the system reaches a static state. The authors demonstrate the eﬃciency of the choreography approaches in comparison with orchestration for large-scale networks. However, the stability of such system is an important challenge, while applications are limited by node capacities to perform complex operations. In this sense, authors propose a logic model to validate distributed application consistency, known as DL-Lite, and an associated protocol called SALT.

2.1.1: Orchestration architecture

2.1.2: Choreography architecture

Figure 2.1 – Service-oriented architecture: orchestration and choreography

20

Chapter 2. State of the Art

2.2.3.3 Object Abstraction and Middleware
[Ban+11] Bandyopadhyay et al. present the main reasons for the use of middleware in IoT applications. Firstly, it is necessary to abstract hardware and networking regarding the huge number of diverse devices and application domains. It is conducted in a uniform manner to manage the heterogeneity of data and software components using an adaptation layer. They provide an Application Programming Interface (API) to hide the particularities of the connected objects. Hence, they facilitate application implementation.
[MA06] Molla et al. compare six examples of middleware to conclude that there is signiﬁcant trade-oﬀ between the challenge of resource constraint and middleware scalability and adaptability. Moreover, they emphasize that, most of the time, QoS, security and context awareness are either partially or not at all supported by middleware.
Hadim et al. [HM06], Rubio et al. [RDT07], Wang et al. [Wan+08] and Rahman et al. [Rah06] propose a middleware classiﬁcation according to the programming approach taken:
• Application-driven middleware provides the applications with access to network and system conﬁgurations.
[Dun03; Dun+06] Dunekls et al. have developed the Contiki OS for WSANs. It includes a uIP 6LoWPAN stack, which is manageable by the applications, and a mechanism for remote installations as well as updates of applications over wireless communications.
Advantage: Program optimization. Drawback: No control on global WSAN behavior.
• Message-oriented middleware is based on a publish-subscribe mechanism to provide an abstraction layer between producers and consumers of data. It facilitates asynchronous communications over a WSAN.
[Sou+04] Souto et al. have developed Mires middleware based on the Tiny OS. The node applications subscribe to topics that are ﬁlled with sensor data by the operating system. The authors highlight the potential energy gain by only transmitting messages that refer to subscribed topics.
Advantage: Easy design of applications. Drawback: Low network scalability.
• Database middleware provides an abstraction in order to consider WSANs, such as a distributed database. Queries are diﬀused over the network and the responses are aggregated in order to generate the ﬁnal one on the sink.

2.2. Wireless Sensor and Actor Networks

21

[Mad+05] Madden et al. have developed TinyDB middleware based on the Tiny OS. The authors provide an advanced SQL-like language to request data over the WSAN. It allows requests to create local storage, aggregate temporal data, and trigger data collection and others mechanisms. They use a duty cycle mechanism to save energy during data aggregation and request resolution.
Advantage: WSAN abstraction. Drawback: Only for data collection.
• Service-oriented middleware facilitates service choreography in providing features of service discovery and binding.
[Kus+07] Kushwaha et al. have developed an OASIS framework, which is composed of middleware and a set of tools to design and deploy choreography over a WSAN. The mapping of communication ﬂows and tasks are performed oﬄine on dedicated platforms in order to be deployed on the connected objects when online .
Advantage:: Management of WSAN heterogeneity Drawback: Requires oﬄine supervisors.
• Tuple space middleware is based on the concept of associative memories. The applications exchange data through a distributed and shared memory space, which is fragmented over the WSAN.
[Cos+07] Costa et al. have developed TeenyLIME middleware based on the Tiny OS. Applications are fully uncoupled from connected object functionalities using a tuple space. The authors explain that this model is very eﬃcient for one-to-many and many-to-many communications thanks to the use of common tuples. Moreover, the concurrent access of functionality by several applications is easily manageable by mutex and semaphors.
Advantage:: Global system management. Drawback: Network bandwidth consumption.
• Virtual machine middleware interprets the applications through a runtime engine. They are implemented in separate and small modules with a high level language in order to be distributed over the WSAN.
[Kwo+06] Kwon et al. have developed ActorNet based on the Tiny OS. Applications are designed similarly to agents, which have the ability to migrate to other connected objects. This feature oﬀers new techniques for application design. Instead of collecting data to be moved to the applications, they are moved to the data. Advantage: Advance programming. Drawback: Virtual machine overhead.

22

Chapter 2. State of the Art

2.3 Ambient Intelligence
[ANA10] Augusto et al. reﬂect on the historical development of Ambient Intelligence (AmI) since the advent of technology: at the beginning of the previous century, computers occupied an entire room, whereas, nowadays, they can be camouﬂaged in the human environment. The term AmI was introduced at the end of the previous century to name the system that manages an environment through a physical infrastructure, which has henceforth been called Smart-X. This multidisciplinary area and the huge number of possible applications have resulted in numerous visions. The system design is oriented diﬀerently according to the environment, the connected object, the network, human-computer interfaces or artiﬁcial intelligence. In all visions, the system has to adapt its behavior according to the evolution of the managed environment and the applications. However, calculating the societal implications is still at the experimental stage, in which its impact on human behavior in a world of hidden and permanent technological assistance is being evaluated:
• [Aug09] Augusto et al. present a survey on smart classroom experimentations. Several uses have been developed with diﬀerent kinds of collected data. The main idea is to increase interactivity between students and teachers through digital supports, such as tablets and Web interfaces. The authors argue that the post-analysis and the online capture of student behavior and annotations can improve course content and teacher pedagogy. Moreover, AmI can help to adapt the course online to the students through the use of alternative pedagogical material and e-learning. Finally, not enough experimentations have been conducted to enable conclusions about the AmI framework for education, although it looks very promising for the future.
• [PBG07] Paganelli et al. present a context-aware e-tourism application. Additional information is provided to visitors according to their location, proﬁle, and their preferences and those of other tourists. When a tourist arrives at a destination, the system evaluates who else is in the same place and encourages the exchange of their opinions through a chat messaging. Context awareness is a feature allowing a system to adapt its decisions according to a multi-modal and sequential analysis of a situation. The system does not make a decision according to the local states of variables, but according to their correlation in a global scheme. Hence, the system is managed globally, which guarantee its consistency. The authors use a combined object-oriented data model to collect and manage information with an ontology-based model to implement a reasoning engine. Their e-tourism application facilitates interactions between visitors and highlights the best places at the respective destination according to their recommendations.

2.3. Ambient Intelligence

23

• [AE10] Alemdar et al. present a survey on AmI requirements, architecture and technologies for healthcare applications. They identify three scales of infrastructure. The body area network is composed of sensors located on patients, nurses and doctors, as well as on pills, in order to improve care traceability. The personal area network refers to the set of sensors to manage the residential environment, such as video cameras, bed tracking and environment monitoring (brightness, pressure, temperature), and provide rich contextual information to the AmI applications. Meanwhile, the wide area network is the communication backbone needed to manage the system remotely through human-computer interfaces over the Internet. Security issues and enabling technologies are listed in diﬀerent studies. The conclusion emphasizes the necessity to develop multi-modal sensor systems to address the challenge of context-aware and pervasive applications in healthcare, while also considering security and privacy issues.
• [RM13] Rashidi et al. present a survey on AmI challenges and techniques for assisting older adults. People are increasing living longer, which in turn aﬀects their mobility and autonomy. While robotics has oﬀered promise in recent decades, its usage with older people is diﬃcult because robots are not accepted by this population. As such, a smart environment seems to be more practicable because intelligence and operations are camouﬂaged within the environment for assisted people. The authors refer to enabling technology and its usage, but also the main issues surrounding this topic. The identiﬁcation of human activity is the principal challenge. Context-aware features allow a system to consider itself in its global state, whereas human activity identiﬁcation tends to predict what humans need next. However, older people can be inconsistent in terms of their actions according to their current needs because of their gradual physical and cognitive decline. Hence, a system must have enough knowledge not to be inﬂuenced by such behavior in the course of providing assistance.
[Sad11] Sadri presents a comprehensive survey on AmI. The development of such technology has become urgent regarding the aging population. It can help older people with independent living, as well as other handicapped people, such as those who are blind. The whole of society may possibly beneﬁt from applications in spaces for the elderly, healthcare, business, commerce, leisure and smart homes. The author lists an important number of projects implemented in real experimentations using diﬀerent kinds of technology. In doing so, she identiﬁes two main approaches, one of which is based on technological automation for elementary decision mechanisms, while the other is based on adaptive intelligence with complex reasoning engines and knowledge representation. Furthermore, the author studies the role of aﬀective computing and human emotions in AmI, as well as its social impact on a group of people. Finally, while the technology is available, its acceptance by humans is not still guaranteed.

24

Chapter 2. State of the Art

2.3.1 Responsive Environment

2.3.1.1 Event Condition Action Rules

[Aug+08; AN04] Augusto et al. have developed a framework based on EventCondition-Action (ECA) rules to model complex patterns of appliance interactions in smart homes. According to an event occurring on a sensor, the system must respond in order to assist in human activity or adapt the environment. The authors propose a new language that is capable of handling spatiotemporal and uncertainty conditions for smart homes. Its semantics facilitate the description of the events needed to formulate the conditions to operate an action. These rules are used to drive the environment from a knowledge database that is ﬁlled by experts. The belief-rule-base component takes into account the degree of belief in order to ensure the consistency of decisions when several condition rules are satisﬁed. An evidential reasoning approach is used to generate the proper output state for actuators. Conversely, when none of the rules can be applied, the system must learn by extracting rules from human activity. Although this symbolic space for describing system behavior is powerful because the internal state of the system cannot be understood by the expert, the use of a description language is diﬃcult in order to describe complex states and actions.

2.3.1.2 Action Planning
[Sim+06] Simpson et al. provide a survey on planning techniques for a smart home. This problem consists of determining a path of actions to reach a goal state from an initially known one. A plan is a sequential ordered collection of actions determined by analyzing the current situation. Firstly, the system has to identify the current context in a smart home according to the sequence of previous events. Then, it has to select the corresponding action plans to control the smart home. An important issue appears when the subsequent states can be derived from the expected state because of actuator errors, external events or human activity. Hence, the planning engine must consider the probability of fails in order to avoid an intractable situation.

2.3.1.3 Decision Tree
[ST06] Stankovski et al. discuss the use of decision tree in smart home applications. A decision tree is a graphical representation in which possible actions are represented by a rectangle, while the probability of reaching the next state is represented by a circle. Hence, a decision does not guarantee that the desired next state is reached. It takes into account the possibility of derivation during the planning phase. Its design requires a lot of experimental data to determine the model, but the planning simply uses the expected utility function and classical inference algorithms.

2.3. Ambient Intelligence

25

2.3.2 Reasoning Engine

2.3.2.1 Fuzzy Rule-Based Engine

[DHC05] Doctor et al. present the project known as iDorm, which is an

AmI based on the fuzzy logic model. Each piece of information has an associated

degree of certainty in order to compute operations with a tolerance interpretation.

For example, the term the door is a little open can be represented mathematically

by the value ’open’ and a certainty degree of

1 2

.

Hence, the reasoning engine

deduces action plans in terms of the door being neither completely open nor

closed. The fuzzy logic model introduces the inaccuracy of language semantics

inside the model. It facilitates the modeling of continuous functions in a symbolic

space, which avoids the determination of a strict system state according to the

sensor values. The authors present results in which their engine of fuzzy logic

produces fewer decision errors than other logic systems.

2.3.2.2 Context-Awareness System
[Mag+06] Magerkurth et al. present the project known as Amigo, which is an ontology model based on AmI. It is used to separate the language logic from its semantics. The keywords are described in terms of a relationship between two other keywords. This set of descriptions deﬁnes a graph called an ontology. This technique is used to facilitate knowledge transfer between heterogeneous devices, such as several types of AmI that do not share a common description language. The authors use ontologies to establish advanced relationships between the diﬀerent pieces of informations used to model the system context. Hence, the system focuses on the relationship between the pieces of information instead of their content, which improves the eﬃciency of the context analysis.

2.3.2.3 Learning Techniques
[AIA10] Aztiria et al. present a survey on learning techniques for AmI. The learning process consists of extracting a general function to associate an output with an input from empirical data. For example, the state of the actuators is determined according to the current context of the system. There are two main approaches: the extraction of a statistical model, such as one involving ANC or a Bayesian network; and symbolic inference, which tries to built associative rules between input and output, such as fuzzy logic, sequence discovery, instance learning and pattern matching. The trade-oﬀ for learning techniques is their ability to learn quickly with the best possible accuracy using a minimal set of data. Meanwhile, the result must be understandable by a human expert. The authors conclude that no learning techniques currently exist that enables AmI to simultaneously address all of these requirements.

26

Chapter 2. State of the Art

2.3.3 Ambient Intelligence Architectures
2.3.3.1 Autonomic Computing
[ATK11] Andrushevich et al. discuss the application of autonomic architecture within AmI. This kind of architecture was introduced by IBM in 2001 in order to build self-adaptive systems [Com+06]. Their architecture is based on a MAPE-K control loop, as illustrated in Figure 2.2, for AmI applications. It is composed of four main components, which share a common knowledge space representing system parameters, user preferences and extracted system information:
• Monitoring consists of aggregating and ﬁltering the data collected from the sensors and the actuator states.
• Analysis determines the system context by evaluating the human and environment activities in order to select an action plan.
• Planning generates or updates the action plan according to possible future scenarios and system goals.
• Execution deploys and executes the selected plan on the actuators.
This control loop has been designed for self-x properties (self-optimization, selfhealing and others). At each iteration, the diﬀerent components create new knowledge that they learn from and exploit in order to improve their results.

Figure 2.2 – MAPE-K control loop instantiated for AmI.

2.3. Ambient Intelligence

27

2.3.3.2 Multi-Agent System

[SV05] Da Silva et al. present architecture for MAS in order to design a form of AmI. It is composed of a set of software agents representing the physical devices or residents in a digital environment, as illustrated in Figure 2.3. Each agent is synchronized bidirectionally with the status of the real device. Hence, the agents can communicate together without any network costs. Within their MAS architecture, the agents exchange data and negotiate the shared resources through a tuple space, which represents the physical world. The authors emphasize the interest in MAS for designing complex interactions in AmI. Instead of designing a global artiﬁcial intelligence, which drives everything, each agent has its own intelligence that collaborates with others’ intelligence to achieve its own goals.
[SM06] Spanoudakis et al. present another form of architecture of MAS for the purposes of designing AmI. The authors are interested in the interoperability of their work with other approaches. Firstly, they use the Agent Communications Language (ACL) deﬁned by the Foundation for Intelligent Physical Agents (FIPA). This language deﬁnes a set of protocols and performatives to implement agent dialogues. Hence, the addition of new agents does not require particular knowledge about their speciﬁc platform. Secondly, they integrate their MAS platform into an Open Services Gateway initiative (OSGi) platform. This kind of platform oﬀers a set of interfaces and functionalities to interconnect heterogeneous components and devices. Finally, this platform can be easily extended by adding a new agent without having particular knowledge and being interconnected with other platforms.

Figure 2.3 – Architecture for a multi-agent system for ambient intelligence.

28

Chapter 2. State of the Art

2.4 Organic Computing Approach

[MSSU11] Müller-Schloer et al. present a compilation of papers focused on Organic Computing (OC). This new paradigm is motivated by the necessity to deﬁne a framework in order to control self-organization processes in large and complex networks. Although numerous contributions in Multi Agent System (MAS) have proposed frameworks with self-x properties, there are no well-deﬁned deﬁnitions that are commonly used. In this book, the authors propose a framework to mathematically deﬁne the terms of autonomy, organization, adaptivity, robustness and others with their relationships. The OC framework focuses on methodology to develop self-organized MAS with trustworthy responses.

2.4.1 Principles and Challenges
2.4.1.1 Trustworthy Systems
[Ste+10] Steghöfer et al. discuss the challenges and perspectives concerning trustworthy OC systems. Behind the idea of the self-organized system is the reduction in control parameters for a managed system. A system increases its autonomy when the number of parameters is reduced to cover the same number of diﬀerent tasks. Therefore, the removed parameters are self-established by the system itself. A trustworthy system provides a correct response independently of internal or external disturbances through the self-adaptation of its internal parameters. The authors deﬁne trust in terms of a multi-faceted concept composed of functional correctness, safety, security, reliability, credibility and usability. They derive these concepts in relation to trust models, trust metrics and trust algorithms. Finally, they conclude that these kinds of technology will be only available in the industrial sector once they are trusted, controlled and comparable.

2.4.1.2 Self-X Properties
[Naf+10] Nafz et al. present a formal framework for the compositional veriﬁcation of self-x properties in OC systems. The authors use a temporal logic to guarantee that the system outputs stay inside a speciﬁed acceptance space for the functioning mode. They split the problem into two parts: the validation of the functional system and the self-x algorithms. Based on these two analyses, the authors provide theorems to determine the robustness of the entire system. They evaluate their proposal using an application of the self-organized data ﬂow problem. Their future work will be interested in extending their formal framework to liveness properties.

2.4. Organic Computing Approach

29

2.4.1.3 Design Methodology
[KB05] Kasinger et al. propose a framework and a methodology for designing Multi Agent System (MAS) that is extendible into OC architecture by adding self-x properties. The authors present a metamodel that can be instantiated through 14 design phases until reaching the ﬁnal operational OC system. They use an extended Uniﬁed Modelling Language (UML) model to represent the diﬀerent components of the OC system. Their methodology is illustrated on a manufacturing control system, in which a traditional MAS is designed beforehand to add self-x properties. Their contribution is a ﬁrst step towards software engineering methodology for OC using standard tools.

2.4.2 Models and Architectures
2.4.2.1 Observer-Controller Model
[Ric+06] Kasinger et al. present the generic observer-controller model for OC systems, as illustrated in Figure 2.4. The component observer evaluates the current situation of the System under Observation and Control (SuOC) according to an observation model, which is selected by an expert. This model conﬁgures the observer engine by selecting the proper analyzers and event predictors to provide context information to the controller. This latter evaluates the possible actions according to the constraints, then selects the best one according to its history database. The constraint model is updated by a simulation engine, which adapts the human requirement to the SuOC.

Figure 2.4 – Generic observer-controller model for organic computing.

30

Chapter 2. State of the Art

2.4.2.2 Multi-Scale Architecture
[Bra+06] Branke et al. present an application of organic traﬃc control on city roads. Informed by the generic observer-controller model discussed above, they introduce its application on a diﬀerent scale, as illustrated in Figure 2.5. The SuOC can be considered diﬀerently according to its application or architectural choices. If the observer and controller engines are located in an independent system, the data are centralized and the orders are remotely distributed over SuOC, as shown in Figure 2.5.1. Conversely, each component of the managed system can have its own observer-controller engines in order to form a Multi Agent System (MAS), as in Figure 2.5.2. The combination of both approaches is a MAS managed by another observer-controller engine in a multi-scale architectural style, as in Figure 2.5.3.

2.5.1: Centralized

2.5.2: Decentralized

2.5.3: Multi-scale

Figure 2.5 – The diﬀerent scales of observer-controller architecture.

2.4.2.3 Evolutionary Computation
[MKD11] Matsumaru et al. present a paper on organization-oriented chemical programming (OOCP). In an Organic Computing (OC) system, the observercontroller model supervises an SuOC, which is mostly a complex system, such as one found in a physical environment or a complex network. This SuOC, however, can be also implemented intentionally in the same way as a complex system. The authors present the OOCP framework in an OC system. The resolution of a problem is performed by a set of interactions between artiﬁcial chemical elements. The problem is deﬁned as a set of possible interaction rules: positive or negative reactions. At the end of the process, the result is encoded in terms of ﬁnal concentration of the artiﬁcial chemical components. Hence, the observer-controller engine prepares the initial conditions for the SuOC analysis and controls the emergence phenomena in order to collect the results. Such an approach has a very strong robustness with regard to failures and system disturbances, which is due to problem resolution not being dependent on hardware computations but the result of an emergency at the software level.

2.4. Organic Computing Approach

31

2.4.3 Application Examples
2.4.3.1 System on Chip
[BKK08] Buchty et al. have developed an innovative self-conﬁguring bioinspired architecture known as the Digital on-Demand Computing Organism (DodOrg). Their project involves fully distributed middleware in order to distribute tasks over multi-core architecture. They present a complete framework composed of three levels: an application test bed, organic middleware and the Organic Processing Cells (OPC). The tasks are implemented with a high level language in order to be distributed over the middleware to minimize global chip temperature. Each computation unit, which is implemented on FPGA, embeds its own observer-controller model and communicates with others by an hormonal interaction system. The authors argue that their system is extremely robust, self-organizing, ﬂexible, real-time, large-scale and self-healing system.
[SHB09] Schuck et al. present, in detail, the architecture of OPC technology. The authors work focuses on the remote reprogramming of cells through the internal conﬁguration access port of Xilinx Virtex-FPGA technology. The DodOrg project oﬀers a new generation of computers, in which tasks are dynamically distributed over the cell according to the computation requirements of the application, as well as factors in the computer environment, such as temperature. This contribution adds the possibility of changing FPGA programming of the DodOrg system in order to deploy new functionalities inside the chips.
[Bou+06] Bouajila et al. present another type of System on Chip (SoC) architecture, based on OPC technology. SoC technology is highly sensitive to environmental variations, which can introduce bit and timing errors. Hence, the authors have developed a system on FPGA to control execution pipeline consistency for Metal Oxide Semiconductor Field Eﬀect Transistor (MOSFET) technology. This is a ﬁrst step towards self-correction properties for SoC technology at the hardware execution level.
[FS05] Fey et al. present OPC architecture for image preprocessing tasks in future Complementary Metal Oxide Semiconductor (CMOS) camera chips. The system architecture is fully distributed over the FPGA. Instead of using a sensor matrix connected to the process unit, each pixel has its own observer-controller system. Hence, the camera chip is composed of a set of OPC. The authors propose a concept of marching pixels, which uses mobile agents located in each OPC to detect an object. The proposed algorithm is similar to an algorithm with attractive and repulsive mechanisms to help the agents become ﬁxed in an interest area. Therefore, either the detection or the tracking of an object involves the analysis of the position of agents on the OPC. The authors expect to extend their work for three-dimensional cameras, which are strongly limited by traditional computation approaches. Indeed, they require much more computations and, in turn, powerful chips that are diﬃcult to miniaturize.

32

Chapter 2. State of the Art

2.4.3.2 Traﬃc Lights in a Smart City
[Pro+08; Pro+11] Prothmann et al. present an application of OC principles and architecture for traﬃc control in a smart city. The system regulates the vehicle ﬂows by managing the traﬃc lights in order to reduce network congestion and the average delay time at the intersections. The system is composed of two observer-controller layers. The ﬁrst one determines the best policy for the traﬃc lights according to the observations on current vehicle ﬂows. The second one creates oﬄine classiﬁers in order to predict the traﬃc according to the period and the events in the surrounding area.

2.4.3.3 Energy Management in Smart Homes
[Bec+10] Becker et al. present a smart home project based on OC technology. The system is composed of multi-scale architecture. Each appliance has its own observer-controller engine in order to locally monitor its usage and its energy consumption, as well as to control them. A main observer-controller engine is responsible for managing all of the appliances. It has to manage the appliance scheduling according to the requirements of the residents and the energy grid operator. In the proposed scenario, the system has to even out the total energy consumption of the smart house. Some appliances have a ﬂexible energy consumption, such as the dishwasher, which can be deferred to a later point in the day. Similarly, an electric car can be powered during the night, while it can also be used to supply power during high levels of demand for energy in order to reduce the energy provided by the provider grid. Hence, the system diﬀers and load-balances energy consumption, as shown in Figure 2.6.

Figure 2.6 – Example of the energy management policy in a smart home.

2.5. Synthesis

33

2.5 Synthesis
This chapter has been presented state-of-the-art developments relating to IoT research activities. It is composed of three parts, from the technological requirements and constraints, to the Ambient Intelligence (AmI) techniques and forms of architecture, which have been extended due to the growing involvement of Organic Computing (OC).
Applications relating to the IoT require massive data produced by smart objects. Their huge number exposes several issues regarding their communications in a large-scale network, which has to be easily connected to the Internet. The constraint in having limited energy consumption can reduce their computation and memory capacities. Being at the intersection between the physical and digital worlds, they will be produced by known IoT experts. Therefore, middleware technology has been intensively developed to provide an eﬃcient abstraction layer between the physical object and the digital world in order to build secure, reliable and heterogeneous architecture, which is composed of thousands of tiny nodes.
The IoT is developing jointly with AmI in order to build smart environments. The technological constraints on the IoT have to be considered when designing intelligent systems. On the one hand, new techniques of artiﬁcial intelligence have been investigated in order to address the challenge of smart environments, while, on the other hand, traditional approaches have to be redesigned to be used on existing IoT architecture. Historically, an intelligent system was located in a set of identiﬁed platforms in order to remotely manage a system. Nowadays, they must be distributed over a network of embedded systems in order to locally manage the environment, while the system consistency must be maintained at a macro level.
Some researchers have started a new initiative to develop a paradigm for such a complex system. The OC approach is a bio-inspired technology that is interested in designing a distributed and autonomic system, in which the system control is not operated by a central decision system, but the interactions of individual agents, in order to facilitate the emergence of the desired global behavior. Current developments focus on the deﬁnition of standard architecture and models, which can be evaluated in real use cases. However, there is still no generic framework for the design of IoT applications, such as an autonomic OC system.
The present thesis has been motivated by proposals for tools needed to design operational IoT systems that are compatible with OC requirements, as stated in Part II. At the same time, it relates to Part III, in which distributed algorithms for context learning and distributed decisions are proposed in relation to an OC-like approach.

Contribution: An Organic Ambient Intelligence1
1Summarized in Clement Duhart and Cyrille Bertelle. “Toward Organic Computing Approach for Cybernetic Responsive Environment”. In: International Journal of Ambient Systems and Applications (IJASA) 3.4 (2015). doi: DOI:10.5121/ijasa.2015.3401

In Organic Computing (OC) community, the term of Organic refers to systems in which the degree of autonomy is increased thanks to a supervisor layer Observer/Controller which self-managed some internal parameters. Therefore such systems are able to change their conﬁguration in order to reduce required human interventions during the dynamic of the managed environment. The reﬂexion is oriented on a new generation of software architecture based on stacked layers of diﬀerent functional levels to adapt the system behaviour on runtime. However based on previous State of the Art, there is no major research on intrinsic properties of organic chemistry of self-adaptation which allows atomic elements to be self-organized to form functional materials at higher levels and multi-scales. In optimization problems based on neural networks, genetic and ant algorithms or others, the information is not stored in their atomic components of neurons, ants, genes but in the self-organization of their interactions. Because the current computers are based on sequential execution, such algorithms have to be adapted to simulate interaction computation with the issues of parallel executions, asynchronous communications and independent process life-cycle.
This thesis is interested in studying a new approach of computation bio-inspired by organic chemistry, cellular supports and neural architectures.
The background contribution is a reﬂexion and an experimentation on the design of Artiﬁcial Organism (AO) for autonomic computing. Obviously such position cannot be fully studied during a single thesis, but the developped softwares and theorical models provide ﬁrst Proof-of-Concepts to design, deploy and execute Artiﬁcial Neural Network (ANN) over distributed support of Wireless Sensor and Actor Network (WSAN) based on interraction of chemistry material at an atomic layer. It is supposed that the next generation of intelligent systems would be more interested in new kinds of computation to have adapted hardware and architectures to Artiﬁcial Intelligence (AI) algorithms.
Environment Monitoring and Management Agent (EMMA) is a proposal of framework for distributed Organic Ambient Intelligence (AmI).
AmI is an interesting application challenge for this approach such as it is an open and distributed system at hardware, network, service and intelligent layers. Multi-levels of failures must be considered in addition of their integration with current and future technological evolution of the concerned research areas. In addition this kind of systems must be highly adaptable such as their purposes, constraints and ressources are evolving at each time and over the time. When AmI will be deployed with the hardware support,the software and the networking, it should not be possible to determine their future use over building life cycle. Hence the autonomy, scalability, security and Internet integration of the system are major concerns of EMMA framework.

The WSAN is considered such as an autonomous System under Observation and Control (SuOC) managed remotely by one or several supervisors which deploy or optimize the running services during runtime. Two applications of intelligent components are proposed: an actuator management by context learning with Artiﬁcial Neural Controller (ANC) and a distributed neural voting procedure for parameter selection. The SuOC is composed of the connected objects located in the managed environment. Each of this connected object is a System on Chip (SoC) with a wireless module executing hard-coded services such as sensor drivers or system tasks. The Web-based architecture is integrated with Internet services thanks to the use of last network standards of IPv6 LoW Power Wireless Area Networks (6LoWPAN). The EMMA middleware abstracts the WSAN to the AmI thanks to a Resource Oriented Architecture (ROA). Finally, the AmI is resumed by a set of Service Choreography (SC) which form a graph of interactions between the object WEB resources. The communication between the ressources of node services are operated by reactive mobile agents. Hence, the middleware is a distributed, autonomous and shared tupple space in which mobile agents are executed. The Service Choreography (SC) act as Observer/Controller component distributed over the nodes to manage the actuators according to the sensors through their respective resources. A security layer ensures that operational communications stay local and encrypted to protect data privacy and system security. Finally, the supervisors are responsible to manage remotely the SC. In the proposal, they are implemented according to the MAPE-K architecture. They compose and deploy the SC from a database according to WSAN requirements and update them according to the system feedbacks. The Figure 2.7 presents the architecture overview with the corresponding chapter colors.
Figure 2.7 – Thesis Overview: EMMA Architecture.

2.5. Synthesis

39

Part II
• Chapter 3 - Capillar Internet Network presents the network architecture on which is running the EMMA framework. It does not contain direct contributions, however the diﬀerent evaluated approaches to build an integrated WSAN with Internet Protocol version 6 (IPv6) networks are presented. Impacts of software architectures between service orchestration and choreography are evaluated in order to validate the use of a distributed model. Finally, the diﬀerent tools developed during this thesis are introduced.
• Chapter 4 - Active Resource Middleware presents the Resource Oriented Architecture (ROA) of the middleware with its mobile agents. They are used to interconnect the resources in order to build the choreographies of services which are denoted SC. The speciﬁcations of the agents are detailed including their graphical representations which are based on an augmented Numerical Petri Network (NPN). The self-x properties of the mobile agents are discussed regarding to the deployment requirements. Finally, the SC partitioning for security aspects are presented.
• Chapter 5 - Service Choreography Deployment presents the deployment process of SC. They must be deployed according to the hosting capacities of nodes, the network constraints and the application requirements in order to minimize the network communications. The deployment process is itself considered such as a SC which must be mapped over the network. The mathematical formulation is resumed by a pseudo-Boolean optimization (PBO) to map the mobile agents and their temporal resources on nodes.
Part III
• Chapter 6 - Artiﬁcial Neural Controller presents the methodology used in EMMA system to create ANC. There are two learning loops to exchange information between a knowledge base composed of logical descriptive rules and the statistical classiﬁers of ANC. They are trained to control actuators according to sensor and system states. The ANC are deployed and executed directly on service components of the nodes. Mobile agents are responsible of their deployments and connections with the other system components through resources.
• Chapter 7 - Neural Voting Procedure presents a fully distributed algorithm of voting procedure to allow the nodes to take a common decision without the centralization of their choice preferences. The implementation of this algorithm is done by mobile agents deployed over the middleware to form a distributed ANN. The nodes publish their preferences through their resources which are connected by the mobile agents.

Part II An Organic IoT Framework

Chapter 3
Capillar Internet Network
Notre progrès technique tant vanté et la civilisation en général peuvent être comparé á une hache mise dans les mains d’un psychopathe criminel.
Our entire much-praised technological progress and civilization generally could be compared to an axe in the hand of a pathological criminal.
Albert Einstein [Ein71]
Contents
3.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . 44 3.2 Network Infrastructure . . . . . . . . . . . . . . . . . . . . 45
3.2.1 Wireless Sensor and Actor Networks . . . . . . . . . . . . 46 3.2.1.1 IP Connectivity: 6LoWPAN . . . . . . . . . . . 46 3.2.1.2 Routing Protocol: RPL . . . . . . . . . . . . . . 46 3.2.1.3 Gateway: Border Edge Router . . . . . . . . . . 47
3.2.2 Home Information System . . . . . . . . . . . . . . . . . . 47 3.2.2.1 Permanent Gateway . . . . . . . . . . . . . . . . 48 3.2.2.2 Mobile Gateway . . . . . . . . . . . . . . . . . . 48 3.2.2.3 IPv6 Backbone . . . . . . . . . . . . . . . . . . . 49
3.2.3 Internet Integration . . . . . . . . . . . . . . . . . . . . . 49 3.3 Service-Oriented Architectures . . . . . . . . . . . . . . . 51
3.3.1 Resource-Oriented Architecture . . . . . . . . . . . . . . . 51 3.3.2 Experimental Model Analysis . . . . . . . . . . . . . . . . 52
3.3.2.1 Service Orchestration . . . . . . . . . . . . . . . 52 3.3.2.2 Service Choreography . . . . . . . . . . . . . . . 53 3.4 Software Tool Contributions . . . . . . . . . . . . . . . . . 54 3.4.1 Active Resource Middleware . . . . . . . . . . . . . . . . . 54 3.4.2 Hybrid Network Simulator . . . . . . . . . . . . . . . . . . 54 3.4.3 Service Choreography Software . . . . . . . . . . . . . . . 55 3.4.4 Network Tools and Connectors . . . . . . . . . . . . . . . 55 3.5 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56

44

Chapter 3. Capillar Internet Network

3.1 Introduction

The Internet of Things (IoT) is the extension of the Internet into the physical world in order to collect real-time information about particular environments. For future applications, such environments should be controlled by intelligent systems from the Internet in order to improve their accessibility and comfort, as well as their safety and security, while optimizing global energy consumption. However, this will require large-scale infrastructure regarding the network, information systems and applications. Each of these parts are strongly dependent on physical characteristics. Given the number of objects involves implies that they should be designed such that their size, cost and energy consumption are limited, which in turn will have a signiﬁcant impact on their communications. Their deployment in large environments, such as buildings, does not allow for the use of wires to connect them. Hence, wireless communications are preferred.
This chapter presents a proposal for network architecture for the IoT by combining current technologies to oﬀer a maximum number of possibilities, in terms of addressability, packet routing and architectural ﬂexibility, in order to establish end-to-end data ﬂows from appliances to Internet services. Section 3.2 introduces the diﬀerent technologies and their achievements in building a complete network solution, composed of appliances and their wireless network, which is connected to the Internet through gateways. This proposal is based on current technological standards based on an end-to-end IPv6 connectivity. Other proposals can be found in the literature, but they are mostly based on an intermediate multi-protocol proxy. However, such approaches are not compatible with the spirit of an homogeneous IoT based on the Internet Protocol (IP), which is the concern of this chapter.
Based on this network overview, an evaluation of Service Oriented Architecture (SOA) paradigms is investigated in relation to service orchestration or choreography in Section 3.3. The ﬁrst paradigm involves architecture in which all data are collected on a central system, which controls everything. This approach facilitates the design and deployment of new services, but it has strong network limitations in large-scale networks. Conversely, service choreography locally distributes all communications between appliances, which reduces network congestion; however, the management of such system is a diﬃcult task. Given that the results have shown that architecture based on service choreography improves network reactivity, this thesis has been motivated by the proposal of a framework for the orchestration of service choreographies.
Finally, Section 3.4 presents an overview of the diﬀerent tools developed during this thesis to build and manage service choreography infrastructures. The following chapters, which together form Part II, detail theoretical contributions and implementation results, in order to provide a software suite using the appliance software and network management for service development.

3.2. Network Infrastructure

45

3.2 Network Infrastructure

Network infrastructure refers to the set of devices required to establish communication links between appliances and the Internet. The development of large-scale wireless networks for IoT applications has raised the issue of energy consumption. On the one hand, some end-devices run on batteries because power lines are not accessible in all places; while, on the other hand, a critical number of network devices can dramatically increase general energy consumption.
Nowadays, standard protocols have been deﬁned in order to improve network lifetime, while ensuring its sustainability through the use of IP-based protocols. The Internet Engineering Task Force (IETF) deﬁnes the IPv6 LoW Power Wireless Area Networks (6LoWPAN) protocol for low power and lossy networks. The energy consumption, memory and computation of network devices are considered in order to connect them to Internet over wireless communications.
Figure 3.1 presents three kinds of devices, which are considered in such an infrastructure: a node is an energy constraint device, which must avoid signiﬁcant communication in order to prolong its lifetime; a router is an intermediate node with lower energy constraint needed to establish a mesh network between nodes; and the Border Edge Router (BER) is a gateway between the Internet and the Wireless Sensor and Actor Network (WSAN).

Figure 3.1 – Illustration of a classical IoT network infrastructure.

46

Chapter 3. Capillar Internet Network

3.2.1 Wireless Sensor and Actor Networks
A Wireless Sensor and Actor Network (WSAN) is composed of distributed energy constraint devices, which communicate over a mesh network. The large number of devices involved and their mobility, in terms of failures or moving physically, require self-conﬁguration mechanisms to establish and maintain networks.

3.2.1.1 IP Connectivity: 6LoWPAN
The 6LoWPAN protocol, deﬁned in RFC 4944 for IEEE 802.15.4 wireless technology, has been designed to address issues concerning RFC 4919: IP connectivity, limited packet size, self-conﬁguration and security aspects. Most IPV6 mechanisms are used in 6LoWPAN, in addition to adaptations for the reduction of energy consumption through the limitation of packet size by the IP and transport header compression.

3.2.1.2 Routing Protocol: RPL
The Routing Protocol for Low power and Lossy Networks (RPL) routing protocol, illustrated in the sequence diagram 3.2, allows WSAN to automatically and dynamically establish IP addresses and routing tables by using the IPv6 Node Discovery mechanism (for more details, see draft-ietf-6lowpan-nd and -rpl). Each node generates its own local IP address (fe80::) until receiving a network preﬁx disseminated from a Border Edge Router (BER). The nodes then subscribe to the ﬁrst available router in order to maximize the data rate between them and the BER. This operation can be iterated periodically to maintain the best network connectivity between nodes and the BER.

Figure 3.2 – Sequence diagram of 6LoWPAN-RPL network establishment.

3.2. Network Infrastructure

47

3.2.1.3 Gateway: Border Edge Router
A gateway is a network device establishing connectivity between two diﬀerent networks. A WSAN based on the 6LoWPAN has two major functions. Firstly, the IPv6 packets must be compressed or uncompressed between the WSAN and traditional network interfaces. Secondly, the gateway hosts the Border Edge Router (BER), which is responsible for the network preﬁx dissemination used during the establishment of network connectivity by the RPL protocol. In Figure 3.3, the network infrastructure is composed of two BERs (gateways), which leads to the construction of diﬀerent overlapped routing trees. Indeed, the IPv6 protocol allows nodes to have several IPs, which can be used to select the best routing path according to the communication recipient.

Figure 3.3 – WSAN Multiple Routing RPL DAG.
3.2.2 Home Information System
The Home Information System (HIS) refers to the set of connected appliances in a residence. Currently, it is mainly composed of multimedia devices, which are already connected through standard protocols, such as Universal Plug and Play (UPnP) and Bluetooth. Their development was not initially designed to be an extension of the Internet, even if more and more HISs are connected to the Internet because of the emergence of Wi-Fi enabling devices, such as Network Attached Storage (NAS), wireless printers and tablets.
The integration of Wireless Sensor and Actor Networks (WSANs) on the Internet should be easy to facilitate given current developments in HIS based on IP technology. The following section reviews the diﬀerent devices enabling WSAN integration into HIS and technological aspects used in this thesis.

48

Chapter 3. Capillar Internet Network

3.2.2.1 Permanent Gateway
Recently, plug computers have appeared in HIS for the purpose of installing local fanless servers at home. Even if their hardware architecture, which is based on ARM technology, is designed to limit energy consumption, most of these devices are able to execute a complete Operating System (OS) based on Linux. They are used in conjunction with NAS and multimedia platforms, which makes them an interesting access point for WSANs. On the one hand, the Linux kernel is natively supporting the IPv6 and includes a set of network management tools. On the other hand, Contiki, presented in Chapter 2, is an Operating System (OS) for nodes, which supports Remote Network Driver Interface Speciﬁcation (RNDIS), thereby allowing it to communicate natively with the Linux kernel. Hence, the architecture in Figure 3.4 is a native integration of a 6LoWPAN WSAN in an HIS based on IPv6.

Figure 3.4 – 6LoWPAN integration on a plug computer based on GNU/Linux. 3.2.2.2 Mobile Gateway The development of smartphones and the improvement in their Internet connectivity oﬀer new perspectives for gateways in HIS. Firstly, they are platforms that already host applications and preferences of residents. Secondly, they enjoy a permanent Internet connection, which can be shared with the HIS instead of using a dedicated Internet Service Provider (ISP). Hence, they all have gateway characteristics for WSANs and are interested in privacy; for example, the HIS is physically disconnected from the Internet when there is no user present.
Figure 3.5 presents architecture for integrating a WSAN to the Internet through a mobile gateway, such as a tablet. A Tunnel Serial Line Internet Protocol (TunSLIP) is established between a Contiki OS node and the Linux kernel of an Android OS. This kind of connection is useful to bypass the lack of an RNDIS driver on a lightweight Linux kernel.
Figure 3.5 – 6LoWPAN integration on a mobile phone based on Android.

3.2. Network Infrastructure

49

3.2.2.3 IPv6 Backbone
The deployment of IPv6 is still an experimental enterprise on a classical network infrastructure, even if signiﬁcant eﬀorts are made to promote it. Currently, the Internet does not fully support IPv6 routing; moreover, most network tools are not stable enough for this IP technology. Hence, its use is mainly concerned with a local network backbone, instead of a general Information Technology (IT) infrastructure. In such situations, the dissemination of the IPv6 network preﬁx can be operated locally from a Border Edge Router (BER) localized on previously presented gateways. Otherwise, it can be installed on a remote Internet server, which pushes IPv6 routes through an Internet Protocol version 4 (IPv4) tunnel.
Figure 3.6 presents a general infrastructure based on an IPv6 backbone, which ensures connection between diﬀerent WSAN, Wireless Fidelity (WiFi) and traditional Home Information System (HIS) devices, such as NAS. In turn, each device has local access to a WSAN; in particular, tablets and mobile phones can operate like a remote control with personal user applications and preferences.

Figure 3.6 – WSAN Integration in Home Information System (HIS).
3.2.3 Internet Integration
The Internet integration of HIS is a still an open issue in IoT discussions. The IPv6 should permit direct access to local devices from the Internet; however, their vulnerability to remote attackers raises diﬃcult security questions. Indeed, WSANs are very sensitive to Denial of Service (DoS) because of their strongly limited bandwidth. Even if WSANs are IP enabling, they must be protected. There are two major use cases for the Internet integration of HIS. On the one hand, the management of home appliances should be managed by external services, such as a security guardian company. On the other hand, an IPv6 backbone of

50

Chapter 3. Capillar Internet Network

HIS could be distributed over several distant sites, such as on a campus composed of diﬀerent buildings.
Figure 3.7, the two examples are represented in which three 6LoWPAN islands communicate with each other over the Internet and external IPv4 services.
IPv6 communications can be performed thanks to 6to4 tunneling. The 6LoWPAN packets are uncompressed on the gateway and encapsulated into IPv4 ones in order to transfer them between HIS islands over the Internet. This approach is natively supported by IP technology, while the communications can also be secured using a tunnel based on a Virtual Personal Network (VPN).
IPv4 services have two main solutions for communicating with an IPv6 HIS. They can translate their IPv4 packets to IPv6 ones thanks to a dual stack IPv4IPv6. Hence, the communications are peer-to-peer between 6LoWPAN devices and external services. Otherwise, the HIS provides a proxy interface, which is responsible for collecting data and managing devices in the HIS, according to the requests of external services. As such, there is no direct communication between the IPv4 external services and the WSAN. This approach is preferred by the IoT community, as it is much easier to protect WSANs against attackers or other inappropriate usages on the Internet. However, the proxy interface must implement all possible uses of the WSAN, as it is the unique controller device.

Figure 3.7 – HIS integration into an IPv4 heterogeneous multi-site infrastructure.

3.3. Service-Oriented Architectures

51

3.3 Service-Oriented Architectures
The typical network infrastructure for the IoT, as presented in the previous section, is composed of several network segments connected through gateways. Long path communications between the Internet and a WSAN are not desirable if network bandwidth, reactivity and security are to be maintained. Hence, this section evaluates the relevance of Service Oriented Architecture (SOA) in order to minimize external communications of a WSAN. Indeed, IoT applications are mainly composed of collaborations between diﬀerent objects in the same physical place. SOA is a generic model in which applications invoke local or remote services to produce, process or manage data. The two major approaches are:
• Service Orchestration (SO): a central system collects all data and directly controls all appliances.
• Service Choreography (SC): diﬀerent appliances are conﬁgured in order to directly exchange information with each other.

3.3.1 Resource-Oriented Architecture
Resource Oriented Architecture (ROA) is software architecture based on SOA in which an application is a set of software components interconnected at a Web resource level. Each service is encapsulated into a container, which publishes a REpresentational State Transfer (REST) interface of resources. Hence, an ROA application is a program in which operations and variables refer to Web resources. Its execution is a set of successive Hyper Text Transfer Protocol (HTTP) requests in order to perform data processing on remote services. The high ﬂexibility of HTTP allows the requests to be adapted to the target services if they are constrained. Moreover, the ROA application can be executed from a central system, such as an SO, or it can be distributed over the services themselves, such as in the case of SC. In this case, an ROA application is a set of distributed publish-subscribe mechanisms that interconnect the resources of diﬀerent services.
Its application on a Wireless Sensor and Actor Network (WSAN) abstracts the actuators, sensors and other operations by resource. In such situations, the application of a control loop between sensors and actuators is performed locally instead of across the diﬀerently presented network segments. Therefore, remote supervisors are responsible for conﬁguring the diﬀerent devices so that SC can be deployed between them, which means that only the data concerning the service and network discovery are collected remotely from the supervisor. As such, the management of SC is performed remotely, whereas the communications of the applications are executed locally. Supervisors are only responsible for monitoring and deploying SC in order to prolong the network lifetime.

52

Chapter 3. Capillar Internet Network

3.3.2 Experimental Model Analysis
The previous sections have presented the standard protocols for Wireless Sensor and Actor Networks (WSANs) designed for centralized architecture, such as in cases where communications are transmitted along a routing tree. The discussions around SOA have emphasized the interest in Service Choreography (SC) in order to avoid long path communications. The following experimentations evaluate this apparent conﬂict in applying SC on WSANs. The experimental setup is composed of 16 nodes (AVR atmega128rfa1, see Table 2.1), executed in a COOJA simulator and distributed randomly in order to build a centric routing tree around the gateway. The longest path to the gateway is limited to 4-hops.

3.3.2.1 Service Orchestration
Orchestration experimentation sends Internet Control Message Protocol (ICMP) requests one-by-one from the external gateway to each node through an RNDIS interface. Figure 3.8 shows an important correlation between node activity and its relative position in routing RPL Directed Acyclic Graph (DAG). Routers forward more network ﬂows when they are close to the gateway. Conversely, node response time increases according to the number of intermediate routers until the gateway is reached. RNDIS interface overcost is very important (more than 200 ms) in comparison with router reactivity (less than 50 ms).

1000 800

Orchestration Evaluation

# Packets Error bars Response time (ms)

600

# Packets

400

200

0

5

10

15

Node ID

Figure 3.8 – Service Orchestration (SO) evaluation on a random network.

3.3. Service-Oriented Architectures

53

3.3.2.2 Service Choreography
In choreography experimentation, each node periodically sends an ICMP request to a random node in the WSAN. Figure 3.9 presents a similar form of results for orchestration experimentation because the network traﬃc follows the routing path built from the gateway. However, it is more distributed over all routers than during orchestration. Besides, the response time of all random communications is signiﬁcantly reduced by a factor of 10 because there is no overcost due to 6LoWPAN and IPv6 translation on a gateway.

1000 800

Choreography Evaluation
# Packets Error bars Response time (ms)

600

# Packets

400

200

0

5

10

15

Node ID

Figure 3.9 – Service Choreography (SC) evaluation on a random network.

Experimentations show that a decentralized model improves node response time and therefore network reactivity. This result is very interesting because the experimentation on SC has been produced in terms of its worst-case scenario. Indeed, the communications are randomly produced, whereas, in real application, they would be conﬁgured in order to minimize network load. The consumers of services should be located close to the device that produces the service. It should be noted that, in the below experimentation, the extreme multi-hop path is 8-hops, with an average response time between neighbours of 7 ms. Therefore, the design of eﬃcient service mapping, according to network topology, is a major key to reducing network load and validating the application of SC on a WSAN.

54

Chapter 3. Capillar Internet Network

3.4 Software Tool Contributions
This section presents the diﬀerent software that has been developed for deploying SC over WSANs; more details are given in subsequent chapters.

3.4.1 Active Resource Middleware
emma-node is middleware based on ROA and implemented on the Contiki OS [Dun03] for 6LoWPAN networked applications.

3.4.2 Hybrid Network Simulator
The emma-cooja package contains a set of plug-ins for the COOJA simulator [Ost+06]. It provides a simulated radio environment in which WSAN nodes are emulated. Below is a list of the developed plug-ins:
• emma-cooja-rndis is a plug-in to execute hybrid simulation in which emulated and physical nodes take part in a common application.
• emma-cooja-analysis vis a plug-in for SC behaviour analysis. Resources are monitored and managed for each node (see Figure 3.10, in which the network communications are visible in real-time between the nodes, in the form of a circle with their IP, and the Uniﬁed Resource Identiﬁer (URI) of their internal Web resources is shown in blue typeface).
• emma-cooja-emma is a plug-in to connect the COOJA simulator in the same way as an EMMA node such as the simulator is an actor of the simulation.

Figure 3.10 – Screenshot of the simulator plug-in emma-cooja-analysis.

3.4. Software Tool Contributions

55

3.4.3 Service Choreography Software
The emma-design package, as illustrated in Figure 3.11, contains two pieces of JAVA software to design, analyze and deploy SC:
• emma-design-agent is an application for the graphic design of SC based on an adapted Petri network model, as detailed in Chapter 4. In addition, a simulator engine is available to evaluate the logical behaviour of SC.
• emma-design-mapper is an application for instantiating designed SC according to a WSAN target. This software evaluates the best SC mapping and deployment process in order to minimize the network load.

Figure 3.11 – Screenshot of the emma-design application.
3.4.4 Network Tools and Connectors
The emma-network package provides a set of tools to connect a WSAN to Internet gateways and IT administration tools:
• emma-network-security is a REDIS-based application to store AES security keys for the WSAN on a gateway (see Section 4.4.3).
• emma-network-rndis and emma-network-tunslip allow 6LoWPAN connectivity between the WSAN and Linux. It is used by gateways, as described in Section 3.2.2, or by a COOJA simulator for hybrid simulation, as described in Section 3.4.2.
• emma-network-snmp is an Simple Network Management Protocol (SNMP) agent, which monitors the WSAN. It allows classical IT network monitoring tools to monitor an EMMA WSAN.
• emma-network-proxy is a Node.js reverse proxy Constrained Application Protocol (COAP)-HTTP on a gateway, whose function is to exchange data between the Internet and the WSAN.

56

Chapter 3. Capillar Internet Network

3.5 Summary
This chapter has introduced the major technologies relating to the development of Wireless Sensor and Actor Networks (WSANs) and their integration on the Internet. Since the last decade, numerous studies have permitted the establishment of network protocols in order to address the issue regarding the energy constraint of devices and its impact on the general network infrastructure. The proposed end-to-end infrastructure is based on the standard protocol of 6LoWPAN, which represents a ﬁrst step towards the IPv6 Internet. The proposal is composed of diﬀerent network segments, which underlie the necessity to propose hierarchical software architecture given that the direct access of devices from the Internet raises several issues regarding network bandwidth, reactivity and security.
Service Oriented Architecture (SOA) has a strong interest in Home Information System (HIS) because it facilitates the service composition of diﬀerent appliances in an Responsive Environments (RE). The trivial experimentation between Service Orchestration (SO) and Service Choreography (SC) has concluded that the distributed approach is more eﬃcient in terms of network reactivity that the centralized one. However, the management of a distributed system is a diﬃcult task, which should be delegated to a supervisor located on a gateway. Hence, the data ﬂows of applications are located inside the WSAN, which reduces network congestion around the routers and improves network reactivity and data privacy, whereas their management should be operated from the Internet.
During this thesis, a set of software has been developed in order to design, deploy and execute an Internet of Things (IoT) infrastructure, in which appliances collaborate according to SC applications. These diﬀerent forms of software permit the deployment of real WSAN infrastructure, its simulation and the design of applications based on SC. Diﬀerent plug-ins have also been developed to analyze system behaviour during the design, simulation and execution of such applications.
The following chapters in this part of the thesis present the theoretical models, problem formalization and resolution for the design, execution and deployment of SC on a Wireless Sensor and Actor Network (WSAN).

Chapter 4
Active Resource Middleware1
L’utopie est le rêve nécessaire et la réalité le déﬁ permanent.
The utopia is the necessary dream and the reality is the permanent challenge.
Daniel Cohn Bendit [CB15]
Contents
4.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . 58 4.2 Architecture . . . . . . . . . . . . . . . . . . . . . . . . . . 59
4.2.1 System Components . . . . . . . . . . . . . . . . . . . . . 59 4.2.2 Resource File System . . . . . . . . . . . . . . . . . . . . 60 4.2.3 COAP Web service Interface . . . . . . . . . . . . . . . . 61 4.3 System Dynamic . . . . . . . . . . . . . . . . . . . . . . . . 62 4.3.1 Basic Services . . . . . . . . . . . . . . . . . . . . . . . . . 62
4.3.1.1 Local Service . . . . . . . . . . . . . . . . . . . . 62 4.3.1.2 System Service . . . . . . . . . . . . . . . . . . . 62 4.3.1.3 Agent Service . . . . . . . . . . . . . . . . . . . 63
4.3.1.3.1 Publish-Subscribe Agent . . . . . . . . 63 4.3.1.3.2 Composed Agent . . . . . . . . . . . . . 64 4.3.1.3.3 Self-X Agent . . . . . . . . . . . . . . . 64 4.3.2 Computation Flows . . . . . . . . . . . . . . . . . . . . . 65 4.3.3 Graphical Model . . . . . . . . . . . . . . . . . . . . . . . 66 4.4 Service Choreography . . . . . . . . . . . . . . . . . . . . . 67 4.4.1 Hierarchical Composition . . . . . . . . . . . . . . . . . . 67 4.4.2 Web Service Heterogeneity . . . . . . . . . . . . . . . . . 68 4.4.3 Name Space Security . . . . . . . . . . . . . . . . . . . . . 69 4.5 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
1Published in Clement Duhart, Michel Cotsaftis, and Cyrille Bertelle. “Wireless Sensor Network Cloud Services: Towards a Partial Delegation”. In: Proceedings of 5th International Conference on Smart Communications in Network Technologies 2014 (IEEE SaCoNeT 2014). Vilanova i la Geltru, Spain, June 2014

58

Chapter 4. Active Resource Middleware

4.1 Introduction

Wireless Sensor and Actor Networks (WSANs) are physically distributed systems; however, the implementation of their information systems can be centralized or decentralized. In the orchestration approach, central servers receive data from nodes and take decisions to control them. This involves an upstream that collects data and a downstream that manages the nodes. The main advantage of this approach is the easiness of application deployment and extension. Meanwhile, the communications between applications and nodes produce network congestion and response latency in large-scale networks, such as those previously presented. Service choreography involves decentralized architecture in which applications are located onto the nodes. Communications is performed locally between the nodes, which avoid long paths of communications. In turn, the issue is the deployment and execution of such applications on strongly constrained nodes.
The Active Resource Middleware (ARM) is a contribution of Service Choreography (SC) middleware applied on a WSAN. It is an abstraction layer between node services and their data exchanges at the choreography level. Its Resource Oriented Architecture (ROA) [GTW10], as presented in Section 4.2, facilitates the software implementation for motes by providing application interfaces, such as data structure, memory management, resource access, data processing, ﬁle systems and security layers. The EMMA middleware is implemented on the Contiki OS and designed to save the memory footprint.
The applications located on the nodes are considered as autonomous services that must be connected in order to design distributed applications through a Web-based choreography language presented in Section 4.3. This design of an SC consists of a conﬁguration of distributed publish-subscribe mechanisms between services located on the nodes. This graphical and ﬂexible high-level language is based on an augmented Petri network model, which exploits its theoretical background in a dynamic system analysis. Section 4.4 considers how they can be easily decomposed in order to design a complex SC.
The SC is performed thanks to reactive agents that model the publish-subscribe mechanisms. They are executed over the ARM in order to transmit requests between the node services. In turn, they can be used to manage the heterogeneity of application protocols with other Constrained Application Protocol (COAP) services. As they are also resources, they can be managed remotely from supervisors, as well as locally by themselves. An agent can create or delete other agents, including itself, which oﬀers the agent the ability to rewrite itself. Hence, the SC can be designed with self-x properties in order to evolve during its execution.

4.2. Architecture

59

4.2 Architecture
An Environment Monitoring and Management Agent (EMMA) node is an inputoutput processing module that receives requests, processes them and emits new requests to other nodes. It is composed of an File System (FS), a COAP client and a COAP server. Node functionalities can use or produce any type of data, such as numerical values (for sensors and actuators) and binary streams (for audio players). All of them are similarly processed in EMMA middleware.

4.2.1 System Components

This middleware is implemented on the Contiki OS by a set of standalone module applications, which communicate by event messaging in order to make use of the sleeping mode of microcontrollers. The global architecture is illustrated in Figure 4.1, while the memory footprints are presented in Table 4.1. It consists of:
• emma-server - for managing incoming COAP transactions and access rights

• emma-client - for forging packets and sending COAP transactions

• emma-resource - for storing resource ﬁles and managing node services
The interface between node services and the middleware core uses JSON ﬁles to allow the EMMA core to be independent of data types. Moreover, microcontrollers have a limited RAM memory (between eight and 16 kB); therefore, all resources are stored and executed from permanent ﬂash memory, which allows large requests to be processed.
All services implement the emma-resource-services interface and are managed by the resource ﬁle system emma-resource. There are three default services: a system conﬁguration interface, a numerical data store and an agent evaluator, which is used for service choreography.

Modules emma-client emma-server emma-resource emma-JSONparser emma-preprocessor emma-service-system emma-service-numeric emma-service-agent
Total

RAM 381 B 456 B 648 B 0B 95 B 60 B 10 B 210 B
1.9 kB

Program memory 8,267 B 4,528 B 4,108 B 382 B 4,116 B 2,845 B 576 B 6,586 B
31.4 kB

Table 4.1 – Memory footprints of EMMA modules on the Contiki OS.

60 EMMA

Chapter 4. Active Resource Middleware
«interface» emma-resource-services

A

dataX

L

dataY

S

*

*

*

*

*

emma-resource

emma-server

1 1 emma-preprocessor 1 emma-client

1

1

Figure 4.1 – EMMA middleware UML diagram.
4.2.2 Resource File System
While all resources have a type according to their responsible service, they are stored in permanent memory as JSON text ﬁles by the resource ﬁle system emmaresource. They are accessible by COAP requests with their Uniﬁed Resource Identiﬁer (URI). To reduce memory costs, they are mapped in permanent memory by a tree-like organization to avoid being stored in an index table. Therefore, the resource ﬁle system has to navigate between resource ﬁles, as shown in Figure 4.2.

Figure 4.2 – EMMA middleware resource ﬁle system schema.

4.2. Architecture

61

4.2.3 COAP Web service Interface
EMMA middleware is REpresentational State Transfer (REST) architecture in which COAP requests change resource states managed by node services. Its Web service implementation uses the Erbium COAP engine [KDD11] of the Contiki OS, as illustrated in Figure 4.3. The COAP protocol is an HTTP-like protocol, which is basically composed of a URI to deﬁne the resource target, a payload containing data and a method to perform an operation. With the right access, a request can read GET, modify PUT, create POST or delete DELETE a resource. Each service has its own processing callbacks to change JSON resource ﬁles stored in the permanent memory according to the request method. The IPv6 LoW Power Wireless Area Networks (6LoWPAN) protocol does not include a fragmentation mechanism that is the responsibility of the application layer. The block-wise transfer mechanism of the COAP protocol is designed to save memory buﬀer. Requests are processed online by a block of 32 bits to avoid requests being assembled in a large buﬀer. Moreover, the use of small blocks facilitates network packet scheduling at the Media Access Control (MAC) layer, such as in the use of Time Division Multiple Access (TDMA) protocol.
Finally, the set of resource data forms node context, which evolves according to processed requests. Node behavior depends of this context state to send internal or external requests in the same way as a cellular system.

Figure 4.3 – EMMA node overview schema.

62

Chapter 4. Active Resource Middleware

4.3 System Dynamic
Node services are provided to EMMA middleware through their resource publishing. By default, there are three types of resource: system, local and agent, which are presented in Section 4.3.1. The system dynamic is achieved by the agents, which generate COAP requests according to the current resource state of their hosting node. As requests change the internal resource state of the target node, a distributed computation ﬂow over the WSAN is executed when an agent triggers other agents, as detailed in Section 4.3.2. Lastly, Section 4.3.3 presents an EMMA graphical model of an Service Choreography (SC) based on a Petri network.

4.3.1 Basic Services
The following services are implemented in the same way as any service and can be removed from EMMA middleware on the Contiki OS compilation to build simple Web services. However,they are necessary for service choreography over the Wireless Sensor and Actor Network (WSAN).

4.3.1.1 Local Service
The local service provides simple numerical data resources to store values. Agents require them during computation ﬂows to store cache values, parameters or data exchanged between each Service Choreography (SC).

4.3.1.2 System Service
The system resources detailed in Table 4.2 encapsulate data or conﬁguration parameters for the Contiki OS or EMMA middleware. They are used by agents to change system conﬁgurations or access sensor and actuator drivers.

Resource URI /S/conf /S/time /S/rand /S/energy /S/ns-uri /S/routing /S/neighbor /S/resources

Methods GET/PUT
GET GET GET GET GET/PUT/POST/DEL GET POST/DELETE

Description EMMA & Network conﬁguration Node uptime Random number Energy battery level URI to RDF node description Routing tables List of neighbor nodes List of all resources

Table 4.2 – List of system resources on EMMA node.

4.3. System Dynamic

63

4.3.1.3 Agent Service

An agent is a conﬁguration ﬁle for the augmented publish-subscribe mechanism, which speciﬁes ’what, when and where’ to send a COAP request. An EMMA agent a is a JavaScript Object Notation (JSON) ﬁle stored on node n that contains a set of resources denoted Xn. It is composed of three elements:
• A Boolean activation function P REa(Xn) Example: /L/threshold < /S/brightness

• A list of denoted resource targets Ya Example: PUT[IPv6]:port/S/light

• The associated payloads ∀y ∈ Ya, P OSTay(Xn, y) Example: {’value’:’/S/light + +’};

When Boolean activation function P REa(Xn) is true, it sends COAP requests to target resource y ∈ Ya according to P OSTay(Xn, y), as summarized in Eq. (4.1).

If

P REa(Xn)

:

∀y

∈

Ya,

y

←−
method

P

OS

Tay (Xn ,

y)

(4.1)

As illustrated in following agent examples, the P RE ﬁeld speciﬁes the ﬁring

condition in order to send a request to each resource target stored in the T ARGET

ﬁeld. A target is deﬁned by a COAP method (GET/PUT/POST/DELETE) and

a URI ([IPv6 ]:port/resource). The payload stored in the P OST ﬁeld for each

resource target is a template ﬁle, which is processed to replace variables with

their resource value. If the payload contains mathematical operations, they are

performed before transmitting the request. This payload can contain unresolved

variables, which are replaced by the resource values of the target node.

4.3.1.3.1 Publish-Subscribe Agent The JSON Agent 4.1 is hosted on a brightness sensor and sends orders to a light to increase its value before transmitting the measured brightness to a database every 10 seconds if it is lower than 50.

1{

2

"NAME": "AgentSensor",

3 "PRE": "L#brightness<50 && S#time%10 == 0",

4

"POST": [

5

"{’value’:’R#light+1’}",

6

"L#brightness"

7

],

8

"TARGET": [

9

"PUT[aaaa::2]:5683/L/light",

10

"PUT[aaaa::1]:5683/database/light"

11

]

12 }

JSON Agent 4.1 – Example of a periodic publish-subscribe agent.

64

Chapter 4. Active Resource Middleware

4.3.1.3.2 Composed Agent JSON Agent 4.2 locally contains and deploys other agents before deleting itself, following which the deployed agent transmits the list of resources to a supervisor.

1{
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
17 }

"NAME": "RelayAgent", "PRE": "A#RelayAgent", "POST": [
{ "PRE": "S#rand%5==0", "POST":[ "{’resources’:S#resources}" ], "TARGET": [ "PUT[aaaa::3]:5683/L/Example" ]
},"" ], "TARGET": ["POST[aaaa::2]:5683/A/TargetAgent",
"DELETE[0::1]:5683/A/RelayAgent"]

JSON Agent 4.2 – Example of a relay agent.

4.3.1.3.3 Self-X Agent The JSON agent 4.3 contains a reference to itself in the PRE condition, the POST ﬁeld and the TARGET tables. It is a self-deployer agent, which sends itself to all its neighbors when it arrives on a node. It then locally deploys an agent to push the list of resources before deleting itself.

1{
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
17 }

"NAME": "DiscoverDeployer", "PRE": "A#DiscoverDeployer", "POST": [
"A#DiscoverDeployer", {
"PRE": "S#rand%5==0", "POST":["{’resources’:S#resources}"], "TARGET": ["PUT[aaaa::1]:5683/NetworkInfo"] },"" ], "TARGET": [
"POST[ff02::2]:5683/A/DiscoverDeployer", "POST[0::1]:5683/A/DiscoverNotifier", "DELETE[0::1]:5683/A/DiscoverDeployer" ]

JSON Agent 4.3 – Example of a self-deployer agent.

4.3. System Dynamic

65

4.3.2 Computation Flows
A computation ﬂow is a set of agent activations produced by a domino eﬀect. This occurs when agent activations depend on the target resources of the other ones. An illustration of this interaction chain is illustrated in Figure 4.4. Requests are emitted by service agents (blue resources) to change another remote or local resource, which can trigger another agent etc. There is no diﬀerence for the Active Resource Middleware (ARM) between local and remote resources due to the middleware abstraction layer between the Service Choreography (SC) and the nodes. A tuple space for agents is provided through the set of all available resources. The agents are executed independently over the Wireless Sensor and Actor Network (WSAN), although they are synchronized by events on their sensitive resources. This event chain moves on the event-driven kernel of the Contiki OS. Therefore, concurrent access to a resource cannot appear inside nodes, while parallel execution can only be used over several nodes. New events are stored in an event pool and processed when the current computation ﬂow of the node is terminated. This execution constraint allows computation ﬂows to be managed by the structural design of the Service Choreography (SC), such as in the case of mutex, semaphore, switching, parallel execution, and synchronization for load balancing, memory management and task scheduling.

Figure 4.4 – Illustration of a computation ﬂows by an event chain of requests.

66

Chapter 4. Active Resource Middleware

4.3.3 Graphical Model
The EMMA graphical model uses a continuous [SR02] and numerical [JL93] Petri network [GS07] to design and analyze the logical behavior of the Service Choreography (SC). It models resource entities and system dynamics through agent activation conditions and requests.
In EMMA, the SC is modeled by an augmented Petri network in which requests are referred by tokens, agents by transitions and resources by places. A transition is ﬁred if the following two conditions are satisﬁed: (1) a token appears in any input place and (2) the agent’s Boolean condition is returned as true. This transition activation produces a token for each output place and changes target resource values in the corresponding preprocessed payload. Agents are also resources then, with each transition associated with a place. If this kind of place is deleted, the associated transition is destroyed, whether for creation or editing. Therefore, this Petri network model is dynamic and can change during its execution. This model illustrated in Figure 4.5 allows SC to be simulated independently of its execution supports. Its behavior is validated by classical algorithms found in the literature on Petri networks concerning safety, liveness, reversibility, determinism, termination, output correctness and input dependence [BWWH91]. Moreover, classical patterns can be reused directly, such as in cases of sequence, parallel splits, synchronization, exclusive choices, simple merges, multi-choices, structured synchronizing merges, multi-merges, arbitrary cycles and multiple instances [Rus+06].
This Service Choreography (SC) computes the diﬀerential value p1(t) = p0(t − 1) − p0(t). Agent t0 computes the diﬀerential value between a new value of p0 and its previous one stored in p2 by the agent t1. If p1 reaches the value 50, the agent t2 is ﬁred and uninstalls the SC including itself.

Figure 4.5 – Example of an EMMA graphical model created by a Petri network.
This Petri network adaptation, used in emma-design-tools, allows application behavior to be simulated. According to a set of input resource values, the ﬁnal state of the Petri network is stored in a SC proﬁle.

4.4. Service Choreography

67

4.4 Service Choreography

4.4.1 Hierarchical Composition
A Responsive Environments (RE) is composed of several appliances that require a diﬀerent SC in order to manage them. Moreover, each SC can require information to be exchanged with other ones; for example, an SC for a control loop of actuators should communicate with the SC responsible for energy management. Hence, the design of a general SC is not suitable, given that its general Petri network ought to be very complicated and, therefore, unmanageable.
The hierarchical composition of a Petri network is used in order to design and validate each diﬀerent SC separately. Each Petri network for an SC has a set of input and output places in order to abstract the diﬀerent subplaces and transitions into a general transition, as illustrated in Figure 4.6. The diﬀerent SC are then connected together through their input and output places, as investigated in Kaaniche et al. [Kaa+12]. The general SC behavior is evaluated by analyzing those of the diﬀerent sub-SC. A behavior is deﬁned as a set of output place states according to a set of possible input stimuli. Hence, at the resource level (detail view 0), the Petri networks are evaluated by classical algorithms found in the literature, in order to build the transition function between input and output places. Then they are abstracted due to a general transition. This approach signiﬁcantly simpliﬁes the design and validation of an SC, in the same way as its sub-SCs are considered as black boxes, which can be reused with an already validated behavior. Hence, the validation process of SC behavior is resumed by correspondence analysis between the behavior transitions of its sub-SCs.

Figure 4.6 – Illustration of Service Choreography (SC) composition.

68

Chapter 4. Active Resource Middleware

4.4.2 Web Service Heterogeneity

Internet of Things (IoT) devices are provided by several diﬀerent manufacturers with their own information systems. The network protocol has been standardized, but the application layer has not, given that future usages are unpredictable. Hence, the management of application heterogeneity at the choreography level is required. Traditionally, this issue is managed by a proxy server, which translates the requests. In this sense, the COAP has an internal static publish-subscribe mechanism, which allows the proxy to collect data from all nodes in order to ensure translations.
The EMMA middleware allows this translation to be operated directly by the agents. As their requests are fully speciﬁed through the P OST and T ARGET ﬁelds, they can natively send any kind of payload using any URI. For example, if remote middleware uses the Extensible Markup Language (XML) formatting language, the P OST ﬁeld of the agent should contain the required XML template. Moreover, the agent can generate requests to subscribe to the COAP observer mechanism in order to collect the data from other middleware. The combination of these two types of agent allows an EMMA node to ascribe data to other middleware in order to generate COAP requests for others, as illustrated in the sequence diagram 4.4.

COAP Node 1

EMMA Node

COAP Node 2

|

|

|

|

| GET /temperature

|

| (registration)

| Observe: 0

|

|

|

Token: 0x4a

|

|

+------------------------> |

|

| 2.05 Content

|

| (notifications)

| Observe: 12

|

|

|

Token: 0x4a

|

|

| Payload: 22.9 C

|

|

| <------------------------+

|

|

|

|

+--+ /A/Transcoder

|

|

(translation)

| | PUT /L/t

|

|

| <+ Payload:?value=L#t |

|

|

|

|

+--+

/A/Sender

|

|

(transmission)

| | PUT /heater

|

|

| | Payload:?value=22.9 C |

| <-------------------------+ <+

|

Sequence Diagram 4.4 – Sequence diagram of an SC for heterogeneity management.

4.4. Service Choreography

69

4.4.3 Name Space Security
Data privacy and system security are important challenges in the IoT. The decentralized aspects and the possibility for diﬀerent service providers to deploy SCs requires a new approach towards protecting the system. In the EMMA framework, the SCs have individualized protection through diﬀerent security partitions in the namespace. An Name Space (NS) is a set of resources that shares a same security partition. Access is protected by an AES 128 bits security key NSKey, which is used to encrypt communications between the resources. Each secured agent adds an additional ﬁeld NS to the request in order to indicate the NSKey ID used for payload encryption. The target resource then uses its corresponding NSKey located at the URI /L/X/aes-keys to decode the payload. As a resource can be shared between several SCs in cases of composition, they have several NSKeys. The deployment process consists of the creation of the resources in which are included the diﬀerent required NSKeys. This process is operated by the supervisor in relation to the diﬀerent nodes by secure communications. Each node is accessible thanks to a RootKey, which is deployed manually by the supervisor (by Radio Frequency IDentiﬁcation (RFID) or by writing it into the permanent memory during the compilation of node software). The RootKey is used by the supervisor to encrypt the payload used for the deployment of SC resources with their NSKeys. Figure 4.7 summarizes this chapter with three nodes, which have diﬀerent resources that are accessible according to their secured namespace containing an SC implemented by hierarchical composition of three other ones that are modeled by Petri networks.

Figure 4.7 – Overview of the EMMA secured architecture.

70

Chapter 4. Active Resource Middleware

4.5 Summary

This section has presented the Active Resource Middleware (ARM), which is the engine core of an EMMA system. It is an abstraction layer between the appliances with the network and a resource tuple space. These resources are provided by local node services and connected in order to form an Service Choreography (SC). The particular agent resources are used to model and deploy the communication rules by distributed publish-subscribe mechanisms. In addition, this proposed model oﬀers the possibility of adding self-x properties to an SC, such as self-deployment. The SC design is totally abstracted to a Wireless Sensor and Actor Network (WSAN) by an augmented Petri network, which is used to analyze SC behavior before being deployed on appliances. The management of heterogeneity with other COAP middleware is natively addressed due to the proposed agent model in a fully distributed way. In addition, the protection of data privacy is based on a proposal of secured namespaces in order to partition the SC, which could be designed by diﬀerent service providers.
The diﬀerent classical challenges for WSANs are summarized in Table 4.3 with their referring components in relation to an EMMA framework. Those challenges concerning the network are not addressed, such as the EMMA framework, which focuses on the application layer. However, the quality of service should be possibly considered through a priority routing engine in the Contiki OS event stack. An additional ﬁeld should be added to the agents in order to deﬁne the priority of the computation ﬂows. Hence, the appliances should be able for them to be scheduled according to their priority.

Layer Hardware Network
Application Data

Challenges Abstraction Energy Eﬃciency Hardware Constraints Addressability Routing Protocol Dynamic Topology Quality of Service
Adaptability Programming
Knowledge Scalability Security Heterogeneity

Entities Contiki OS Mapping Deployment Lightweight Services 6LoWPAN
RPL None None
Resource tuple Space Petri Network Model Petri Network Patterns Choreography Composition
Name Space Agent

Table 4.3 – WSAN challenges addressed by active resource middleware

Chapter 5
Service Choreography Deployment1
Le tout est autre chose que la somme de ces parties.
The whole is diﬀerent than the sum of its parts.
Kurt Koﬀka [Kof77]
Contents
5.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . 72 5.2 Network Mapping Process . . . . . . . . . . . . . . . . . . 73
5.2.1 Stages Overview . . . . . . . . . . . . . . . . . . . . . . . 74 5.2.1.1 Functional Design . . . . . . . . . . . . . . . . . 74 5.2.1.2 Instantiation and Simulation . . . . . . . . . . . 74 5.2.1.3 Network Mapping . . . . . . . . . . . . . . . . . 75
5.2.2 Dynamic Deployment . . . . . . . . . . . . . . . . . . . . 76 5.2.2.1 Residual Network Agents . . . . . . . . . . . . . 76 5.2.2.2 Dynamic Network Agents . . . . . . . . . . . . . 76 5.2.2.3 Self-X Agents . . . . . . . . . . . . . . . . . . . . 76
5.2.3 Deployment Process . . . . . . . . . . . . . . . . . . . . . 77 5.2.3.1 Direct Deployment . . . . . . . . . . . . . . . . . 77 5.2.3.2 Deployment Container . . . . . . . . . . . . . . . 77 5.2.3.3 Self-Deployment Container . . . . . . . . . . . . 78
5.3 Theoretical Background . . . . . . . . . . . . . . . . . . . 79 5.3.1 Model Deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . 79 5.3.1.1 Network . . . . . . . . . . . . . . . . . . . . . . . 79 5.3.1.2 Resources . . . . . . . . . . . . . . . . . . . . . . 79 5.3.1.3 Scopes . . . . . . . . . . . . . . . . . . . . . . . 79 5.3.1.4 Places . . . . . . . . . . . . . . . . . . . . . . . . 80
1Submission in Clement Duhart, Pierre Sauvage, and Cyrille Bertelle. “A Resource Oriented Framework for Service Choreography over Wireless Sensor and Actor Networks”. In: Submission in International Journal of Wireless Information Networks (IJWI) ()

72

Chapter 5. Service Choreography Deployment

5.3.2 Problem Formulation . . . . . . . . . . . . . . . . . . . . 80 5.3.2.1 Knapsack Problems . . . . . . . . . . . . . . . . 80 5.3.2.2 Service Choreography Mapping . . . . . . . . . . 80
5.3.3 Pseudo-Boolean Optimization . . . . . . . . . . . . . . . . 81 5.3.3.1 Communication Cost Function . . . . . . . . . . 82 5.3.3.2 Constraint Set . . . . . . . . . . . . . . . . . . . 82
5.4 Experimental Results . . . . . . . . . . . . . . . . . . . . . 83 5.4.1 Dining Philosopher Mapping . . . . . . . . . . . . . . . . 83 5.4.2 Deployment Evaluation . . . . . . . . . . . . . . . . . . . 86 5.4.3 Deployment Strategy . . . . . . . . . . . . . . . . . . . . . 89
5.5 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90

5.1 Introduction
The previous chapter presented models, mechanisms and features of an Active Resource Middleware (ARM) to build a Service Choreography (SC). From the design to operational deployment, the diﬀerent steps are outlined in Section 5.2. Given that Wireless Sensor and Actor Networks (WSANs) have several life cycles, a deployment process should be adapted. At the ﬁrst time of starting, all node and network resources are available for the deployment process, which is no more possible during the running of services. Consequently, three deployment processes are considered according to their properties. Direct deployment between supervisor and nodes is only used for punctual mapping corrections. Meanwhile, composed deployment facilitates a SC upgrade by delegation to the remote nodes. Finally, at the initialization step, all WSANs can be used by self-deployment to map everything, everywhere.
The genericity of the EMMA resource model allows for SC mapping to be automatic. According to the node services and their resource hosting capacity, SCs are distributed over entire WSANs to minimize network communication load. Several constraints are considered in the course of the mapping process regarding node, network and application speciﬁcations. Its mathematical formulation is successfully resumed by the pseudo-Boolean optimization (PBO) problem in Section 5.3, which allows any PBO solver to be used. Finally, Section 5.4 presents results about the complexity of the mapping problem according to number of resources and WSAN sizes. Analysis shows that, in a large-scale network, it is preferable to use several deployment partitions instead of one big mapping process. Evaluation of deployment agents shows their execution time on an ARM for comparing them and proposing an example of best practice for SC deployment.

5.2. Network Mapping Process

73

5.2 Network Mapping Process

The Service Choreography (SC) mapping process associates an empty resource space for each place of the SC. Such an association is performed according to the resource type and the hosting capacity of nodes for each service. The eﬃciency of a mapping process is deﬁned by a cost function in Section 5.3, which minimizes, by default, the network communication load. This mapping process is composed of three speciﬁcation stages: the functional design, the instantiated graph and the network mapping, as illustrated in Figure 5.1 and discussed in the following sections.

Figure 5.1 – Network mapping process for a multi-layer perceptron.

74

Chapter 5. Service Choreography Deployment

5.2.1 Stages Overview
5.2.1.1 Functional Design
The functional design establishes SC templates, which could be deployed over diﬀerent Wireless Sensor and Actor Networks (WSANs). They are abstracted from the WSAN and node services as a result of the previously discussed Petri network. A Petri network in a SC connects a set of input places to output places in order to deﬁne their general transition functions. The input and output places are characterized in order to deﬁne compatible resources of node services, which could be used for this SC.
The diﬀerent input-output resources produced by the node services are connected through agent resources A (modeled by transitions) in addition to temporary resources L (corresponding to places). This speciﬁcation stage introduces the concept of scope, which manages structural dependencies, as illustrated at the top of Figure 5.1. The term scope alludes to the mapping speciﬁcation, which refers to a group of resources that must be mapped on the same node. For implementation reasons, a transition resource a must be on the same node n, which the resources of its input places Xn required due to its activation function P REa(Xn) in the Petri network. Otherwise, for eﬃciency reasons, such high frequency communication exchanges, a SC designer would seek to force several resources to be located on the same node. The mapping can be constrained by scopes because of the following:
• Scope multiplicity: A scope that requires several identical scopes is connected by a link of multiplicity M . For example, an agent of data aggregation requires M values produced by the sensor resources. Hence, the scope containing the agent is linked to the scope, which models the sensor resources by a multiplicity parameter equal to M .
• Scope dependency: The SC design is operated independently of the target network. However, it is possible to constrain the resource mapping in respect of network constraints, such as the maximal number of communication hops between two scopes.

5.2.1.2 Instantiation and Simulation
The instantiation step generates the complete graph of a Service Choreography (SC) based on the set of functional design templates for a target of WSANs. Based on the network information collected by the service discovery mechanism (see 4.2), all SC templates are duplicated for each couple of input-output scopes in order to satisfy their multiplicities. All ﬁnal resources are deﬁned and linked to their value range speciﬁcations. If a resource in a SC template has a diﬀerent value range to those in a WSAN, an intermediate agent is automatically placed to adapt value

5.2. Network Mapping Process

75

range. During this step, the SC designer will have to check and correct possible mistakes produced by this automatic process performed by emma-tools-design.
The simulation of the generated SC must validate its behavior. As previously discussed, the simulation of this ﬁnal SC for each possible initial marking on input places produces a large set of tests. The use of composed general compositions, which have already been simulated, drastically reduces the number of transitions. All places and transitions contained in a uncorrected template is resumed by their composed transition. Based on their value ranges on output places, the input ranges of the next connected transition are reduced. Hence, all composed transitions, which are connected without an intermediate transition being manually added, can be reduced to a single one with a ﬁxed value range of its input and output places. Even if the set of possible initial markings on input places is large, the simulation is resumed to simulate the manually added transition with the composed transitions.
Given that the deployment process is also a Service Choreography (SC), as presented in the previous chapter, it should be validated in the same way. The deployment process requires some resources, which have to be reserved during the mapping process. Therefore, the SC of deployment is added into the instantiated Petri network, although it uses some temporary resources.

5.2.1.3 Network Mapping
Network mapping determines the list of possible matchings between the instantiated SC graph and the resource distribution on the ARM under the functional design constraints. In addition, this process builds the composed agents, which install the resources along a speciﬁed path of deployment (by default, it follows the network routing path from the supervisor: the 6LoWPAN edge router). The mathematical formulation of this mapping problem is resumed by a PBO problem detailed in Section 5.3.
The process of deployment is based on a set of composed agents (see 4.2 deﬁned in Section 4.3.1.3). They are deployed on a node in order to install the resources on the hosting node or on the neighbors. In addition, they send other agents of deployment to other nodes, such as Matroska containers. Given that an agent is also a resource, the number of resources that it can install is limited by its maximum size. Hence, several composed agents of deployment are generated according to the hosting capacity of nodes. The mapping of the deployment process determines the distribution of the deployment agents over the WSAN and their composition. This process is performed by backpropagation along the deﬁned deployment path in order to include the deployment agents with the others until they reach their maximum size. This process is reiterated until the coverage for all of the resources to deploy is reached, after which each deployment agent is sent to its corresponding node.

76

Chapter 5. Service Choreography Deployment

5.2.2 Dynamic Deployment
Dynamic deployment is composed of two stages. Firstly, deployment agents are diﬀused over an Active Resource Middleware (ARM) to deploy locally resources. Then, deployment agents are deleted to allow only service resources. The deployment agents, called Dynamic Network Agents (DNAs), change the dynamic of WSAN behavior, which is produced by a set of SC agents called Residual Network Agents (RNAs). Both these categories are deﬁned to facilitate the organization, management and understanding of the mapping dynamic.
5.2.2.1 Residual Network Agents
Residual Network Agents (RNAs) are the set of agents deployed by a Dynamic Network Agent (DNA). They can be considered, from the node perspective, as a set of interaction rules that deﬁne its behavior; from a system perspective, they can be considered as part of a Service Choreography (SC). The RNA produces the static system dynamic by diﬀusing computation ﬂows over the ARM when an event occurs on input places. These agents do not modify the system dynamic by modifying other agents.
5.2.2.2 Dynamic Network Agents
Dynamic Network Agents (DNAs) are responsible for updating the system dynamic by modifying other agents. They are used during the installation procedures of a Service Choreography (SC), as well as by a SC with self-x properties. During a deployment, they are composed agents that contain a set of rules to install the resources (including other agents) on the nodes. They then delete themselves when the deployment process is terminated.
5.2.2.3 Self-X Agents
After the deployment process, the DNAs are normally deleted as they have deployed all the resources. The agent model, however, oﬀers the possibility of allowing them in standby. Instead of starting the deployment under the condition that the agent has arrived on a new node, the ﬁeld P REa(Xn) can be deﬁned in order to match it with a particular resource context of the node. The agent then deploys the resources when they are required. Hence, an agent can contain diﬀerent SCs, which are deployed according to the online node requirements.
The ﬁrst use example of this approach involves the establishment of the selfrepair property. If a node resource is accidentally deleted, a sensitive DNA in its presence could deploy it again. Another example involves the self-deployment of a common SC, such as a network and service discovery mechanism. A DNA can contain a set of SCs, which must be deployed on all nodes. Hence, it broadcasts itself to all nodes in order to install the required resources for a common SC on them. The new connected node then automatically receives a basic SC.

5.2. Network Mapping Process

77

5.2.3 Deployment Process
The deployment process deploys a diﬀerent SC from the supervisor to the nodes. In the literature, diﬀerent middleware perform this operation in a peer-to-peer dynamic between the supervisor and the nodes. However, in a large-scale WSAN, the deployment process produces signiﬁcant network congestion around the routers, such as that evaluated in Chapter 3. The EMMA framework proposes two other strategies through the use of Dynamic Network Agents (DNAs): the deployment container and self-deployment in addition to direct deployment.

5.2.3.1 Direct Deployment
Direct deployment sends agents directly to each node from the supervisor. In a large-scale WSAN, this approach is not suitable when the supervisor is far away. However, as presented in Chapter 3, the supervisor can be localized on a mobile device. Hence, this communication path can be reduced by physically moving the supervisor on the region of interest. A technician can then apply local corrections with their tablet.

5.2.3.2 Deployment Container
A deployment container uses agents to carry other agents. These DNAs, which are illustrated in Figure 5.2, are sent to nodes and deploy locally required resources. Other DNAs can be contained within them and sent to other locally accessible nodes. This composition of a deployment container produces a deployment chain, such as in the case of Matroska containers. However, the overhead of this kind of DNA is very important, as evaluated in Section 5.4.

Figure 5.2 – Petri network of a DNA deployment container.

78

Chapter 5. Service Choreography Deployment

5.2.3.3 Self-Deployment Container
A self-deployment container is a deployment container that refers to itself in P RE, P OST and/or T ARGET ﬁelds; see Agent 4.3. Being sensitive to itself in the P RE ﬁeld, it duplicates itself on other nodes on arrival. With the possibility to refer to itself in the P OST ﬁeld, it can update its deﬁnition during its copy process, which oﬀers evolving possibilities. If this DNA deletes itself after copying itself in the T ARGET ﬁeld, however, it is a mobile agent.
At ﬁrst deployment, all nodes have to receive their resources, while WSANs are not used by any service. Therefore, the use of a ﬂooding technique to reach all nodes is possible. This DNA embeds all Service Choreographys (SCs) for deployment on the WSANs. When it arrives on a node, it sends itself to all the neighbors before deploying local resources. This initializer agent is built to be sensitive according to the /s/ns-uri resource, which speciﬁes the node type in order to only deploy the required resources for this node.
Moreover, this DNA can contain other DNAs, which can be used to deploy self-repair agents or other deployment containers responsible for a particular SC deployment. For example, the Agent 4.3, deﬁned in Section 4.3.1.3, is a selfdeployment container, as illustrated in Figure 5.3, that is automatically deployed on new neighbor nodes in order to install a set of Residual Network Agents (RNAs) with one local resource.

Figure 5.3 – Petri network of a DNA self-deployment container agent.
There are a lot of possible deployment strategies with such DNAs. Some of them can be used for initial deployment, others to install local SCs and, ﬁnally, others to deploy automatically minimal SCs, such as a discovery service and a system logger. Best practice is proposed at the end of this chapter.

5.3. Theoretical Background

79

5.3 Theoretical Background
The application mapping problem determines an eﬃcient distribution of resources on the nodes to minimize communication load. Based on the functional constraints, the network topology and the hosting capacities of nodes, the instantiated graph must be mapped over the WSAN with its deployment process.

5.3.1 Model Deﬁnitions
5.3.1.1 Network
A WSAN is composed of a set of nodes N = {n1, n2, ...} modeled by a distance matrix D, in which d(n1, n2) represents the cost metric between n1 and n2. By default, the cost metric is determined by the routing algorithm according to the number of hops between two nodes. It can model any others parameters, such as the bandwidth, the link quality or an aggregation of them. If, and only if, the communications are bidirectional, ∀n1, n2 ∈ N : d(n1, n2) = d(n2, n1). Due to node memory limitations, the routing tables of nodes are partial and a node n1 can be unreachable from n2, then d(n2, n1) = −1.
5.3.1.2 Resources
The resource r is an allocated space of memory on a node associated with a unique access path U RI(r), deﬁned by /type/resource_name. Each resource has a type j ∈ T corresponding to its service (T = {A, S, L, ...}; see Section 4.2.3). ∀n ∈ N , ∀j ∈ T , Rnj deﬁnes the set of resources of type j on node n. Rn then denotes the set of all resources on node n, Rn = Rnj .
j∈T
Deﬁnition 5.1. cardj(n) refers to the maximum number of resources of type j on node n, which is deﬁned during the software compilation. Therefore, it is considered ﬁxed for the mapping process.

5.3.1.3 Scopes
The scope s is a set of places Ps that must be mapped on the resource spaces of the same node. Ms refers to the multiplicity of scope s (see Section 5.2.1.1). The set of scopes S = {S1, ..., Sm} represents all the SCs to be deployed on the WSAN. Several scopes can be mapped onto the same node, as long as the node capacities are suﬃcient. Two scopes are considered linked if at least one place of the ﬁrst scope interacts with one of the second. A communication a is modeled by a data exchange function fa(t) and a weight wa, which represents the number of packets required to transmit payload. As the function fa(t) cannot be assessed a priori, we will instead consider an estimated frequency of fa.

80

Chapter 5. Service Choreography Deployment

The set of all communications from scope s1 to scope s2 is denoted by As1,s2, as per the sum of all place communication costs deﬁned in Eq. (5.1) between scopes

s1 and s2. Communications between two scopes are generally asymmetric; hence, c(s1, s2) = c(s2, s1).

c(s1, s2) = ca = fa × wa

(5.1)

5.3.1.4 Places

a∈As1,s2 a∈As1,s2

The place p ∈ Ps is a requirement deﬁned by an access path of U RI(p), such as

/type/place_name for the mapping of scope s on a node. There are two subsets,

such as Ps =

Psj P˙sj .

j∈T

• ∀j ∈ T , Psj deﬁnes the set of places that requires an available resource space of type j on the node. Example: The place p ∈ PsL requires an empty
resource space of type L on the node.

• ∀j ∈ T , P˙sj deﬁnes the set of places which requires a resource of type j on the node. Example: The place p˙ ∈ P˙sL, speciﬁed with the U RI(p) = /L/temp, requires a resource with the same U RI on the node.

5.3.2 Problem Formulation
5.3.2.1 Knapsack Problems
The formulation of a SC mapping problem is composed of two variants of the knapsack problem:
• Multiple Knapsack Problem (MKP): Each node is considered to be like a knapsack in which places should be mapped according to the node capacity.
• Multiple Choice Knapsack Problem (MCKP): The nodes have a ﬁnite partition for each resource type. The number of elements by type is limited on each node because of node’s hosting capacity.
Finally, the problem formulation can be summarized thus:
How can scopes, which require diﬀerent numbers and types of places over a set of nodes and which do not have the same hosting capacities in terms of resource
type and memory size, be mapped in order to minimize the network load?

5.3.2.2 Service Choreography Mapping
Deﬁnition 5.2. The operator size() is deﬁned as follows:
• size(r) refers to the memory space used by the resource r. • size(R), R ∈ {Rn, Rnj } refers to the memory space used by resources in R. • size(Psj) refers to the memory space used by all places in Psj.

5.3. Theoretical Background

81

• size(n) refers to the total memory space of the node n.

Deﬁnition 5.3. ∀s ∈ S, Ns ⊆ N denotes the set of nodes on which the scope s is mappable. A scope s is mappable on a node n ∈ N if, and only if, the following applies:

• Constraint (5.2) deﬁnes that the node n has a free resource for each place

p ∈ Psj in scope s of type j.

∀j ∈ T , |Psj| + |Rnj | ≤ cardj(n)

(5.2)

• Constraint (5.3) deﬁnes that the node n has a resource of type j for each

p˙ ∈ P˙sj.

∀p˙ ∈ P˙sj, ∃r ∈ Rnj / U RI(p˙) = U RI(r)

(5.3)

• Constraint (5.4) deﬁnes that the node n has enough hardware memory to

contain the places of scope s.

size(Psj) ≤ size(n) − size(Rn)
j∈T

(5.4)

Deﬁnition 5.4. A Service Choreography (SC), deﬁned by its set S of scopes, is not mappable if one of its scopes is not mappable, due to its multiplicity:

∃s ∈ S, |Ns| < Ms

(5.5)

Deﬁnition 5.5. The set of scopes that can be mapped on the node n is denoted ∀n ∈ N, Sn ⊆ S.

5.3.3 Pseudo-Boolean Optimization

The PBO minimizes a pseudo-Boolean function under a set of pseudo-Boolean constraints expressed by equations or inequations. The best SC mapping associates the places of the scopes with the available resource spaces on the nodes in order to minimize network load over the WSAN.

Deﬁnition 5.6. The mapping of the scope s ∈ S onto its possible hosting nodes in n ∈ Ns is denoted by the Boolean vector xns . The set X then determines the mappings of all scopes among their possible hosting nodes.
∀s ∈ S, ∀n ∈ Ns : X = {x00, x10..., x01, x11, ..., xns }
In turn, Eq. (5.6) resumes the total number of Boolean literals for the PBO, such as the number of possible mapping permutations on the nodes.

|X| = |Ns|
s∈S

(5.6)

82

Chapter 5. Service Choreography Deployment

5.3.3.1 Communication Cost Function
The cost function z(X) evaluates the impact of the mappings X on the network communication load. The pseudo-Boolean optimization (PBO) solver determines the best combinations of scopes and nodes among the set X of permutations in order to minimize the communication costs between the linked scopes. The communication cost of SC mapping is deﬁned, for example, as the sum of its scope link costs c(s1, s2), deﬁned in Eq. (5.1), multiplied by the network distance d(n, n ) between their respecting hosting nodes. Then the pseudo-Boolean function of general WSAN communication costs, which must be minimized, is deﬁned in Eq. (5.7).

z(X) =

c(s1, s2)d(n, n )xns1xns2

s1∈S n∈Ns1 s2∈S n ∈Ns2

(5.7)

5.3.3.2 Constraint Set
The minimization of the function z(X) is constrained by the following set of (in)equations to deﬁne available mappings of the SC.

• Constraint (5.8) deﬁnes that each scope must be mapped several times according to its multiplicity parameter Ms.

∀s ∈ S :

xns = Ms

n∈Ns

(5.8)

• Constraint (5.9) forces the mapping of linked scopes to have a network route between their hosting nodes. If there are communications between s1 and s2 (c (s1, s2) > 0), they can be mapped respectively on n and n if, and only if, d(n, n ) ≥ 0.

∀(s1, s2) ∈ S2, ∀n ∈ Ns1, ∀n ∈ Ns2:

c(s1, s2)d(n, n )xns1xns2 ≥ 0 (5.9)

• Constraint (5.10) deﬁnes that the total available resource space required by all scopes mapped on a node n does not exceed its capacity.

∀n ∈ N, ∀j ∈ T : |Psj|xns ≤ cardj(n) − |Rnj |
s∈Sn

(5.10)

• Constraint (5.11) limits the total memory usage by the mapped resources on a node to its available hardware memory.

∀n ∈ N :

size(Psj)xns ≤ size(n) − size(Rn)

s∈Sn j∈T

(5.11)

5.4. Experimental Results

83

5.4 Experimental Results
This experimental section presents results regarding mapping complexity and the execution time of deployment agents. Firstly, the number of constraints for the pseudo-Boolean optimization (PBO) problem is evaluated according to the size of the Service Choreography (SC) and the Wireless Sensor and Actor Network (WSAN). The second section evaluates the deployment agent execution for the service discovery mechanism over the Active Resource Middleware (ARM). Based on these results, deployment strategies are discussed in order to determine best practice concerning SC mapping and its deployment on an EMMA framework.

5.4.1 Dining Philosopher Mapping
The dining philosopher mapping process is a classical problem faced by distributed systems in terms of synchronization issues within concurrent resource access. In the case of a smart home under an energy contract with power delivery limitations, the diﬀerent appliances must not simultaneously consume electricity. Therefore, they must be scheduled. One distributed approach involves each appliance negotiating permission with the others to be turned on. For example, the electric car and the hot water tank alternate their scheduling.
Figure 5.4 presents the functional design, while Figure 5.5 presents its mapping on the EMMA framework of a Petri network involving dining philosophers, as detailed in [HV+87]. Each appliance is represented by a philosopher and then a scope. They must exchange energy tokens in order that an appliance can consume energy, provided it has the tokens of the other appliances, which should not be turned on simultaneously.
The purpose of this experimentation is the evaluation of the resolution time of the mapping process according to the number of scopes and nodes. Figure 5.6 illustrates the number of generated constraints, which depend on the literals xns ∈ X. They increase linearly and, in the main, according to the number of nodes, whereas the number of scopes has a lower impact. Figure 5.7 shows that the resolution time increases drastically according to the number of nodes, which is an expected result, such that the Knapsack problem is NP-complete.
Hence, the mapping process can be performed simultaneously for a lot of Service Choreographys (SCs), but only on a WSAN partition, which limits the number of nodes. This limitation is not particularly punitive because the deployment process is already partitioned by the composed agents.
Setup This experimentation has been realized with the PBO solver, based on an SAT4J framework on processor 4 cores at 2.2 GHz with multi-threading support and 8 GB of RAM memory. After several experimentations, available RAM memory for a Glucose solver seems to be the major factor on the resolution

