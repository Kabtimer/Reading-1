Python pour les économistes
Ewen Gallic Octobre 2018

2

Table des matières

Liste des tableaux

11

Table des ﬁgures

13

Propos liminaires

15

0.1 Objectifs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15

0.2 À qui s’adressent ces notes ? . . . . . . . . . . . . . . . . . . . . . . . . . . . 15

1 Introduction

17

1.1 Historique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17

1.2 Versions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17

1.3 Espace de travail . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19

1.3.1 Python dans un terminal . . . . . . . . . . . . . . . . . . . . . . . . . 19

1.3.2 IPython . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20

1.3.3 Spyder . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22

1.3.4 Jupyter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23

1.3.4.1 Évaluation d’une instruction . . . . . . . . . . . . . . . . . . 25

1.3.4.2 Cellules de texte . . . . . . . . . . . . . . . . . . . . . . . . 25

1.3.4.3 Suppression d’une cellule . . . . . . . . . . . . . . . . . . . . 27

1.4 Les variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27

1.4.1 Assignation et suppression . . . . . . . . . . . . . . . . . . . . . . . . 27

1.4.2 Conventions de nommage . . . . . . . . . . . . . . . . . . . . . . . . 29

1.5 Les commentaires . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30

1.6 Les modules et les packages . . . . . . . . . . . . . . . . . . . . . . . . . . . 30

1.7 L’aide . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32

2 Types de données

35

2.1 Chaînes de caractères . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35

2.1.1 Concaténation de chaînes . . . . . . . . . . . . . . . . . . . . . . . . 37

2.1.2 Indexation et extraction . . . . . . . . . . . . . . . . . . . . . . . . . 38

2.1.3 Méthodes disponibles avec les chaînes de caractères . . . . . . . . . . 40

2.1.3.1 Conversion en majuscules ou en minuscules . . . . . . . . . 41

2.1.3.2 Recherche de chaînes de caractères . . . . . . . . . . . . . . 41

2.1.3.3 Découpage en sous-chaînes . . . . . . . . . . . . . . . . . . . 42

2.1.3.4 Nettoyage, complétion . . . . . . . . . . . . . . . . . . . . . 43

3

4

TABLE DES MATIÈRES

2.1.3.5 Remplacements . . . . . . . . . . . . . . . . . . . . . . . . . 44 2.1.4 Conversion en chaînes de caractères . . . . . . . . . . . . . . . . . . . 44 2.1.5 Exercice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 2.2 Valeurs numériques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 2.2.1 Entiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 2.2.2 Nombre à virgule ﬂottante . . . . . . . . . . . . . . . . . . . . . . . . 46 2.2.3 Nombres complèxes . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47 2.2.4 Conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
2.2.4.1 Conversion en entier . . . . . . . . . . . . . . . . . . . . . . 49 2.2.4.2 Conversion en nombre à virgule ﬂottante . . . . . . . . . . . 49 2.2.4.3 Conversion en complèxe . . . . . . . . . . . . . . . . . . . . 50 2.3 Booléens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50 2.4 Objet vide . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51 2.5 Dates et temps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51 2.5.1 Module datetime . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52 2.5.1.1 Date . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52 2.5.1.2 Time . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57 2.5.1.3 Datetime . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58 2.5.1.4 Timedelta . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60 2.5.2 Module pytz . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62 2.5.3 Exercices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63

3 Structures

65

3.1 Listes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65

3.1.1 Extraction des éléments . . . . . . . . . . . . . . . . . . . . . . . . . 66

3.1.2 Modiﬁcation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67

3.1.2.1 Remplacement . . . . . . . . . . . . . . . . . . . . . . . . . 68

3.1.2.2 Ajout d’éléments . . . . . . . . . . . . . . . . . . . . . . . . 68

3.1.2.3 Suppression d’éléments . . . . . . . . . . . . . . . . . . . . . 68

3.1.2.4 Aﬀectations multiples . . . . . . . . . . . . . . . . . . . . . 69

3.1.3 Test d’appartenance . . . . . . . . . . . . . . . . . . . . . . . . . . . 69

3.1.4 Copie de liste . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70

3.1.5 Tri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71

3.2 N-uplets (Tuples) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71

3.2.1 Extraction des éléments . . . . . . . . . . . . . . . . . . . . . . . . . 72

3.2.2 Modiﬁcation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72

3.3 Ensembles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72

3.3.1 Modiﬁcations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74

3.3.1.1 Ajout . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74

3.3.1.2 Suppression . . . . . . . . . . . . . . . . . . . . . . . . . . . 74

3.3.2 Test d’appartenance . . . . . . . . . . . . . . . . . . . . . . . . . . . 75

3.3.3 Copie d’ensemble . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75

3.3.4 Conversion en liste . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75

3.4 Dictionnaires . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76

3.4.1 Extraction des éléments . . . . . . . . . . . . . . . . . . . . . . . . . 77

TABLE DES MATIÈRES

5

3.4.2 Clés et valeurs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78 3.4.3 Recherche d’appartenance . . . . . . . . . . . . . . . . . . . . . . . . 79 3.4.4 Modiﬁcation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
3.4.4.1 Remplacement . . . . . . . . . . . . . . . . . . . . . . . . . 80 3.4.4.2 Ajout d’éléments . . . . . . . . . . . . . . . . . . . . . . . . 80 3.4.4.3 Suppression d’éléments . . . . . . . . . . . . . . . . . . . . . 81 3.4.5 Copie de dictionnaire . . . . . . . . . . . . . . . . . . . . . . . . . . . 82 3.4.6 Exercice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82

4 Opérateurs

83

4.1 Opérateurs arithmétiques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83

4.1.1 Addition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83

4.1.2 Soustraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83

4.1.3 Multiplication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84

4.1.4 Division . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84

4.1.5 Modulo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84

4.1.6 Puissance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84

4.1.7 Ordre . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85

4.1.8 Opérateurs mathématiques sur des chaînes de caractères . . . . . . . 85

4.1.9 Opérateurs mathématiques sur des listes ou des n-uplets . . . . . . . 86

4.2 Opérateurs de comparaison . . . . . . . . . . . . . . . . . . . . . . . . . . . 86

4.2.1 Égalité, inégalité . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87

4.2.2 Infériorité et supériorité, stricts ou larges . . . . . . . . . . . . . . . . 88

4.2.3 Inclusion et exclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . 90

4.3 Opérateurs logiques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90

4.3.1 Et logique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90

4.3.2 Ou logique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91

4.3.3 Non logique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92

4.4 Quelques fonctions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93

4.5 Quelques constantes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94

4.6 Exercice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95

5 Chargement et sauvegarde de données

97

5.1 Charger des données . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98

5.1.1 Fichiers textes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98

5.1.1.1 Importation depuis internet . . . . . . . . . . . . . . . . . . 100

5.1.2 Fichiers CSV . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101

5.1.2.1 Importation depuis internet . . . . . . . . . . . . . . . . . . 102

5.1.3 Fichier JSON . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103

5.1.3.1 Importation depuis Internet . . . . . . . . . . . . . . . . . . 103

5.1.4 Fichiers Excel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104

5.2 Exporter des données . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104

5.2.1 Fichiers textes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104

5.2.2 Fichiers CSV . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106

5.2.3 Fichier JSON . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106

6

TABLE DES MATIÈRES

5.2.4 Exercice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108

6 Conditions

109

6.1 Les instructions conditionnelles if . . . . . . . . . . . . . . . . . . . . . . . . 109

6.2 Les instructions conditionnelles if-else . . . . . . . . . . . . . . . . . . . . 111

6.3 Les instructions conditionnelles if-elif . . . . . . . . . . . . . . . . . . . . 112

6.4 Exercice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113

7 Boucles

115

7.1 Boucles avec while() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115

7.2 Boucles avec for() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116

7.3 Exercice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119

8 Fonctions

121

8.1 Déﬁnition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121

8.1.1 Ajout d’une description . . . . . . . . . . . . . . . . . . . . . . . . . . 122

8.1.2 Paramètres d’une fonction . . . . . . . . . . . . . . . . . . . . . . . . 122

8.1.2.1 Appel sans noms de paramètres . . . . . . . . . . . . . . . . 123

8.1.2.2 Paramètres positionnels paramètres par mots-clés . . . . . . 123

8.1.2.3 Fonction comme paramètre . . . . . . . . . . . . . . . . . . 125

8.2 Portée . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125

8.3 Fonctions lambda . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128

8.4 Retour de plusieurs valeurs . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129

8.5 Exercice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130

9 Introduction à Numpy

131

9.1 Tableaux . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131

9.1.1 Création . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132

9.1.1.1 Quelques fonctions générant des array . . . . . . . . . . . . 133

9.1.2 Dimensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136

9.1.3 Extraction des éléments d’un tableau . . . . . . . . . . . . . . . . . . 137

9.1.3.1 Extraction à l’aide de booléens . . . . . . . . . . . . . . . . 140

9.1.4 Modiﬁcation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140

9.1.4.1 Ajout d’éléments . . . . . . . . . . . . . . . . . . . . . . . . 141

9.1.4.2 Suppression d’éléments . . . . . . . . . . . . . . . . . . . . . 142

9.1.5 Copie de tableau . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144

9.1.6 Tri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146

9.1.7 Transposition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146

9.1.8 Opérations sur les tableaux . . . . . . . . . . . . . . . . . . . . . . . 148

9.1.8.1 Opérateurs + et - . . . . . . . . . . . . . . . . . . . . . . . . 148

9.1.8.2 Opérateurs * et / . . . . . . . . . . . . . . . . . . . . . . . . 149

9.1.8.3 Puissance . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149

9.1.8.4 Opérations sur des matrices . . . . . . . . . . . . . . . . . . 150

9.1.9 Opérateurs logiques . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150

9.1.10 Quelques constantes . . . . . . . . . . . . . . . . . . . . . . . . . . . 151

TABLE DES MATIÈRES

7

9.1.11 Fonctions universelles . . . . . . . . . . . . . . . . . . . . . . . . . . . 152 9.1.12 Méthodes et fonctions mathématiques et statistiques . . . . . . . . . 154 9.2 Génération de nombres pseudo-aléatoires . . . . . . . . . . . . . . . . . . . . 156 9.3 Exercice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159

10 Manipulation de données avec pandas

161

10.1 Structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161

10.1.1 Séries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161

10.1.1.1 Création de séries à partir d’une liste . . . . . . . . . . . . . 161

10.1.1.2 Déﬁnition de l’index . . . . . . . . . . . . . . . . . . . . . . 163

10.1.1.3 Création de séries particulières . . . . . . . . . . . . . . . . 164

10.1.2 Dataframes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165

10.1.2.1 Création de dataframes à partir d’un dictionnaire . . . . . . 165

10.1.2.2 Création de dataframes à partir d’une série . . . . . . . . . 167

10.1.2.3 Création de dataframes à partir d’une liste de dictionnaire . 168

10.1.2.4 Création de dataframes à partir d’un dictionnaire de séries . 169

10.1.2.5 Création de dataframes à partir d’un tableau NumPy à deux

dimensions . . . . . . . . . . . . . . . . . . . . . . . . . . . 170

10.1.2.6 Dimensions . . . . . . . . . . . . . . . . . . . . . . . . . . . 171

10.1.2.7 Modiﬁcation de l’index . . . . . . . . . . . . . . . . . . . . . 172

10.2 Sélection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172

10.2.1 Pour les séries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173

10.2.1.1 Avec les crochets . . . . . . . . . . . . . . . . . . . . . . . . 173

10.2.1.2 Avec les indexeurs . . . . . . . . . . . . . . . . . . . . . . . 175

10.2.2 Pour les dataframes . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178

10.2.2.1 Extraction d’une ligne . . . . . . . . . . . . . . . . . . . . . 180

10.2.2.2 Extraction de plusieurs lignes . . . . . . . . . . . . . . . . . 181

10.2.2.3 Découpage de plusieurs lignes . . . . . . . . . . . . . . . . . 182

10.2.2.4 Masque . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183

10.2.2.5 Extraction d’une seule colonne . . . . . . . . . . . . . . . . 183

10.2.2.6 Extraction de plusieurs colonnes . . . . . . . . . . . . . . . 184

10.2.2.7 Découpage de plusieurs colonnes . . . . . . . . . . . . . . . 185

10.2.2.8 Extraction de lignes et colonnes . . . . . . . . . . . . . . . . 186

10.3 Renommage des colonnes dans un dataframe . . . . . . . . . . . . . . . . . . 187

10.4 Filtrage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188

10.4.1 Test d’appartenance . . . . . . . . . . . . . . . . . . . . . . . . . . . 190

10.5 Valeurs manquantes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190

10.5.1 Repérer les valeurs manquantes . . . . . . . . . . . . . . . . . . . . . 192

10.5.2 Retirer les observations avec valeurs manquantes . . . . . . . . . . . . 193

10.5.3 Retirer les valeurs manquantes par d’autres valeurs . . . . . . . . . . 193

10.6 Suppressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193

10.6.1 Suppression d’éléments dans une série . . . . . . . . . . . . . . . . . . 193

10.6.2 Suppression d’éléments dans un dataframe . . . . . . . . . . . . . . . 196

10.6.2.1 Suppressions de lignes . . . . . . . . . . . . . . . . . . . . . 197

10.6.2.2 Suppressions de colonnes . . . . . . . . . . . . . . . . . . . . 198

8

TABLE DES MATIÈRES

10.7 Remplacement de valeurs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199 10.7.1 Pour une série . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199 10.7.2 Pour un dataframe . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200 10.7.2.1 Modiﬁcations d’une valeur particulière . . . . . . . . . . . . 201 10.7.2.2 Modiﬁcations sur une ou plusieurs colonnes . . . . . . . . . 202 10.7.2.3 Modiﬁcations sur une ou plusieurs lignes . . . . . . . . . . . 203
10.8 Ajout de valeurs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205 10.8.1 Pour une série . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205 10.8.1.1 Ajout d’une seule valeur dans une série . . . . . . . . . . . . 206 10.8.1.2 Ajout de plusieurs valeurs dans une série . . . . . . . . . . . 207 10.8.2 Pour un dataframe . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207 10.8.2.1 Ajout d’une ligne dans un dataframe . . . . . . . . . . . . . 208 10.8.2.2 Ajout de plusieurs lignes dans un dataframe . . . . . . . . . 209 10.8.2.3 Ajout d’une colonne dans un dataframe . . . . . . . . . . . 209 10.8.2.4 Ajout de plusieurs colonnes dans un dataframe . . . . . . . 210
10.9 Retrait des valeurs dupliquées . . . . . . . . . . . . . . . . . . . . . . . . . . 210 10.10Opérations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
10.10.1 Statistiques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 214 10.11Tri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 216 10.12Concaténation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217 10.13Jointures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220 10.14Agrégation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224
10.14.1 Agrégation selon les valeurs d’une seule colonne . . . . . . . . . . . . 225 10.14.2 Agrégation selon les valeurs de plusieurs colonnes . . . . . . . . . . . 226 10.15Stacking et unstacking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 226 10.16Exportation et importation de données . . . . . . . . . . . . . . . . . . . . . 226 10.16.1 Exportation des données . . . . . . . . . . . . . . . . . . . . . . . . . 226
10.16.1.1 Exportation de données tabulaires . . . . . . . . . . . . . . 226 10.17Importation des données . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 229
10.17.1 Fichiers CSV . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 229 10.17.2 Fichiers Excel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230 10.17.3 Fichiers HDF5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230 10.18Exercice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231

11 Visualisation de données

233

11.1 Graphiques avec matplotlib . . . . . . . . . . . . . . . . . . . . . . . . . . . 233

11.1.1 Géométries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 234

11.1.1.1 Lignes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 234

11.1.1.2 Nuage de points . . . . . . . . . . . . . . . . . . . . . . . . 242

11.1.1.3 Taille et couleur . . . . . . . . . . . . . . . . . . . . . . . . 244

11.1.1.4 Histogrammes . . . . . . . . . . . . . . . . . . . . . . . . . . 246

11.1.1.5 Diagrammes en bâtons . . . . . . . . . . . . . . . . . . . . . 251

11.1.1.6 Boxplots . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 256

11.1.2 Plusieurs graphiques sur une ﬁgure . . . . . . . . . . . . . . . . . . . 258

11.1.3 Éléments de graphiques . . . . . . . . . . . . . . . . . . . . . . . . . 261

TABLE DES MATIÈRES

9

11.1.3.1 Titre . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261 11.1.3.2 Axes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262 11.1.3.3 Légendes . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270 11.1.4 Dimensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272 11.1.5 Enregistrement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273 11.2 Graphiques avec seaborn . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 274

12 References

275

10

TABLE DES MATIÈRES

Liste des tableaux
2.3 Codes de formatages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56 4.1 Opérateurs de comparaison . . . . . . . . . . . . . . . . . . . . . . . . . . . 86 4.2 Quelques fonctions numériques . . . . . . . . . . . . . . . . . . . . . . . . . . 93 4.3 Quelques constantes intégrées dans Python . . . . . . . . . . . . . . . . . . . 94 5.1 Valeurs principales pour la manière d’ouvrir les ﬁchiers. . . . . . . . . . . . . 98 5.2 Paramètres de la fonction reader() . . . . . . . . . . . . . . . . . . . . . . . 101 9.1 Fonctions logiques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150 9.2 Codes de formatages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151 9.3 Fonctions universelles unaires . . . . . . . . . . . . . . . . . . . . . . . . . . 152 9.4 Fonctions universelles binaires . . . . . . . . . . . . . . . . . . . . . . . . . . 153 9.5 Méthodes mathématiques et statistiques . . . . . . . . . . . . . . . . . . . . 154 9.6 Fonctions statistiques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155 9.7 Quelques fonctions de génération de nombres pseudo-aléatoires . . . . . . . . 156 10.1 Paramètres principaux de la fonction to_csv . . . . . . . . . . . . . . . . . . 227 11.1 Formats des lignes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237 11.2 Formats des lignes via le paramètre linestyle . . . . . . . . . . . . . . . . . 238 11.3 Formats des lignes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239
11

12

LISTE DES TABLEAUX

Table des ﬁgures
1.1 Langages de programmation, de scripting et de balisage. . . . . . . . . . . . 18 1.2 Python dans un terminal. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 1.3 Fenêtre d’accueil d’Anaconda. . . . . . . . . . . . . . . . . . . . . . . . . . . 21 1.4 Console IPython. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 1.5 Spyder. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 1.6 Jupyter. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 1.7 Un notebook vide. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 1.8 Cellule évaluée. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25 1.9 Cellule textuelle non évaluée. . . . . . . . . . . . . . . . . . . . . . . . . . . 27
13

14

TABLE DES FIGURES

Propos liminaires
Ces notes de cours ont été réalisées dans le cadre d’un enseignement d’introduction à Python adressé à des étudiants du parcours Économétrie et Big Data de l’École d’Economie d’AixMarseille / Aix-Marseille School of Economics (AMSE) d’Aix-Marseille Université.
0.1 Objectifs
Cet ouvrage a pour but l’initiation au langage de programmation Python, aﬁn d’être capable de s’en servir de manière eﬃcace et autonome. Le lecteur peut exécuter tous les exemples fournis (et est vivement encouragé à le faire). Des exercices viennent clore certains chapitres, pour mieux s’approprier les notions couvertes au fur et à mesure de la lecture. Bien évidemment, Python étant un langage très vaste, ces notes ne sauraient et n’ont pas pour vocation à être exhaustives de l’utilisation de ce langage informatique.
0.2 À qui s’adressent ces notes ?
Dans un premier temps, cet ouvrage s’adresse aux débutants qui souhaientent apprendre les bases en Python. Il est à destination des étudiants de l’AMSE mais pourrait intéresser des individus ayant une approche de la donnée à travers la discipline économique désirant découvrir Python. Merci à Adrien Paciﬁco pour ses commentaires instructifs.
15

16

TABLE DES FIGURES

Chapitre 1
Introduction
Ce document est construit principalement à l’aide de diﬀérentes références, parmi lesquelles : — des livres : Briggs (2013), Grus (2015), VanderPlas (2016), McKinney (2017) ; — des (excellents) notebooks : Navaro (2018).
1.1 Historique
Python est un langage de programmation multi plates-formes, écrit en C, placé sous une licence libre. Il s’agit d’un langage interprété, c’est-à-dire qu’il nécessite un interprète pour exécuter les commandes, et n’a pas de phase de compilation. Sa première version publique date de 1991. L’auteur principal, Guido van Rossum avait commencé à travailler sur ce langage de programmation durant la ﬁn des années 1980. Le nom accordé au langage Python provient de l’intérêt de son créateur principal pour une série télévisée britannique diﬀusée sur la BBC intitulée “Monty Python’s Flying Circus”. La popularité de Python a connu une croissance forte ces dernières années, comme le conﬁrment les résultats de sondages proposés par Stack Overﬂow depuis 2011. Stack Overﬂow propose à ses utilisateurs de répondre à une enquête dans laquelle de nombreuses questions leur sont proposées, aﬁn de décrire leur expérience en tant que développeur. Les résultats de l’enquête de 2018 montrent une nouvelle avancée de l’utilisation de Python par les développeurs. En eﬀet, comme le montre la Figure 1.1, 38.8% des répondants indiquent développer en Python, soit 6.8 points de pourcentage de plus qu’un an auparavant, ce qui fait de ce langage de programmation celui dont la croissance a été la plus importante entre 2017 et 2018.
1.2 Versions
Ces notes de cours visent à fournir une introduction à Python, dans sa version 3.x. En ce sens, les exemples fournis corresponderont à cette version, non pas aux précédentes.
17

18

CHAPITRE 1. INTRODUCTION

Perl Groovy
Scala Kotlin VBA Matlab
R VB.NET Objective−C
Go Assembly
Swift Ruby TypeScript
C C++ PHP
C# Python Bash/Shell
Java SQL CSS HTML JavaScript
0

20

40

60

Pourcentage de répondants

Figure 1.1 – Langages de programmation, de scripting et de balisage.

1.3. ESPACE DE TRAVAIL

19

Comparativement à la version 2.7, la version 3.0 a apporté des modoﬁcations profondes. Il faut noter que Python 2.7 prendra “sa retraite” le premier janvier 2020. Passée cette date, le support ne sera plus assuré.

1.3 Espace de travail
Il existe de nombreux environnements dans lesquels programmer en Python. Nous allons en présenter succinctement quelques uns. Il est supposé ici que vous vous avez installé Anaconda sur votre poste. Anaconda est une distribution gratuite et open source des langages de programmation Python et R pour les applications en data science et apprentissage automatique. Par ailleurs, lorsqu’il est fait mention du terminal dans les notes, il est supposé que le système d’exploitation de votre machine est soit Linux, soit Mac OS.
1.3.1 Python dans un terminal
Il est possible d’appeler Python depuis un terminal, en exécutant la commande suivante (sous Windows : dans le menu démarrer, lancer le logiciel “Python 3.6”) :
python

Ce qui donne le rendu visible sur la Figure 1.2 :

Figure 1.2 – Python dans un terminal.

20

CHAPITRE 1. INTRODUCTION

On note la présence des caractères >>> (prompt), qui invitent l’utilisateur à inscrie une commande. Les expressions sont évaluées une fois qu’elle sont soumises (à l’aide de la touche ENTREE) et le résultat est donné, lorsqu’il n’y a pas d’erreur dans le code.

Par exemple, lorsque l’on évalue 2+1 :

>>> 2+1 3 >>>

On note la présence du prompt à la ﬁn, indiquant que Python est prêt à recevoir de nouvelles instructions.

1.3.2 IPython
Il existe un environnement un peu plus chaleureux que Python dans le terminal : IPython. Il s’agit également d’un terminal interactif, mais avec davantages de fonctionnalités, notamment la coloration syntaxique ou l’auto-complétion (en utilisant la touche de tabulation). Pour lancer IPython, on peut ouvrir un terminal et taper (puis valider) :
ipython
On peut également lancer IPython depuis la fenêtre d’accueil d’Anaconda, en cliquant sur le bouton Launch de l’application qtconsole, visible sur la Figure 1.3.

1.3. ESPACE DE TRAVAIL

21

Figure 1.3 – Fenêtre d’accueil d’Anaconda. La console IPython, une fois lancée, ressemble à ceci :
Figure 1.4 – Console IPython. Soumettons une instruction simple pour évaluation à Python :

22
print("Hello World")
Le résultat donne :
In [1]: print("Hello World") Hello World In [2]:

CHAPITRE 1. INTRODUCTION

Plusieurs choses sont à noter. Premièrement, on note qu’à la ﬁn de l’exécution de l’instruction, IPython nous indique qu’il est prêt à recevoir de nouvelles instruction, par la présence du prompt In [2]:. Le numéro entre les crochets désigne le numéro de l’instruction. On note qu’il est passé de 1 à 2 après l’exécution. Ensuite, on note que le résultat de l’appel à la fonction print(), avec la chaîne de caractères (délimitée par des guillemets), aﬃche à l’écran ce qui était contenu entre les parenthèses.
1.3.3 Spyder
Tandis que lorsqu’on utilise Python via un terminal, il est préférable d’avoir un éditeur de texte ouvert à côté (pour pouvoir sauvegarder les instructions), comme, par exemple, Sublime Text sous Linux ou Mac OS, ou notepad++ sous Windows.
Une autre alternative consiste à utiliser un environnement de développement (IDE, pour Integrated development environment) unique proposant notamment, à la fois un éditeur et une console. C’est ce que propose Spyder, avec en outre de nombreuses fonctionnalités supplémentaires, comme la gestion de projet, un explorateur de ﬁchier, un historique des commandes, un débugger, etc.
Pour lancer Spyder, on peut passer par un terminal, en évaluant tout simplement Spyder (ou en lançant le logiciel depuis le menu démarrer sous Windows). Il est également possible de lancer Spyder depuis Anaconda.
L’environnement de développement, comme visible sur la Figure 1.5, se décompose en plusieurs fenêtres :
— à gauche : l’éditeur de script ; — en haut à droite : une fenêtre permettant d’aﬃcher l’aide de Python, l’arborescence
du système ou encore les variables créées ; — en bas à droite : une ou plusieurs consoles.

1.3. ESPACE DE TRAVAIL

23

Figure 1.5 – Spyder.
1.3.4 Jupyter
Il existe une interface graphique par navigateur d’IPython, appelée Jupyter Notebook. Il s’agit d’une application en open-source permettant de créer et partager des documents qui contiennent du code, des équations, des représentations graphiques et du texte. Il est possible de faire ﬁgurer et exécuter des codes de langages diﬀérents dans les notebook Jupyter. Pour lancer Jupyter, on peut passer par Anaconda. Après avoir cliqué sur le bouton Launch, de Jupyter Notebook, le navigateur web se lance et propose une arborescence, comme montré sur la Figure 1.6. Sans que l’on s’en rendiez compte, un serveur local web a été lancé ainsi qu’un processus Python (un kernel).
Si le navigateur en se lance pas automatiquement, on peut accéder à la page qui aurait dû s’aﬃcher, en se rendant à l’adresse suivante : http://localhost:8890/tree ?.

24

CHAPITRE 1. INTRODUCTION

Figure 1.6 – Jupyter.
Pour aborder les principales fonctions de Jupyter, nous allons créer un dossier jupyter dans un répertoire de notre choix. Une fois ce dossier créé, y naviguer à travers l’arborescence de Jupyter, dans le navigateur web. Une fois dans le dossier, créer un nouveau Notebook Python 3 (en cliquant sur le bouton New en haut à gauche de la fenêtre, puis sur Python 3‘). Un notebook intitulé Untitled vient d’être créé, la page aﬃche un document vide, comme visible sur la Figure 1.7.
Figure 1.7 – Un notebook vide.
Si on regarde dans notre explorateur de ﬁchier, dans le dossier jupyter fraîchement créé, un nouveau ﬁchier est apparu : Untitled.ipynb.

1.3. ESPACE DE TRAVAIL

25

1.3.4.1 Évaluation d’une instruction

Retournons dans le navigateur web, sur la page aﬃchant notre notebook.
En dessous de la barre des menus, on note la présence d’une zone encadrée, une cellule, commençant, à l’instar de ce que l’on voyait dans la console sur IPython, par IN []:. À droite, la zone grisée nous invite à soumettre des instructions en Python.
Inscrivons : 2+1
Pour soumettre l’instruction à évaluation, il existe plusieurs manières (il s’assurer d’avoir cliqué à l’intérieur de la cellule) :
— dans la barre des menus : Cell > Run Cells ; — dans la barre des raccourcis : bouton Run ; — avec le clavier : maintenir la touche CTRLet presser sur Entree.

Figure 1.8 – Cellule évaluée.
1.3.4.2 Cellules de texte
Un des intérêts des notebooks est qu’il est possible d’ajouter des cellules de texte.
Ajoutons une cellule en-dessous de la première. Pour ce faire, on peut procéder soit :
— par la barre de menu : Insert > Insert Cell Below (pour insérer une cellule endessous ; si on désire une insertion au-dessus, il suﬃt de choisir Insert Cell Above) ;
— en cliquant dans le cadre de la cellule à partir de laquelle on désire faire un ajout (n’importe où, sauf dans la zone grisée de code, de manière à passer en mode commande), puis en appuyant sur la touche B du clavier (A pour une insertion au-dessus).
La nouvelle cellule appelle à nouveau à inscrire une instruction en Python. Pour indiquer que le contenu doit être interprété comme du texte, il est nécessaire de le préciser. Encore une fois, plusieurs méthodes permettent de le faire :
— par la barre de menu : Cell > Cell Type > Markdown ; — par la barre des raccourcis : dans le menu déroulant où est inscrit Code, en sélectionnant
Markdown ; — en mode commande (après avoir cliqué à l’intérieur du cadre de la cellule, mais pas
dans la zone de code), en appuyant sur la touche M du clavier.

26

CHAPITRE 1. INTRODUCTION

La cellule est alors prête à recevoir du texte, rédigé en markdown. Pour plus d’informations sur la rédaction en Markdown, se référer à cette antisèche par exemple.
Entrons quelques lignes de texte pour voir très rapidement le fonctionnement des cellules rédigées en Markdown.
# Un titre de niveau 1
Je vais écrire *du texte en italique* et aussi **en gras**.
## Un titre de niveau 2
Je peux faire des listes :
- avec un item ; - un second ; - et un troisième imbriquant une nouvelle liste :
- avec un sous -item , - et un second ; - un quatrième incluant une liste imbriquée numérotée : 1. avec un sous -item , 1. et un autre.
## Un autre titre de niveau 2

Je peux même faire figurer des équation $\LaTeX$. Comme par exemple $X \sim \mathcal{N}(0,1)$.
Pour en savoir plus sur $\LaTeX$ , on peut se référer à cette : [page Wikipédia](https://en.wikibooks.org/wiki/LaTeX/Mathematics).

Ce qui donne, dans Jupyter :
Reste alors à l’évaluer, comme s’il s’agissait d’une cellule contenant une instruction Python, pour basculer vers un aﬃchage Markdown (CTRL et ENTREE).
Pour éditer le texte une fois que l’on a basculé en markdown, un simple double-clic dans la zone de texte de la cellule fait l’aﬀaire.
Pour changer le type de la cellule pour qu’elle devienne du code :
— par la barre de menu : Cell > Cell Type > Code ; — par la barre des raccourcis : dans le menu déroulant où est inscrit Code, en sélectionnant
Code ; — en mode commande, appuyer sur la touche du clavier Y.

1.4. LES VARIABLES

27

Figure 1.9 – Cellule textuelle non évaluée.
1.3.4.3 Suppression d’une cellule
Pour supprimer une cellule : — par la barre de menu : Edit > Delete Cells ; — par la barre des raccourcis : icône en forme de ciseaux ; — en mode commande, appuyer deux fois sur la touche du clavier D.
1.4 Les variables
1.4.1 Assignation et suppression
Lorsque nous avons évalué les instructions 2+1 précédemment, le résultat s’est aﬃché dans la console, mais il n’a pas été enregistré. Dans de nombreux cas, il est utile de conserver le contenu du résultat dans un objet, pour pouvoir le réutiliser par la suite. Pour ce faire, on utilise des variables. Pour créer une variable, on utilise le signe d’égalité (=), que l’on fait suivre par ce que l’on veut sauvegarder (du texte, un nombre, plusieurs nombres, etc.) et précéder par le nom que l’on utilisera pour désigner cette variable. Par exemple, si on souhaite stocker le résultat du calcul 2+1 dans une variable que l’on nommera x, il faudra écrire :

28

CHAPITRE 1. INTRODUCTION

x = 2+1 Pour aﬃcher la valeur de notre variable x, on fait appel à la fonction print() : print(x)
## 3

Pour changer la valeur de la variable, il suﬃt de faire une nouvelle assignation : x=4 print(x)
## 4

Il est également possible de donner plus d’un nom à un même contenu (on réalise une copie de x) : x = 4; y = x; print(y)
## 4

Si on modiﬁe la copie, l’original ne sera pas aﬀecté : y=0 print(y)
## 0
print(x)
## 4

Pour supprimer une variable, on utilise l’instruction del : del y
L’aﬃchage du contenu de y renvoit une erreur : print(y)

1.4. LES VARIABLES

29

## NameError: name y is not defined ## ## Detailed traceback: ## File "<string >", line 1, in <module >

Mais on note que la variable x n’a pas été supprimée : print(x)
## 4

1.4.2 Conventions de nommage
Le nom d’une variable peut être composé de caractères alphanumériques ainsi que du trait de soulignement (_) (il n’y a pas de limite sur la longueur du nom). Il est proscrit de faire commencer le nom de la variable par un nombre. Il est également interdit de faire ﬁgurer une espace dans le nom d’une variable.
Pour accroitre la lisibilité du nom des variables, plusieurs méthodes existes. Nous adopterons la suivante :
— toutes les lettres en minuscule ; — la séparation des termes par un trait de soulignement.
Exemple, pour une variable contenant la valeur de l’identiﬁant d’un utilisateur : id_utilisateur.
Il faut noter que le nom des variables est sensible à la casse : x = "toto" print(x)
## toto
print(X)
## NameError: name X is not defined ## ## Detailed traceback: ## File "<string >", line 1, in <module >

30
1.5 Les commentaires

CHAPITRE 1. INTRODUCTION

Pour ajouter des commentaires en python, il existe plusieurs façons.
Une des manières de faire est d’utiliser le symbole dièse (#) pour eﬀectuer un commentaire sur une seule ligne. Tout ce qui suit le dièse jusqu’à la ﬁn de la ligne ne sera pas évalué par Python. En revanche, ce qui vient avant le dièse le sera. # Un commentaire print("Bonjour") print("Hello") # Un autre commentaire
## Hello

L’introduction d’un bloc de commentaires (des commentaires sur plusieurs lignes) s’eﬀectue quant à elle en entourant ce qui est ) commenter d’un délimiteur : trois guillemets simples ou doubles :
""" Un commentaire qui commencer sur une ligne et qui continue sur une autre et s arrête à la troisième """

1.6 Les modules et les packages
Certaines fonctions de base en Python sont chargées par défaut. D’autres, nécessitent de charger un module. Ces modules sont des ﬁchiers qui contiennent des déﬁnitions ainsi que des instructions.
Lorsque plusieurs modules sont réunis pour oﬀrir un ensemble de fonctions, on parle alors de package.
Parmi les packages qui seront utilisés dans ces notes, on peut citer :
— NumPy, un package fondamental pour eﬀectuer des calculs scientiﬁques ; — pandas, un package permettant de manipuler facilement les données et de les analyser ; — Matplotlib, un package permettant de réaliser des graphiques.
Pour charger un module (ou un package), on utilise la commande import. Par exemple, pour charger le package pandas : import pandas
Ce qui permet de faire appel à des fonctions contenues dans le module ou le package. Par exemple, ici, on peut faire appel à la fonction Series(), contenue dans le package pandas, permettant de créer un tableau de données indexées à une dimension :

1.6. LES MODULES ET LES PACKAGES

31

x = pandas.Series([1, 5, 4]) print(x)

## 0

1

## 1

5

## 2

4

## dtype: int64

Il est possible de donner un alias au module ou au package que l’on importe, en le précisant à l’aide de la syntaxe suivante :
import module as alias

Cette pratique est courante pour abréger les noms des modules que l’on va être amené à utiliser beaucoup. Par exemple, pour pandas, il est coutume d’écourter le nom en pd :
import pandas as pd x = pd.Series([1, 5, 4]) print(x)

## 0

1

## 1

5

## 2

4

## dtype: int64

On peut également importer une seule fonction d’un module, et lui attribuer (optionnellement) un alias. Par exemple, avec la fonction pyplot du package matplotlib, il est coutume de faire comme suit :
import matplotlib import matplotlib.pyplot as plt import numpy as np x = np.arange(0, 5, 0.1); y = np.sin(x) plt.plot(x, y)

32

CHAPITRE 1. INTRODUCTION

1.7 L’aide
Pour conclure cette introduction, il semble important de mentionner la présence de l’aide et de la documentation en Python.
Pour obtenir des informations sur des fonctions, il est possible de se référer à la documentation en ligne. Il est également possible d’obtenir de l’aide à l’intérieur de l’environnement que l’on utilise, en utilisant le point d’interrogation (?).
Par exemple, lorsque l’on utilise IPython (ce qui, rappelons-le, est le cas dans Jupyter), on peut accéder à l’aide à travers diﬀérentes syntaxes :
— ? : fournit une introduction et un aperçu des fonctionnalités oﬀertes en Python (on la quitte avec la touche ESC par exemple) ;
— object? : fournit des détails au sujet de object (par exemple x? ou encore plt.plot?) ;
— object?? : plus de détails à propos de object ; — %quickref : référence courte sur les syntaxes en Python ; — help() : accès à l’aide de Python.
Note : la touche de tabulation du clavier permet non seulement une autocomplétion, mais

1.7. L’AIDE

33

aussi une exploration du contenu d’un objet ou module.
Par ailleurs, lorsqu’il s’agit de trouver de l’aide sur un problème plus complèxe, le bon réﬂèxe à adopter est de ne pas hésiter à chercher sur un moteur de recherche, dans des mailing-lists et bien évidemment sur les nombreuses questions sur Stack Overﬂow.

34

CHAPITRE 1. INTRODUCTION

Chapitre 2
Types de données
Il existe quelques types de données intégrés dans Python. Nous allons dans cette partie évoquer les chaînes de caractères, les valeurs numériques, les bouléens (TRUE/FALSE), la valeur null et les dates et temps.
2.1 Chaînes de caractères
Une chaîne de caractères, ou string en anglais, est une collection de caractères comme des lettres, des nombres, des espaces, des signes de ponctuation, etc. Les chaînes de caractères sont repérées à l’aide de guillemets simples, doubles, ou triples. Voici un exemple : x = "Hello World" Pour aﬃcher dans la console le contenu de notre variable x contenant la chaîne de caractères, on fait appel à la fonction print() : print(x)
## Hello World
Comme indiqué juste avant, des guillemets simples peuvent être utilisés pour créer une chaîne de caractères : y = How are you? print(y)
## How are you?
35

36

CHAPITRE 2. TYPES DE DONNÉES

Pour faire ﬁgurer des apostrophes dans une chaîne de caractères créée à l’aide de guillemets simples, il est nécessaire d’utiliser un caracrère d’échappement : une barre oblique inversée (\) :
z = I\ m fine print(z)

## I m fine

On peut noter que si la chaîne de caractères est créée à l’aide de guillemets doubles, il n’est pas nécessaire d’avoir recours au caractère d’échappement : z = "I m \"fine\"" print(z)
## I m "fine"

Pour indiquer un retour à la ligne, on utilise la chaîne \n : x = "Hello, \nWorld" print(x)
## Hello , ## World

Dans le cas de chaînes de caractères sur plusieurs lignes, le fait d’utiliser des guillemets simples ou doubles renverra une erreur (EOL while scanning trial literal, i.e., détection d’une erreur de syntaxe, Python s’attendait à quelque chose d’autre à la ﬁn de la ligne). Pour écrire une chaîne de caractères sur plusieurs lignes, Python propose d’utiliser trois fois des guillemets (simples ou doubles) en début et ﬁn de chaîne :
x = """Hello, World""" print(x)
## Hello , ## World

2.1. CHAÎNES DE CARACTÈRES

37

Remarque 2.1.1
Le caractère \ (barre oblique inversée, ou backslash) est le caractère d’échappement. Il permet d’aﬃcher certains caractères, comme les guillemets dans une chaîne elle-même déﬁnie à l’aide de guillemets, ou bien les caractères de contrôle, comme la tabulation, le saut de ligne, etc. Voici quelques exemples courants :

Code

Description

Code Description

\n

Nouvelle ligne

\r Retour à la ligne

\t

Tabulation

\b Retour arrière

\\ Barre oblique inversée \

Apostrophe

\" Apostrophe double \

Accent grave

Pour récupérer la longueur d’une chaîne de caractères, Python propose la fonction len() : x = "Hello World !" print(len(x))
## 13

print(x, len(x))
## Hello World ! 13

2.1.1 Concaténation de chaînes
Pour concaténer des chaînes de caractères, c’est-à-dire les mettre bout à bout, Python propose d’utiliser l’opérateur + : print("Hello" + " World")
## Hello World
L’opérateur * permet quant à lui de répéter plusieurs fois une chaîne : print( 3 * "Go Habs Go! " + "Woo Hoo!")
## Go Habs Go! Go Habs Go! Go Habs Go! Woo Hoo!

38

CHAPITRE 2. TYPES DE DONNÉES

Lorsque deux littéraux de chaînes sont côte à côte, Python les concatène :

x = ( You shall print(x)

not "pass!")

## You shall not pass!

Il est également possible d’ajouter à une chaîne de caractères le contenu d’une variable, à l’aide de crochets ({}) et de la méthode format() x = "J aime coder en {}" langage_1 = "R" langage_2 = "Python" preference_1 = x.format(langage_1) print(preference_1)
## J aime coder en R
preference_2 = x.format(langage_2) print(preference_2)
## J aime coder en Python

Il est tout à fait possible d’ajouter plus d’un contenu de variable dans une chaîne de caractères, toujours avec les crochets et la méthode format() :
x = "J aime coder en {} et en {}" preference_3 = x.format(langage_1, langage_2) print(preference_3)
## J aime coder en R et en Python

2.1.2 Indexation et extraction
Les chaînes de caractères peuvent être indexées. Attention, l’indice du premier caractère commence à 0. Pour obtenir le ie caractère d’une chaîne, on utilise des crochets. La syntaxe est la suivante : x[i-1] Par exemple, pour aﬃcher le premier caractère, puis le cinquième de la chaîne Hello :

2.1. CHAÎNES DE CARACTÈRES

39

x = "Hello" print(x[0])
## H

print(x[4])
## o

L’extraction peut s’eﬀectuer en partant par la ﬁn de la chaîne, en faisant précéder la veleur de l’indice par le signe moins (-). Par exemple, pour aﬃcher l’avant-dernier caractère de notre chaîne x : print(x[-2])
## l

L’extraction d’une sous-chaîne en précisant sa position de début et de ﬁn (implicitement ou non) s’eﬀectue avec les crochets également. Il suﬃt de préciser les deux valeurs d’indices : [debut:fin]. x = "You shall not pass!"
# Du quatrième caractère (non inclus) au neuvième (inclus) print(x[4:9])
## shall

Lorsque l’on ne précise pas la première valeur, le début de la chaîne est pris par défaut ; lorsque le second n’est pas précisé, la ﬁn de la chaîne est prise par défaut.
# Du 4e caractère (non inclus) à la fin de la chaîne print(x[4:]) # Du début de la chaîne à l avant dernier caractère (inclus) print(x[:-1]) # Du 3e caractère avant la fin (inclus) jusqu à la fin print(x[-5:])
## shall not pass!

40
## You shall not pass

CHAPITRE 2. TYPES DE DONNÉES

## pass!

Il est possible de rajouter un troisième indice dans les crochets : le pas. # Du 4e caractère (non inclus), jusqu à la fin de la chaîne, # par pas de 3. print(x[4::3])
## sln s

Pour obtenir la chaîne en dans le sens opposé : print(x[::-1])
## !ssap ton llahs uoY

2.1.3 Méthodes disponibles avec les chaînes de caractères
De nombreuses méthodes sont disponibles pour les chaînes de caractères. En ajoutant un point (.) après le nom d’un objet désignant une chaîne de caractères puis en appuyant sur la touche de tabulation, les méthodes disponibles s’aﬃchent dans un menu déroulant. Par exemple, la méthode count() permet de compter le nombre d’occurrences d’un motif dans la chaîne. Pour compter le nombre d’occurrence de in dans la chaîne suivante : x = "le train de tes injures roule sur le rail de mon indifférence" print(x.count("in"))
## 3
Remarque 2.1.2 Une fois l’appel à méthode écrit, en plaçant le curseur à la ﬁn de la ligne et en appuyant sur les touches Shift et Tabulation, on peut aﬃcher des explications.

2.1. CHAÎNES DE CARACTÈRES

41

2.1.3.1 Conversion en majuscules ou en minuscules
Les méthodes lower() et upper() permettent de passer une chaîne de caractères en caractères minuscules et majuscules, respectivement. x = "le train de tes injures roule sur le rail de mon indifférence" print(x.lower()) print(x.upper())
## le train de tes injures roule sur le rail de mon indifférence

## LE TRAIN DE TES INJURES ROULE SUR LE RAIL DE MON INDIFFÉRENCE

2.1.3.2 Recherche de chaînes de caractères
Quand on souhaite retrouver un motif dans une chaîne de caractères, on peut utiliser la méthode find(). On fournit en paramètres un motif à rechercher. La méthode find() retourne le plus petit indice dans la chaîne où le motif est trouvé. Si le motif n’est pas retrouvé, la valeur retournée est -1. print(x.find("in")) print(x.find("bonjour"))
## 6
## -1
Il est possible d’ajouter en option une indication permettant de limiter la recherche sur une sous-chaîne, en précisant l’indice de début et de ﬁn : print(x.find("in", 7, 20))
## 16
Note : on peut omettre l’indice de ﬁn ; en ce cas, la ﬁn de la chaîne est utilisée : print(x.find("in", 20))
## 49

42

CHAPITRE 2. TYPES DE DONNÉES

Remarque 2.1.3
Si on ne désire pas connaître la position de la sous-chaîne, mais uniquement sa présence ou son absence, on peut utiliser l’opérateur in : print("train" in x)

Pour eﬀectuer une recherche sans prêter attention à la casse, on peut utiliser la méthode capitalize() : x = "Mademoiselle Deray, il est interdit de manger de la choucroute ici." print(x.find("deray"))
## -1

print(x.capitalize().find("deray"))
## 13

2.1.3.3 Découpage en sous-chaînes
Pour découper une chaîne de caractères en sous-chaînes, en fonction d’un motif servant à la délimitation des sous-chaînes (par exemple une virgule, ou une espace), on utilise la méthode split() : print(x.split(" "))
## [ Mademoiselle , Deray , , il , est , interdit , de , manger , de , la , choucroute , ici. ]
En indiquant en paramètres une valeur numérique, on peut limiter le nombre de sous-chaînes retournées : # Le nombre de sous-chaînes maximum sera de 3 print(x.split(" ", 3))
## [ Mademoiselle , Deray , , il , est interdit de manger de la choucroute ici. ]
La méthode splitlines() permet également de séparer une chaîne de caractères en fonction d’un motif, ce motif étant un caractère de ﬁn de ligne, comme un saut de ligne ou un retour chariot par exemple.

2.1. CHAÎNES DE CARACTÈRES

43

x = "Luke, je suis ton pere ! - Non... ce n est pas vrai ! C est impossible ! - Lis dans ton coeur, tu sauras que c est vrai. - Noooooooon ! Noooon !" print(x.splitlines())
## [ "Luke , je suis ton pere ! , "- Non... ce n est pas vrai ! C est impossible !", "- Lis dans ton coeur , tu sauras que c est vrai
.", - Noooooooon ! Noooon !" ]

2.1.3.4 Nettoyage, complétion

Pour retirer des caractères blancs (e.g., des espaces, sauts de ligne, quadratins, etc.) présents en début et ﬁn de chaîne, on peut utiliser la méthode strip(), ce qui est parfois très utile pour nettoyer des chaînes.

x = "\n\n Pardon, du sucre ? print(x.strip())

\n \n"

## Pardon , du sucre ?

On peut préciser en paramètre quels caractères retirer en début et ﬁn de chaîne : x = "www.egallic.fr" print(x.strip("wrf."))
## egallic

Parfois, il est nécessaire de s’assurer d’obtenir une chaîne d’une longueur donnée (lorsque l’on doit fournir un ﬁchier avec des largeurs ﬁxes pour chaque colonne par exemple). La méthode rjust() est alors d’un grand secours. En lui renseignant une longueur de chaîne et un caractère de remplissage, elle retourne la chaîne de caractères avec une complétion éventuelle (si la longueur de la chaîne retournée n’est pas assez longue au regard de la valeur demandée), en répétant le caractère de remplissage autant de fois que nécessaire.
Par exemple, pour avoir une coordonnée de longitude, stockée dans une chaîne de caractères de longueur 7, en rajoutant des espaces si nécessaire :
longitude = "48.11" print(x.rjust(7," "))
## www.egallic.fr

44

CHAPITRE 2. TYPES DE DONNÉES

2.1.3.5 Remplacements
La méthode replace() permet d’eﬀectuer des remplacements de motifs dans une chaîne de caractères. x = "Criquette ! Vous, ici ? Dans votre propre salle de bain ? Quelle surprise !" print(x.replace("Criquette", "Ridge"))
## Ridge ! Vous , ici ? Dans votre propre salle de bain ? Quelle surprise !

Cette méthode est très pratique pour retirer des espaces par exemple : print(x.replace(" ", ""))
## Criquette!Vous ,ici?Dansvotrepropresalledebain?Quellesurprise!

Voici un tableau répertoriant quelques méthodes disponibles (liste exhaustive dans la documentation) :

Méthode

Description

capitalize()

Mise en majuscule du premier caractère et en minuscile du reste

casefold() retire les distinctions de casse (utile pour la comparaison de chaînes sans

faire attention à la casse)

count()

Compte le nombre d’occurrence (sans chevauchement) d’un motif

encode()

Encode une chaîne de caractères dans un encodage spéciﬁque

find()

Retourne le plus petit indice où une sous-chaîne est trouvée

lower()

Retourne la chaîne en ayant passé chaque caractère alphabétique en

minuscules

replace()

Remplace un motif par un autre

split()

Sépare la chaîne en sous-chaînes en fonction d’un motif

title() Retourne la chaîne en ayant passé chaque première lettre de mot par une

majuscule

upper()

Retourne la chaîne en ayant passé chaque caractère alphabétique en

majuscules

2.1.4 Conversion en chaînes de caractères
Lorsque l’on veut concaténer une chaîne de caractères avec un nombre, Python retourne une erreur.

2.1. CHAÎNES DE CARACTÈRES

45

nb_followers = 0 message = "He has " + nb_followers + "followers."
## TypeError: must be str , not int ## ## Detailed traceback: ## File "<string >", line 1, in <module >

print(message)
## NameError: name message is not defined ## ## Detailed traceback: ## File "<string >", line 1, in <module >

Il est alors nécessaire de convertir au préalable l’objet n’étant pas une chaîne en une chaîne de caractères. Pour ce faire, Python propose la fonction str() : message = "He has " + str(nb_followers) + " followers." print(message)
## He has 0 followers.

2.1.5 Exercice
1. Créer deux variables nommées a et b aﬁn qu’elles contiennent respectivement les chaînes de caractères suivantes : 23 à 0 et C est la piquette, Jack!.
2. Aﬃcher le nombre de caractères de a, puis de b. 3. Concaténer a et b dans une seule chaîne de caractères, en ajoutant une virgule comme
caractère de séparation. 4. Même question en choisissant une séparation permettant un retour à la ligne entre les
deux phrases. 5. À l’aide de la méthode appropriée, mettre en majuscules a et b. 6. À l’aide de la méthode appropriée, mettre en minuscules a et b. 7. Extraire le mot la et Jack de la chaîne b, en utilisant les indices. 8. Rechercher si la sous-chaîne piqu est présente dans b, puis faire de même avec la
sous-chaîne mauvais. 9. Retourner la position (indice) du premier caractère a retrouvé dans la chaîne b, puis
essayer avec le caractère w. 10. Remplacer les occurrences du motif a par le motif Z dans la sous-chaîne b. 11. Séparer la chaîne b en utilisant la virgule comme séparateur de sous-chaînes.

46

CHAPITRE 2. TYPES DE DONNÉES

12. (Bonus) Retirer tous les caractères de ponctuation de la chaîne b, puis utiliser une méthode appropriée pour retirer les caractères blancs en début et ﬁn de chaîne. (Utiliser la librairie regex).

2.2 Valeurs numériques
Il existe quatre catégories de nombres en Python : les entiers, les nombres à virgule ﬂottante et les complèxes.
2.2.1 Entiers
Les entiers (ints), en Python, sont des nombres entiers signés. Remarque 2.2.1 On accède au type d’un objet à l’aide de la fonction type() en Python.
x=2 y = -2 print(type(x))
## <class int >
print(type(y))
## <class int >

2.2.2 Nombre à virgule ﬂottante
Les nombres à virgule ﬂottante (floats) représentent les nombres réels. Ils sont écrits à l’aide d’un point permettant de distinguer la partie entière de la partie décimale du nombre. x = 2.0 y = 48.15162342 print(type(x))
## <class float >

2.2. VALEURS NUMÉRIQUES

47

print(type(y))
## <class float >

Il est également possible d’avoir recours aux notations scientiﬁques, en utilisant E ou e pour indiquer une puissance de 10. Par exemple, pour écrire 3, 212, on procèdera comme suit : x = 3.2E12 y = 3.2e12 print(x)
## 3200000000000.0
print(y)
## 3200000000000.0

Par ailleurs, lorsque le nombre est égal à une fraction de 0, on peut s’aﬀranchir d’écrire le zéro : print(0.35)
## 0.35
print(.35)
## 0.35

2.2.3 Nombres complèxes
Python permet nativement de manipuler des nombres complèxes, de la forme z = a + ib, où a et b sont des nombres à virgule ﬂottante, et tel que i2 = (−i)2 = 1. La partie réelle du nombre, R(z), est a tandis que sa partie imaginaire, I(z), est b.
En python, l’unité imaginaire i est dénotée par la lettre j. z = 1+3j print(z)
## (1+3j)

48
print(type(z))
## <class complex >

CHAPITRE 2. TYPES DE DONNÉES

Il est également possible d’utiliser la fonction complex(), qui demande deux paramètres (la partie réelle et la partie imaginaire) : z = complex(1, 3) print(z)
## (1+3j)
print(type(z))
## <class complex >

Plusieurs méthodes sont disponibles avec les nombres complèxes. Par exemple, pour accéder au conjugué, Python fournit la méthode conjugate() : print(z.conjugate())
## (1-3j)

L’accès à la partie réelle d’un complèxe ou à sa partie imaginaire s’eﬀectue à l’aide des méthodes real() et imag(), respectivement. z = complex(1, 3) print(z.real())
## TypeError: float object is not callable ## ## Detailed traceback: ## File "<string >", line 1, in <module >
print(z.imag())
## TypeError: float object is not callable ## ## Detailed traceback: ## File "<string >", line 1, in <module >

2.2. VALEURS NUMÉRIQUES

49

2.2.4 Conversions

Pour convertir un nombre dans un autre format numérique, Python dispose de quelques fonctions.

2.2.4.1 Conversion en entier
La conversion d’un nombre ou d’une chaîne de caractères en entier s’eﬀectue à l’aide de la fonction int() : x = "3" x_int = int(x) print(type(x_int))
## <class int >

print(type(x))
## <class str >

On note que la conversion d’un nombre à virgule ﬂottante tronque le nombre pour ne garder que la partie entière : x = 3.6 x_int = int(x) print(x_int)
## 3

2.2.4.2 Conversion en nombre à virgule ﬂottante
Pour convertir un nombre ou une chaîne de caractères en nombre à virgule ﬂottante (si possible), Python propose d’utiliser la fonction float(). x = "3.6" x_float = float(x) print(type(x_float))
## <class float >

50
Avec un entier à l’origine : x=3 x_float = float(x) print(x_float)
## 3.0

CHAPITRE 2. TYPES DE DONNÉES

2.2.4.3 Conversion en complèxe
La conversion d’un nombre ou d’une chaîne de caractères en nombre complèxe s’eﬀectue avec la fonction complex() : x = "2" x_complex = complex(x) print(x_complex)
## (2+0j)
Avec un ﬂoat : x = 2.4 x_complex = complex(x) print(x_complex)
## (2.4+0j)

2.3 Booléens
Les données de type logique peuvent prendre deux valeurs : True ou False. Elles répondent à une condition logique. Il faut faire attention à bien respecter la casse. x = True y = False print(x, y)
## True False
True peut être converti automatiquement en 1 ; False en 0. Cela peut s’avérer très pratique, pour faire des comptages de valeurs vraies ou fausses dans les colonnes d’un tableau de données, par exemple.

2.4. OBJET VIDE

51

res = True + True + False + True*True print(res)
## 3

2.4 Objet vide
L’objet vide, communément appelé null, possède un équivalent en Python : None. Pour l’assigner à une variable, il faut faire attention à la casse : x = None print(x)
## None
print(type(x))
## <class NoneType >
L’objet None est une variable neutre, au comportement “null”. Pour tester si un objet est l’objet None, on procède comme suit (le résultat est un booléen) : x=1 y = None print(x is None)
## False
print(y is None)
## True

2.5 Dates et temps
Il existe plusieurs moduels pour gérer les dates et le temps en Python. Nous allons explorer une partie du module datetime.

52

CHAPITRE 2. TYPES DE DONNÉES

2.5.1 Module datetime

Python possède un module appelé datetime qui oﬀre la possibilité de manipuler des dates et des durées (dates et times).
Il existe plusieurs types d’objets désignant des dates :
— date : une date suivant le calendrier grégorien, renseignant l’année, le mois et le jour ; — time : un temp donné, sans prise en compte d’un jour particulier, renseignant l’heure,
la minute, la seconde (possiblement la microseconde et le fuseau horaire également). — datetime : une date combinant date et time ; — timedelta : une durée entre deux objets de type dates, time ou datetime ; — tzinfo : un type de base abstraite, renseignant au sujet des fuseaux horaires ; — timezone : un type utilisant le type tzinfo comme un décalage ﬁxe par rapport à
l’UTC.

2.5.1.1 Date
Les objets de type date désignent des dates du calendrier grégorien, pour lesquelles sont mentionnées les caractéristiques suivantes : l’année, le mois et le jour. Pour créer un objet date, la syntaxe est la suivante : date(year, month, day)
Par exemple, pour créer la date renseignant le 23 avril 2013 : from datetime import date debut = date(year = 2013, month = 4, day = 23) print(debut)
## 2013-04-23

print(type(debut))
## <class datetime.date >

Remarque 2.5.1 Il n’est pas obligatoire de préciser le nom des paramètres dans l’appel à la fonction date. L’ordre à respecter devra toutefois être le suivant : année, mois, jour.
On peut ensuite accéder aux attributs de la date créée (ce sont des entiers) :

2.5. DATES ET TEMPS

53

print(debut.year) # Extraire l année
## 2013

print(debut.month) # Extraire le mois
## 4

print(debut.day) # Extraire le jour
## 23

Les objets du type date possèdent quelques méthodes. Nous allons passer en revue quelquesunes d’entre-elles.
2.5.1.1.1 ctime() La méthode ctime() retourne la date sous forme d’une chaîne de caractères. print(debut.ctime())
## Tue Apr 23 00:00:00 2013

2.5.1.1.2 weekday() La méthode weekday() retourne la position du jour de la semaine (lundi valant 0, dimanche 6) print(debut.weekday())
## 1
Remarque 2.5.2 Cette méthode peut être très pratique lors d’une analyse des données, pour explorer les aspects de saisonnalité hebdomadaire.

54

CHAPITRE 2. TYPES DE DONNÉES

2.5.1.1.3 isoweekday() Dans la même veine que weekday(), la méthode isoweekday() retourne la position du jour de la semaine, en attribuant cette fois la valeur 1 au lundi et 7 au dimanche. print(debut.isoweekday())
## 2

2.5.1.1.4 toordinal() La méthode toordinal() retourne le numéro du jour, en prenant comme référence la valeur 1 pour le premier jour de l’an 1. print(debut.toordinal())
## 734981

2.5.1.1.5 isoformat() La méthode isoformat() retourne la date en numérotation ISO, sous forme d’une chaîne de caractères. print(debut.isoformat())
## 2013-04-23

2.5.1.1.6 isocalendar() La méthode isocalendar() retourne un nuplet (c.f. Section 3.2) comprenant trois éléments : l’année, le numéro de la semaine et le jour de la semaine (les trois en numérotation ISO). print(debut.isocalendar())
## (2013, 17, 2)

2.5.1.1.7 replace() La méthode replace() retourne la date après avoir eﬀectué une modiﬁcation

2.5. DATES ET TEMPS

55

x = debut.replace(year=2014) y = debut.replace(month=5) z = debut.replace(day=24) print(x, y, z)
## 2014-04-23 2013-05-23 2013-04-24

Cela n’a pas d’incidence sur l’objet d’origine : print(debut)
## 2013-04-23

Il est possible de modiﬁer plusieurs éléments en même temps : x = debut.replace(day=24, month=5) print(x)
## 2013-05-24

2.5.1.1.8 strftime() La méthode strftime() retourne, sous la forme d’une chaîne de caractères, une représentation de la date, selon un masque utilisé. Par exemple, pour que la date soit représentée sous la forme DD-MM-YYYY (jour sur deux chiﬀres, mois sur deux chiﬀres et année sur 4) : print(debut.strftime("%d-%m-%Y"))
## 23-04-2013
Dans l’exemple précédent, on note deux choses : la présence de directives de formatage (qui commencent par le symbole de pourcentage) et des caractères autres (ici, les tirets). On peut noter que les caractères peuvent être remplacés par d’autres, il s’agit ici d’un choix pour représenter la date en séparant ses éléments par ddes tirets. Il est tout à fait possible d’adopter une autre écriture, par exemple avec des barres obliques, ou même d’autres chaînes de caractères : print(debut.strftime("%d/%m/%Y"))
## 23/04/2013

56

CHAPITRE 2. TYPES DE DONNÉES

print(debut.strftime("Jour : %d, Mois : %m, Annee : %Y"))
## Jour : 23, Mois : 04, Annee : 2013

Concernant les directives de formatage, elles correspondent aux codes requis par le standard C (c.f. la documentation de Python). En voici quelques-uns :

Table 2.3 – Codes de formatages

Code

Description

%a Abréviation du jour de la semaine (dépend du lieu)

%A

Jour de la semaine complet (dépend du lieu)

%b

Abréviation du mois (dépend du lieu)

%B

Nom du mois complet (dépend du lieu) octobre

%c Date et heure (dépend du lieu) au format %a %e %b

%H :%M :%S :%Y

%C Siècle (00-99) -1 (partie entière de la division de l’année

par 100)

%d

Jour du mois (01–31)

%D

Date au format %m/%d/%y

%e

Jour du mois en nombre décimal (1–31)

%F

Date au format %Y-%m-%d

%h

Même chose que %b

%H

Heure (00–24)

%I

Heure (01–12)

%j

Jour de l’année (001–366)

%m

Mois (01–12)

%M

Minute (00-59)

%n Retour à la ligne en output, caractère blanc en input

%p

AM/PM PM

%r

Heure au format 12 AM/PM

%R

Même chose que %H :%M

%S

Seconde (00-61)

%t

Tabulation en output, caractère blanc en input

%T

Même chose que %H :%M :%S

%u

Jour de la semaine (1–7), commence le lundi

%U Semaine de l’anné (00–53), dimanche comme début de

semaine, et le premier dimanche de l’année déﬁnit la

semaine

Exemple
Tue Tuesday
Apr April Tue Apr 23 00:00:00 2013
20
23 04/23/13
23 2013-04-23
Apr 00 12
113 04 00 \n AM
12:00:00 AM 00:00 00 \t
00:00:00 2
16

2.5. DATES ET TEMPS

Code

Description

%V

Semaine de l’année (00-53). Si la semaine (qui

commence un lundi) qui contient le 1 er janvier a

quatre jours ou plus dans la nouvelle année, alors elle

est considérée comme la semaine 1. Sinon, elle est

considérée comme la dernière de l’année précédente, et

la semaine suivante est considérée comme semaine 1

(norme ISO 8601)

%w

Jour de la semaine (0–6), dimanche étant 0

%W Semaine de l’année (00–53), le lundi étant le premier

jour de la semaine, et typiquement, le premier lundi de

l’année déﬁnit la semaine 1 (conviention G.B.)

%x

Date (dépend du lieu)

%X

Heure (dépend du lieu)

%y

Année sans le “siècle”" (00–99)

%Y

Année (en input, uniquement de 0 à 9999)

%z oﬀset en heures et minutes par rapport au temps UTC

%Z Abréviation du fuseau horaire (en output seulement)

CEST

57 Exemple
17
2 16
04/23/13 00:00:00
13 2013

2.5.1.2 Time
Les objets de type time désignent des temps précis sans prise en compte d’un jour particulier. Ils renseignant l’heure, la minute, la seconde (possiblement la microseconde et le fuseau horaire également).
Pour créer un objet time, la syntaxe est la suivante : time(hour, minute, second)
Par exemple, pour créer le moment 23 :04 :59 (vingt-trois heures, quatre minutes et cinquanteneuf secondes) : from datetime import time moment = time(hour = 23, minute = 4, second = 59) print(moment)
## 23:04:59

print(type(moment))
## <class datetime.time >

58

CHAPITRE 2. TYPES DE DONNÉES

On peut rajouter des informations sur la microseconde. Sa valeur doit être comprise entre zéro et un million. moment = time(hour = 23, minute = 4, second = 59, microsecond = 230) print(moment)
## 23:04:59.000230

print(type(moment))
## <class datetime.time >

On peut ensuite accéder aux attributs de la date créée (ce sont des entiers), parmi lesquels : print(moment.hour) # Extraire l heure
## 23
print(moment.minute) # Extraire la minute
## 4
print(moment.second) # Extraire la seconde
## 59

print(moment.microsecond) # Extraire la microseconde
## 230

Les objets du type time possèdent quelques méthodes, dont l’utilisation est similaire aux objets de classe date (se référer à la Section 2.5.1.1).
2.5.1.3 Datetime
Les objets de type datetime combinent les éléments des objets de type date et time. Ils renseignant le jour dans le calendrier grégorien ainsi que l’heure, la minute, la seconde (possiblement la microseconde et le fuseau horaire). Pour créer un objet datetime, la syntaxe est la suivante :

2.5. DATES ET TEMPS

59

datetime(year, month, day, hour, minute, second, microsecond)
Par exemple, pour créer la date 23-04-2013 à 17 :10 :00 : from datetime import datetime x = datetime(year = 2013, month = 4, day = 23,
hour = 23, minute = 4, second = 59) print(x)
## 2013-04-23 23:04:59

print(type(x))
## <class datetime.datetime >

Les objets de type datetime disposent des attributs des objets de type date (c.f. Section 2.5.1.1) et de type time (c.f. Section 2.5.1.2). Pour ce qui est des méthodes, davantage sont disponibles. Nous allons en commenter certaines.
2.5.1.3.1 today() et now() Les méthodes today() et now() retournent le datetime courant, celui au moment où est évaluée l’instruction : print(x.today())
## 2018-10-19 16:03:47.514049

print(datetime.today())
## 2018-10-19 16:03:47.515594

La distinction entre les deux réside dans le fuseau horaire. Avec today(), l’attribut tzinfo est mis à None, tandis qu’avec now(), l’attribut tzinfo, s’il est indiqué, est pris en compte.
2.5.1.3.2 timestamp() La méthode timestamp() retourne, sous forme d’un nombre à virgule ﬂottante, le timestamp POSIX correspondant à l’objet de type datetime. Le timestamp POSIX correspond à l’heure Posix, équivalent au nombre de secondes écoulées depuis le premier janvier 1970, à 00 :00 :00 UTC.

60
print(x.timestamp())
## 1366751099.0

CHAPITRE 2. TYPES DE DONNÉES

2.5.1.3.3 date() La méthode date() retourne un objet de type date dont les attributs d’année, de mois et de jour sont identiques à ceux de l’objet : x_date = x.date() print(x_date)
## 2013-04-23
print(type(x_date))
## <class datetime.date >

2.5.1.3.4 time() La méthode time() retourne un objet de type time dont les attributs d’heure, minute, seconde, microseconde sont identiques à ceux de l’objet : x_time = x.time() print(x_time)
## 23:04:59
print(type(x_time))
## <class datetime.time >

2.5.1.4 Timedelta
Les objets de type timedelta représentent des durées séparant deux dates ou heures. Pour créer un objet de type timedelta, la syntaxe est la suivante :

2.5. DATES ET TEMPS

61

timedelta(days, hours, minutes, seconds, microseconds)
Il n’est pas obligatoire de fournir une valeur à chaque paramètre. Lorsque qu’un paramètre ne reçoit pas de valeur, celle qui lui est attribuée par défaut est 0.
Par exemple, pour créer un objet indiquant une durée de 1 jour et 30 secondes : from datetime import timedelta duree = timedelta(days = 1, seconds = 30) duree
datetime.timedelta(1, 30)
On peut accéder ensuite aux attributs (ayant été déﬁnis). Par exemple, pour accéder au nombre de jours que représente la durée : duree.days
1
La méthode total_seconds() permet d’obtenir la durée exprimée en secondes : duree = timedelta(days = 1, seconds = 30, hours = 20) duree.total_seconds() 158430.0

2.5.1.4.1 Durée séparant deux objets date ou datetime
Lorsqu’on soustrait deux objets de type date, on obtient le nombre de jours séparant ces deux dates, sous la forme d’un objet de type timedelta : from datetime import timedelta debut = date(2018, 1, 1) fin = date(2018, 1, 2) nb_jours = fin-debut print(type(nb_jours))
## <class datetime.timedelta >

print(nb_jours)
## 1 day , 0:00:00

Lorsqu’on soustrait deux objets de type datetime, on obtient le nombre de jours, secondes (et microsecondes, si renseignées) séparant ces deux dates, sous la forme d’un objet de type timedelta :

62

CHAPITRE 2. TYPES DE DONNÉES

debut = datetime(2018, 1, 1, 12, 26, 30, 230) fin = datetime(2018, 1, 2, 11, 14, 31) duree = fin-debut print(type(duree))
## <class datetime.timedelta >

print(duree)
## 22:48:00.999770

On peut noter que les durée données prennent en compte les années bissextiles. Regardons d’abord pour une année non-bissextile, le nombre de jours séparant le 28 février du premier mars : debut = date(2021, 2,28) fin = date(2021, 3, 1) duree = fin - debut duree
datetime.timedelta(1)
Regardons à présent la même chose, mais dans le cas d’une année bissextile : debut_biss = date(2020, 2,28) fin_biss = date(2020, 3, 1) duree_biss = fin_biss - debut_biss duree_biss
datetime.timedelta(2)
Il est également possible d’ajouter des durées à une date : debut = datetime(2018, 12, 31, 23, 59, 59) print(debut + timedelta(seconds = 1))
## 2019-01-01 00:00:00

2.5.2 Module pytz
Si la gestion des dates revêt une importance particulière, une librairie propose d’aller un peu plus loins, notamment en ce qui concerne la gestion des fuseaux horaires. Cette librarie s’appelle pytz. De nombreux exemples sont proposés sur la page web du projet.

2.5. DATES ET TEMPS

63

2.5.3 Exercices

1. En utilisant la fonction appropriée, stocker la date du 29 août 2019 dans un objet que l’on appellera d puis aﬃcher le type de l’objet.
2. À l’aide de la fonction appropriée, aﬃcher la date du jour. 3. Stocker la date suivante dans un objet nommé d2 : “2019-08-29 20 :30 :56”. Puis, aﬃcher
dans la console avec la fonction print() les attributs d’année, de minute et de seconde de d2. 4. Ajouter 2 jours, 3 heures et 4 minutes à d2, et stocker le résultat dans un objet appelé d3. 5. Aﬃcher la diﬀérence en secondes entre d3 et d2. 6. À partir de l’objet d2, aﬃcher sous forme de chaîne de caractères la date de d2 de manière à ce qu’elle respecte la syntaxe suivante : “Mois Jour, Année”, avec “Mois”
le nom du mois (August), “Jour” le numéro du jour sur deux chiﬀres (29) et “Année”
l’année de la date (2019).

64

CHAPITRE 2. TYPES DE DONNÉES

Chapitre 3
Structures
Python dispose de plusieurs structures diﬀérentes intégrées de base. Nous allons aborder dans cette partie quelques unes d’entre-elles : les listes, les N-uplet (ou tuples), les ensembles et les dictionnaires.
3.1 Listes
Une des structures les plus ﬂexibles en Python est la liste. Il s’agit d’un regroupement de valeurs. La création d’une liste s’eﬀectue en écrivant les valeurs en les séparant par une virgule et en entourant l’ensemble par des crochets ([ et ]). x = ["Pascaline", "Gauthier", "Xuan", "Jimmy"] print(x)
## [ Pascaline , Gauthier , Xuan , Jimmy ]
Le contenu d’une liste n’est pas forcément du texte : y = [1, 2, 3, 4, 5] print(y)
## [1, 2, 3, 4, 5]
Il est même possible de faire ﬁgurer des éléments de type diﬀérent dans une liste : z = ["Piketty", "Thomas", 1971] print(z)
## [ Piketty , Thomas , 1971]
65

66

CHAPITRE 3. STRUCTURES

Une liste peut contenir une autre liste :
tweets = ["aaa", "bbb"] followers = ["Anne", "Bob", "Irma", "John"] compte = [tweets, followers] print(compte)
## [[ aaa , bbb ], [ Anne , Bob , Irma , John ]]

3.1.1 Extraction des éléments
L’accès aux éléments se fait grace à son indexation (attention, l’indice du premier élément est 0) : print(x[0]) # Le premier élément de x
## Pascaline
print(x[1]) # Le second élément de x
## Gauthier
L’accès à un élément peut aussi se faire en parant de la ﬁn, en faisant ﬁgurer le signe moins (-) devant l’indice : L’accès aux éléments se fait grace à son indexation (attention, l’indice du premier élément est 0) : print(x[-1]) # Le dernier élément de x
## Jimmy
print(x[-2]) # L avant dernier élément de x
## Xuan
Le découpage d’une liste de manière à obtenir un sous-ensemble de la liste s’eﬀectue avec les deux points (:) : print(x[1:2]) # Les premiers et seconds éléments de x
## [ Gauthier ]

3.1. LISTES

67

print(x[2:]) # Du second (non inclus) à la fin de x
## [ Xuan , Jimmy ]

print(x[:-2]) # Du premier à l avant dernier (non inclus)
## [ Pascaline , Gauthier ]

Remarque 3.1.1 Le découpage retourne également une liste.
Lors de l’extraction des éléments de la liste à l’aide des crochets, il est possible de rajouter un troisième paramètre, le pas : print(x[::2]) # Un élément sur deux
## [ Pascaline , Xuan ]

L’accès à des listes imbriquées s’eﬀectue en utilisant plusieurs fois les crochets : tweets = ["aaa", "bbb"] followers = ["Anne", "Bob", "Irma", "John"] compte = [tweets, followers] res = compte[1][3] # Le 4e élément du 2e élément de la liste compte
Le nombre d’éléments d’une liste s’obtient avec la fonction len() : print(len(compte))
## 2
print(len(compte[1]))
## 4

3.1.2 Modiﬁcation
Les listes sont mutables, c’est-à-dire que leur contenu peut être modiﬁé une fois l’objet créé.

68

CHAPITRE 3. STRUCTURES

3.1.2.1 Remplacement

Pour modiﬁer un élément dans une liste, on utilise l’indiçage : x = [1, 3, 5, 6, 9] x[3] = 7 # Remplacement du 4e élément print(x)
## [1, 3, 5, 7, 9]

3.1.2.2 Ajout d’éléments
Pour ajouter des éléments à une liste, on utilise la méthode append() : x.append(11) # Ajout de la valeur 11 en fin de liste print(x)
## [1, 3, 5, 7, 9, 11]
Il est aussi possible d’utiliser la méthode extend(), pour concaténer des listes : y = [13, 15] x.extend(y) print(x)
## [1, 3, 5, 7, 9, 11, 13, 15]

3.1.2.3 Suppression d’éléments
Pour retirer un élément d’une liste, on utilise la méthode remove() : x.remove(3) # Retire le 4e élément print(x)
## [1, 5, 7, 9, 11, 13, 15]
On peut aussi utiliser la commande del : x = [1, 3, 5, 6, 9] del x[3] # Retire le 4e élément print(x)

3.1. LISTES

69

## [1, 3, 5, 9]

3.1.2.4 Aﬀectations multiples
On peut modiﬁer plusieurs valeurs en même temps : x = [1, 3, 5, 6, 10] x[3:5] = [7, 9] # Remplace les 4e et 5e valeurs print(x)
## [1, 3, 5, 7, 9]
La modiﬁcation peut agrandir la taille de la liste : x = [1, 2, 3, 4, 5] x[2:3] = [ a , b , c , d ] # Remplace la 3e valeur print(x)
## [1, 2, a , b , c , d , 4, 5]
On peut supprimer plusieurs valeurs en même temps : x = [1, 2, 3, 4, 5] x[3:5] = [] # Retire les 4e et 5e valeurs print(x)
## [1, 2, 3]

3.1.3 Test d’appartenance
En utilisant l’opérateur in, on peut tester l’appartenance d’un objet à une liste : x = [1, 2, 3, 4, 5] print(1 in x)
## True

70

CHAPITRE 3. STRUCTURES

3.1.4 Copie de liste

Attention, la copie d’une liste n’est pas triviale en Python. Prenons un exemple. x = [1, 2, 3] y=x
Modiﬁons le premier élément de y, et observons le contenu de y et de x : y[0] = 0 print(y)
## [0, 2, 3]

print(x)
## [0, 2, 3]

Comme on peut le constater, le fait d’avoir utilisé le signe égal a simplement créé une référence et non pas une copie.
Pour eﬀectuer une copie de liste, plusieurs façons existent. Parmi elles, l’utilisation de la fonction list() :
x = [1, 2, 3] y = list(x) y[0] = 0 print("x : ", x)
## x : [1, 2, 3]

print("y : ", y)
## y : [0, 2, 3]

On peut noter que lorsque l’on fait un découpement, un nouvel objet est créé, pas une référence :
x = [1, 2, 3, 4] y = x[:2] y[0] = 0 print("x : ", x)
## x : [1, 2, 3, 4]

3.2. N-UPLETS (TUPLES)

71

print("y : ", y)
## y : [0, 2]

3.1.5 Tri
Pour trier les objets de la liste (sans en créer une nouvelle), Python propose la méthode sort() : x = [2, 1, 4, 3] x.sort() print(x)
## [1, 2, 3, 4]
Cela fonctionne également avec des valeurs textuelles, en triant par ordre alphabétique : x = ["c", "b", "a", "a"] x.sort() print(x)
## [ a , a , b , c ]
Il est possible de fournir à la méthode sort() des paramètres. Parmi ces paramètres, il en est un, key, qui permet de fournir une fonction pour eﬀectuer le tri. Cette fonction doit retourner une valeur pour chaque objet de la liste, sur laquelle le tri sera eﬀectué. Par exemple, avec la fonction len(), qui, lorsqu’appliquée à du texte, retourne le nombre de caractères : x = ["aa", "a", "aaaaa", "aa"] x.sort(key=len) print(x)
## [ a , aa , aa , aaaaa ]

3.2 N-uplets (Tuples)
Les n-uplets, ou tuples sont des séquences d’objets Python. Pour créer un n-uplet, on liste les valeurs, séparées par des virgules :

72
x = 1, 4, 9, 16, 25 print(x)
## (1, 4, 9, 16, 25)

CHAPITRE 3. STRUCTURES

On note que les n-uplets sont repérés par une suite de valeurs, entourées dans deux parenthèses.
3.2.1 Extraction des éléments
Les éléments d’un n-uplet s’extraient de la même manière que ceux des listes (c.f. Section 3.1.1). print(x[0])
## 1

3.2.2 Modiﬁcation
Contrairement aux listes, les n-uplets sont inaltérables (c’est-à-dire ne pouvant pas être modifés après avoir été créés) : x[0] = 1
## TypeError: tuple object does not support item assignment ## ## Detailed traceback: ## File "<string >", line 1, in <module >
Il est possible d’imbriquer des n-uplets à l’intérieur d’un autre n-uplet. Pour ce faire, on a recours à l’utilisation de parenthèses : x = ((1, 4, 9, 16), (1, 8, 26, 64)) print(x)
## ((1, 4, 9, 16), (1, 8, 26, 64))

3.3 Ensembles
Les ensembles (sets) sont des collections non ordonnée d’éléments uniques. Les ensembles sont inaltérables, et non indexés.

3.3. ENSEMBLES

73

Pour créer un ensemble, Python fournit la fonction set(). On fournit un ou plusieurs éléments constituant l’ensemble, en les séparant par des virgules et en entourant l’ensemble d’accolades ({}) :
ensemble = set({"Marseille", "Aix-en-Provence", "Nice", "Rennes"}) print(ensemble)
## { Aix -en -Provence , Rennes , Nice , Marseille }

De manière équivalent, on peut ne pas utiliser la fonction set() et déﬁnir l’ensemble uniquement à l’aide des crochets :
ensemble = {"Marseille", "Aix-en-Provence", "Nice", "Rennes"} print(ensemble)
## { Aix -en -Provence , Rennes , Nice , Marseille }

En revanche, si l’ensemble est vide, Python retourne un erreur si la fonction set() n’est pas utilisée : il est nécessaire d’utiliser la fonction set : ensemble_vide = {} type(ensemble_vide)
Le type de l’objet que l’on vient de créer n’est pas set mais dict (c.f. Section 3.4). Aussi, pour créer l’ensemble vide, on utilise set() : ensemble_vide = set() print(type(ensemble_vide))
## <class set >

Lors de la création, s’il existe des doublons dans les valeurs fournies, ils seront supprimés pour ne garder qu’une seule valeur : ensemble = set({"Marseille", "Aix-en-Provence", "Nice", "Marseille", "Rennes"}) print(ensemble)
## { Aix -en -Provence , Rennes , Nice , Marseille }

La longueur d’un ensemble s’obtient à l’aide de la fonction len() : print(len(ensemble))
## 4

74

CHAPITRE 3. STRUCTURES

3.3.1 Modiﬁcations

3.3.1.1 Ajout

Pour ajouter un élément à un ensemble, Python oﬀre la méthode add() : ensemble.add("Toulon") print(ensemble)
## { Nice , Rennes , Aix -en -Provence , Toulon , Marseille }

Si l’élément est déjà présent, il ne sera pas ajouté : ensemble.add("Toulon") print(ensemble)
## { Nice , Rennes , Aix -en -Provence , Toulon , Marseille }

3.3.1.2 Suppression
Pour supprimer une valeur d’un ensemble, Python propose la méthode remove() : ensemble.remove("Toulon") print(ensemble)
## { Nice , Rennes , Aix -en -Provence , Marseille }
Si la valeur n’est pas présente dans l’ensemble, Python retourne un message d’erreur : ensemble.remove("Toulon")
## KeyError: Toulon ## ## Detailed traceback: ## File "<string >", line 1, in <module >
print(ensemble)
## { Nice , Rennes , Aix -en -Provence , Marseille }

3.3. ENSEMBLES

75

3.3.2 Test d’appartenance

Un des intérêts des ensembles est la recherche rapide de présence ou absence de valeurs (plus rapide que dans une liste). Comme pour les listes, les tests d’appartenance s’eﬀectuent à l’aide de l’opérateur in : print("Marseille" in ensemble)
## True

print("Paris" in ensemble)
## False

3.3.3 Copie d’ensemble
Pour copier un ensemble, comme pour les listes (c.f. Section 3.1.4), il ne faut pas utiliser le signe d’égalité. La copie d’un ensemble se fait à l’aide de la méthode copy() : ensemble = set({"Marseille", "Aix-en-Provence", "Nice"}) y = ensemble.copy() y.add("Toulon") print("y : ", y)
## y : { Aix -en -Provence , Toulon , Nice , Marseille }
print("ensemble : ", ensemble)
## ensemble : { Aix -en -Provence , Nice , Marseille }

3.3.4 Conversion en liste
Un des intérêts des ensembles est est qu’ils contiennent des éléments uniques. Aussi, lorsque l’on souhaite obtenir les éléments distincts d’une liste, il est possible de la convertir en ensemble (avec la fonction set()), puis de convertir l’ensemble en liste (avec la fonction list()) : ma_liste = ["Marseille", "Aix-en-Provence", "Marseille", "Marseille"] print(ma_liste)

76

CHAPITRE 3. STRUCTURES

## [ Marseille , Aix -en -Provence , Marseille , Marseille ]

mon_ensemble = set(ma_liste) print(mon_ensemble)
## { Aix -en -Provence , Marseille }

ma_nouvelle_liste = list(mon_ensemble) print(ma_nouvelle_liste)
## [ Aix -en -Provence , Marseille ]

3.4 Dictionnaires
Les dictionnaires en Python sont une implémentation d’objets clé-valeurs, les clés étant indexées.
Les clés sont souvent du texte, les valeurs peuvent être de diﬀérents types et diﬀérentes structures. Pour créer un dictionnaire, on peut procéder en utilisant des accolades ({}). Comme rencontré dans la Section 3.3, si on évalue le code suivant, on obtient un dictionnaire : dict_vide = {} print(type(dict_vide))
## <class dict >
Pour créer un dictionnaire avec des entrée, on peut utiliser les accolades, on sépare chaque entrée par des virgules, et on distingue la clé de la valeur associée par deux points (:) : mon_dict = { "nom": "Kyrie",
"prenom": "John", "naissance": 1992, "equipes": ["Cleveland", "Boston"]} print(mon_dict)
## { nom : Kyrie , prenom : John , naissance : 1992, equipes : [ Cleveland , Boston ]}

3.4. DICTIONNAIRES

77

Il est aussi possible de créer un dictionnaire à l’aide de la fonction dict(), en fournissant une séquence de clés-valeurs :
x = dict([("Julien-Yacine", "Data-scientist"), ("Sonia", "Directrice")])
print(x)
## { Julien -Yacine : Data -scientist , Sonia : Directrice }

3.4.1 Extraction des éléments
L’extraction dans les dictionnaires repose sur le même principe que pour les listes et les n-uplets (c.f. Section @ref(#structure-liste-extraction)). Toutefois, l’extraction d’un élément d’un dictionnaire ne se fait pas en fonction de sa position dans le dictionnaire, mais par sa clé : print(mon_dict["prenom"])
## John
print(mon_dict["equipes"])
## [ Cleveland , Boston ]
Si l’extraction s’eﬀectue par une clé non présente dans le dictionnaire, une erreur sera retournée : print(mon_dict["age"])
## KeyError: age ## ## Detailed traceback: ## File "<string >", line 1, in <module >
On peut tester la présence d’une clé avec l’opérateur in : print("prenom" in mon_dict)
## True

78
print("age" in mon_dict)
## False

CHAPITRE 3. STRUCTURES

L’extraction de valeurs peut aussi se faire à l’aide de la méthode get(), qui retourne une valeur None si la clé n’est pas présente : print(mon_dict.get("prenom"))
## John

print(mon_dict.get("age"))
## None

3.4.2 Clés et valeurs
À l’aide de la méthode key(), on peut accéder aux clés du dictionnaire : les_cles = mon_dict.keys() print(les_cles)
## dict_keys([ nom , prenom , naissance , equipes ])
print(type(les_cles))
## <class dict_keys >
Il est possible par la suite de transformer cette énumération de clés en liste : les_cles_liste = list(les_cles) print(les_cles_liste)
## [ nom , prenom , naissance , equipes ]
La méthode values() fournit quand à elle les valeurs du dictionnaire : les_valeurs = mon_dict.values() print(les_valeurs)

3.4. DICTIONNAIRES

79

## dict_values([ Kyrie , John , 1992, [ Cleveland , Boston ]])

print(type(les_valeurs))
## <class dict_values >

La méthode items() fournit quand à elle les clés et valeurs sous forme de n-uplets : les_items = mon_dict.items() print(les_items)
## dict_items([( nom , Kyrie ), ( prenom , John ), ( naissance , 1992), ( equipes , [ Cleveland , Boston ])])
print(type(les_items))
## <class dict_items >

3.4.3 Recherche d’appartenance
Grâce aux méthodes keys(), values() et items(), il est aisé de rechercher la présence d’objets dans un dictionnaire. print("age" in les_cles)
## False
print("nom" in les_cles)
## True
print([ Cleveland , Boston ] in les_valeurs)
## True

80

CHAPITRE 3. STRUCTURES

3.4.4 Modiﬁcation

3.4.4.1 Remplacement

Pour remplacer la valeur associée à une clé, on peut utiliser les crochets ([]) et le signe d’égalité (=).
Par exemple, pour remplacer les valeurs associées à la clé equipes :
mon_dict["equipes"] = ["Montclair Kimberley Academy", "Cleveland Cavaliers", "Boston Celtics"]
print(mon_dict)
## { nom : Kyrie , prenom : John , naissance : 1992, equipes : [ Montclair Kimberley Academy , Cleveland Cavaliers , Boston Celtics ]}

3.4.4.2 Ajout d’éléments
L’ajout d’un élément dans un dictionnaire peut s’eﬀectuer avec les crochets ([]) et le signe d’égalité (=) : mon_dict["taille_cm"] = 191 print(mon_dict)
## { nom : Kyrie , prenom : John , naissance : 1992, equipes : [ Montclair Kimberley Academy , Cleveland Cavaliers , Boston Celtics ], taille_cm : 191}
Pour ajouter le contenu d’un autre dictionnaire à un dictionnaire, Python propose la méthode update(). Créons un second dictionnaire dans un premier temps : second_dict = {"masse_kg" : 88, "debut_nba" : 2011} print(second_dict)
## { masse_kg : 88, debut_nba : 2011}
Ajoutons le contenu de ce second dictionnaire au premier : mon_dict.update(second_dict) print(mon_dict)

3.4. DICTIONNAIRES

81

## { nom : Kyrie , prenom : John , naissance : 1992, equipes : [ Montclair Kimberley Academy , Cleveland Cavaliers , Boston Celtics ], taille_cm : 191, masse_kg : 88, debut_nba : 2011}

Si on modiﬁe par la suite le second dictionnaire, cela n’aura pas d’incidence sur le premier : second_dict["poste"] = "PG" print(second_dict)
## { masse_kg : 88, debut_nba : 2011, poste : PG }
print(mon_dict)
## { nom : Kyrie , prenom : John , naissance : 1992, equipes : [ Montclair Kimberley Academy , Cleveland Cavaliers , Boston Celtics ], taille_cm : 191, masse_kg : 88, debut_nba : 2011}

3.4.4.3 Suppression d’éléments
La suppression d’un élément dans un dictionnaire peut s’eﬀectuer de plusieurs manières. Par exemple, avec l’opérateur del : del mon_dict["debut_nba"] print(mon_dict)
## { nom : Kyrie , prenom : John , naissance : 1992, equipes : [ Montclair Kimberley Academy , Cleveland Cavaliers , Boston Celtics ], taille_cm : 191, masse_kg : 88}
Il est également possible d’utiliser la méthode pop() : res = mon_dict.pop("masse_kg") print(mon_dict)
## { nom : Kyrie , prenom : John , naissance : 1992, equipes : [ Montclair Kimberley Academy , Cleveland Cavaliers , Boston Celtics ], taille_cm : 191}
Dans l’instruction précédente, nous avons ajouté une assignation du résultat de l’appliation de la méthode pop() à une variable nommée res. Comme on peut le constater, la méthode pop(), en plus d’avoir supprimé la clé, a retourné la valeur associée :

82
print(res)
## 88

CHAPITRE 3. STRUCTURES

3.4.5 Copie de dictionnaire
Pour copier un dictionnaire, et non créer une référence (ce qui est le cas si on utilise le signe d’égalité), Python fournit comme pour les ensembles, une méthode copy() : d = {"Marseille": 13, "Rennes" : 35} d2 = d.copy() d2["Paris"] = 75 print("d: ", d)
## d: { Marseille : 13, Rennes : 35}
print("d2: ", d2)
## d2: { Marseille : 13, Rennes : 35, Paris : 75}

3.4.6 Exercice
1. Créer un dictionnaire nommé photo, comprenant les couples clés-valeurs suivants : 2. clé : id, valeur : 1, 3. clé : description, valeur : Une photo du Vieux-port de Marseille, 4. clé : loc, valeur : une liste dans laquelle sont données les coordonnées suivantes
5.3772133, 43.302424. 2.Ajouter le couple de clé-valeur suivant au dictionnaire photo : clé : utilisateur, valeur : bob. 5. Rechercher s’il existe une entrée dont la clé vaut description dans le dictionnaire photo. Si tel est le cas, aﬃcher l’entrée correspondante (clé et valeur). 6. Supprimer l’entrée dans photo dont la clé vaut utilisateur. 7. Modiﬁer la valeur de l’entrée loc dans le dictionnaire photo, pour proposer une nouvelle liste, dont les coordonnées sont les suivantes : 5.3692712 et 43.2949627.

Chapitre 4
Opérateurs
Python comprend diﬀérents opérateurs, permettant d’eﬀectuer des opérations entre les opérandes, c’est-à-dire entre des variables, des littéraux ou encore des expressions.
4.1 Opérateurs arithmétiques
Les opérateurs arithmétiques de base sont intégrés dans Python. Nous avons déjà utilisé dans les chapitres précédents certains d’entre eux, pour eﬀectuer des opérations sur les entiers ou les nombres à virgule ﬂotante (addition, soustraction, etc.). Faisons un tour rapide des opérateurs arithmétiques les plus courants permettant de réaliser des opérations sur des nombres.
4.1.1 Addition
On eﬀectue une addition entre deux nombres à l’aide du symbole + : print(1+1) # Addition
## 2
4.1.2 Soustraction
On eﬀectue une soustraction entre deux nombres à l’aide du symbole - : print(1-1) # Soustraction
83

84
## 0

CHAPITRE 4. OPÉRATEURS

4.1.3 Multiplication
On eﬀectue une multiplication entre deux nombres à l’aide du symbole * : print(2*2) # Multiplication
## 4

4.1.4 Division
On eﬀectue une division (réelle) entre deux nombres à l’aide du symbole / : print(3/2) # Division
## 1.5
Pour eﬀectuer une division entière, on double la barre oblique : print(3//2) # Division entière
## 1

4.1.5 Modulo
Le modulo (reste de la division euclidienne) s’obtient à l’aide du symbole % : print(12%10) # Modulo
## 2

4.1.6 Puissance
Pour élever un nombre à une puissance données, on utilise deux étoiles (**) :

4.1. OPÉRATEURS ARITHMÉTIQUES

85

print(2**3) # 2 élevé à la puissance 3
## 8

4.1.7 Ordre
L’ordre des opérations suit la règle PEMDAS (Parentheses, Exponents, Multiplication and Division, Addition and Subtraction). Par exemple, l’instruction suivante eﬀectue d’abord le calcul 2 × 2, puis ajoute 1 : print(2*2+1)
## 5
L’instruction suivante, grâce aux parenthèses, eﬀectue d’abord le calcul 2 + 1, puis la multiplication du résultat avec 2 : print(2*(2+1))
## 6

4.1.8 Opérateurs mathématiques sur des chaînes de caractères
Certains opérateurs mathématiques présentés dans la Section 4.1 peuvent-être appliquées à des chaînes de caractères. Lorsque l’on utilise le symbole + entre deux chaînes de caractères, Python concatène ces deux chaînes (cf. Section 2.1.1) : a = "euro" b = "dollar" print(a+b)
## eurodollar
Lorsqu’on “multiplie” une chaîne par un scalaire n, Python répète la chaîne le nombre n fois : 2*a

86

CHAPITRE 4. OPÉRATEURS

4.1.9 Opérateurs mathématiques sur des listes ou des n-uplets

Certains opérateurs mathématiques peuvent également être appliquées à des listes.
Lorsque l’on utilise le symble + entre deux listes, Python les concatène en une seule : l_1 = [1, "pomme", 5, 7] l_2 = [9, 11] print(l_1 + l_2)
## [1, pomme , 5, 7, 9, 11]

Idem avec des n-uplets : t_1 = (1, "pomme", 5, 7) t_2 = (9, 11) print(t_1 + t_2)
## (1, pomme , 5, 7, 9, 11)

En “multipliant” une liste par un scalaire n, Python répète n fois cette liste : print(3*l_1)
## [1, pomme , 5, 7, 1, pomme , 5, 7, 1, pomme , 5, 7]

Idem avec des n-uplets : print(3*t_1)
## (1, pomme , 5, 7, 1, pomme , 5, 7, 1, pomme , 5, 7)

4.2 Opérateurs de comparaison

Les opérateurs de comparaisons permettent de comparer entre eux des objets de tous les types de base. Le résultat d’un test de comparaison produit des valeurs booléennes.
Table 4.1 – Opérateurs de comparaison

Opérateur Opérateur en Python

=

==

Description Égal à

4.2. OPÉRATEURS DE COMPARAISON

87

Opérateur Opérateur en Python

Description

=

!= (ou <>)

Diﬀérent de

>

>

Supérieur à

≥

>= & Supérieur ou égal à

<

<

Inférieur à

≤

<=

Inférieur ou égal à

∈

in

Dans

∈/

not in

Exclu

4.2.1 Égalité, inégalité
Pour tester l’égalité de contenu entre deux objets : a = "Hello" b = "World" c = "World" print(a == c)
## False
print(b == c)
## True

L’inégalité entre deux objets : x = [1,2,3] y = [1,2,3] z = [1,3,4] print(x != y)
## False
print(x != z)
## True

88

CHAPITRE 4. OPÉRATEURS

4.2.2 Infériorité et supériorité, stricts ou larges

Pour savoir si un objet est inférieur (strictement ou non) ou inférieur (strictement ou non) à un autre : x=1 y=1 z=2
print(x < y)
## False

print(x <= y)
## True

print(x > z)
## False

print(x >= z)
## False

On peut également eﬀectuer la comparaison entre deux chaînes de caractères. La comparaison s’eﬀectue en fonction de l’ordre lexicographique : m_1 = "mange" m_2 = "manger" m_3 = "boire" print(m_1 < m_2) # mange avant manger
## True
print(m_3 > m_1) # boire avant manger
## False

4.2. OPÉRATEURS DE COMPARAISON

89

Lorsque l’on compare deux listes entre-elles, Python fonctionne pas à pas. Regardons à travers un exemple comment cette comparaison est eﬀectuée.
Créons deux listes : x = [1, 3, 5, 7] y = [9, 11]
Python va commencer par comparer les premiers éléments de chaque liste (ici, c’est possible, les deux éléments sont comparables ; dans le cas contraire, une erreur serait retournée) : print(x < y)
## True

Comme 1<9, Python retourne True.
Changeons x pour que le premier élément soit supérieur au premier de y x = [10, 3, 5, 7] y = [9, 11] print(x < y)
## False

Cette fois, comme 10 > 9, Python retourne False.
Changeons à présent le premier élément de x pour qu’ils soit égal à celui de y : x = [10, 3, 5, 7] y = [10, 11] print(x < y)
## True

Cette fois, Python compare le premier élement de x avec celui de y, comme les deux sont identiques, les seconds éléments sont comparés. On peut s’en convaincre en évaluant le code suivant :
x = [10, 12, 5, 7] y = [10, 11] print(x < y)
## False

90

CHAPITRE 4. OPÉRATEURS

4.2.3 Inclusion et exclusion

Comme rencontré plusieurs fois dans le Chapitre 3, les tests d’inclusions s’eﬀectuent à l’aide de l’opérateur in. print(3 in [1,2, 3])
## True

Pour tester si un élément est exclu d’une liste, d’un n-uplet, dictionnaire, etc., on utilise not in : print(4 not in [1,2, 3])
## True
print(4 not in [1,2, 3, 4])
## False

Avec un dictionnaire :
dictionnaire = {"nom": "Rockwell", "prenom": "Criquette"} "age" not in dictionnaire.keys()

4.3 Opérateurs logiques
Les opérateurs logiques opèrent sur un ou plusieurs objets de type logique (des booléens).
4.3.1 Et logique
L’opérateur and permet d’eﬀectuer des comparaisons “ET” logiques. On compare deux objets, x et y (ces objets peuvent résulter d’une comparaison préalable, il suﬃt juste que tous deux soient des booléens). Si l’un des deux objets x et y est vrai, la comparaison “ET” logique retourne vrai : x = True y = True print(x and y)

4.3. OPÉRATEURS LOGIQUES

91

## True

Si au moins l’un des deux est faux, la comparaison “ET” logique retourne faux : x = True y = False print(x and y)
## False
print(y and y)
## False

Si un des deux objets comparés vaut la valeur vide (None), alors la comparaison “ET” logique retourne :
— la valeur None si l’autre objet vaut True ou None ; — la valeur False si l’autre objet vaut False x = True y = False z = None print(x and z)
## None
print(y and z)
## False
print(z and z)
## None

4.3.2 Ou logique
L’opérateur or permet d’eﬀectuer des comparaisons “OU” logiques. À nouveau, on compare deux booléens, x et y.

92

CHAPITRE 4. OPÉRATEURS

Si au moins un des deux objets x et y est vrai, la comparaison “OU” logique retourne vrai : x = True y = False print(x or y)
## True

Si les deux sont faux, la comparaison “OU” logique retourne faux : x = False y = False print(x or y)
## False

Si l’un des deux objets vaut None, la comparaison “OU” logique retourne : — True si l’autre objet vaut True ; — None si l’autre objet vaut False ou None
x = True y = False z = None print(x or z)
## True
print(y or z)
## None
print(z or z)
## None

4.3.3 Non logique
L’opérateur not, lorsqu’appliqué à un booléen, évalue ce dernier à sa valeur opposée :

4.4. QUELQUES FONCTIONS

93

x = True y = False print(not x)
## False

print(not y)
## True

Lorsque l’on utilise l’opérateur not sur une valeur vide (None), Python retourne True :
x = None not x

4.4 Quelques fonctions

Python dispose de nombreuses fonctions utiles pour manipuler les structures et données. Le tableau suivant en répertorie quelques-unes. Certaines nécessitent le chargement de la librairie math, d’autres la librairie statistics. Nous verrsons d’autres fonctions propres à la librairie NumPy au Chapitre 9.
Table 4.2 – Quelques fonctions numériques

Fonction
math.ceil(x) math.copysign(x,
y) math.floor(x) math.round(x,
ndigits) math.fabs(x)
math.exp(x) math.log(x) math.log(x, b) math.log10(x) math.pow(x,y) math.sqrt(x) math.fsum() math.sin(x) math.cos(x)

Description
Plus petits entier supérieur ou égal à x Valeur absolue de x mais avec le signe de y
Plus petits entier inférieur ou égal à x Arrondi de x à ndigits décimales près
Valeur absolue de x Exponentielle de x Logarithme naturel de x (en base e) Logarithme en base b de x Logarithme en base 10 de x x élevé à la puissance y Racine carrée de x Somme des valeurs de x
Sinus de x Cosinus de x

94

CHAPITRE 4. OPÉRATEURS

Fonction

Description

math.tan(x)

Tangente de x

math.asin(x)

Arc-sinus de x

math.acos(x)

Arc-cosinus de x

math.atan(x)

Arc-tangente de x

math.sinh(x)

Sinus hyperbolique de x

math.cosh(x)

Cosinus hyperbolique de x

math.tanh(x)

Tangente hyperbolique de x

math.asinh(x)

Arc-sinus hyperbolique de x

math.acosh(x)

Arc-cosinus hyperbolique de x

math.atanh(x)

Arc-tangente hyperbolique de x

math.degree(x)

Conversion de x de radians en degrés

math.radians(x)

Conversion de x de degrés en radians

math.factorial()

Factorielle de x

math.gcd(x, y)

Plus grand commun diviseur de x et y

math.isclose(x, Compare x et y et retourne s’ils sont proches au reard

y,

de la tolérance rel_tol (abs_tol est la tolérance

rel_tol=1e-09,

minimum absolue)

abs_tol=0.0)

math.isfinite(x)

Retourne True si x est soit l’inﬁni, soir NaN

math.isinf(x)

Retourne True si x est l’inﬁni, False sinon

math.isnan(x)

Retourne True si x est NaN, False sinon

statistics.mean(x)

Moyenne de x

statistics.median(x)

Médiane de x

statistics.mode(x)

Mode de x

statistics.stdev(x)

Écart-type de x

statistics.variance(x)

Variance de x

4.5 Quelques constantes

La librairie math propose quelques constantes : Table 4.3 – Quelques constantes intégrées dans Python

Fonction

Description

math.pi math.e
math.tau math.inf -math.inf math.nan

Le nombre Pi (π) La constante e
La constante τ , égale à 2π L’inﬁni (∞)
Moins l’inﬁni (−∞) Nombre à virgule ﬂotante not a number

4.6. EXERCICE

95

4.6 Exercice

1. Calculer le reste de la division euclidienne de 10 par 3. 2. Aﬃcher le plus grand commun diviseur entre 6209 et 4435. 3. Soient deux objets : a = 18 et b = -4. Tester si :
— a est inférieur à b strictement, — a est supérieur ou égal à b, — a est diﬀérent de b.
4. Soit la liste x = [1, 1, 2, 3, 5, 8]. Regarder si :
— 1 est dans x ; — 0 est dans x ; — 1 et 0 sont dans x ; — 1 ou 0 sont dans x ; — 1 ou 0 n’est pas présent dans x.

96

CHAPITRE 4. OPÉRATEURS

Chapitre 5
Chargement et sauvegarde de données
Pour explorer des données et/ou réaliser des analyses statistiques ou économétriques, il est important de savoir importer et exporter des données. Avant toute chose, il convient d’évoquer la notion de répertoire courant (working directory). En informatique, le répertroire courant d’un processus désigne un répertoire du système de ﬁchier associé à ce processus. Lorsqu’on lance Jupyter, une arborescence nous est proposée, et nous navigons à l’interieur de celle-ci pour créer ou ouvrir un notebook. Le répertoire contenant le notebook est le répertoire courant. Lorsqu’on indiquera à Python d’importer des données (ou d’exporter des objets), l’origine (ou la destination) sera indiquée relativement au répertoire courant, à moins d’avoir recours à des chemins absolus (c’est-à-dire un chemin d’accès à partir de la racine /). Si on lance un programme Python depuis un terminal, le répertoire courant est le répertoire dans lequel on se trouve dans le terminal au moment de lancer le programme. Pour aﬃcher dans Python le répertoire courant, on peut utiliser le code suivant : import os cwd = os.getcwd() print(cwd)
## /Users/ewengallic/Dropbox/Universite_Aix_Marseille/ Magistere_2_Programming_for_big_data/Cours/chapters/python/ Python_pour_economistes
Remarque 5.0.1 La fonction listdir() de la librairie os est très pratique : elle permet de lister tous les documents et répertoires contenus dans le répertoire couant, ou dans n’importe quel répertoire si le paramètre path renseigne le chemin (absolu ou relatif). Après avoir importé la fonction (from os import getcwd), on peut l’appeler : os.listdir().
97

98

CHAPITRE 5. CHARGEMENT ET SAUVEGARDE DE DONNÉES

5.1 Charger des données

En fonction du format d’enregistrement des données, les techniques d’importation de données diﬀèrent.
Remarque 5.1.1
Le Chapitre 10 propose d’autres manières d’importer les données, avec la libraririe pandas.

5.1.1 Fichiers textes

Lorsque les données sont présentes dans un ﬁchier texte (ASCII), Python propose d’utiliser la fonction open().
La syntaxe (simpliﬁée) de la fonction open() est la suivante :
open(file, mode= r , buffering=-1, encoding=None, errors=None, newline=None)
Voici à quoi correspondent les paramètres (il en existe d’autres) :
— file : une chaîne de caractères indiquant le chemin et le nom du ﬁchier à ouvrir ; — mode : spéciﬁe la manière par laquelle le ﬁchier est ouvert (c.f. juste après pour les
valeurs possibles) ; — buffering : spéciﬁe à l’aide d’un entier le comportement à adopter pour la mise en
mémoire tampon (1 pour mettre en mémoire par ligne ; un entier > 1 pour indiquer la taille en octets des morceaux à charger en mémoire tampon) ; — encoding : spéciﬁe l’encodage du ﬁchier ; — errors : spéciﬁe la manière de gérer les erreurs d’encodage et de décodage (e.g., strict retourne une erreur d’exception, ignore permet d’ignorer les erreurs, replace de les remplacer, backslashreplace de remplacer les données mal formées par des séquences d’échappement) ; — newline : contrôle la ﬁn des lignes (\n, \r, etc.).
Table 5.1 – Valeurs principales pour la manière d’ouvrir les ﬁchiers.

Valeur r w x
a
+

Description
Ouverture pour lire (défaut) Ouverture pour écrire
Ouverture pour créer un document, échoue si le ﬁchier existe déjà
Ouverture pour écrire, en venant ajouter à la ﬁn du ﬁchier si celui-ci existe déjà
Ouverture pour mise à jour (lecture et écriture)

5.1. CHARGER DES DONNÉES

99

Valeur

Description

b À ajouter à un mode d’ouverture pour les ﬁchiers binaires (rb ou wb)
t Mode texte (décodage automatique des octets en Unicode). Par défaut si non spéciﬁé (s’ajoute au mode, comme b)

Il est important de bien penser à fermer le ﬁchier une fois qu’on a terminé de l’utiliser. Pour ce faire, on utilise la méthode close().
Dans le dossier fichiers_exemples se trouve un ﬁchier appelé fichier_texte.txt qui contient trois lignes de texte. Ouvrons ce ﬁchier, et utilisons la méthode .read() pour aﬃcher son contenu :
path = "./fichiers_exemples/fichier_texte.txt" # Ouverture en mode lecture (par défaut) mon_fichier = open(path, mode = "r") print(mon_fichier.read())
## Bonjour , je suis un fichier au format txt. ## Je contiens plusieurs lignes , l idée étant de montrer comment
fonctionne l importation d un tel fichier dans Python. ## Trois lignes devraient suffir.

mon_fichier.close()
Une pratique courante en Python est d’ouvrir un ﬁchier dans un bloc with. La raison de ce choix est qu’un ﬁchier ouvert dans un tel bloc est automatiquement refermé à la ﬁn du bloc.
La syntaxe est la suivante :
# Ouverture en mode lecture (par défaut) with open(path, "r") as mon_fichier:
donnees = fonction_pour_recuperer_donnees_depuis_mon_fichier()
Par exemple, pour récupérer chaque ligne comme un élément d’une liste, on peut utiliser une boucle parcourant chaque ligne du ﬁchier. À chaque itération, on récupère la ligne :
# Ouverture en mode lecture (par défaut) with open(path, "r") as mon_fichier:
donnees = [x for x in mon_fichier] print(donnees)
## [ Bonjour , je suis un fichier au format txt.\n , "Je contiens plusieurs lignes , l idée étant de montrer comment fonctionne l importation d un tel fichier dans Python.\n", Trois lignes devraient suffir. ]

100

CHAPITRE 5. CHARGEMENT ET SAUVEGARDE DE DONNÉES

Note : à chaque itération, on peut appliquer la méthode strip(), qui retourne la chaîne de caractère de la ligne, en retirant les éventuels caractères blancs en début de chaîne :
# Ouverture en mode lecture (par défaut) with open(path, "r") as mon_fichier:
donnees = [x.strip() for x in mon_fichier] print(donnees)
## [ Bonjour , je suis un fichier au format txt. , "Je contiens plusieurs lignes , l idée étant de montrer comment fonctionne l importation d un tel fichier dans Python.", Trois lignes devraient suffir. ]

On peut également utiliser la méthode readlines() pour importer les lignes dans une liste :
with open(path, "r") as mon_fichier: donnees = mon_fichier.readlines()
print(donnees)
## [ Bonjour , je suis un fichier au format txt.\n , "Je contiens plusieurs lignes , l idée étant de montrer comment fonctionne l importation d un tel fichier dans Python.\n", Trois lignes devraient suffir. ]

Il se peut parfois que l’encodage des caractères pose problème lors de l’importation. Dans ce cas, il peut être une bonne idée de changer la valeur du paramètre encoding de la fonction open(). Les encodages disponibles sont fonction de la locale. Les valeurs disponibles s’obtiennent à l’aide de la méthode suivante (code non exécuté dans ces notes) : import locale locale.locale_alias
5.1.1.1 Importation depuis internet
Pour importer un ﬁchier texte depuis Internet, on peut utiliser des méthodes de la librairie urllib : import urllib from urllib.request import urlopen url = "http://egallic.fr/Enseignement/Python/fichiers_exemples/fichier_texte.txt" with urllib.request.urlopen(url) as mon_fichier:
donnees = mon_fichier.read() print(donnees)

