Introduction to Python for Econometrics, Statistics and Data Analysis
Kevin Sheppard University of Oxford Tuesday 5th August, 2014

-
©2012, 2013, 2014 Kevin Sheppard 2

Changes since the Second Edition
Version 2.2.1 (August 2014) • Fixed typos reported by a reader – thanks to Ilya Sorvachev
Version 2.2 (July 2014) • Code veriﬁed against Anaconda 2.0.1. • Added diagnostic tools and a simple method to use external code in the Cython section. • Updated the Numba section to reﬂect recent changes. • Fixed some typos in the chapter on Performance and Optimization. • Added examples of joblib and IPython’s cluster to the chapter on running code in parallel
Version 2.1 (February 2014) • New chapter introducing object oriented programming as a method to provide structure and organization to related code. • Added seaborn to the recommended package list, and have included it be default in the graphics chapter. • Based on experience teaching Python to economics students, the recommended installation has been simpliﬁed by removing the suggestion to use virtual environment. The discussion of virtual environments as been moved to the appendix. • Rewrote parts of the pandas chapter. • Code veriﬁed against Anaconda 1.9.1.
Version 2.02 (November 2013) • Changed the Anaconda install to use both create and install, which shows how to install additional packages. • Fixed some missing packages in the direct install. • Changed the conﬁguration of IPython to reﬂect best practices. • Added subsection covering IPython proﬁles.
i

Version 2.01 (October 2013) • Updated Anaconda to 1.8 and added some additional packages to the installation for Spyder. • Small section about Spyder as a good starting IDE.
ii

Notes to the 2nd Edition
This edition includes the following changes from the ﬁrst edition (March 2012): • The preferred installation method is now Continuum Analytics’ Anaconda. Anaconda is a complete scientiﬁc stack and is available for all major platforms. • New chapter on pandas. pandas provides a simple but powerful tool to manage data and perform basic analysis. It also greatly simpliﬁes importing and exporting data. • New chapter on advanced selection of elements from an array. • Numba provides just-in-time compilation for numeric Python code which often produces large performance gains when pure NumPy solutions are not available (e.g. looping code). • Dictionary, set and tuple comprehensions • Numerous typos • All code has been veriﬁed working against Anaconda 1.7.0.
iii

iv

Contents

1 Introduction

1

1.1 Background . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1

1.2 Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2

1.3 Important Components of the Python Scientiﬁc Stack . . . . . . . . . . . . . . . . . . . . . . . . 3

1.4 Setup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4

1.5 Using Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6

1.6 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17

1.A Frequently Encountered Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17

1.B register_python.py . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18

1.C Advanced Setup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19

2 Python 2.7 vs. 3 (and the rest)

27

2.1 Python 2.7 vs. 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27

2.2 Intel Math Kernel Library and AMD Core Math Library . . . . . . . . . . . . . . . . . . . . . . . . 27

2.3 Other Variants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28

2.A Relevant Differences between Python 2.7 and 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . 29

3 Built-in Data Types

31

3.1 Variable Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31

3.2 Core Native Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32

3.3 Python and Memory Management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42

3.4 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44

4 Arrays and Matrices

47

4.1 Array . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47

4.2 Matrix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49

4.3 1-dimensional Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50

4.4 2-dimensional Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51

4.5 Multidimensional Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51

4.6 Concatenation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51

4.7 Accessing Elements of an Array . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52

4.8 Slicing and Memory Management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57

v

4.9 import and Modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59 4.10 Calling Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59 4.11 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61

5 Basic Math

63

5.1 Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63

5.2 Broadcasting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64

5.3 Array and Matrix Addition (+) and Subtraction (-) . . . . . . . . . . . . . . . . . . . . . . . . . . 65

5.4 Array Multiplication (*) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66

5.5 Matrix Multiplication (*) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66

5.6 Array and Matrix Division (/) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66

5.7 Array Exponentiation (**) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66

5.8 Matrix Exponentiation (**) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67

5.9 Parentheses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67

5.10 Transpose . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67

5.11 Operator Precedence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67

5.12 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68

6 Basic Functions and Numerical Indexing

71

6.1 Generating Arrays and Matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71

6.2 Rounding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74

6.3 Mathematics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75

6.4 Complex Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77

6.5 Set Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77

6.6 Sorting and Extreme Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78

6.7 Nan Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80

6.8 Functions and Methods/Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81

6.9 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82

7 Special Arrays

83

7.1 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84

8 Array and Matrix Functions

85

8.1 Views . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85

8.2 Shape Information and Transformation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86

8.3 Linear Algebra Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93

8.4 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96

9 Importing and Exporting Data

99

9.1 Importing Data using pandas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99

9.2 Importing Data without pandas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100

9.3 Saving or Exporting Data using pandas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106

vi

9.4 Saving or Exporting Data without pandas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106 9.5 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107

10 Inf, NaN and Numeric Limits

109

10.1 inf and NaN . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109

10.2 Floating point precision . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109

10.3 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110

11 Logical Operators and Find

113

11.1 >, >=, <, <=, ==, != . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113

11.2 and, or, not and xor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114

11.3 Multiple tests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115

11.4 is* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116

11.5 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117

12 Advanced Selection and Assignment

119

12.1 Numerical Indexing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119

12.2 Logical Indexing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124

12.3 Performance Considerations and Memory Management . . . . . . . . . . . . . . . . . . . . . . . 128

12.4 Assignment with Broadcasting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128

12.5 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130

13 Flow Control, Loops and Exception Handling

133

13.1 Whitespace and Flow Control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133

13.2 if . . . elif . . . else . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133

13.3 for . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134

13.4 while . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137

13.5 try . . . except . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139

13.6 List Comprehensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139

13.7 Tuple, Dictionary and Set Comprehensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141

13.8 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141

14 Dates and Times

143

14.1 Creating Dates and Times . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143

14.2 Dates Mathematics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143

14.3 Numpy datetime64 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144

15 Graphics

147

15.1 seaborn . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147

15.2 2D Plotting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147

15.3 Advanced 2D Plotting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153

15.4 3D Plotting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162

vii

15.5 General Plotting Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165 15.6 Exporting Plots . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165 15.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166

16 Structured Arrays

167

16.1 Mixed Arrays with Column Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167

16.2 Record Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170

17 pandas

171

17.1 Data Structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171

17.2 Statistical Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191

17.3 Time-series Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192

17.4 Importing and Exporting Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196

17.5 Graphics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200

17.6 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201

18 Custom Function and Modules

207

18.1 Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207

18.2 Variable Scope . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 214

18.3 Example: Least Squares with Newey-West Covariance . . . . . . . . . . . . . . . . . . . . . . . 215

18.4 Anonymous Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 216

18.5 Modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 216

18.6 Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217

18.7 PYTHONPATH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219

18.8 Python Coding Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219

18.9 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220

18.A Listing of econometrics.py . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221

19 Probability and Statistics Functions

225

19.1 Simulating Random Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225

19.2 Simulation and Random Number Generation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 229

19.3 Statistics Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231

19.4 Continuous Random Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 234

19.5 Select Statistics Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237

19.6 Select Statistical Tests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240

19.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 241

20 Non-linear Function Optimization

243

20.1 Unconstrained Optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244

20.2 Derivative-free Optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 247

20.3 Constrained Optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 248

20.4 Scalar Function Minimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252

viii

20.5 Nonlinear Least Squares . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253 20.6 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 254

21 String Manipulation

255

21.1 String Building . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 255

21.2 String Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 256

21.3 Formatting Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 260

21.4 Regular Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264

21.5 Safe Conversion of Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 265

22 File System Operations

267

22.1 Changing the Working Directory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267

22.2 Creating and Deleting Directories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267

22.3 Listing the Contents of a Directory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268

22.4 Copying, Moving and Deleting Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268

22.5 Executing Other Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 269

22.6 Creating and Opening Archives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 269

22.7 Reading and Writing Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270

22.8 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272

23 Performance and Code Optimization

273

23.1 Getting Started . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273

23.2 Timing Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273

23.3 Vectorize to Avoid Unnecessary Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 274

23.4 Alter the loop dimensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275

23.5 Utilize Broadcasting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 276

23.6 Use In-place Assignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 276

23.7 Avoid Allocating Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 276

23.8 Inline Frequent Function Calls . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 276

23.9 Consider Data Locality in Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 276

23.10Proﬁle Long Running Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 277

23.11Numba . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282

23.12Cython . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 288

23.13External Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 297

23.14Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 302

24 Executing Code in Parallel

303

24.1 map and related functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 303

24.2 multiprocessing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 304

24.3 joblib . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 306

24.4 IPython’s Parallel Cluster . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 308

24.5 Converting a Serial Program to Parallel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 314

ix

24.6 Other Concerns when executing in Parallel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 316

25 Object Oriented Programming (OOP)

319

25.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 319

25.2 Class basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 320

25.3 Building a class for Autoregressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 322

25.4 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 329

26 Other Interesting Python Packages

331

26.1 statsmodels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 331

26.2 pytz and babel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 331

26.3 rpy2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 331

26.4 PyTables and h5py . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 331

27 Examples

333

27.1 Estimating the Parameters of a GARCH Model . . . . . . . . . . . . . . . . . . . . . . . . . . . 333

27.2 Estimating the Risk Premia using Fama-MacBeth Regressions . . . . . . . . . . . . . . . . . . . 338

27.3 Estimating the Risk Premia using GMM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 341

27.4 Outputting LATEX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 344

28 Quick Reference

347

28.1 Built-ins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 347

28.2 NumPy (numpy) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 354

28.3 SciPy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 369

28.4 Matplotlib . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 372

28.5 Pandas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 374

28.6 IPython . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 378

x

Chapter 1
Introduction
1.1 Background
These notes are designed for someone new to statistical computing wishing to develop a set of skills necessary to perform original research using Python. They should also be useful for students, researchers or practitioners who require a versatile platform for econometrics, statistics or general numerical analysis (e.g. numeric solutions to economic models or model simulation).
Python is a popular general purpose programming language which is well suited to a wide range of problems.1 Recent developments have extended Python’s range of applicability to econometrics, statistics and general numerical analysis. Python – with the right set of add-ons – is comparable to domain-speciﬁc languages such as R, MATLAB or Julia. If you are wondering whether you should bother with Python (or another language), a very incomplete list of considerations includes:
You might want to consider R if:
• You want to apply statistical methods. The statistics library of R is second to none, and R is clearly at the forefront in new statistical algorithm development – meaning you are most likely to ﬁnd that new(ish) procedure in R.
• Performance is of secondary importance.
• Free is important.
You might want to consider MATLAB if:
• Commercial support, and a clean channel to report issues, is important.
• Documentation and organization of modules is more important than raw routine availability.
• Performance is more important than scope of available packages. MATLAB has optimizations, such as Just-in-Time (JIT) compilation of loops, which is not automatically available in most other packages.
You might want to consider Julia if:
1According to the ranking onhttp://www.tiobe.com/, Python is the 8th most popular language. http://langpop.corger. nl/ ranks Python as 5th or 6th, and on http://langpop.com/, Python is 6th.
1

• Performance in an interactive based language is your most important concern.
• You don’t mind learning enough Python to interface with Python packages. The Julia ecosystem is in its infancy and a bridge to Python is used to provide important missing features.
• You like living on the bleeding edge, and aren’t worried about code breaking across new versions of Julia.
• You like to do most things yourself.
Having read the reasons to choose another package, you may wonder why you should consider Python.
• You need a language which can act as an end-to-end solution so that everything from accessing webbased services and database servers, data management and processing and statistical computation can be accomplished in a single language. Python can even be used to write server-side apps such as dynamic website (see e.g. http://stackoverflow.com), apps for desktop-class operating systems with graphical user interfaces and even tablets and phones apps (iOS and Android).
• Data handling and manipulation – especially cleaning and reformatting – is an important concern. Python is substantially more capable at data set construction than either R or MATLAB.
• Performance is a concern, but not at the top of the list.2
• Free is an important consideration – Python can be freely deployed, even to 100s of servers in a compute cluster or in the cloud (e.g. Amazon Web Services or Azure).
• Knowledge of Python, as a general purpose language, is complementary to R/MATLAB/Julia/Ox/GAUSS/Stata.
1.2 Conventions
These notes will follow two conventions.
1. Code blocks will be used throughout.
"""A docstring """
# Comments appear in a different color
# Reserved keywords are highlighted and as assert break class continue def del elif else except exec finally for from global if import in is lambda not or pass print raise return try while with yield
# Common functions and classes are highlighted in a # different color. Note that these are not reserved, 2Python performance can be made arbitrarily close to C using a variety of methods, including Numba (pure python), Cython (C/Python creole language) or directly calling C code. Moreover, recent advances have substantially closed the gap with respect to other Just-in-Time compiled languages such as MATLAB.
2

# and can be used although best practice would be # to avoid them if possible array matrix xrange list True False None
# Long lines are indented some_text = ’This is a very, very, very, very, very, very, very, very, very, very, very
, very long line.’
2. When a code block contains >>>, this indicates that the command is running an interactive IPython session. Output will often appear after the console command, and will not be preceded by a command indicator.
>>> x = 1.0 >>> x + 2 3.0
If the code block does not contain the console session indicator, the code contained in the block is intended to be executed in a standalone Python ﬁle.
from __future__ import print_function import numpy as np
x = np.array([1,2,3,4]) y = np.sum(x) print(x) print(y)
1.3 Important Components of the Python Scientiﬁc Stack
1.3.1 Python Python 2.7.6 (or later, but in the Python 2.7.x family) is required. This provides the core Python interpreter.
1.3.2 NumPy NumPy provides a set of array and matrix data types which are essential for statistics, econometrics and data analysis.
1.3.3 SciPy SciPy contains a large number of routines needed for analysis of data. The most important include a wide range of random number generators, linear algebra routines and optimizers. SciPy depends on NumPy.
1.3.4 IPython IPython provides an interactive Python environment which enhances productivity when developing code or performing interactive data analysis.
3

1.3.5 matplotlib and seaborn matplotlib provides a plotting environment for 2D plots, with limited support for 3D plotting. seaborn is a Python package that improves the default appearance of matplotlib plots without any additional code.
1.3.6 pandas pandas provides high-performance data structures.
1.3.7 Performance Modules A number of modules are available to help with performance. These include Cython and Numba. Cython is a Python module which facilitates using a simple Python-derived creole to write functions that can be compiled to native (C code) Python extensions. Numba uses a method of just-in-time compilation to translate a subset of Python to native code using Low-Level Virtual Machine (LLVM).
1.4 Setup
The recommended method to install the Python scientiﬁc stack is to use Continuum Analytics’ Anaconda. Appendix 1.C describes a more complex installation procedure with instructions for directly installing Python and the required modules when it is not possible to install Anaconda. The appendix also discusses using virtual environments, which are considered best practices when using Python.
1.4.1 Continuum Analytics’ Anaconda Anaconda, a free product of Continuum Analytics (www.continuum.io), is a virtually complete scientiﬁc stack for Python. It includes both the core Python interpreter and standard libraries as well as most modules required for data analysis. Anaconda is free to use and modules for accelerating the performance of linear algebra on Intel processors using the Math Kernel Library (MKL) are available (free to academic users and for a small cost to non-academic users). Continuum Analytics also provides other high-performance modules for reading large data ﬁles or using the GPU to further accelerate performance for an additional, modest charge. Most importantly, installation is extraordinarily easy on Windows, Linux and OS X. Anaconda is also simple to update to the latest version using
conda update conda conda update anaconda
Windows Installation on Windows requires downloading the installer and running. These instructions use ANACONDA to indicate the Anaconda installation directory (e.g. the default is C:\Anaconda). Once the setup has completed, open a command prompt (cmd.exe) and run cd ANACONDA\Scripts conda update conda conda update anaconda conda install mkl
4

which will ﬁrst ensure that Anaconda is up-to-date. The ﬁnal line installs the recommended Intel Math Kernel Library to accelerate linear algebra routines. Using MKL requires a license which is available for free to academic uses and for a modest charge otherwise. If acquiring a license is not possible, omit this line. conda install can be used later to install other packages that may be of interest. Next, change to and then run
cd ANACONDA\Scripts pip install pylint html5lib seaborn
which installs additional packages not directly available in Anaconda. Note that if Anaconda is installed into a directory other than the default, the full path should not contain unicode characters or spaces.
Notes
The recommended settings for installing Anaconda on Windows are:
• Install for all users, which requires admin privileges. If these are not available, then choose the “Just for me” option, but be aware of installing on a path that contains non-ASCII characters which can cause issues.
• Add Anaconda to the System PATH - This is important to ensure that Anaconda commands can be run from the command prompt.
• Register Anaconda as the system Python - If Anaconda is the only Python installed, then select this option.
If Anaconda is not added to the system path, it is necessary to add the ANACONDA and ANACONDA\Scripts directories to the PATH using
set PATH=ANACONDA;ANACONDA\Scripts;%PATH%
before running Python programs.
Linux and OS X
Installation on Linux requires executing
bash Anaconda-x.y.z-Linux-ISA.sh
where x.y.z will depend on the version being installed and ISA will be either x86 or more likely x86_64. The OS X installer is available either in a GUI installed (pkg format) or as a bash installer which is installed in an identical manner to the Linux installation. It is strongly recommended that the anaconda/bin is prepended to the path. This can be performed in a session-by-session basis by entering
export PATH=/home/python/anaconda/bin;$PATH
On Linux this change can be made permanent by entering this line in .bashrc which is a hidden ﬁle located in ~/. On OS X, this line can be added to .bash_proﬁle which is located in the home directory (~/).
After installation completes, change to the folder where Anaconda installed (written here as ANACONDA, default ~/anaconda) and execute
conda update conda conda update anaconda conda install mkl
5

which will ﬁrst ensure that Anaconda is up-to-date and then to install the Intel Math Kernel library-linked modules, which provide substantial performance improvements – this package requires a license which is free to academic users and low cost to others. If acquiring a license is not possible, omit this line. conda install can be used later to install other packages that may be of interest. Finally, run the command
pip install pylint html5lib seaborn
to install some packages not included in Anaconda.
Notes All instructions for OS X and Linux assume that ANACONDA/bin has been added to the path. If this is not the case, it is necessary to run
cd ANACONDA cd bin
and then all commands must be prepended by a . as in
.conda update conda
1.5 Using Python
Python can be programmed using an interactive session using IPython or by directly executing Python scripts – text ﬁles that end in the extension .py – using the Python interpreter.
1.5.1 Python and IPython Most of this introduction focuses on interactive programming, which has some distinct advantages when learning a language. The standard Python interactive console is very basic and does not support useful features such as tab completion. IPython, and especially the QtConsole version of IPython, transforms the console into a highly productive environment which supports a number of useful features:
• Tab completion - After entering 1 or more characters, pressing the tab button will bring up a list of functions, packages and variables which match the typed text. If the list of matches is large, pressing tab again allows the arrow keys can be used to browse and select a completion.
• “Magic” function which make tasks such as navigating the local ﬁle system (using %cd ~/directory/ or just cd ~/directory/ assuming that %automagic is on) or running other Python programs (using run program.py) simple. Entering %magic inside and IPython session will produce a detailed description of the available functions. Alternatively, %lsmagic produces a succinct list of available magic commands. The most useful magic functions are
– cd - change directory – edit ﬁlename - launch an editor to edit ﬁlename – ls or ls pattern - list the contents of a directory
6

– run ﬁlename - run the Python ﬁle ﬁlename – timeit - time the execution of a piece of code or function
• Integrated help - When using the QtConsole, calling a function provides a view of the top of the help function. For example, entering mean( will produce a view of the top 20 lines of its help text.
• Inline ﬁgures - The QtConsole can also display ﬁgure inline which produces a tidy, self-contained environment. (when using the --pylab=inline switch when starting, or when using the conﬁguration option _c.IPKernelApp.pylab="inline").
• The special variable _ contains the last result in the console, and so the most recent result can be saved to a new variable using the syntax x = _.
• Support for proﬁles, which provide further customization of sessions.

1.5.2 IPython Proﬁles

IPython supports using proﬁles which allows for alternative environments (at launch), either in appearance or in terms of packages which have been loaded into the IPython session. Proﬁles are conﬁgured using a set of ﬁles located in %USERPROFILE%\.ipython\ on Windows and ~/.conﬁg/ipython/ on OS X or Linux. There should be one directory in this location, proﬁle_default, that is mostly empty. To conﬁgure a proﬁle open a terminal or command prompt and run
ipython profile create econometrics
This will create a directory named proﬁle_econometrics and populate it with 4 ﬁles:

File

Purpose

ipython_conﬁg.py ipython_nbconvert_conﬁg.py ipython_notebook_conﬁg.py ipython_qtconsole_conﬁg.py

General IPython setting for all IPython sessions Settings used by the Notebook converter Settings speciﬁc to IPython Notebook (browser) sessions Settings speciﬁc to QtConsole sessions

The two most important are ipython_conﬁg and ipython_qtconsole_conﬁg. Opening these ﬁles in a text editor will reveal a vast array of options, all which are commented out using #. A full discussion of these ﬁles would require a chapter or more, and so please refer to the online IPython documentation for details about a speciﬁc setting (although most settings have a short comment containing an explanation and possible values).
ipython_conﬁg
The settings in this ﬁle apply to all IPython sessions using this proﬁle, irrespective of whether they are in the terminal, QtConsole or Notebook. One of the most useful settings is
c.InteractiveShellApp.exec_lines
7

which allows commands to be executed each time an IPython session is open. This is useful, for example, to import speciﬁc packages commonly used in a project. Another useful conﬁguration options is
c.InteractiveShellApp.pylab
which can be used to load pylab in the session, and is identical to launching an IPython session using the command line switch --pylab=backend. An alternative is to use
c.InteractiveShellApp.matplotlib
which will only load matplotlib and not the rest of pylab.
ipython_qtconsole_conﬁg The settings in this ﬁle only apply to QtConsole sessions, and the most useful affect the appearance of the console. The ﬁrst two can be used to set the font size (a number) and font family (a string, containing the name of the font). c.IPythonWidget.font_size
c.IPythonWidget.font_family
The next setting sets the model for pylab, which can in particular be set to "inline" which is identical to using the command line switch --pylab=inline when starting IPython using the QtConsole. This setting is similar to the previous pylab setting, but since this is speciﬁc to QtConsole sessions, it will override the general setting (only) in using QtConsole, and so it is possible to use, for example, "qt4", for terminalbased IPython sessions, and to use "inline" for QtConsole sessions.
c.IPKernelApp.pylab
This ﬁnal setting is identical to the command-line switch --colors and can be set to "linux" to produce a console with a dark background and light characters.
c.ZMQInteractiveShell.colors
1.5.3 Conﬁguring IPython These notes assume that two imports are made when running code in IPython or as stand-alone Python programs. These imports are
from __future__ import print_function, division
which imports the future versions of print and / (division). Open ipython_conﬁg.py in the directory proﬁle_econometrics and set the values
c.InteractiveShellApp.exec_lines=["from __future__ import print_function, division", "import os", "os.chdir(’c:\\dir\\to\\start\\in’)"]
and
c.InteractiveShellApp.pylab="qt4"
8

This code does two things. First, it imports two “future” features (which are standard in Python 3.x+), the print function and division, which are useful for numerical programming.
• In Python 2.7, print is not a standard function and is used like print ’string to print’. Python 3.x changes this behavior to be a standard function call, print(’string to print’). I prefer the latter since it will make the move to 3.x easier, and ﬁnd it more coherent with other function in Python.
• In Python 2.7, division of integers always produces an integer so that the result is truncated (i.e. 9/5=1). In Python 3.x, division of integers does not produce an integer if the integers are not even multiples (i.e. 9/5=1.8). Additionally, Python 3.x uses the syntax 9//5 to force integer division with truncation (i.e. 11/5=2.2, while 11//5=2).
Second, pylab will be loaded by default using the qt4 backend. Changing settings in ipython_qtconsole_conﬁg.py is optional, although I recommend using
c.IPythonWidget.font_size=11 c.IPythonWidget.font_family="Bitstream Vera Sans Mono" c.IPKernelApp.pylab="inline" c.ZMQInteractiveShell.colors="linux"
These commands assume that the Bitstream Vera fonts have been locally installed, which are available from http://ftp.gnome.org/pub/GNOME/sources/ttf-bitstream-vera/1.10/.
1.5.4 Launching IPython
OS X and Linux IPython can be started by running ipython --profile=econometrics
in the terminal. Starting IPython using the QtConsole is virtually identical.
ipython qtconsole --profile=econometrics
A single line launcher on OS X or Linux can be constructed using
bash -c "ipython qtconsole --profile=econometrics"
This single line launcher can be saved as ﬁlename.command where ﬁlename is a meaningful name (e.g. IPython-Terminal) to create a launcher on OS X by entering the command
chmod 755 /FULL/PATH/TO/filename.command
The same command can to create a Desktop launcher on Ubuntu by running
sudo apt-get install --no-install-recommends gnome-panel gnome-desktop-item-edit ~/Desktop/ --create-new
and then using the command as the Command in the dialog that appears.
9

Figure 1.1: IPython running in the standard Windows console (cmd.exe). Windows (Anaconda)
To run IPython open cmd and enter
ipython --profile=econometrics
Starting IPython using the QtConsole is similar.
ipython qtconsole --profile=econometrics
Launchers can be created for these shortcuts. Start by creating a launcher to run IPython in the standard Windows cmd.exe console. Open a text editor enter
cmd "/c cd ANACONDA\Scripts\ && start "" "ipython.exe" --profile=econometrics"
and save the ﬁle as ANACONDA\ipython-plain.bat. Finally, right click on ipython-plain.bat select Sent To, Desktop (Create Shortcut). The icon of the shortcut will be generic, and if you want a more meaningful icon, select the properties of the shortcut, and then Change Icon, and navigate to c:\Anaconda\Menu\ and select IPython.ico. Opening the batch ﬁle should create a window similar to that in ﬁgure 1.1.
Launching the QtConsole is similar. Start by entering the following command in a text editor
cmd "/c cd ANACONDA\Scripts && start "" "pythonw" ANACONDA\Scripts\ipython-script.py qtconsole --profile=econometrics"
and then saving the ﬁle as ANACONDA\ipython-qtconsole.bat. Create a shortcut for this batch ﬁle, and change the icon if desired. Opening the batch ﬁle should create a window similar to that in ﬁgure 1.2 (although the appearance might differ).
1.5.5 Getting Help
Help is available in IPython sessions using help(function). Some functions (and modules) have very long help ﬁles. When using IPython, these can be paged using the command ?function or function? so that the
10

Figure 1.2: IPython running in a QtConsole session. 11

text can be scrolled using page up and down and q to quit. ??function or function?? can be used to type the entire function including both the docstring and the code.
1.5.6 Running Python programs
While interactive programing is useful for learning a language or quickly developing some simple code, complex projects require the use of complete programs. Programs can be run either using the IPython magic work %run program.py or by directly launching the Python program using the standard interpreter using python program.py. The advantage of using the IPython environment is that the variables used in the program can be inspected after the program run has completed. Directly calling Python will run the program and then terminate, and so it is necessary to output any important results to a ﬁle so that they can be viewed later.3
To test that you can successfully execute a Python program, input the code in the block below into a text ﬁle and save it as firstprogram.py.
# First Python program from __future__ import print_function, division import time
print(’Welcome to your first Python program.’) raw_input(’Press enter to exit the program.’) print(’Bye!’) time.sleep(2)
Once you have saved this ﬁle, open the console, navigate to the directory you saved the ﬁle and enter python firstprogram.py. Finally, run the program in IPython by ﬁrst launching IPython, and the using %cd to change to the location of the program, and ﬁnally executing the program using %run firstprogram.py.
1.5.7 Testing the Environment
To make sure that you have successfully installed the required components, run IPython using the shortcut previously created on windows, or by running ipython --pylab or ipython qtconsole --pylab in a Unix terminal window. Enter the following commands, one at a time (the meaning of the commands will be covered later in these notes).
>>> x = randn(100,100) >>> y = mean(x,0) >>> plot(y) >>> import scipy as sp
If everything was successfully installed, you should see something similar to ﬁgure 1.3.
1.5.8 IPython Notebook
IPython notebooks are a useful method to share code with others. Notebooks allow for a ﬂuid synthesis of formatted text, typeset mathematics (using LATEX via MathJax) and Python. The primary method for using IPython notebooks is through a web interface. The web interface allow creation, deletion, export
3Programs can also be run in the standard Python interpreter using the command: exec(compile(open(’filename.py’).read(),’filename.py’,’exec’))
12

Figure 1.3: A successful test that matplotlib, IPython, NumPy and SciPy were all correctly installed. 13

and interactive editing of notebooks. Before running IPython Notebook for the ﬁrst time, it is useful to open IPython and run the following two commands.
>>> from IPython.external.mathjax import install_mathjax >>> install_mathjax()
These commands download a local copy of MathJax, a Javascript library for typesetting LATEX math on web pages.
To launch the IPython notebook server on Anaconda/Windows, open a text editor, enter
cmd "/c cd ANACONDA\Scripts && start "" "ipython.exe" notebook --matplotlib=’inline’ --notebook-dir=u’c:\\PATH\\TO\\NOTEBOOKS\\’"
and save the ﬁle as ipython-notebook.bat. If using Linux or OS X, run
ipython notebook --matplotlib=’inline’ --notebook-dir=’/PATH/TO/NOTEBOOKS/’
The command uses two optional argument. --matplotlib=’inline’ launches IPython with inline ﬁgures so that they show in the browser, and is highly recommended. --notebook-dir=’/PATH/TO/NOTEBOOKS/’ allows the default path for storing the notebooks to be set. This can be set to any location, and if not set, a default value is used. Note that both of these options can be set in ipython_notebook_conﬁg.py in proﬁle_econometrics using
c.IPKernelApp.matplotlib = ’inline’ c.FileNotebookManager.notebook_dir = ’/PATH/TO/NOTEBOOKS/’
and then the notebook should be started using only --profile=econometrics. These commands will start the server and open the default browser which should be a modern version
of Chrome (preferable) Chromium or Firefox. If the default browser is Safari, Internet Explorer or Opera, the URL can be copied into the Chrome address bar. The ﬁrst screen that appears will look similar to ﬁgure 1.4, except that the list of notebooks will be empty. Clicking on New Notebook will create a new notebook, which, after a bit of typing, can be transformed to resemble ﬁgure 1.5. Notebooks can be imported by dragging and dropping and exported from the menu inside a notebook.
1.5.9 Integrated Development Environments
As you progress in Python and begin writing more sophisticated programs, you will ﬁnd that using an Integrated Development Environment (IDE) will increase your productivity. Most contain productivity enhancements such as built-in consoles, code completion (or intellisense, for completing function names) and integrated debugging. Discussion of IDEs is beyond the scope of these notes, although Spyder is a reasonable choice (free, cross-platform). Aptana Studio is another free alternative. My preferred IDE is PyCharm, which has a community edition that is free for use (the professional edition is low cost for academics).
14

Figure 1.4: The default IPython Notebook screen showing two notebooks.
Figure 1.5: An IPython notebook showing formatted markdown, LATEX math and cells containing code. 15

Spyder

Figure 1.6: The default Spyder IDE on Windows.

Spyder is an IDE specialized for use in scientiﬁc application rather than for general purpose Python application development. This is both an advantage and a disadvantage when compared to more full featured IDEs such as PyCharm, PyDev or Aptana Studio. The main advantage is that many powerful but complex features are not integrated into Spyder, and so the learning curve is much shallower. The disadvantage is similar - in more complex projects, or if developing something that is not straight scientiﬁc Python, Spyder is less capable. However, netting these two, Spyder is almost certainly the IDE to use when starting Python, and it is always relatively simple to migrate to a sophisticated IDE if needed.
Spyder is started by entering spyder in the terminal or command prompt. A window similar to that in ﬁgure 1.6 should appear. The main components are the the editor (1), the object inspector (2), which dynamically will show help for functions that are used in the editor, and the console (3). By default Spyder opens a standard Python console, although it also supports using the more powerful IPython console. The object inspector window, by default, is grouped with a variable explorer, which shows the variables that are in memory and the ﬁle explorer, which can be used to navigate the ﬁle system. The console is grouped with an IPython console window (needs to be activated ﬁrst using the Interpreters menu along the top edge), and the history log which contains a list of commands executed. The buttons along the top edge facilitate saving code, running code and debugging.
16

1.6 Exercises
1. Install Python.
2. Test the installation using the code in section 1.5.7.
3. Conﬁgure IPython using the start-up script in section 1.5.3.
4. Customize IPython QtConsole using a font or color scheme. More customizations can be found by running ipython -h.
5. Explore tab completion in IPython by entering a<TAB> to see the list of functions which start with a and are loaded by pylab. Next try i<TAB>, which will produce a list longer than the screen – press ESC to exit the pager.
6. Launch IPython Notebook and run code in the testing section.
7. Open Spyder and explore its features.
1.A Frequently Encountered Problems
All Whitespace sensitivity Python is whitespace sensitive and so indentation, either spaces or tabs, affects how Python interprets ﬁles. The conﬁguration ﬁles, e.g. ipython_conﬁg.py, are plain Python ﬁles and so are sensitive to whitespace. Introducing white space before the start of a conﬁguration option will produce an error, so ensure there is no whitespace before conﬁguration lines such as c.InteractiveShellApp.exec_lines.
Windows Spaces in path Python does not generally work when directories have spaces.
Unicode in path Python 2.7 does not work well when a path contains unicode characters, such as in a user name. While this isn’t an issue for installing Python or Anaconda, it is an issue for IPython which looks in c:\user\username\.ipython for conﬁguration ﬁles. The solution is to deﬁne the HOME variable before launching IPython to a path that has only ASCII characters.
mkdir c:\anaconda\ipython_config set HOME=c:\anaconda\ipython_config c:\Anaconda\Scripts\activate econometrics ipython profile create econometrics ipython --profile=econometrics
17

The set HOME=c:\anaconda\ipython_config can point to any path with directories containing only ASCII characters, and can also be added to any batch ﬁle to achieve the same effect.
OS X
Installing Anaconda to the root of the partition
If the user account used is running as root, then Anaconda may install to /anaconda and not ~/anaconda by default. Best practice is not to run as root, although in principle this is not a problem, and /anaconda can be used in place of ~/anaconda in any of the instructions.
Unable to create proﬁle for IPython
Non-ASCII characters can create issues for IPython since it look in $HOME/.ipython which is normally /Users/username/.ipython. If username has non-ASCII characters, this can create difﬁculties. The solution is to deﬁne an environment variable to a path that only contains ASCII characters.
mkdir /tmp/ipython_config export IPYTHONDIR=/tmp/ipython_config source ~/anacound/bin/activate econometrics ipython profile create econometrics ipython --profile=econometrics
These commands should create a proﬁle directory in /tmp/ipython_conﬁg (which can be any directory with only ASCII characters in the path). These changes can be made permanent by editing ~/.bash_proﬁle and adding the line
export IPYTHONDIR=/tmp/ipython_config
in which case no further modiﬁcations are needed to the commands previously discussed. Note that ~/.bash_proﬁle is hidden and may not exist, so nano ~/.bash_profile can be used to create and edit this ﬁle.
1.B register_python.py
A complete listing of register_python.py is included in this appendix.
# -*- encoding: utf-8 -*# # Script to register Python 2.0 or later for use with win32all # and other extensions that require Python registry settings # # Adapted by Ned Batchelder from a script # written by Joakim Law for Secret Labs AB/PythonWare # # source: # http://www.pythonware.com/products/works/articles/regpy20.htm
18

import sys from _winreg import *
# tweak as necessary version = sys.version[:3] installpath = sys.prefix
regpath = "SOFTWARE\\Python\\Pythoncore\\%s\\" % (version) installkey = "InstallPath" pythonkey = "PythonPath" pythonpath = "%s;%s\\Lib\\;%s\\DLLs\\" % (
installpath, installpath, installpath )
def RegisterPy(): try: reg = OpenKey(HKEY_LOCAL_MACHINE, regpath) except EnvironmentError: try: reg = CreateKey(HKEY_LOCAL_MACHINE, regpath) except Exception, e: print "*** Unable to register: %s" % e return
SetValue(reg, installkey, REG_SZ, installpath) SetValue(reg, pythonkey, REG_SZ, pythonpath) CloseKey(reg) print "--- Python %s at %s is now registered!" % (version, installpath)
if __name__ == "__main__": RegisterPy()
1.C Advanced Setup
The simplest method to install the Python scientiﬁc stack is to use directly Continuum Analytics’ Anaconda. These instructions describe alternative installation options using virtual environments, which are considered best practices when using Python.
1.C.1 Using Virtual Environments with Anaconda
Windows
Installation on Windows requires downloading the installer and running. These instructions use ANACONDA to indicate the Anaconda installation directory (e.g. the default is C:\Anaconda). Once the setup has completed, open a command prompt (cmd.exe) and run
cd ANACONDA conda update conda conda update anaconda
19

conda create -n econometrics ipython-qtconsole ipython-notebook scikit-learn matplotlib numpy pandas scipy spyder statsmodels
conda install -n econometrics cython distribute lxml nose numba numexpr openpyxl pep8 pip psutil pyflakes pytables pywin32 rope sphinx xlrd xlwt
conda install -n econometrics mkl
which will ﬁrst ensure that Anaconda is up-to-date and then create a virtual environment named econometrics. The virtual environment provides a set of components which will not change even if Anaconda is updated. Using a virtual environment is a best practice and is important since component updates can lead to errors in otherwise working programs due to backward incompatible changes in a module. The long list of modules in the conda create command includes the core modules. The first conda install contains the remaining packages, and is shown as an example of how to add packages to a virtual environment after it has been created. The second conda install installs the Intel Math Kernel library linkedmodules which provide large performance gains in Intel systems – this package requires a license from Continuum which is is free to academic users (and low cost otherwise). I recommend acquiring a license as the performance gains are substantial, even on dual core machines. If you will not be purchasing a license, this line should be omitted. It is also possible to install all available packages using the command conda create -n econometrics anaconda.
The econometrics environment must be activated before use. This is accomplished by running
ANACONDA\Scripts\activate.bat econometrics
from the command prompt, which prepends [econometrics] to the prompt as an indication that virtual environment is active. Activate the econometrics environment and then run
pip install pylint html5lib seaborn
which installs one package not directly available in Anaconda.
Linux and OS X
Installation on Linux requires executing
bash Anaconda-x.y.z-Linux-ISA.sh
where x.y.z will depend on the version being installed and ISA will be either x86 or more likely x86_64. The OS X installer is available either in a GUI installed (pkg format) or as a bash installer which is installed in an identical manner to the Linux installation. After installation completes, change to the folder where Anaconda installed (written here as ANACONDA, default ~/anaconda) and execute
cd ANACONDA cd bin ./conda update conda ./conda update anaconda ./conda create -n econometrics ipython-qtconsole ipython-notebook matplotlib numpy pandas
scikit-learn scipy spyder statsmodels ./conda install -n econometrics cython distribute lxml nose numba numexpr openpyxl pep8 pip
psutil pyflakes pytables rope sphinx xlrd xlwt ./conda install -n econometrics mkl
which will ﬁrst ensure that Anaconda is up-to-date and then create a virtual environment named econometrics with the required packages. conda create creates the environment and conda install installs
20

additional packages to the existing environment. The second invocation of conda install is used to install the Intel Math Kernel library-linked modules, which provide substantial performance improvements – this package requires a license which is free to academic users and low cost to others. If acquiring a license is not possible, omit this line. conda install can be used later to install other packages that may be of interest. To activate the newly created environment, run
source ANACONDA/bin/activate econometrics
and then run the command
pip install pylint html5lib seaborn
to install one package not included in Anaconda.

1.C.2 Installation without Anaconda
Anaconda greatly simpliﬁes installing the scientiﬁc Python stack. However, there may be situations where installing Anaconda is not possible, and so (substantially more complicated) instructions are included for both Windows and Linux.

Windows
The list of required windows binary packages, along with the version and Windows installation ﬁle, required for these notes include:

Package

Version File name

Python Setuptools Pip Virtualenv pywin32 Jinja2 Tornado PyCairo PyZMQ PyQt NumPy SciPy MatplotLib pandas IPython scikit-learn statsmodels PyTables lxml psutil

2.7.5 2.2.0 1.5.4 1.11.1 218.5 2.7.2 3.2.0 1.10.0 14.0.1 4.9.6-1 1.8.0 0.13.3 1.3.1 0.13.0 1.2.0 0.14.1 0.5.0 3.1.0 3.3.1 1.2.1

python-2.7.5.amd64 setuptools-2.2.win-amd64-py2.7 pip-1.5.4.win-amd64-py2.7 virtualenv-1.11.4.win-amd64-py2.7 pywin32-218.5.win-amd64-py2.7 Jinja2-2.7.2.win-amd64-py2.7.exe tornado-3.2.0.win-amd64-py2.7.exe pycairo-1.10.0.win-amd64-py2.7 pyzmq-14.0.1.win-amd64-py2.7 PyQt-Py2.7-x64-gpl-4.9.6-1 numpy-MKL-1.8.0.win-amd64-py2.7 scipy-0.13.3.win-amd64-py2.7 matplotlib-1.3.1.win-amd64-py2.7 pandas-0.13.1.win-amd64-py2.7 ipython-1.2.0.win-amd64-py2.7 scikit-learn-0.14.1.win-amd64-py2.7 statsmodels-0.5.0.win-amd64-py2.7 tables-3.1.0.win-amd64-py2.7 lxml-3.3.1.win-amd64-py2.7 psutil-1.2.1.win-amd64-py2.7

21

These remaining packages are optional and are only discussed in the ﬁnal chapters related to performance.

Package

Version File name

Performance Cython Cython Numba LLVMPy LLVMMath Numba pandas (Optional) Bottleneck NumExpr

0.20.1
0.12.3 0.1.2 0.12.1
0.8.0 2.3.1

Cython-0.20.1.win-amd64-py2.7
llvmpy-0.12.3.win-amd64-py2.7 llvmmath-0.1.2.win-amd64-py2.7 numba-0.12.1.win-amd64-py2.7
Bottleneck-0.8.0.win-amd64-py2.7 numexpr-2.3.1.win-amd64-py2.7

Begin by installing Python, setuptools, pip and virtualenv. After these four packages are installed, open an elevated command prompt (cmd.exe with administrator privileges) and initialized the virtual environment using the command:
cd C:\Dropbox virtualenv econometrics
I prefer to use my Dropbox as the location for virtual environments and have named the virtual environment econometrics. The virtual environment can be located anywhere (although best practice is to use a path without spaces) and can have a different name. Throughout the remainder of this section, VIRTUALENV will refer to the complete directory containing the virtual environment (e.g. C:\Dropbox\econometrics).
Once the virtual environment setup is complete, run
cd VIRTUALENV\Scripts activate.bat pip install beautifulsoup4 html5lib meta nose openpyxl patsy pep8 pyflakes pygments pylint
pylint pyparsing pyreadline python-dateutil pytz==2013d rope seaborn sphinx spyder wsgiref xlrd xlwt
which activates the virtual environment and installs some additional required packages. Finally, before installing the remaining packages, it is necessary to register the virtual environment as the default Python environment by running the script register_python.py4, which is available on the website. Once the correct version of Python is registered, install the remaining packages in order, including any optional packages. Finally, run one ﬁnal command in the prompt.
xcopy c:\Python27\tcl VIRTUALENV\tcl /S /E /I
4This ﬁle registers the virtual environment as the default python in Windows. To restore the main Python installation (normally C:\Python27) run register_python.py with the main Python interpreter (normally C:\Python27\python.exe) in an elevated command prompt.
22

Linux (Ubuntu 12.04 LTS)
To install on Ubuntu 12.04 LTS, begin by updating the system using
sudo apt-get update sudo apt-get upgrade
Next, install the system packages required using
sudo apt-get install python-pip libzmq-dev python-all-dev build-essential gfortran libatlasbase-dev libatlas-dev libatlas3-base pyqt4-dev-tools libfreetype6-dev libpng12-dev python-qt4 python-qt4-dev python-cairo python-cairo-dev hdf5-tools libhdf5-serial-dev texlive-full dvipng pandoc
Finally, install virtualenv using
sudo pip install virtualenv
The next step is to initialize the virtual environment, which is assumed to be in your home directory and named econometrics.
cd ~ virtualenv econometrics
The virtual environment can be activated using
source ~/econometrics/bin/activate
Once the virtual environment has been initialized, the remaining packages can be installed using the commands
mkdir ~/econometrics/lib/python2.7/site-packages/PyQt4/ mkdir ~/econometrics/lib/python2.7/site-packages/cairo/ cp -r /usr/lib/python2.7/dist-packages/PyQt4/* ~/econometrics/lib/python2.7/site-packages/
PyQt4/ cp -r /usr/lib/python2.7/dist-packages/cairo/* ~/econometrics/lib/python2.7/site-packages/
cairo/ cp /usr/lib/python2.7/dist-packages/sip* ~/econometrics/lib/python2.7/site-packages/ pip install Cython pip install numpy pip install scipy pip install matplotlib pip install ipython[/*all*/] pip install scikit-learn pip install beautifulsoup4 html5lib lxml openpyxl pytz==2013d xlrd xlwt pip install patsy bottleneck numexpr pip install tables pip install pandas pip install statsmodels pip install distribute meta rope pep8 pexpect pylint pyflakes psutil seaborn sphinx spyder
The three cp lines copy ﬁles from the default Python installation which are more difﬁcult to build using pip. Next, if interested in Numba, a package which can be used to enhance the performance of Python, enter the following commands. Note: The correct version of llvm might change as llvmpy and numba progress.
23

wget http://llvm.org/releases/3.2/llvm-3.2.src.tar.gz tar -zxf llvm-3.2.src.tar.gz cd llvm-3.2.src ./configure --enable-optimizations --prefix=/home/username/llvm REQUIRES_RTTI=1 make make install cd .. LLVM_CONFIG_PATH=/home/username/llvm/bin/llvm-config pip install llvmpy pip install llvmmath pip install numba
1.C.3 Launching IPython
OS X and Linux
Starting IPython requires activating the virtual environment and then starting IPython with the correct proﬁle.
source ANACONDA/bin/activate econometrics ipython --profile=econometrics
Starting IPython using the QtConsole is virtually identical.
source ANACONDA/bin/activate econometrics ipython qtconsole --profile=econometrics
A single line launcher on OS X or Linux can be constructed using
bash -c "source ANACONDA/bin/activate econometrics && ipython qtconsole --profile= econometrics"
This single line launcher can be saved as ﬁlename.command where ﬁlename is a meaningful name (e.g. IPython-Terminal) to create a launcher on OS X by entering the command
chmod 755 /FULL/PATH/TO/filename.command
The same command can to create a Desktop launcher on Ubuntu by running
sudo apt-get install --no-install-recommends gnome-panel gnome-desktop-item-edit ~/Desktop/ --create-new
and then using the command as the Command in the dialog that appears. Note that if Python was directly installed, launching IPython is identical only replacing the Anaconda
virtual environment activation line with the activation line for the directly created virtual environment, as in
source VIRTUALENV/bin/activate econometrics ipython qtconsole --profile=econometrics
Windows (Anaconda)
Starting IPython requires activating the virtual environment and the starting IPython with the correct proﬁle using cmd.
24

ANACONDA/Scripts/activate.bat econometrics ipython --profile=econometrics
Starting using the QtConsole is similar.
ANACONDA/Scripts/activate.bat econometrics ipython qtconsole --profile=econometrics
Launchers can be created for the both the virtual environment and the IPython interactive Python console. First, open a text editor, enter
cmd /k "ANACONDA\Scripts\activate econometrics"
and save the ﬁle as ANACONDA\envs\econometrics\python-econometrics.bat. The batch ﬁle will open a command prompt in the econometrics virtual environment. Right click on the batch ﬁle and select Send To, Desktop (Create Shortcut) which will place a shortcut on the desktop. Next, create a launcher to run IPython in the standard Windows cmd.exe console. Open a text editor enter
cmd "/c ANACONDA\Scripts\activate econometrics && start "" "ipython.exe" --profile= econometrics"
and save the ﬁle as ANACONDA\envs\econometrics\ipython-plain.bat. Finally, right click on ipython-plain.bat select Sent To, Desktop (Create Shortcut). The icon of the shortcut will be generic, and if you want a more meaningful icon, select the properties of the shortcut, and then Change Icon, and navigate to c:\Anaconda\envs\econometrics\Menu\ and select IPython.ico. Opening the batch ﬁle should create a window similar to that in ﬁgure 1.1.
Launching the QtConsole is similar. Start by entering the following command in a text editor
cmd "/c ANACONDA\Scripts\activate econometrics && start "" "pythonw" ANACONDA\envs\ econometrics\Scripts\ipython-script.py qtconsole --profile=econometrics"
and then saving the ﬁle as ANACONDA\envs\econometrics\ipython-qtconsole.bat. Create a shortcut for this batch ﬁle, and change the icon if desired.
Windows (Direct)
If using the direct installation method on Windows, open a text editor, enter the following text
cmd "/c VIRTUALENV\Scripts\activate.bat && start "" "python" VIRTUALENV\Scripts\ ipython-script.py --profile=econometrics"
and save the ﬁle in VIRTUALENV as ipython.bat. Right-click on ipython.bat and Send To, Desktop (Create Shortcut). The icon of the shortcut will be generic, and if you want a nice icon, select the properties of the shortcut, and then Change Icon, and navigate to VIRTUALENV\Scripts\ and select IPython.ico.
The QtConsole can be conﬁgured to run by entering
cmd "/c VIRTUALENV\Scripts\activate.bat && start "" "pythonw" VIRTUALENV\Scripts\ ipython-script.py qtconsole --profile=econometrics"
saving the ﬁle as VIRTUALENV\ipython-qtconsole.bat and ﬁnally right-click and Sent To, Desktop (Create Shortcut). The icon can be changed using the same technique as the basic IPython shell.
25

26

Chapter 2
Python 2.7 vs. 3 (and the rest)
Python comes in a number of ﬂavors which may be suitable for econometrics, statistics and numerical analysis. This chapter explains why 2.7 was chosen for these notes and highlights some of the available alternatives.
2.1 Python 2.7 vs. 3
Python 2.7 is the ﬁnal version of the Python 2.x line – all future development work will focus on Python 3. It may seem strange to learn an “old” language. The reasons for using 2.7 are:
• There are more modules available for Python 2.7. While all of the core python modules are available for both Python 2.7 and 3, some of the more esoteric modules are either only available for 2.7 or have not been extensively tested in Python 3. Over time, many of these modules will be available for Python 3, but they aren’t ready today.
• The language changes relevant for numerical computing are very small – and these notes explicitly minimize these so that there should few changes needed to run against Python 3+ in the future (ideally none).
• Conﬁguring and installing 2.7 is easier. • Anaconda defaults to 2.7 and the selection of packages available for Python 3 is limited. Learning Python 3 has some advantages: • No need to update in the future. • Some improved out-of-box behavior for numerical applications.
2.2 Intel Math Kernel Library and AMD Core Math Library
Intel’s MKL and AMD’s CML provide optimized linear algebra routines. The functions in these libraries execute faster than basic those in linear algebra libraries and are, by default, multithreaded so that a many linear algebra operations will automatically make use all of the processors on your system. Most standard builds of NumPy do not include these, and so it is important to use a Python distribution built with an
27

appropriate linear algebra library (especially if computing inverses or eigenvalues of large matrices). The three primary methods to access NumPy built with the Intel MKL are:
• Use Anaconda on any platform and secure a license for MKL (free for academic use, otherwise $29 at the time of writing).
• Use the pre-built NumPy binaries made available by Christoph Gohlke for Windows.
• Follow instructions for building NumPy on Linux with MKL, which is free on Linux.
There are no pre-built libraries using AMD’s CML, and so it is necessary to build NumPy from scratch if using an AMD processor (or buy an Intel system, which is an easier solution).
2.3 Other Variants
Some other variants of the recommended version of Python are worth mentioning.
2.3.1 Enthought Canopy Enthought Canopy is an alternative to Anaconda. It is available for Windows, Linux and OS X. Canopy is regularly updated and is currently freely available in its basic version. The full version is also freely available to academic users. Canopy is built using MKL, and so matrix algebra performance is very fast.
2.3.2 IronPython IronPython is a variant which runs on the Common Language Runtime (CLR , aka Windows .NET). The core modules – NumPy and SciPy – are available for IronPython, and so it is a viable alternative for numerical computing, especially if already familiar with the C# or interoperation with .NET components is important. Other libraries, for example, matplotlib (plotting) are not available, and so there are some important limitations.
2.3.3 Jython Jython is a variant which runs on the Java Runtime Environment (JRE). NumPy is not available in Jython which severely limits Jython’s usefulness for numeric work. While the limitation is important, one advantage of Python over other languages is that it is possible to run (mostly unaltered) Python code on a JVM and to call other Java libraries.
2.3.4 PyPy PyPy is a new implementation of Python which uses Just-in-time compilation to accelerate code, especially loops (which are common in numerical computing). It may be anywhere between 2 - 500 times faster than standard Python. Unfortunately, at the time of writing, the core library, NumPy is only partially implemented, and so it is not ready for use. Current plans are to have a version ready in the near future, and if so, PyPy may quickly become the preferred version of Python for numerical computing.
28

2.A Relevant Differences between Python 2.7 and 3
Most differences between Python 2.7 and 3 are not important for using Python in econometrics, statistics and numerical analysis. I will make three common assumptions which will allow 2.7 and 3 to be used interchangeable. The conﬁguration instructions in the previous chapter for IPython will produce the expected behavior when run interactively. Note that these differences are important in stand-alone Python programs.
2.A.1 print print is a function used to display test in the console when running programs. In Python 2.7, print is a keyword which behaves differently from other functions. In Python 3, print behaves like most functions. The standard use in Python 2.7 is
print ’String to Print’
while in Python 3 the standard use is
print(’String to Print’)
which resembles calling a standard function. Python 2.7 contains a version of the Python 3 print, which can be used in any program by including
from __future__ import print_function
at the top of the ﬁle. I prefer the Python 3 version of print, and so I assume that all programs will include this statement.
2.A.2 division Python 3 changes the way integers are divided. In Python 2.7, the ratio of two integers was always an integer, and so results are truncated towards 0 if the result was fractional. For example, in Python 2.7, 9/5 is 1. Python 3 gracefully converts the result to a ﬂoating point number, and so in Python 3, 9/5 is 1.8. When working with numerical data, automatically converting ratios avoids some rare errors. Python 2.7 can use the Python 3 behavior by including
from __future__ import division
at the top of the program. I assume that all programs will include this statement.
2.A.3 range and xrange It is often useful to generate a sequence of number for use when iterating over the some data. In Python 2.7, the best practice is to use the keyword xrange to do this, while in Python 3, this keyword has been renamed range. I will always use xrange and so it is necessary to replace xrange with range if using Python 3.
2.A.4 Unicode strings Unicode is an industry standard for consistently encoding text. The computer alphabet was originally limited to 128 characters which is insufﬁcient to contain the vast array of characters in all written languages.
29

Unicode expands the possible space to be up to 231 characters (depending on encoding). Python 3 treats all strings as unicode unlike Python 2.7 where characters are a single byte, and unicode strings require the special syntax u’unicode string’ or unicode(’unicode string’). In practice this is unlikely to impact most numeric code written in Python except possibly when reading or writing data. If working in a language where characters outside of the standard but limited 128 character set are commonly encountered, it may be useful to use
from __future__ import unicode_literals
to will help with future compatibility when moving to Python 3.
30

Chapter 3
Built-in Data Types
Before diving into Python for analyzing data or running Monte Carlos, it is necessary to understand some basic concepts about the core Python data types. Unlike domain-speciﬁc languages such as MATLAB or R, where the default data type has been chosen for numerical work, Python is a general purpose programming language which is also well suited to data analysis, econometrics and statistics. For example, the basic numeric type in MATLAB is an array (using double precision, which is useful for ﬂoating point mathematics), while the basic numeric data type in Python is a 1-dimensional scalar which may be either an integer or a double-precision ﬂoating point, depending on the formatting of the number when input.
3.1 Variable Names
Variable names can take many forms, although they can only contain numbers, letters (both upper and lower), and underscores (_). They must begin with a letter or an underscore and are CaSe SeNsItIve. Additionally, some words are reserved in Python and so cannot be used for variable names (e.g. import or for). For example,
x = 1.0 X = 1.0 X1 = 1.0 X1 = 1.0 x1 = 1.0 dell = 1.0 dellreturns = 1.0 dellReturns = 1.0 _x = 1.0 x_ = 1.0
are all legal and distinct variable names. Note that names which begin or end with an underscore, while legal, are not normally used since by convention these convey special meaning.1 Illegal names do not follow these rules.
1Variable names with a single leading underscores, for example _some_internal_value, indicate that the variable is for internal use by a module or class. While indicated to be private, this variable will generally be accessible by calling code. Double leading underscores, for example __some_private_value indicate that a value is actually private and is not accessible. Variable names with trailing underscores are used to avoid conﬂicts with reserved Python words such as class_ or lambda_. Double leading and trailing underscores are reserved for “magic” variable (e.g. __init__) , and so should be avoided except when speciﬁcally accessing a feature.
31

# Not allowed x: = 1.0 1X = 1 X-1 = 1 for = 1
Multiple variables can be assigned on the same line using commas,
x, y, z = 1, 3.1415, ’a’
3.2 Core Native Data Types
3.2.1 Numeric
Simple numbers in Python can be either integers, ﬂoats or complex. Integers correspond to either 32 bit or 64-bit integers, depending on whether the python interpreter was compiled for a 32-bit or 64-bit operating system, and ﬂoats are always 64-bit (corresponding to doubles in C/C++). Long integers, on the other hand, do not have a ﬁxed size and so can accommodate numbers which are larger than maximum the basic integer type can handle. This chapter does not cover all Python data types, and instead focuses on those which are most relevant for numerical analysis, econometrics and statistics. The byte, bytearray and memoryview data types are not described.
3.2.1.1 Floating Point (ﬂoat)
The most important (scalar) data type for numerical analysis is the ﬂoat. Unfortunately, not all noncomplex numeric data types are ﬂoats. To input a ﬂoating data type, it is necessary to include a . (period, dot) in the expression. This example uses the function type() to determine the data type of a variable.
>>> x = 1 >>> type(x) int
>>> x = 1.0 >>> type(x) float
>>> x = float(1) >>> type(x) float
This example shows that using the expression that x = 1 produces an integer-valued variable while x = 1.0 produces a ﬂoat-valued variable. Using integers can produce unexpected results and so it is important to include “.0” when expecting a ﬂoat.
3.2.1.2 Complex (complex)
Complex numbers are also important for numerical analysis. Complex numbers are created in Python using j or the function complex().
32

>>> x = 1.0 >>> type(x) float
>>> x = 1j >>> type(x) complex
>>> x = 2 + 3j >>> x (2+3j)
>>> x = complex(1) >>> x (1+0j)
Note that a +b j is the same as complex(a ,b ), while complex(a ) is the same as a +0j.
3.2.1.3 Integers (int and long)
Floats use an approximation to represent numbers which may contain a decimal portion. The integer data type stores numbers using an exact representation, so that no approximation is needed. The cost of the exact representation is that the integer data type cannot express anything that isn’t an integer, rendering integers of limited use in most numerical work.
Basic integers can be entered either by excluding the decimal (see ﬂoat), or explicitly using the int() function. The int() function can also be used to convert a ﬂoat to an integer by round towards 0.
>>> x = 1 >>> type(x) int
>>> x = 1.0 >>> type(x) float
>>> x = int(x) >>> type(x) int
Integers can range from −231 to 231 − 1. Python contains another type of integer, known as a long integer, which has no effective range limitation. Long integers are entered using the syntax x = 1L or by calling long(). Additionally python will automatically convert integers outside of the standard integer range to long integers.
>>> x = 1 >>> x 1
>>> type(x) int
33

>>> x = 1L >>> x 1L
>>> type(x) long
>>> x = long(2) >>> type(x) long
>>> y = 2 >>> type(y) int
>>> x = y ** 64 # ** is denotes exponentiation, y^64 in TeX >>> x 18446744073709551616L
The trailing L after the number indicates that it is a long integer, rather than a standard integer.
3.2.2 Boolean (bool)
The Boolean data type is used to represent true and false, using the reserved keywords True and False. Boolean variables are important for program ﬂow control (see Chapter 13) and are typically created as a result of logical operations (see Chapter 11), although they can be entered directly.
>>> x = True >>> type(x) bool
>>> x = bool(1) >>> x True
>>> x = bool(0) >>> x False
Non-zero, non-empty values generally evaluate to true when evaluated by bool(). Zero or empty values such as bool(0), bool(0.0), bool(0.0j), bool(None), bool(’’) and bool([]) are all false.
3.2.3 Strings (str)
Strings are not usually important for numerical analysis, although they are frequently encountered when dealing with data ﬁles, especially when importing or when formatting output for human consumption. Strings are delimited using ’’ or "" but not using combination of the two delimiters (i.e. do not try ’") in a single string, except when used to express a quotation.
>>> x = ’abc’ >>> type(x)
34

str
>>> y = ’"A quotation!"’ >>> print(y) "A quotation!"
String manipulation is further discussed in Chapter 21.
3.2.3.1 Slicing Strings
Substrings within a string can be accessed using slicing. Slicing uses [] to contain the indices of the characters in a string, where the ﬁrst index is 0, and the last is n − 1 (assuming the string has n letters). The following table describes the types of slices which are available. The most useful are s[i ], which will return the character in position i , s[:i ], which return the leading characters from positions 0 to i − 1, and s[i :] which returns the trailing characters from positions i to n − 1. The table below provides a list of the types of slices which can be used. The second column shows that slicing can use negative indices which essentially index the string backward.

Slice

Behavior

s[:]
s[i ] s[i :] s[:i ] s[i : j ] s[i : j :m ]

Entire string

Charactersi

Charactersi , . . . , n − 1

Characters0, . . . , i − 1

Charactersi , . . . , j − 1

Charactersi ,i + m,. . .i + m

j −i −1 m

Slice

Behavior

s[−i ] s[−i :] s[:−i ] s[− j :−i ] s[− j :−i :m ]

Characters n − i

Charactersn − i , . . . , n − 1

Characters0, . . . , n − i − 1

Characters n − j , . . . , n − i − 1, − j < −i

Characters n − j ,n − j + m,. . .,n − j + m

j −i − m

>>> text = ’Python strings are sliceable.’ >>> text[0] ’P’
>>> text[10] ’i’
>>> L = len(text) >>> text[L] # Error IndexError: string index out of range
>>> text[L-1] ’.’
>>> text[:10] ’Python str’
>>> text[10:] ’ings are sliceable.’
35

3.2.4 Lists (list)
Lists are a built-in data type which require other data types to be useful. A list is a collection of other objects – ﬂoats, integers, complex numbers, strings or even other lists. Lists are essential to Python programming and are used to store collections of other values. For example, a list of ﬂoats can be used to express a vector (although the NumPy data types array and matrix are better suited). Lists also support slicing to retrieve one or more elements. Basic lists are constructed using square braces, [], and values are separated using commas.
>>> x = [] >>> type(x) builtins.list
>>> x=[1,2,3,4] >>> x [1,2,3,4]
# 2-dimensional list (list of lists) >>> x = [[1,2,3,4], [5,6,7,8]] >>> x [[1, 2, 3, 4], [5, 6, 7, 8]]
# Jagged list, not rectangular >>> x = [[1,2,3,4] , [5,6,7]] >>> x [[1, 2, 3, 4], [5, 6, 7]]
# Mixed data types >>> x = [1,1.0,1+0j,’one’,None,True] >>> x [1, 1.0, (1+0j), ’one’, None, True]
These examples show that lists can be regular, nested and can contain any mix of data types including other lists.
3.2.4.1 Slicing Lists
Lists, like strings, can be sliced. Slicing is similar, although lists can be sliced in more ways than strings. The difference arises since lists can be multi-dimensional while strings are always 1 × n. Basic list slicing is identical to slicing strings, and operations such as x[:], x[1:], x[:1] and x[-3:] can all be used. To understand slicing, assume x is a 1-dimensional list with n elements and i ≥ 0, j > 0, i < j ,m ≥ 1. Python uses 0-based indices, and so the n elements of x can be thought of as x0, x1, . . . , xn−1.
36

Slice

Behavior,

x[:]
x[i ] x[i :] x[:i ] x[i : j ] x[i : j :m ]

Return all x

Return xi

Return xi , . . . xn−1

Return x0, . . . , xi −1

Return xi , xi +1, . . . x j −1

Returns xi ,xi +m ,. . .xi +m

j −i −1 m

Slice

Behavior

x[i ] x[−i ] x[−i :] x[:−i ] x[− j :−i ] x[− j :−i :m ]

Return xi

Returns xn−i except when i = −0

Return xn−i , . . . , xn−1

Return x0, . . . , xn−i

Return xn−j , . . . , xn−i

Returns xn− j ,xn− j +m ,. . .,xn− j +m

j −i −1 m

The default list slice uses a unit stride (step size of one) . It is possible to use other strides using a third input in the slice so that the slice takes the form x[i:j:m] where i is the index to start, j is the index to end (exclusive) and m is the stride length. For example x[::2] will select every second element of a list and is equivalent to x[0:n:2] where n = len(x). The stride can also be negative which can be used to select the elements of a list in reverse order. For example, x[::-1] will reverse a list and is equivalent to x[0:n:-1] .
Examples of accessing elements of 1-dimensional lists are presented below.
>>> x = [0,1,2,3,4,5,6,7,8,9] >>> x[0] 0 >>> x[5] 5 >>> x[10] # Error IndexError: list index out of range >>> x[4:] [4, 5, 6, 7, 8, 9] >>> x[:4] [0, 1, 2, 3] >>> x[1:4] [1, 2, 3] >>> x[-0] 0 >>> x[-1] 9 >>> x[-10:-1] [0, 1, 2, 3, 4, 5, 6, 7, 8]
List can be multidimensional, and slicing can be done directly in higher dimensions. For simplicity, consider slicing a 2-dimensional list x = [[1,2,3,4], [5,6,7,8]]. If single indexing is used, x[0] will return the ﬁrst (inner) list, and x[1] will return the second (inner) list. Since the list returned by x[0] is sliceable, the inner list can be directly sliced using x[0][0] or x[0][1:4].
>>> x = [[1,2,3,4], [5,6,7,8]] >>> x[0] [1, 2, 3, 4] >>> x[1] [5, 6, 7, 8] >>> x[0][0] 1
37

>>> x[0][1:4] [2, 3, 4] >>> x[1][-4:-1] [5, 6, 7]

3.2.4.2 List Functions

A number of functions are available for manipulating lists. The most useful are

Function

Method

Description

list.append(x,value)
len(x)
list.extend(x,list ) list.pop(x,index) list.remove(x,value) list.count(x,value) del x[slice]

x.append(value) – x.extend(list ) x.pop(index) x.remove(value) x.count(value)

Appends value to the end of the list. Returns the number of elements in the list. Appends the values in list to the existing list.2 Removes the value in position index and returns the value. Removes the ﬁrst occurrence of value from the list. Counts the number of occurrences of value in the list. Deletes the elements in slice.

>>> x = [0,1,2,3,4,5,6,7,8,9] >>> x.append(0) >>> x [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
>>> len(x) 11
>>> x.extend([11,12,13]) >>> x [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 11, 12, 13]
>>> x.pop(1) 1
>>> x [0, 2, 3, 4, 5, 6, 7, 8, 9, 0, 11, 12, 13]
>>> x.remove(0) >>> x [2, 3, 4, 5, 6, 7, 8, 9, 0, 11, 12, 13]
Elements can also be deleted from lists using the keyword del in combination with a slice.
>>> x = [0,1,2,3,4,5,6,7,8,9] >>> del x[0] >>> x [1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> x[:3] [1, 2, 3]

38

>>> del x[:3] >>> x [4, 5, 6, 7, 8, 9]
>>> del x[1:3] >>> x [4, 7, 8, 9]
>>> del x[:] >>> x []
3.2.5 Tuples (tuple)
A tuple is in many ways like a list – tuple contain multiple pieces of data which may contain a mix of data types. Aside from using a different syntax to construct a tuple, they are close enough to lists to ignore the difference except that tuples are immutable. Immutability means that the elements the comprise a tuple cannot be changed. It is not possible to add or remove elements form a tuple. However, if a tuple contains a mutable data type, for example a tuple that contains a list, the contents mutable data type can change.
Tuples are constructed using parentheses (()), rather than square braces ([]) of lists. Tuples can be sliced in an identical manner as lists. A list can be converted into a tuple using tuple() (Similarly, a tuple can be converted to list using list()).
>>> x =(0,1,2,3,4,5,6,7,8,9) >>> type(x) tuple
>>> x[0] 0
>>> x[-10:-5] (0, 1, 2, 3, 4)
>>> x = list(x) >>> type(x) list
>>> x = tuple(x) >>> type(x) tuple
>>> x= ([1,2],[3,4]) >>> x[0][1] = -10 >>> x # Contents can change, elements cannot ([1, -10], [3, 4])
Note that tuples containing a single element must contain a comma when created, so that x = (2,) is assign a tuple to x, while x=(2) will assign 2 to x. The latter interprets the parentheses as if they are part of a mathematical formula rather than being used to construct a tuple. x = tuple([2]) can also be used to
39

create a single element tuple. Lists do not have this issue since square brackets do not have this ambiguity.
>>> x =(2) >>> type(x) int
>>> x = (2,) >>> type(x) tuple
>>> x = tuple([2]) >>> type(x) tuple

3.2.5.1 Tuple Functions
Tuples are immutable, and so only have the methods index and count, which behave in an identical manner to their list counterparts.

3.2.6 Xrange (xrange)

A xrange is a useful data type which is most commonly encountered when using a for loop. xrange(a,b,i)

creates the sequences that follows the pattern a , a + i , a + 2i , . . . , a + (m − 1)i where m =

b −a i

. In other

words, it ﬁnd all integers x starting with a such a ≤ x < b and where two consecutive values are sepa-

rated by i . xrange can be called with 1 or two parameters – xrange(a,b) is the same as xrange(a,b,1)

and xrange(b) is the same as xrange(0,b,1).

>>> x = xrange(10) >>> type(x) xrange

>>> print(x) xrange(0, 10)

>>> list(x) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

>>> x = xrange(3,10) >>> list(x) [3, 4, 5, 6, 7, 8, 9]

>>> x = xrange(3,10,3) >>> list(x) [3, 6, 9]

>>> y = range(10) >>> type(y) list

>>> y

40

[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
xrange is not technically a list, which is why the statement print(x) returns xrange(0,10). Explicitly converting with list produces a list which allows the values to be printed. Technically xrange is an iterator which does not actually require the storage space of a list. This can be seen in the differences between using y = range(10), which returns a list and y=xrange(10) which returns an xrange object. Best practice is to use xrange instead of range.3
3.2.7 Dictionary (dict)
Dictionaries are encountered far less frequently than then any of the previously described data types in numerical Python. They are, however, commonly used to pass options into other functions such as optimizers, and so familiarity with dictionaries is important. Dictionaries in Python are composed of keys (words) and values (deﬁnitions). Dictionaries keys must be unique primitive data types (e.g. strings, the most common key), and values can contain any valid Python data type.4 Values are accessed using keys.
>>> data = {’age’: 34, ’children’ : [1,2], 1: ’apple’} >>> type(data) dict
>>> data[’age’] 34
Values associated with an existing key can be updated by making an assignment to the key in the dictionary.
>>> data[’age’] = ’xyz’ >>> data[’age’] ’xyz’
New key-value pairs can be added by deﬁning a new key and assigning a value to it.
>>> data[’name’] = ’abc’ >>> data {1: ’apple’, ’age’: ’xyz’, ’children’: [1, 2], ’name’: ’abc’}
Key-value pairs can be deleted using the reserved keyword del.
>>> del data[’age’] >>> data {1: ’apple’, ’children’: [1, 2], ’name’: ’abc’}
3.2.8 Sets (set, frozenset)
Sets are collections which contain all unique elements of a collection. set and frozenset only differ in that the latter is immutable (and so has higher performance), and so set is similar to a unique list while frozenset is similar to a unique tuple . While sets are generally not important in numerical analysis, they can be very useful when working with messy data – for example, ﬁnding the set of unique tickers in a long list of tickers.
3xrange has been removed in Python 3 and range is always an iterator. 4Formally dictionary keys must support the __hash__ function, equality comparison and it must be the case that different keys have different hashes.
41

3.2.8.1 Set Functions

A number of methods are available for manipulating sets. The most useful are

Function

Method

Description

set.add(x,element)
len(x)
set.difference(x,set ) set.intersection(x,set ) set.remove(x,element ) set.union(x,set )

x.add(element) – x.difference(set ) x.intersection(set ) x.remove(element) x.union(set )

Appends element to a set. Returns the number of elements in the set. Returns the elements in x which are not in set. Returns the elements of x which are also in set. Removes element from the set. Returns the set containing all elements of x and set.

The code below demonstrates the use of set. Note that ’MSFT’ is repeated in the list used to initialize the set, but only appears once in the set since all elements must be unique.
>>> x = set([’MSFT’,’GOOG’,’AAPL’,’HPQ’,’MSFT’]) >>> x {’AAPL’, ’GOOG’, ’HPQ’, ’MSFT’}

>>> x.add(’CSCO’) >>> x {’AAPL’, ’CSCO’, ’GOOG’, ’HPQ’, ’MSFT’}

>>> y = set([’XOM’, ’GOOG’]) >>> x.intersection(y) {’GOOG’}

>>> x = x.union(y) >>> x {’AAPL’, ’CSCO’, ’GOOG’, ’HPQ’, ’MSFT’, ’XOM’}

>>> x.remove(’XOM’) {’AAPL’, ’CSCO’, ’GOOG’, ’HPQ’, ’MSFT’}
A frozenset supports the same methods except add and remove.

3.3 Python and Memory Management
Python uses a highly optimized memory allocation system which attempts to avoid allocating unnecessary memory. As a result, when one variable is assigned to another (e.g. to y = x), these will actually point to the same data in the computer’s memory. To verify this, id() can be used to determine the unique identiﬁcation number of a piece of data.5
>>> x = 1 >>> y = x >>> id(x) 82970264L
>>> id(y)
5The ID numbers on your system will likely differ from those in the code listing.
42

82970264L
>>> x = 2.0 >>> id(x) 93850568L
>>> id(y) 82970264L
In the above example, the initial assignment of y = x produced two variables with the same ID. However, once x was changed, its ID changed while the ID of y did not, indicating that the data in each variable was stored in different locations. This behavior is both safe and efﬁcient, and is common to the basic Python immutable types: int, long, ﬂoat, complex, string, tuple, frozenset and xrange.
3.3.1 Example: Lists
Lists are mutable and so assignment does not create a copy , and so changes to either variable affect both.
>>> x = [1, 2, 3] >>> y = x >>> y[0] = -10 >>> y [-10, 2, 3]
>>> x [-10, 2, 3]
Slicing a list creates a copy of the list and any immutable types in the list – but not mutable elements in the list.
>>> x = [1, 2, 3] >>> y = x[:] >>> id(x) 86245960L
>>> id(y) 86240776L
To see that the inner lists are not copied, consider the behavior of changing one element in a nested list.
>>> x=[[0,1],[2,3]] >>> y = x[:] >>> y [[0, 1], [2, 3]]
>>> id(x[0]) 117011656L
>>> id(y[0]) 117011656L
>>> x[0][0]
43

0.0
>>> id(x[0][0]) 30390080L
>>> id(y[0][0]) 30390080L
>>> y[0][0] = -10.0 >>> y [[-10.0, 1], [2, 3]]
>>> x [[-10.0, 1], [2, 3]]
When lists are nested or contain other mutable objects (which do not copy), slicing copies the outermost list to a new ID, but the inner lists (or other objects) are still linked. In order to copy nested lists, it is necessary to explicitly call deepcopy(), which is in the module copy.
>>> import copy as cp >>> x=[[0,1],[2,3]] >>> y = cp.deepcopy(x) >>> y[0][0] = -10.0 >>> y [[-10.0, 1], [2, 3]]
>>> x [[0, 1], [2, 3]]
3.4 Exercises
1. Enter the following into Python, assigning each to a unique variable name:
(a) 4 (b) 3.1415 (c) 1.0 (d) 2+4j (e) ’Hello’ (f ) ’World’
2. What is the type of each variable? Use type if you aren’t sure.
3. Which of the 6 types can be:
(a) Added + (b) Subtracted (c) Multiplied *
44

(d) Divided /
4. What are the types of the output (when an error is not produced) in the above operations? 5. Input the variable ex = ’Python is an interesting and useful language for numerical computing!’.
Using slicing, extract:
(a) Python (b) ! (c) computing (d) in
Note: There are multiple answers for all. (e) !gnitupmoc laciremun rof egaugnal lufesu dna gnitseretni na si nohtyP’ (Reversed) (f ) nohtyP (g) Pto sa neetn n sfllnug o ueia optn!
6. What are the direct 2 methods to construct a tuple that has only a single item? How many ways are there to construct a list with a single item?
7. Construct a nested list to hold the matrix
1 .5 .5 1
so that item [i][j] corresponds to the position in the matrix (Remember that Python uses 0 indexing). 8. Assign the matrix you just created ﬁrst to x, and then assign y=x. Change y[0][0] to 1.61. What happens to x? 9. Next assign z=x[:] using a simple slice. Repeat the same exercise using y[0][0] = 1j. What happens to x and z ? What are the ids of x, y and z? What about x[0], y[0] and z[0]? 10. How could you create w from x so that w can be changed without affecting x? 11. Initialize a list containing 4, 3.1415, 1.0, 2+4j, ’Hello’, ’World’. How could you:
(a) Delete 1.0 if you knew its position? What if you didn’t know its position? (b) How can the list [1.0, 2+4j, ’Hello’] be added to the existing list? (c) How can the list be reversed? (d) In the extended list, how can you count the occurrence of ’Hello’?
12. Construct a dictionary with the keyword-value pairs: ’alpha’ and 1.0, ’beta’ and 3.1415, ’gamma’ and -99. How can the value of alpha be retrieved?
13. Convert the ﬁnal list at the end of problem 11 to a set. How is the set different from the list?
45

46

Chapter 4
Arrays and Matrices
NumPy provides the most important data types for econometrics, statistics and numerical analysis – arrays and matrices. The difference between these two data types are:
• Arrays can have 1, 2, 3 or more dimensions, and matrices always have 2 dimensions. This means that a 1 by n vector stored as an array has 1 dimension and n elements, while the same vector stored as a matrix has 2-dimensions where the sizes of the dimensions are 1 and n (in either order).
• Standard mathematical operators on arrays operate element-by-element. This is not the case for matrices, where multiplication (*) follows the rules of linear algebra. 2-dimensional arrays can be multiplied using the rules of linear algebra using dot. Similarly, the function multiply can be used on two matrices for element-by-element multiplication.
• Arrays are more common than matrices, and all functions are thoroughly tested with arrays. Functions should also work with matrices, but an occasional strange result may be encountered.
• Arrays can be quickly treated as a matrix using either asmatrix or mat without copying the underlying data.
The best practice is to use arrays and to use the asmatrix view when writing linear algebra-heavy code. It is also important to test any custom function with both arrays and matrices to ensure that false assumptions about the behavior of multiplication have not been made.
4.1 Array
Arrays are the base data type in NumPy, are are arrays in some ways similar to lists since they both contain collections of elements. The focus of this section is on homogeneous arrays containing numeric data – that is, an array where all elements have the same numeric type (heterogeneous arrays are covered in Chapters 16 and 17). Additionally, arrays, unlike lists, are always rectangular so that all rows have the same number of elements.
Arrays are initialized from lists (or tuples) using array. Two-dimensional arrays are initialized using lists of lists (or tuples of tuples, or lists of tuples, etc.), and higher dimensional arrays can be initialized by further nesting lists or tuples.
47

>>> x = [0.0, 1, 2, 3, 4] >>> y = array(x) >>> y array([ 0., 1., 2., 3.,

4.])

>>> type(y) numpy.ndarray
Two (or higher) -dimensional arrays are initialized using nested lists.
>>> y = array([[0.0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]) >>> y array([[ 0., 1., 2., 3., 4.],
[ 5., 6., 7., 8., 9.]])

>>> shape(y) (2L, 5L)

>>> y = array([[[1,2],[3,4]],[[5,6],[7,8]]]) >>> y array([[[1, 2],
[3, 4]],

[[5, 6], [7, 8]]])

>>> shape(y) (2L, 2L, 2L)

4.1.1 Array dtypes
Homogeneous arrays can contain a variety of numeric data types. The most useful is ’ﬂoat64’, which corresponds to the python built-in data type of ﬂoat (and C/C++ double). By default, calls to array will preserve the type of the input, if possible. If an input contains all integers, it will have a dtype of ’int32’ (similar to the built in data type int). If an input contains integers, ﬂoats, or a mix of the two, the array’s data type will be float64. If the input contains a mix of integers, ﬂoats and complex types, the array will be initialized to hold complex data.
>>> x = [0, 1, 2, 3, 4] # Integers >>> y = array(x) >>> y.dtype dtype(’int32’)
>>> x = [0.0, 1, 2, 3, 4] # 0.0 is a float >>> y = array(x) >>> y.dtype dtype(’float64’)
>>> x = [0.0 + 1j, 1, 2, 3, 4] # (0.0 + 1j) is a complex >>> y = array(x)
48

>>> y array([ 0.+1.j, 1.+0.j, 2.+0.j, 3.+0.j, 4.+0.j])
>>> y.dtype dtype(’complex128’)
NumPy attempts to ﬁnd the smallest data type which can represent the data when constructing an array. It is possible to force NumPy to select a particular dtype by using the keyword argument dtype=datetype when initializing the array.
>>> x = [0, 1, 2, 3, 4] # Integers >>> y = array(x) >>> y.dtype dtype(’int32’)
>>> y = array(x, dtype=’float64’) # String dtype >>> y.dtype dtype(’float64’)
>>> y = array(x, dtype=float64) # NumPy type dtype >>> y.dtype dtype(’float64’)
4.2 Matrix
Matrices are essentially a subset of arrays, and behave in a virtually identical manner. The two important differences are:
• Matrices always have 2 dimensions
• Matrices follow the rules of linear algebra for * 1- and 2-dimensional arrays can be copied to a matrix by calling matrix on an array. Alternatively, calling mat or asmatrix provides a faster method where an array can behave like a matrix without copying any data.
>>> x = [0.0, 1, 2, 3, 4] # Any float makes all float >>> y = array(x) >>> type(y) numpy.ndarray
>>> y * y # Element-by-element array([ 0., 1., 4., 9., 16.])
>>> z = asmatrix(x) >>> type(z) numpy.matrixlib.defmatrix.matrix
>>> z * z # Error ValueError: matrices are not aligned
49

4.3 1-dimensional Arrays
A vector

x = [1 2 3 4 5]
is entered as a 1-dimensional array using
>>> x=array([1.0,2.0,3.0,4.0,5.0]) array([ 1., 2., 3., 4., 5.])

>>> ndim(x) 1
If an array with 2-dimensions is required, it is necessary to use a trivial nested list.
>>> x=array([[1.0,2.0,3.0,4.0,5.0]]) array([[ 1., 2., 3., 4., 5.]])

>>> ndim(x) 2
A matrix is always 2-dimensional and so a nested list is not required to initialize a a row matrix
>>> x=matrix([1.0,2.0,3.0,4.0,5.0]) >>> x matrix([[ 1., 2., 3., 4., 5.]])

>>> ndim(x) 2
Notice that the output matrix representation uses nested lists ([[ ]]) to emphasize the 2-dimensional structure of all matrices. The column vector,

1

2



x = 3  

 

4

 

5

is entered as a matrix or 2-dimensional array using a set of nested lists

>>> x=matrix([[1.0],[2.0],[3.0],[4.0],[5.0]]) >>> x matrix([[ 1.],
[ 2.], [ 3.], [ 4.], [ 5.]])

>>> x = array([[1.0],[2.0],[3.0],[4.0],[5.0]]) >>> x array([[ 1.],

50

[ 2.], [ 3.], [ 4.], [ 5.]])

4.4 2-dimensional Arrays

Matrices and 2-dimensional arrays are rows of columns, and so





123

x =  4 5 6 ,





789

is input by enter the matrix one row at a time, each in a list, and then encapsulate the row lists in another list.

>>> x = array([[1.0,2.0,3.0],[4.0,5.0,6.0],[7.0,8.0,9.0]]) >>> x array([[ 1., 2., 3.],
[ 4., 5., 6.], [ 7., 8., 9.]])

4.5 Multidimensional Arrays
Higher dimensional arrays are useful when tracking matrix valued processes through time, such as a timevarying covariance matrices. Multidimensional (N -dimensional) arrays are available for N up to about 30, depending on the size of each matrix dimension. Manually initializing higher dimension arrays is tedious and error prone, and so it is better to use functions such as zeros((2, 2, 2)) or empty((2, 2, 2)).

4.6 Concatenation

Concatenation is the process by which one vector or matrix is appended to another. Arrays and matrices can be concatenation horizontally or vertically. For example, suppose

x = 1 2 and y = 5 6 and z = x

34

78

y

needs to be constructed. This can be accomplished by treating x and y as elements of a new matrix and using the function concatenate to join them. The inputs to concatenate must be grouped in a tuple and the keyword argument axis speciﬁes whether the arrays are to be vertically (axis = 0) or horizontally (axis = 1) concatenated.

>>> x = array([[1.0,2.0],[3.0,4.0]]) >>> y = array([[5.0,6.0],[7.0,8.0]]) >>> z = concatenate((x,y),axis = 0) >>> z array([[ 1., 2.],

51

[ 3., [ 5., [ 7.,

4.], 6.], 8.]])

>>> z = concatenate((x,y),axis = 1) >>> z array([[ 1., 2., 5., 6.],
[ 3., 4., 7., 8.]])
Concatenating is the code equivalent of block-matrix forms in standard matrix algebra. Alternatively, the functions vstack and hstack can be used to vertically or horizontally stack arrays, respectively.
>>> z = vstack((x,y)) # Same as z = concatenate((x,y),axis = 0) >>> z = hstack((x,y)) # Same as z = concatenate((x,y),axis = 1)

4.7 Accessing Elements of an Array

Four methods are available for accessing elements contained within an array: scalar selection, slicing, numerical indexing and logical (or Boolean) indexing. Scalar selection and slicing are the simplest and so are presented ﬁrst. Numerical indexing and logical indexing both depends on specialized functions and so these methods are discussed in Chapter 12.
4.7.1 Scalar Selection
Pure scalar selection is the simplest method to select elements from an array, and is implemented using [i ] for 1-dimensional arrays, [i , j ] for 2-dimensional arrays and [i1,i2,. . .,in ] for general n -dimensional arrays.
>>> x = array([1.0,2.0,3.0,4.0,5.0]) >>> x[0] 1.0
>>> x = array([[1.0,2,3],[4,5,6]]) >>> x[1,2] 6.0
>>> type(x[1,2]) numpy.float64
Pure scalar selection always returns a single element which is not an array. The data type of the selected element matches the data type of the array used in the selection. Scalar selection can also be used to assign values in an array.
>>> x = array([1.0,2.0,3.0,4.0,5.0]) >>> x[0] = -5 >>> x array([-5., 2., 3., 4., 5.])
52

4.7.2 Array Slicing
Arrays, like lists and tuples, can be sliced. Arrays slicing is virtually identical to lists slicing except that a simpler slicing syntax is available since arrays are explicitly multidimensional and rectangular. Arrays are sliced using the syntax [:,:,. . .,:] (where the number of dimensions of the arrays determines the size of the slice).1 Recall that the slice notation a:b:s will select every sth element where the indices i satisfy a ≤ i < b so that the starting value a is always included in the list and the ending value b is always excluded. Additionally, a number of shorthand notations are commonly encountered
• : and :: are the same as 0:n:1 where n is the length of the array (or list).
• a: and a:n are the same as a:n:1 where n is the length of the array (or list).
• :b is the same as 0:b:1.
• ::s is the same as 0:n:s where n is the length of the array (or list).
Basic slicing of 1-dimensional arrays is identical to slicing a simple list, and the returned type of all slicing operations matches the array being sliced.
>>> x = array([1.0,2.0,3.0,4.0,5.0]) >>> y = x[:] array([ 1., 2., 3., 4., 5.])
>>> y = x[:2] array([ 1., 2.])
>>> y = x[1::2] array([ 2., 4.])
In 2-dimensional arrays, the ﬁrst dimension speciﬁes the row or rows of the slice and the second dimension speciﬁes the the column or columns. Note that the 2-dimensional slice syntax y[a:b,c:d] is the same as y[a:b,:][:,c:d] or y[a:b][:,c:d], although clearly the shorter form is preferred. In the case where only row slicing in needed y[a:b], which is the equivalent to y[a:b,:], is the shortest syntax.
>>> y = array([[0.0, 1, 2, 3, 4],[5, 6, 7, 8, 9]]) >>> y array([[ 0., 1., 2., 3., 4.],
[ 5., 6., 7., 8., 9.]])
>>> y[:1,:] # Row 0, all columns array([[ 0., 1., 2., 3., 4.]])
>> y[:1] # Same as y[:1,:] array([[ 0., 1., 2., 3., 4.]])
>>> y[:,:1] # all rows, column 0 array([[ 0.],
1It is not necessary to include all trailing slice dimensions, and any omitted trailing slices are set to select all elements (the slice :). For example, if x is a 3-dimensional array, x[0:2] is the same as x[0:2,:,:] and x[0:2,0:2] is the same as x[0:2,0:2,:].
53

[ 5.]])
>>> y[:1,0:3] # Row 0, columns 0 to 2 array([[ 0., 1., 2.]])
>>> y[:1][:,0:3] # Same as previous array([[ 0., 1., 2.]])
>>> y[:,3:] # All rows, columns 3 and 4 array([[ 3., 4.],
[ 8., 9.]])
>>> y = array([[[1.0,2],[3,4]],[[5,6],[7,8]]]) >>> y[:1,:,:] # Panel 0 of 3D y array([[[ 1., 2.],
[ 3., 4.]]])
In the previous examples, slice notation was always used even when only selecting 1 row or column. This was done to emphasize the difference between using slice notation, which always returns an array with the same dimension and using a scalar selector which will perform dimension reduction.
4.7.3 Mixed Selection using Scalar and Slice Selectors
When arrays have more than 1-dimension, it is often useful to mix scalar and slice selectors to select an entire row, column or panel of a 3-dimensional array. This is similar to pure slicing with one important caveat – dimensions selected using scalar selectors are eliminated. For example, if x is a 2-dimensional array, then x[0,:] will select the ﬁrst row. However, unlike the 2-dimensional array constructed using the slice x[:1,:], x[0,:] will be a 1-dimensional array.
>>> x = array([[1.0,2],[3,4]]) >>> x[:1,:] # Row 1, all columns, 2-dimensional array([[ 1., 2.]])
>>> x[0,:] # Row 1, all columns, dimension reduced array([ 1., 2.])
While these two selections appear similar, the ﬁrst produces a 2-dimensional array (note the [[ ]] syntax) while the second is a 1-dimensional array. In most cases where a single row or column is required, using scalar selectors such as y[0,:] is the best practice. It is important to be aware of the dimension reduction since scalar selections from a 2-dimensional arrays will no longer have 2-dimensions. This type of dimension reduction may matter when evaluating linear algebra expression.
The principle adopted by NumPy is that slicing should always preserve the dimension of the underlying array, while scalar indexing should always collapse the dimension(s). This is consistent with x[0,0] returning a scalar (or 0-dimensional array) since both selections are scalar. This is demonstrated in the next example which highlights the differences between pure slicing, mixed slicing and pure scalar selection. Note that the function ndim returns the number of dimensions of an array.
>>> x = array([[0.0, 1, 2, 3, 4],[5, 6, 7, 8, 9]]) >>> x[:1,:] # Row 0, all columns, 2-dimensional array([[ 0., 1., 2., 3., 4.]])
54

>>> ndim(x[:1,:]) 2
>>> x[0,:] # Row 0, all column, dim reduction to 1-d array array([ 0., 1., 2., 3., 4.])
>>> ndim(x[0,:]) 1
>>> x[0,0] # Top left element, dim reduction to scalar (0-d array) 0.0
>>> ndim(x[0,0]) 0
>>> x[:,0] # All rows, 1 column, dim reduction to 1-d array array([ 0., 5.])

4.7.4 Assignment using Slicing

Slicing and scalar selection can be used to assign arrays that have the same dimension as the slice.2

>>> x = array([[0.0]*3]*3) >>> x array([[0, 0, 0],
[0, 0, 0], [0, 0, 0]])

# *3 repeats the list 3 times

>>> x[0,:] = array([1.0, 2.0, 3.0]) >>> x array([[ 1., 2., 3.],
[ 0., 0., 0.], [ 0., 0., 0.]])

>>> x[::2,::2] = array([[-99.0,-99],[-99,-99]]) # 2 by 2 >>> x array([[-99., 2., -99.],
[ 0., 0., 0.], [-99., 0., -99.]])

>>> x[1,1] = pi

>>> x

array([[-99.

, 2.

, -99.

],

[ 0.

, 3.14159265, 0.

],

[-99.

, 0.

, -99.

]])

2Formally, the array to be assigned must be broadcastable to the size of the slice. Broadcasting is described in Chapter 5, and assignment using broadcasting is discussed in Chapter 12.
55

NumPy attempts to automatic (silent) data type conversion if an element with one data type is inserted into an array wit a different data type. For example, if an array has an integer data type, place a ﬂoat into the array results in the ﬂoat being truncated and stored as an integer. This is dangerous, and so in most cases, arrays should be initialized to contain ﬂoats unless a considered decision is taken to use a different data type.
>>> x = [0, 1, 2, 3, 4] # Integers >>> y = array(x) >>> y.dtype dtype(’int32’)

>>> y[0] = 3.141592 >>> y array([3, 1, 2, 3, 4])

>>> x = [0.0,1, 2, 3, 4] # 1 Float makes all float >>> y = array(x) >>> y.dtype dtype(’float64’)

>>> y[0] = 3.141592

>>> y

array([ 3.141592, 1.

, 2.

, 3.

, 4.

])

4.7.5 Linear Slicing using flat

Data in matrices is stored in row-major order – elements are indexed by ﬁrst counting across rows and then down columns. For example, in the matrix





123

x = 4 5 6 





789

the ﬁrst element of x is 1, the second element is 2, the third is 3, the fourth is 4, and so on. In addition to slicing using the [:,:,. . .,:] syntax, k -dimensional arrays can be linear sliced. Linear
slicing assigns an index to each element of the array, starting with the ﬁrst (0), the second (1), and so on until the ﬁnal element (n − 1). In 2-dimensions, linear slicing works by ﬁrst counting across rows, and then down columns. To use linear slicing, the method or function flat must ﬁrst be used.

>>> y = reshape(arange(25.0),(5,5)) >>> y array([[ 0., 1., 2., 3., 4.],
[ 5., 6., 7., 8., 9.], [ 10., 11., 12., 13., 14.], [ 15., 16., 17., 18., 19.], [ 20., 21., 22., 23., 24.]])

>>> y[0] # Same as y[0,:], first row array([ 0., 1., 2., 3., 4.])

56

>>> y.flat[0] # Scalar slice, flat is 1-dimensional 0

>>> y[6] # Error IndexError: index out of bounds

>>> y.flat[6] # Element 6 6.0

>>> y.flat[12:15] array([ 12., 13., 14.])

>>> y.flat[:] # All element slice array([[ 0., 1., 2., 3., 4.,
11., 12., 13., 14., 15., 22., 23., 24.]])

5., 16.,

6., 17.,

7., 18.,

8., 19.,

9., 20.,

10., 21.,

Note that arange and reshape are useful functions are described in later chapters.

4.8 Slicing and Memory Management
Unlike lists, slices of arrays are do not copy the underlying data. Instead a slice of an array returns a view of the array which shares the data in the sliced array. This is important since changes in slices will propagate to the underlying array and to any other slices which share the same element.
>>> x = reshape(arange(4.0),(2,2)) >>> x array([[ 0., 1.],
[ 2., 3.]])
>>> s1 = x[0,:] # First row >>> s2 = x[:,0] # First column >>> s1[0] = -3.14 # Assign first element >>> s1 array([-3.14, 1. ])
>>> s2 array([-3.14, 2. ])
>>> x array([[-3.14, 1. ],
[ 2. , 3. ]])
If changes should not propagate to parent and sibling arrays, it is necessary to call copy on the slice. Alternatively, they can also be copied by calling array on arrays, or matrix on matrices.
>>> x = reshape(arange(4.0),(2,2)) >>> s1 = copy(x[0,:]) # Function copy >>> s2 = x[:,0].copy() # Method copy >>> s3 = array(x[0,:]) # Create a new array
57

>>> s1[0] = -3.14 >>> s1 array([-3.14, 1.])

>>> s2 array([ 0., 2.])

>>> s3 array([0., 1.])

>>> x[0,0] array([[ 0.,
[ 2.,

1.], 3.]])

There is one notable exception to this rule – when using pure scalar selection the (scalar) value returned is always a copy.

>>> x = arange(5.0) >>> y = x[0] # Pure scalar selection >>> z = x[:1] # A pure slice >>> y = -3.14 >>> y # y Changes -3.14

>>> x # No propagation array([ 0., 1., 2., 3., 4.])

>>> z # No changes to z either array([ 0.])

>>> z[0] = -2.79 >>> y # No propagation since y used pure scalar selection -3.14

>>> x # z is a view of x, so changes propagate array([-2.79, 1. , 2. , 3. , 4. ])
Finally, assignments from functions which change values will automatically create a copy of the underlying array.
>>> x = array([[0.0, 1.0],[2.0,3.0]]) >>> y = x >>> print(id(x),id(y)) # Same
129186368 129186368 >>> y = x + 1.0 >>> y array([[ 1., 2.],
[ 3., 4.]])

>>> print(id(x),id(y)) # Different 129186368 129183104

58

>>> x # Unchanged array([[ 0., 1.],
[ 2., 3.]])
>>> y = exp(x) >>> print(id(x),id(y)) # Also Different 129186368 129185120
Even trivial function such as y = x + 0.0 create a copy of x, and so the only scenario where explicit copying is required is when y is directly assigned using a slice of x, and changes to y should not propagate to x.
4.9 import and Modules
Python, by default, only has access to a small number of built-in types and functions. The vast majority of functions are located in modules, and before a function can be accessed, the module which contains the function must be imported. For example, when using ipython --pylab (or any variants), a large number of modules are automatically imported, including NumPy and matplotlib. This is style of importing useful for learning and interactive use, but care is needed to make sure that the correct module is imported when designing more complex programs.
import can be used in a variety of ways. The simplest is to use from module import * which imports all functions in module. This method of using import can dangerous since if you use it more than once, it is possible for functions to be hidden by later imports. A better method is to just import the required functions. This still places functions at the top level of the namespace, but can be used to avoid conﬂicts.
from pylab import log2 # Will import log2 only from scipy import log10 # Will not import the log2 from SciPy
The functions log2 and log10 can both be called in subsequent code. An alternative, and more common, method is to use import in the form
import pylab import scipy import numpy
which allows functions to be accessed using dot-notation and the module name, for example scipy.log2. It is also possible to rename modules when imported using as
import pylab as pl import scipy as sp import numpy as np
The only difference between these two is that import scipy is implicitly calling import scipy as scipy. When this form of import is used, functions are used with the “as” name. For example, the load provided by NumPy is accessed using sp.log2, while the pylab load is pl.log2 – and both can be used where appropriate. While this method is the most general, it does require slightly more typing.
4.10 Calling Functions
Functions calls have different conventions than most other expressions. The most important difference is that functions can take more than one input and return more than one output. The generic structure
59

of a function call is out1, out2, out3, . . . = functionname(in1, in2, in3, . . .). The important aspects of this structure are
• If multiple outputs are returned, but only one output variable is provided, the output will (generally) be a tuple.
• If more than one output variable is given in a function call, the number of output must match the number of output provided by the function. It is not possible to ask for two output if a function returns three – using an incorrect number of outputs results in ValueError: too many values to unpack.
• Both inputs and outputs must be separated by commas (,)
• Inputs can be the result of other functions as long only one output is returned. For example, the following are equivalent,
>>> y = var(x) >>> mean(y)
and
>>> mean(var(x))
Required Arguments Most functions have required arguments. For example, consider the deﬁnition of array from help(array), array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0) Array has 1 required input, object, which is the list or tuple which contains values to use when creating the array. Required arguments can be determined by inspecting the function signature since all of the input follow the patters keyword=default except object – required arguments will not have a default value provided. The other arguments can be called in order (array accepts at most 2 non-keyword arguments). >>> array([[1.0,2.0],[3.0,4.0]]) array([[ 1., 2.],
[ 3., 4.]])
>>> array([[1.0,2.0],[3.0,4.0]], ’int32’) array([[1, 2],
[3, 4]])
Keyword Arguments All of the arguments to array can be called by their keyword, which is listed in the help ﬁle deﬁnition. array(object=[[1.0,2.0],[3.0,4.0]]) array([[1.0,2.0],[3.0,4.0]], dtype=None, copy=True, order=None, subok=False, ndmin=0) Keyword arguments have two important advantages. First, they do not have to appear in any order (Note: randomly ordering arguments is not good practice, and this is only an example), and second, keyword arguments can be used only when needed since a default value is always given.
60

>>> array(dtype=’complex64’, object = [[1.0,2.0],[3.0,4.0]], copy=True) array([[ 1.+0.j, 2.+0.j],
[ 3.+0.j, 4.+0.j]], dtype=complex64)
Default Arguments
Functions have defaults for optional arguments. These are listed in the function deﬁnition and appear in the help in the form keyword=default. Returning to array, all inputs have default arguments except object – the only required input.
Multiple Outputs
Some functions can have more than 1 output. These functions can be used in a single output mode or in multiple output mode. For example, shape can be used on an array to determine the size of each dimension.
>>> x = array([[1.0,2.0],[3.0,4.0]]) >>> s = shape(x) >>> s (2L, 2L)
Since shape will return as many outputs as there are dimensions, it can be called with 2 outputs when the input is a 2-dimensional array.
>>> x = array([[1.0,2.0],[3.0,4.0]]) >>> M,N = shape(x) >>> M 2L
>>> N 2L
Requesting more outputs than are required will produce an error.
>>> M,N,P = shape(x) # Error ValueError: need more than 2 values to unpack
Similarly, providing two few output can also produce an error. Consider the case where the argument used with shape is a 3-dimensional array.
>>> x = randn(10,10,10) >>> shape(x) (10L, 10L, 10L) >>> M,N = shape(x) # Error ValueError: too many values to unpack
4.11 Exercises
1. Input the following mathematical expressions into Python as both arrays and matrices.
u = [1 1 2 3 5 8]
61

1

1



v

=

 

2

 

 

3

 

 

5

 

8

x= 1 0 01

y= 1 2 34





1212

z = 3 4 3 4 





1212

w= x x yy

Note: A column vector must be entered as a 2-dimensional array. 2. What command would pull x out of w ? (Hint: w[?,?] is the same as x .) 3. What command would pull x y out of w? Is there more than one? If there are, list all alternatives. 4. What command would pull y out of z ? List all alternatives. 5. Explore the options for creating an array using keyword arguments. Create an array containing
y = 1 −2 −3 4

with combination of keyword arguments in:
(a) dtype in float, float64, int32 (32-bit integers), uint32 (32-bit unsigned integers) and complex128 (double precision complex numbers).
(b) copy either True or False. (c) ndim either 3 or 4. Use shape(y) to see the effect of this argument.
6. Enter y = [1.6180 2.7182 3.1415] as an array. Deﬁne x = mat(y). How is x different from y ?

62

Chapter 5
Basic Math

Note: Python contains a math module providing functions which operate on built-in scalar data types (e.g. float and complex). This and subsequent chapters assume mathematical functions must operate on arrays and matrices, and so are imported from NumPy.

5.1 Operators

These standard operators are available:

Operator + * / **

Meaning Addition Subtraction Multiplication Division (Left divide) Exponentiation

Example
x+y x-y x*y x/y x**y

Algebraic
x+y
x−y
xy
x y
xy

When x and y are scalars, the behavior of these operators is obvious. The only possible exception

occurs when both x and y are integers for division, where x/y returns the smallest integer less than the

ratio (e.g.

x y

). The simplest method to avoid this problem is use from

__future__ import division

which changes the default behavior. Alternatively, declaring numeric values to be ﬂoats using 5.0 rather

than 5 will also mitigate this issue as well explicitly casting integers to ﬂoats before dividing.

>>> x = 9 >>> y = 5 >>> (type(x), type(y)) (int, int)

>>> x/y # Since division imported 1.8

>>> float(x)/y 1.8
When x and y are arrays or matrices, the behavior of mathematical operations is more complex. The examples in this chapter refer to arrays, and except where explicit differences are noted, it is safe to assume that the behavior of 2-dimensional arrays and matrices is identical.

63

I recommend using the import command from __future__ import division in all programs and IPython. The “future” division avoids this issue by always casting division to ﬂoating point when the result is not an exact integer.

5.2 Broadcasting
Under the normal rules of array mathematics, addition and subtraction are only deﬁned for arrays with the same shape or between an array and a scalar. For example, there is no obvious method to add a 5-element vector and a 5 by 4 matrix. NumPy uses a technique called broadcasting to allow element-by-element mathematical operations on arrays (and matrices) which would not be compatible under the standard rules of array mathematics.
Arrays can be used in element-by-element mathematics if x is broadcastable to y. Suppose x is an m dimensional array with dimensions d = [d1, d2. . . dm ], and y is an n -dimensional array with dimensions f = [ f1, f2. . . fn ] where m ≥ n . Formally, two arrays are broadcastable if the following two conditions hold.
1. If m > n , then treat y as a m -dimensional array with size g = [1, 1, . . . , 1, f1, f2. . . fn ] where the number of 1s prepended is m − n . The dimensions are gi = 1 for i = 1, . . . m − n and gi = fi −m+n for i > m − n.
2. For i = 1, . . . , m , max (di , gi ) / min (di , gi ) ∈ {1, max (di , gi )}.
The ﬁrst rule is simply states that if one array has fewer dimensions, it is treated as having the same number of dimensions as the larger array by prepending 1s. The second rule states that arrays will only be broadcastable if either (a) they have the same dimension along axis i or (b) one has dimension 1 along axis i . When 2 arrays are broadcastable, the dimension of the output array is max (di , gi ) for i = 1, . . . n .
Consider the following examples where m, n and p are assumed to have different values.

x

y

Broadcastable Output Size x Operation

y Operation

Any

Scalar

m, 1

1, n or n

m, 1

n, 1

×

m, n

1, n or n

m, n, 1 1, 1, p or 1, p or p

m, n, p 1, 1, p or 1, p or p

m, n, 1

p, 1

×

m, 1, p 1, n, 1, 1, n, p or n, 1

Same as x m, n

x tile(x,(1,n))

tile(y,shape(x)) tile(y,(m,1))

m, n m, n, p m, n, p

x tile(x,(1,1,p))
x

tile(y,(m,1)) tile(y,(m,n,1)) tile(y,(m,n,1))

m, n, p

tile(x,(1,n,1)) tile(y,(m,1,p))

One simple method to visualize broadcasting is to use an add and subtract operation where the addition causes the smaller array to be broadcast, and then the subtract removes the values in the larger array. This will produce a replicated version of the smaller array which shows the nature of the broadcasting.
64

>>> x = array([[1,2,3.0]]) >>> x array([[ 1., 2., 3.]])
>>> y = array([[0],[0],[0.0]]) >>> y array([[ 0.],
[ 0.], [ 0.]])
>>> x + y # Adding 0 produces broadcast array([[ 1., 2., 3.],
[ 1., 2., 3.], [ 1., 2., 3.]])
In the next example, x is 3 by 5, so y must be either scalar or a 5-element array or a 1 × 5 array to be broadcastable. When y is a 3-element array (and so matches the leading dimension), an error occurs.
>>> x = reshape(arange(15),(3,5)) >>> x array([[ 0, 1, 2, 3, 4],
[ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]]) >>> y = 1 >>> x + y - x array([[5, 5, 5, 5, 5], [5, 5, 5, 5, 5], [5, 5, 5, 5, 5]])
>>> y = arange(5) >>> y array([0, 1, 2, 3, 4])
>>> x + y - x array([[0, 1, 2, 3, 4],
[0, 1, 2, 3, 4], [0, 1, 2, 3, 4]])
>>> y = arange(3) >>> y array([0, 1, 2])
>>> x + y - x # Error ValueError: operands could not be broadcast together with shapes (3,5) (3)
5.3 Array and Matrix Addition (+) and Subtraction (-)
Subject to broadcasting restrictions, addition and subtraction works element-by-element.
65

5.4 Array Multiplication (*)

The standard multiplication operator differs for variables with type array and matrix. For arrays, * performs element-by-element multiplication and so inputs must be broadcastable. For matrices, * is matrix multiplication as deﬁned by linear algebra, and there is no broadcasting.
Conformable arrays can be multiplied according to the rules of matrix algebra using the function dot(). For simplicity, assume x is N by M and y is K by L . If M = K , dot(x,y) will produce the array N by L array z[i,j] = =dot( x[i,:], y[:,j]) where dot on 1-dimensional arrays is the usual vector dot-product. The behavior of dot() is described as:

y

Scalar

Array

Scalar

Any

Any

x

z = xy

zi j = x yi j

Array

Any

Inside Dimensions Match

zi j = y xi j

zi j =

M k =1

xi

k

yk

j

These rules conform to the standard rules of matrix multiplication. dot() can also be used on higher dimensional arrays, and is useful if x is T by M by N and y is N by P to produce an output matrix which is T by M by P , where each of the M by P (T in total) have the form dot(x[i],y).

5.5 Matrix Multiplication (*)

If x is N by M and y is K by L and both are non-scalar matrices, x*y requires M = K . Similarly, y*x requires L = N . If x is scalar and y is a matrix, then z=x*y produces z(i,j)=x*y(i,j). Suppose z=x * y where both x and y are matrices:

y

Scalar

Matrix

Scalar

Any

Any

x

z = xy

zi j = x yi j

Matrix

Any

Inside Dimensions Match

zi j = y xi j

zi j =

M k =1

xi

k

yk

j

Note: These conform to the standard rules of matrix multiplication. multiply() performs element-by-element multiplication of matrices, and will use broadcasting if nec-
essary. Matrices are identical to 2-dimensional arrays when performing element-by-element multiplication.

5.6 Array and Matrix Division (/)
Division is always element-by-element, and the rules of broadcasting are used.

5.7 Array Exponentiation (**)
Array exponentiation operates element-by-element, and the rules of broadcasting are used. 66

5.8 Matrix Exponentiation (**)
Matrix exponentiation differs from array exponentiation, and can only be used on square matrices. When x is a square matrix and y is a positive integer, x**y produces x*x*...*x (y times). When y is a negative integer, x**y produces inv(x**abs(y)) where inv produces the inverse, and so x must have full rank. Python does not support non-integer values for y, although x p can be deﬁned (in linear algebra) using eigenvalues and eigenvectors for a subset of all matrices.
5.9 Parentheses
Parentheses can be used in the usual way to control the order in which mathematical expressions are evaluated, and can be nested to create complex expressions. See section 5.11 on Operator Precedence for more information on the order mathematical expressions are evaluated.
5.10 Transpose
Matrix transpose is expressed using either the transpose function, or the shortcut .T. For instance, if x is an M by N matrix, transpose(x), x.transpose() and x.T are all its transpose with dimensions N by M . In practice, using the .T is the preferred method and will improve readability of code. Consider
>>> x = asmatrix(randn(2,2)) >>> xpx1 = x.T * x >>> xpx2 = x.transpose() * x >>> xpx3 = transpose(x) * x
Transpose has no effect on 1-dimensaional arrays. In 2-dimensions, transpose switches indices so that if z=x.T, z[j,i] is that same as x[i,j]. In higher dimensions, transpose reverses the order or the indices. For example, if x has 3 dimensions and z=x.T, then x[i,j,k] is the same as z[k,j,i]. Transpose takes an optional second argument to specify the axis to use when permuting the array.
5.11 Operator Precedence
Computer math, like standard math, has operator precedence which determined how mathematical expressions such as
2**3+3**2/7*13
are evaluated. Best practice is to always use parentheses to avoid ambiguity in the order or operations. The order of evaluation is:
67

Operator ( ), [ ] , ( ,)
** ~
+,*, /, //, %
+,-
& ^
<, <=, >, >= ==, !=
in, not in is, is not
not and
or
=,+=,-=,/=,*=,**=

Name Parentheses, Lists, Tuples Exponentiation Bitwise NOT Unary Plus, Unary Minus Multiply, Divide, Modulo Addition and Subtraction Bitwise AND Bitwise XOR Bitwise OR Comparison operators Equality operators Identity Operators Membership Operators Boolean NOT Boolean AND Boolean OR Assignment Operators

Rank 1 2 3 3 4 5 6 7 8 9 9 9 9 10 11 12 13

Note that some rows of the table have the same precedence, and are only separated since they are conceptually different. In the case of a tie, operations are executed left-to-right. For example, x**y**z is interpreted as (x**y)**z. This table has omitted some operators available in Python which are not generally useful in numerical analysis (e.g. shift operators).
Note: Unary operators are + or - operations that apply to a single element. For example, consider the expression (-4). This is an instance of a unary negation since there is only a single operation and so (-4)**2 produces 16. On the other hand, -4**2 produces -16 since ∗∗ has higher precedence than unary negation and so is interpreted as -(4**2). -4 * -4 produces 16 since it is interpreted as (-4) * (-4), since unary negation has higher precedence than multiplication.

5.12 Exercises
1. Using the arrays entered in exercise 1 of chapter 4, compute the values of u + v , v + u , v u , u v and x y (where the multiplication is as deﬁned as linear algebra).
2. Repeat exercise 1 treating the inputs as matrices.
3. Which of the arrays in exercise 1 are broadcastable with: a = [3 2],
b= 3 , 2
c = [3 2 1 0] , 68

3

d

=

 

2

 .

 

1

 

0

4. Is x/1 legal? If not, why not. What about 1/x?

5. Compute the values (x+y)**2 and x**2+x*y+y*x+y**2. Are they the same when x and y are arrays? What if they are matrices?

6. Is x**2+2*x*y+y**2 the same as any of the above?
7. When will x**y for matrices be the same as x**y for vectors?
8. For conformable arrays, is a*b+a*c the same as a*b+c? If so, show with an example. If not, how can the second be changed so they are equal.

9. Suppose a command x**y*w+z was entered. What restrictions on the dimensions of w, x, y and z must be true for this to be a valid statement?

10. What is the value of -2**4? What about (-2)**4? What about -2*-2*-2*-2?

69

70

Chapter 6
Basic Functions and Numerical Indexing
6.1 Generating Arrays and Matrices
linspace linspace(l,u,n) generates a set of n points uniformly spaced between l, a lower bound (inclusive) and u, an upper bound (inclusive).
>>> x = linspace(0, 10, 11) >>> x array([ 0., 1., 2., 3., 4., 5., 6., 7., 8., 9., 10.])
logspace logspace(l,u,n) produces a set of logarithmically spaced points between 10l and 10u . It is identical to 10**linspace(l,u,n).
arange arange(l,u,s) produces a set of points spaced by s between l, a lower bound (inclusive) and u, an upper bound (exclusive). arange can be used with a single parameter, so that arange(n) is equivalent to arange(0,n,1). Note that arange will return integer data type if all inputs are integer.
>>> x = arange(11) array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
>>> x = arange(11.0) array([ 0., 1., 2., 3., 4., 5., 6., 7., 8., 9., 10.])
>>> x = arange(4, 10, 1.25) array([ 4. , 5.25, 6.5 , 7.75, 9. ])
meshgrid meshgrid broadcasts two vectors to produce two 2-dimensional arrays, and is a useful function when plotting 3-dimensional functions.
71

>>> x = arange(5) >>> y = arange(3) >>> X,Y = meshgrid(x,y) >>> X array([[0, 1, 2, 3, 4],
[0, 1, 2, 3, 4], [0, 1, 2, 3, 4]])
>>> Y array([[0, 0, 0, 0, 0],
[1, 1, 1, 1, 1], [2, 2, 2, 2, 2]])

r_
r_ is a convenience function which generates 1-dimensional arrays from slice notation. While r_ is highly ﬂexible, the most common use it r_[ start : end : stepOrCount ] where start and end are the start and end points, and stepOrCount can be either a step size, if a real value, or a count, if complex.
>>> r_[0:10:1] # arange equiv array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

>>> r_[0:10:.5] # arange equiv array([ 0. , 0.5, 1. , 1.5,
5.5, 6. , 6.5, 7. ,

2. , 7.5,

2.5, 8. ,

3. , 8.5,

3.5, 9. ,

4. , 4.5, 9.5])

5. ,

>>> r_[0:10:5j] # linspace equiv, includes end point array([ 0. , 2.5, 5. , 7.5, 10. ])
r_ can also be used to concatenate slices using commas to separate slice notation blocks.
>>> r_[0:2, 7:11, 1:4] array([ 0, 1, 7, 8, 9, 10, 1, 2, 3])
Note that r_ is not a function and that is used with [].

c_
c_ is virtually identical to r_ except that column arrays are generates, which are 2-dimensional (second dimension has size 1)
>>> c_[0:5:2] array([[0],
[2], [4]])

>>> c_[1:5:4j]

array([[ 1.

],

[ 2.33333333],

[ 3.66666667],

[ 5.

]])

c_, like r_, is not a function and is used with [].

72

ix_
ix_(a,b) constructs an n -dimensional open mesh from n 1-dimensional lists or arrays. The output of ix_ is an n -element tuple containing 1-dimensional arrays. The primary use of ix_ is to simplify selecting slabs inside a matrix. Slicing can also be used to select elements from an array as long as the slice pattern is regular. ix_ is particularly useful for selecting elements from an array using indices which are not regularly spaced, as in the ﬁnal example.
>>> x = reshape(arange(25.0),(5,5)) >>> x array([[ 0., 1., 2., 3., 4.],
[ 5., 6., 7., 8., 9.], [ 10., 11., 12., 13., 14.], [ 15., 16., 17., 18., 19.], [ 20., 21., 22., 23., 24.]])
>>> x[ix_([2,3],[0,1,2])] # Rows 2 & 3, cols 0, 1 and 2 array([[ 10., 11., 12.],
[ 15., 16., 17.]])
>>> x[2:4,:3] # Same, standard slice array([[ 10., 11., 12.],
[ 15., 16., 17.]])
>>> x[ix_([0,3],[0,1,4])] # No slice equiv

mgrid

mgrid is very similar to meshgrid but behaves like r_ and c_ in that it takes slices as input, and uses a real valued variable to denote step size and complex to denote number of values. The output is an n + 1 dimensional vector where the ﬁrst index of the output indexes the meshes.

>>> mgrid[0:3,0:2:.5] array([[[ 0. , 0. , 0. ,
[ 1. , 1. , 1. , [ 2. , 2. , 2. ,

0. ], 1. ], 2. ]],

[[ 0. , [ 0. , [ 0. ,

0.5, 0.5, 0.5,

1. , 1. , 1. ,

1.5], 1.5], 1.5]]])

>>> mgrid[0:3:3j,0:2:5j] array([[[ 0. , 0. , 0. ,
[ 1.5, 1.5, 1.5, [ 3. , 3. , 3. ,

0. , 1.5, 3. ,

0. ], 1.5], 3. ]],

[[ 0. , [ 0. , [ 0. ,

0.5, 0.5, 0.5,

1. , 1. , 1. ,

1.5, 1.5, 1.5,

2. ], 2. ], 2. ]]])

73

ogrid

ogrid is identical to mgrid except that the arrays returned are always 1-dimensional. ogrid output is generally more appropriate for looping code, while mgrid is usually more appropriate for vectorized code. When the size of the arrays is large, then ogrid uses much less memory.

>>> ogrid[0:3,0:2:.5] [array([[ 0.],
[ 1.], [ 2.]]), array([[ 0. , 0.5, 1. , >>> ogrid[0:3:3j,0:2:5j] [array([[ 0. ], [ 1.5], [ 3. ]]), array([[ 0. , 0.5, 1. , 1.5, 2. ]])]

1.5]])]

6.2 Rounding
around, round around rounds to the nearest integer, or to a particular decimal place when called with two arguments.
>>> x = randn(3) array([ 0.60675173, -0.3361189 , -0.56688485])
>>> around(x) array([ 1., 0., -1.])
>>> around(x, 2) array([ 0.61, -0.34, -0.57])
around can also be used as a method on an ndarray – except that the method is named round. For example, x.round(2) is identical to around(x, 2). The change of names is needed to avoid conﬂicting with the Python built-in function round.
floor floor rounds to the next smallest integer.
>>> x = randn(3) array([ 0.60675173, -0.3361189 , -0.56688485])
>>> floor(x) array([ 0., -1., -1.])
ceil ceil rounds to the next largest integer.
74

>>> x = randn(3) array([ 0.60675173, -0.3361189 , -0.56688485])
>>> ceil(x) array([ 1., -0., -0.])
Note that the values returned are still ﬂoating points and so -0. is the same as 0..

6.3 Mathematics

sum, cumsum
sum sums elements in an array. By default, it will sum all elements in the array, and so the second argument is normally used to provide the axis to use – 0 to sum down columns, 1 to sum across rows. cumsum produces the cumulative sum of the values in the array, and is also usually used with the second argument to indicate the axis to use.
>>> x = randn(3,4) >>> x array([[-0.08542071, -2.05598312, 2.1114733 , 0.7986635 ],
[-0.17576066, 0.83327885, -0.64064119, -0.25631728], [-0.38226593, -1.09519101, 0.29416551, 0.03059909]])

>>> sum(x) # all elements -0.62339964288008698

>>> sum(x, 0) # Down rows, 4 elements array([-0.6434473 , -2.31789529, 1.76499762, 0.57294532])

>>> sum(x, 1) # Across columns, 3 elements array([ 0.76873297, -0.23944028, -1.15269233])

>>> cumsum(x,0) # Down rows array([[-0.08542071, -2.05598312,
[-0.26118137, -1.22270427, [-0.6434473 , -2.31789529,

2.1114733 , 1.47083211, 1.76499762,

0.7986635 ], 0.54234622], 0.57294532]])

sum and cumsum can both be used as function or as methods. When used as methods, the ﬁrst input is the axis so that sum(x,0) is the same as x.sum(0).

prod, cumprod
prod and cumprod behave similarly to sum and cumsum except that the product and cumulative product are returned. prod and cumprod can be called as function or methods.

diff diff computes the ﬁnite difference of a vector (also array) and returns n -1 an element vector when used on an n element vector. diff operates on the last axis by default, and so diff(x) operates across columns and returns x[:,1:size(x,1)]-x[:,:size(x,1)-1] for a 2-dimensional array. diff takes an optional keyword
75

argument axis so that diff(x, axis=0) will operate across rows. diff can also be used to produce higher order differences (e.g. double difference).
>>> x= randn(3,4) >>> x array([[-0.08542071, -2.05598312, 2.1114733 , 0.7986635 ],
[-0.17576066, 0.83327885, -0.64064119, -0.25631728], [-0.38226593, -1.09519101, 0.29416551, 0.03059909]])
>>> diff(x) # Same as diff(x,1) -0.62339964288008698
>>> diff(x, axis=0) array([[-0.09033996, 2.88926197, -2.75211449, -1.05498078],
[-0.20650526, -1.92846986, 0.9348067 , 0.28691637]])
>>> diff(x, 2, axis=0) # Double difference, column-by-column array([[-0.11616531, -4.81773183, 3.68692119, 1.34189715]])
exp exp returns the element-by-element exponential (e x ) for an array.
log log returns the element-by-element natural logarithm (ln(x )) for an array.
log10 log10 returns the element-by-element base-10 logarithm (log10 (x )) for an array.
sqrt √
sqrt returns the element-by-element square root ( x ) for an array.
square square returns the element-by-element square (x 2) for an array, and is equivalent to calling x**2.0 when x is an array (but not a matrix)
absolute, abs abs and absolute returns the element-by-element ab√solute value for an array. Complex modulus is returned when the input is complex valued (|a + b i | = a 2 + b 2).
sign sign returns the element-by-element sign function, deﬁned as 0 if x = 0, and x /|x | otherwise.
76

6.4 Complex Values
real real returns the real elements of a complex array. real can be called either as a function real(x) or as an attribute x.real.
imag imag returns the complex elements of a complex array. imag can be called either as a function imag(x) or as an attribute x.imag.
conj, conjugate conj returns the element-by-element complex conjugate for a complex array. conj can be called either as a function conj(x) or as a method x.conj(). conjugate is identical to conj.

6.5 Set Functions

unique

unique returns the unique elements in an array. It only operates on the entire array. An optional second argument can be returned which contains the original indices of the unique elements.

>>> x = repeat(randn(3),(2)) array([ 0.11335982, 0.11335982,
1.34424621])

0.26617443,

0.26617443,

1.34424621,

>>> unique(x) array([ 0.11335982, 0.26617443, 1.34424621])

>>> y,ind = unique(x, True) >>> ind array([0, 2, 4], dtype=int64)
>>> x.flat[ind] array([ 0.11335982, 0.26617443, 1.34424621])

in1d

in1d returns a Boolean array with the same size as the ﬁrst input array indicating the elements which are also in a second array.

>>> x = arange(10.0) >>> y = arange(5.0,15.0) >>> in1d(x,y) array([False, False, False, False, False,

True,

True,

True,

True,

True], dtype=bool)

77

intersect1d

intersect1d is similar to in1d, except that it returns the elements rather than a Boolean array, and only unique elements are returned. It is equivalent to unique(x.flat[in1d(x,y)]).

>>> x = arange(10.0) >>> y = arange(5.0,15.0) >>> intersect1d(x,y) array([ 5., 6., 7., 8.,

9.])

union1d
union1d returns the unique set of elements in 2 arrays.
>>> x = arange(10.0) >>> y = arange(5.0,15.0) >>> union1d(x,y) array([ 0., 1., 2., 3., 4., 5., 6., 7., 8., 9., 10.,
11., 12., 13., 14.])

setdiff1d

setdiff1d returns the set of the elements which are only in the ﬁrst array but not in the second array.

>>> x = arange(10.0) >>> y = arange(5.0,15.0) >>> setdiff1d(x,y) array([ 0., 1., 2., 3.,

4.])

setxor1d
setxor1d returns the set of elements which are in one (and only one) of two arrays.
>>> x = arange(10.0) >>> y = arange(5.0,15.0) >>> setxor1d(x,y) array([ 0., 1., 2., 3., 4., 10., 11., 12., 13., 14.])

6.6 Sorting and Extreme Values
sort
sort sorts the elements of an array. By default, it sorts using the last axis of x. It uses an optional second argument to indicate the axis to use for sorting (i.e. 0 for column-by-column, None for sorting all elements). sort does not alter the input when called as function, unlike the method version of sort.
>>> x = randn(4,2) >>> x array([[ 1.29185667, 0.28150618],
[ 0.15985346, -0.93551769],
78

[ 0.12670061, 0.6705467 ], [ 2.77186969, -0.85239722]])

>>> sort(x) array([[ 0.28150618,
[-0.93551769, [ 0.12670061, [-0.85239722,

1.29185667], 0.15985346], 0.6705467 ], 2.77186969]])

>>> sort(x, 0) array([[ 0.12670061, -0.93551769],
[ 0.15985346, -0.85239722], [ 1.29185667, 0.28150618], [ 2.77186969, 0.6705467 ]])

>>> sort(x, axis=None) array([-0.93551769, -0.85239722,
0.6705467 , 1.29185667,

0.12670061, 0.15985346, 2.77186969])

0.28150618,

ndarray.sort, argsort
ndarray.sort is a method for ndarrays which performs an in-place sort. It economizes on memory use, although x.sort() is different from x after the function, unlike a call to sort(x). x.sort() sorts along the last axis by default, and takes the same optional arguments as sort(x). argsort returns the indices necessary to produce a sorted array, but does not actually sort the data. It is otherwise identical to sort, and can be used either as a function or a method.
>>> x = randn(3) >>> x array([ 2.70362768, -0.80380223, -0.10376901])
>>> sort(x) array([-0.80380223, -0.10376901, 2.70362768])
>>> x array([ 2.70362768, -0.80380223, -0.10376901])
>>> x.sort() # In-place, changes x >>> x array([-0.80380223, -0.10376901, 2.70362768])

max, amax, argmax, min, amin, argmin

max and min return the maximum and minimum values from an array. They take an optional second argument which indicates the axis to use.

>>> x = randn(3,4) >>> x array([[-0.71604847,

0.35276614, -0.95762144,

0.48490885],

79

[-0.47737217, 1.57781686, -0.36853876, 2.42351936], [ 0.44921571, -0.03030771, 1.28081091, -0.97422539]])
>>> amax(x) 2.4235193583347918
>>> x.max() 2.4235193583347918
>>> x.max(0) array([ 0.44921571, 1.57781686, 1.28081091, 2.42351936])
>>> x.max(1) array([ 0.48490885, 2.42351936, 1.28081091])
max and min can only be used on arrays as methods. When used as a function, amax and amin must be used to avoid conﬂicts with the built-in functions max and min. This behavior is also seen in around and round. argmax and argmin return the index or indices of the maximum or minimum element(s). They are used in an identical manner to max and min, and can be used either as a function or method.

minimum, maximum

maximum and minimum can be used to compute the maximum and minimum of two arrays which are broadcastable.

>>> x = randn(4) >>> x array([-0.00672734,

0.16735647,

0.00154181, -0.98676201])

>>> y = randn(4) array([-0.69137963, -2.03640622, 0.71255975, -0.60003157])

>>> maximum(x,y) array([-0.00672734, 0.16735647, 0.71255975, -0.60003157])

6.7 Nan Functions
NaN function are convenience function which act similarly to their non-NaN versions, only ignoring NaN values (rather than propagating) when computing the function.
nansum nansum is identical sum, except that NaNs are ignored. nansum can be used to easily generate other NaNfunctions, such as nanstd (standard deviation, ignoring nans) since variance can be implemented using 2 sums.
>>> x = randn(4) >>> x[1] = nan >>> x
80

array([-0.00672734,

nan, 0.00154181, -0.98676201])

>>> sum(x) nan

>>> nansum(x) -0.99194753275859726

>>> nansum(x) / sum(x[logical_not(isnan(x))]) 1.0

>>> nansum(x) / sum(1-isnan(x)) # nanmean -0.33064917999999999

nanmax, nanargmax, nanmin, nanargmin
nanmax, nanmin, nanargmax and nanargmin are identical to their non-NaN counterparts, except that NaNs are ignored.

6.8 Functions and Methods/Properties

Many operations on NumPy arrays and matrices can be performed using a function or as a method of the array. For example, consider reshape.

>>> x = arange(25.0) >>> y = x.reshape((5,5)) >>> y array([[ 0., 1., 2.,
[ 5., 6., 7., [ 10., 11., 12., [ 15., 16., 17., [ 20., 21., 22.,

3., 8., 13., 18., 23.,

4.], 9.], 14.], 19.], 24.]])

>>> z = reshape(x,(5,5)) >>> z array([[ 0., 1., 2.,
[ 5., 6., 7., [ 10., 11., 12., [ 15., 16., 17., [ 20., 21., 22.,

3., 8., 13., 18., 23.,

4.], 9.], 14.], 19.], 24.]])

Both the function and method produce the same output and the choice of which to use is ultimately a personal decision. I use both and the choice primarily depends on the context. For example, to get the shape of an array, my preference is for x.shape over shape(x) since shape appears to be integral to x.1 On the other hand, I prefer shape(y+z) over (y+z).shape due to the presence of the mathematical operation.

1Formally shape is a property of an array, not a method since it does not require a function call.

81

6.9 Exercises
1. Construct each of the following sequences using linspace, arange and r_:

0, 1, . . . , 10

4, 5, 6, . . . , 13 0, .25, .5, .75, 1 0, −1, −2, . . . , −5
2. Show that logspace(0,2,21) can be constructed using linspace and 10 (and **). Similarly, show how linsapce(2,10,51) can be constructed with logspace and log10.
3. Determine the differences between the rounding by applying round (or around), ceil and floor to
y = [0, 0.5, 1.5, 2.5, 1.0, 1.0001, −0.5, −1, −1.5, −2.5]

4. Prove the relationship that

n j =1

j

=

n (n

+ 1)/2 for 0

≤

n

≤

10 using cumsum and directly using

math on an array.

5. randn(20) will generate an array containing draws from a standard normal random variable. If x=randn(20), which element of y=cumsum(x) is the same as sum(x)?

6. cumsum computes the cumulative sum while diff computes the difference. Is diff(cumsum(x)) the same as x? If not, how can a small modiﬁcation be made to the this statement to recover x?

7. Compute the exp of

y = [ln 0.5 ln 1 ln e ]

Note: You should use log and the constant numpy.e to construct y.
8. What is absolute of 0.0, -3.14, and 3+4j?
9. Suppose x = [−4 2 − 9 − 8 10]. What is the difference between y = sort(x) and x.sort()?
10. Using the same x as in the previous problem, ﬁnd the max. Also, using argmax and a slice, retrieve the same value.
11. Show that setdiff1d could be replaced with in1d and intersect1d using x = [1 2 3 4 5] and y = [1 2 4 6]? How could setxor1d be replaced with union1d, intersect1d and in1d?
12. Suppose y = [nan 2.2 3.9 4.6 nan 2.4 6.1 1.8] . How can nansum be used to compute the variance or the data? Note: sum(1-isnan(y)) will return the count of non-NaN values.

82

Chapter 7
Special Arrays
Functions are available to construct a number of useful, frequently encountered arrays.
ones
ones generates an array of 1s and is generally called with one argument, a tuple, containing the size of each dimension. ones takes an optional second argument (dtype) to specify the data type. If omitted, the data type is ﬂoat.
>>> M, N = 5, 5 >>> x = ones((M,N)) # M by N array of 1s >>> x = ones((M,M,N)) # 3D array >>> x = ones((M,N), dtype=’int32’) # 32-bit integers
ones_like creates an array with the same shape and data type as the input. Calling ones_like(x) is equivalent to calling ones(x.shape,x.dtype).
zeros
zeros produces an array of 0s in the same way ones produces an array of 1s, and commonly used to initialize an array to hold values generated by another procedure. zeros takes an optional second argument (dtype) to specify the data type. If omitted, the data type is ﬂoat.
>>> x = zeros((M,N)) # M by N array of 0s >>> x = zeros((M,M,N)) # 3D array of 0s >>> x = zeros((M,N),dtype=’int64’) # 64 bit integers
zeros_like creates an array with the same size and shape as the input. Calling zeros_like(x) is equivalent to calling zeros(x.shape,x.dtype).
empty
empty produces an empty (uninitialized) array to hold values generated by another procedure. empty takes an optional second argument (dtype) which speciﬁes the data type. If omitted, the data type is ﬂoat.
83

>>> x = empty((M,N)) # M by N empty array >>> x = empty((N,N,N,N)) # 4D empty array >>> x = empty((M,N),dtype=’float32’) # 32-bit floats (single precision)
Using empty is slightly faster than calling zeros since it does not assign 0 to all elements of the array – the “empty” array created will be populated with (essential random) non-zero values. empty_like creates an array with the same size and shape as the input. Calling empty_like(x) is equivalent to calling empty(x.shape,x.dtype).
eye, identity
eye generates an identity array – an array with ones on the diagonal, zeros everywhere else. Normally, an identity array is square and so usually only 1 input is required. More complex zero-padded arrays containing an identity matrix can be produced using optional inputs.
>>> In = eye(N)
identity is a virtually identical function with similar use, In = identity(N).
7.1 Exercises
1. Produce two arrays, one containing all zeros and one containing only ones, of size 10 × 5. 2. Multiply (linear algebra) these two arrays in both possible ways. 3. Produce an identity matrix of size 5. Take the exponential of this matrix, element-by-element. 4. How could ones and zeros be replaced with tile? 5. How could eye be replaced with diag and ones? 6. What is the value of y=empty((1,))? Is it the same as any element in y=empty((10,))?
84

Chapter 8
Array and Matrix Functions

Many functions operate exclusively on array inputs, including functions which are mathematical in nature, for example computing the eigenvalues and eigenvectors and functions for manipulating the elements of an array.
8.1 Views
Views are computationally efﬁcient methods to produce objects of one type which behave as other objects of another type without copying data. For example, an array x can always be converted to a matrix using matrix(x), which will copy the elements in x. View “fakes” the call to matrix and only inserts a thin layer so that x viewed as a matrix behaves like a matrix.
view
view can be used to produce a representation of an array, matrix or recarray as another type without copying the data. Using view is faster than copying data into a new class.
>>> x = arange(5) >>> type(x) numpy.ndarray
>>> x.view(matrix) matrix([[0, 1, 2, 3, 4]])
>>> x.view(recarray) rec.array([0, 1, 2, 3, 4])

asmatrix, mat

asmatrix and mat can be used to view an array as a matrix. This view is useful since matrix views will use matrix multiplication by default.

>>> x = array([[1,2],[3,4]])

>>> x * x array([[ 1, 4],

# Element-by-element

[ 9, 16]])

85

>>> mat(x) * mat(x) # Matrix multiplication matrix([[ 7, 10],
[15, 22]])
Both commands are equivalent to using view(matrix).
asarray
asarray work in a similar matter as asmatrix, only that the view produced is that of ndarray. Calling asarray is equivalent to using view(ndarray)
8.2 Shape Information and Transformation
shape
shape returns the size of all dimensions or an array or matrix as a tuple. shape can be called as a function or an attribute. shape can also be used to reshape an array by entering a tuple of sizes. Additionally, the new shape can contain -1 which indicates to expand along this dimension to satisfy the constraint that the number of elements cannot change.
>>> x = randn(4,3) >>> x.shape (4L, 3L)
>>> shape(x) (4L, 3L)
>>> M,N = shape(x) >>> x.shape = 3,4 >>> x.shape
(3L, 4L)
>>> x.shape = 6,-1 >>> x.shape (6L, 2L)
reshape
reshape transforms an array with one set of dimensions and to one with a different set, preserving the number of elements. Arrays with dimensions M by N can be reshaped into an array with dimensions K by L as long as M N = K L . The most useful call to reshape switches an array into a vector or vice versa.
>>> x = array([[1,2],[3,4]]) >>> y = reshape(x,(4,1)) >>> y array([[1],
[2], [3],
86

[4]])
>>> z=reshape(y,(1,4)) >>> z array([[1, 2, 3, 4]])
>>> w = reshape(z,(2,2)) array([[1, 2],
[3, 4]])
The crucial implementation detail of reshape is that arrays are stored using row-major notation. Elements in arrays are counted ﬁrst across rows and then then down columns. reshape will place elements of the old array into the same position in the new array and so after calling reshape, x (1) = y (1), x (2) = y (2), and so on.
size size returns the total number of elements in an array or matrix. size can be used as a function or an attribute.
>>> x = randn(4,3) >>> size(x) 12
>>> x.size 12
ndim ndim returns the size of all dimensions or an array or matrix as a tuple. ndim can be used as a function or an attribute .
>>> x = randn(4,3) >>> ndim(x) 2
>>> x.ndim 2
tile tile, along with reshape, are two of the most useful non-mathematical functions. tile replicates an array according to a speciﬁed size vector. To understand how tile functions, imagine forming an array composed of blocks. The generic form of tile is tile(X , (M , N ) ) where X is the array to be replicated, M is the number of rows in the new block array, and N is the number of columns in the new block array. For example, suppose X was an array
X= 1 2 34
87

and the block array
Y= X X X XXX
was required. This could be accomplished by manually constructing y using hstack and vstack.
>>> x = array([[1,2],[3,4]]) >>> z = hstack((x,x,x)) >>> y = vstack((z,z))
However, tile provides a much easier method to construct y
>>> w = tile(x,(2,3)) >>> y - w array([[0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]])
tile has two clear advantages over manual allocation: First, tile can be executed using parameters determined at run-time, such as the number of explanatory variables in a model and second tile can be used for arbitrary dimensions. Manual array construction becomes tedious and error prone with as few as 3 rows and columns. repeat is a related function which copies data is a less useful manner.
ravel
ravel returns a ﬂattened view (1-dimensional) of an array or matrix. ravel does not copy the underlying data (when possible), and so it is very fast.
>>> x = array([[1,2],[3,4]]) >>> x array([[ 1, 2],
[ 3, 4]])
>>> x.ravel() array([1, 2, 3, 4])
>>> x.T.ravel() array([1, 3, 2, 4])
flatten
flatten works much like ravel, only that is copies the array when producing the ﬂattened version.
flat
flat produces a numpy.flatiter object (ﬂat iterator) which is an iterator over a ﬂattened view of an array. Because it is an iterator, it is especially fast and memory friendly. flat can be used as an iterator in a for loop or with slicing notation.
88

