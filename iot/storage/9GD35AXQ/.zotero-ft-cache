Cours de Python
https://python.sdv.univ-paris-diderot.fr/
Patrick Fuchs et Pierre Poulain prénom [point] nom [arobase] univ-paris-diderot [point] fr
version du 9 mai 2019
Université Paris Diderot-Paris 7, Paris, France
Ce document est sous licence Creative Commons Attribution - Partage dans les Mêmes Conditions 3.0 France (CC BY-SA 3.0 FR) https://creativecommons.org/licenses/by-sa/3.0/fr/

Table des matières

Avant-propos

6

Quelques mots sur l’origine de ce cours . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6

Remerciements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6

1 Introduction

7

1.1 C’est quoi Python ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7

1.2 Conseils pour installer et conﬁgurer Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7

1.3 Notations utilisées . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8

1.4 Introduction au shell . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8

1.5 Premier contact avec Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9

1.6 Premier programme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10

1.7 Commentaires . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10

1.8 Notion de bloc d’instructions et d’indentation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10

1.9 Autres ressources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11

2 Variables

12

2.1 Déﬁnition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12

2.2 Les types de variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12

2.3 Nommage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13

2.4 Opérations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13

2.5 La fonction type() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15

2.6 Conversion de types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15

2.7 Note sur la division de deux nombres entiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15

2.8 Note sur le vocabulaire et la syntaxe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15

2.9 Exercices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16

3 Afﬁchage

17

3.1 La fonction print() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17

3.2 Écriture formatée . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18

3.3 Ancienne méthode de formatage des chaînes de caractères . . . . . . . . . . . . . . . . . . . . . . . . . . . 20

3.4 Note sur le vocabulaire et la syntaxe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20

3.5 Exercices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21

4 Listes

22

4.1 Déﬁnition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22

4.2 Utilisation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22

4.3 Opération sur les listes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22

4.4 Indiçage négatif . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23

4.5 Tranches . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23

4.6 Fonction len() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24

4.7 Les fonctions range() et list() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24

4.8 Listes de listes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25

4.9 Exercices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25

2

Table des matières

Table des matières

5 Boucles et comparaisons

27

5.1 Boucles for . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27

5.2 Comparaisons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30

5.3 Boucles while . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31

5.4 Exercices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31

6 Tests

36

6.1 Déﬁnition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36

6.2 Tests à plusieurs cas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36

6.3 Importance de l’indentation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37

6.4 Tests multiples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37

6.5 Instructions break et continue . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38

6.6 Tests de valeur sur des ﬂoats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39

6.7 Exercices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39

7 Fichiers

44

7.1 Lecture dans un ﬁchier . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44

7.2 Écriture dans un ﬁchier . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46

7.3 Ouvrir deux ﬁchiers avec l’instruction with . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47

7.4 Note sur les retours à la ligne sous Unix et sous Windows . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47

7.5 Importance des conversions de types avec les ﬁchiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48

7.6 Du respect des formats de données et de ﬁchiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48

7.7 Exercices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48

8 Modules

51

8.1 Déﬁnition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51

8.2 Importation de modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51

8.3 Obtenir de l’aide sur les modules importés . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53

8.4 Quelques modules courants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54

8.5 Module sys : passage d’arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54

8.6 Module os : interaction avec le système d’exploitation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55

8.7 Exercices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56

9 Fonctions

59

9.1 Principe et généralités . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59

9.2 Déﬁnition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60

9.3 Passage d’arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61

9.4 Renvoi de résultats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61

9.5 Arguments positionnels et arguments par mot-clé . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61

9.6 Variables locales et variables globales . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63

9.7 Exercices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66

10 Plus sur les chaînes de caractères

70

10.1 Préambule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70

10.2 Chaînes de caractères et listes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70

10.3 Caractères spéciaux . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70

10.4 Méthodes associées aux chaînes de caractères . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71

10.5 Extraction de valeurs numériques d’une chaîne de caractères . . . . . . . . . . . . . . . . . . . . . . . . . . 73

10.6 Conversion d’une liste de chaînes de caractères en une chaîne de caractères . . . . . . . . . . . . . . . . . . 73

10.7 Exercices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

3

Table des matières

Table des matières

11 Plus sur les listes

78

11.1 Méthodes associées aux listes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78

11.2 Construction d’une liste par itération . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79

11.3 Test d’appartenance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80

11.4 Copie de listes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80

11.5 Exercices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82

12 Plus sur les fonctions

84

12.1 Appel d’une fonction dans une fonction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84

12.2 Fonctions récursives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85

12.3 Portée des variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86

12.4 Portée des listes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87

12.5 Règle LGI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88

12.6 Recommandations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88

12.7 Exercices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89

13 Dictionnaires et tuples

90

13.1 Dictionnaires . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90

13.2 Tuples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91

13.3 Exercices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92

14 Création de modules

95

14.1 Pourquoi créer ses propres modules ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95

14.2 Création d’un module . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95

14.3 Utilisation de son propre module . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96

14.4 Les docstrings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96

14.5 Visibilité des fonctions dans un module . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97

14.6 Module ou script ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97

14.7 Exercice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98

15 Bonnes pratiques en programmation Python

99

15.1 De la bonne syntaxe avec la PEP 8 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99

15.2 Les docstrings et la PEP 257 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103

15.3 Outils de contrôle qualité du code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105

15.4 Organisation du code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107

15.5 Conseils sur la conception d’un script . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108

15.6 Pour terminer : la PEP 20 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108

16 Expressions régulières et parsing

110

16.1 Déﬁnition et syntaxe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110

16.2 Quelques ressources en ligne . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112

16.3 Le module re . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112

16.4 Exercices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114

17 Quelques modules d’intérêt en bioinformatique

117

17.1 Module NumPy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117

17.2 Module Biopython . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122

17.3 Module matplotlib . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124

17.4 Module pandas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128

17.5 Un exemple plus complet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132

17.6 Exercices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137

4

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

Table des matières

Table des matières

18 Jupyter et ses notebooks

140

18.1 Installation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140

18.2 Lancement de Jupyter et création d’un notebook . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140

18.3 Le format Markdown . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143

18.4 Des graphiques dans les notebooks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145

18.5 Les magic commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148

18.6 JupyterLab . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148

19 Avoir la classe avec les objets

152

19.1 Construction d’une classe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152

19.2 Espace de noms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163

19.3 Polymorphisme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166

19.4 Héritage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168

19.5 Accès et modiﬁcations des attributs depuis l’extérieur . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173

19.6 Bonnes pratiques pour construire et manipuler ses classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177

19.7 Exercices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181

20 Fenêtres graphiques et Tkinter

182

20.1 Utilité d’une GUI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182

20.2 Quelques concepts liés à la programmation graphique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183

20.3 Notion de fonction callback . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183

20.4 Prise en main du module Tkinter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184

20.5 Construire une application Tkinter avec une classe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186

20.6 Le widget canvas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187

20.7 Pour aller plus loin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193

20.8 Exercices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197

21 Remarques complémentaires

200

21.1 Différences Python 2 et Python 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200

21.2 Liste de compréhension . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 202

21.3 Gestion des erreurs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 202

21.4 Shebang et /usr/bin/env python3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204

21.5 Passage d’arguments avec *args et **kwargs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205

21.6 Un peu de transformée de Fourier avec NumPy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206

21.7 Sauvegardez votre historique de commandes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207

22 Mini-projets

208

22.1 Description des projets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208

22.2 Accompagnement pas à pas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209

A Quelques formats de données rencontrés en biologie

223

A.1 FASTA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223

A.2 GenBank . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225

A.3 PDB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 226

A.4 Format XML, CSV et TSV . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232

B Installation de Python

237

B.1 Que recommande-t-on pour l’installation de Python ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237

B.2 Installation de Python avec Miniconda . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237

B.3 Utilisation de conda pour installer des modules complémentaires . . . . . . . . . . . . . . . . . . . . . . . . 246

B.4 Choisir un bon éditeur de texte . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252

B.5 Comment se mettre dans le bon répertoire dans le shell . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 255

B.6 Python web et mobile . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 256

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

5

Avant-propos
Quelques mots sur l’origine de ce cours
Ce cours a été conçu à l’origine pour les étudiants débutants en programmation Python des ﬁlières de biologie et de biochimie de l’université Paris Diderot - Paris 7 1 ; et plus spécialement pour les étudiants du master Biologie Informatique.
Ce cours est basé sur la version 3 de Python, version recommandée par la communauté scientiﬁque. Des références à l’ancienne version, Python 2, seront néanmoins régulièrement apportées.
Si vous relevez des erreurs à la lecture de ce document, merci de nous les signaler. Le cours est disponible en version HTML 2 et PDF 3.
Remerciements
Un grand merci à Sander 4 du Centre for Molecular and Biomolecular Informatic de Nijmegen aux Pays-Bas pour la toute première version 5 de ce cours qui remonte à l’année 2003.
Nous remercions le professeur Philip Guo 6 de l’UC San Diego, pour nous avoir autorisé à utiliser des copies d’écran de son excellent site Python Tutor 7.
Merci également à tous les contributeurs, occasionels ou réguliers : Jennifer Becq, Virginie Martiny, Romain Laurent, Benoist Laurent, Benjamin Boyer, Hubert Santuz, Catherine Lesourd, Philippe Label, Rémi Cuchillo, Cédric Gageat, Philibert Malbranche, Mikaël Naveau, Amélie Bacle, Alexandra Moine-Franel.
Nous remercions aussi Denis Mestivier de qui nous nous sommes inspirés pour certains exercices. Enﬁn, merci à vous tous, les curieux de Python, qui avez été nombreux à nous envoyer des retours sur ce cours, à nous suggérer des améliorations et à nous signaler des coquilles. De nombreuses personnes nous ont aussi demandé les corrections des exercices. Nous ne les mettons pas sur le site aﬁn d’éviter la tentation de les regarder trop vite, mais vous pouvez nous écrire et nous vous les enverrons.
1. http://www.univ-paris-diderot.fr/ 2. https://python.sdv.univ-paris-diderot.fr/index.html 3. https://python.sdv.univ-paris-diderot.fr/cours-python.pdf 4. http://sander.nabuurs.org/ 5. http://www.cmbi.ru.nl/pythoncourse/spy/index.spy?site=python&action=Home 6. http://pgbovine.net/ 7. http://pythontutor.com/
6

Chapitre 1
Introduction
1.1 C’est quoi Python ?
Le langage de programmation Python a été créé en 1989 par Guido van Rossum, aux Pays-Bas. Le nom Python vient d’un hommage à la série télévisée Monty Python’s Flying Circus dont G. van Rossum est fan. La première version publique de ce langage a été publiée en 1991.
La dernière version de Python est la version 3. Plus précisément, la version 3.7 a été publiée en juin 2018. La version 2 de Python est désormais obsolète et cessera d’être maintenue après le 1er janvier 2020. Dans la mesure du possible évitez de l’utiliser.
La Python Software Foundation 1 est l’association qui organise le développement de Python et anime la communauté de développeurs et d’utilisateurs.
Ce langage de programmation présente de nombreuses caractéristiques intéressantes : — Il est multiplateforme. C’est-à-dire qu’il fonctionne sur de nombreux systèmes d’exploitation : Windows, Mac OS X,
Linux, Android, iOS, depuis les mini-ordinateurs Raspberry Pi jusqu’aux supercalculateurs. — Il est gratuit. Vous pouvez l’installer sur autant d’ordinateurs que vous voulez (même sur votre téléphone !). — C’est un langage de haut niveau. Il demande relativement peu de connaissance sur le fonctionnement d’un ordinateur
pour être utilisé. — C’est un langage interprété. Un script Python n’a pas besoin d’être compilé pour être exécuté, contrairement à des
langages comme le C ou le C++. — Il est orienté objet. C’est-à-dire qu’il est possible de concevoir en Python des entités qui miment celles du monde réel
(une cellule, une protéine, un atome, etc.) avec un certain nombre de règles de fonctionnement et d’interactions. — Il est relativement simple à prendre en main 2. — Enﬁn, il est très utilisé en bioinformatique et plus généralement en analyse de données. Toutes ces caractéristiques font que Python est désormais enseigné dans de nombreuses formations, depuis l’enseignement secondaire jusqu’à l’enseignement supérieur.
1.2 Conseils pour installer et conﬁgurer Python
Pour apprendre la programmation Python, il va falloir que vous pratiquiez et pour cela il est préférable que Python soit installé sur votre ordinateur. La bonne nouvelle est que vous pouvez installer gratuitement Python sur votre machine, que ce soit sous Windows, Mac OS X ou Linux. Nous donnons dans cette rubrique un résumé des points importants concernant cette installation. Tous les détails et la marche à suivre pas à pas sont donnés à l’adresse https://python.sdv. univ-paris-diderot.fr/livre-dunod.
1.2.1 Python 2 ou Python 3 ?
Ce cours est basé sur la version 3 de Python, qui est désormais le standard.
1. https://www.python.org/psf/ 2. Nous sommes d’accord, cette notion est très relative.
7

Chapitre 1. Introduction

1.3. Notations utilisées

Si, néanmoins, vous deviez un jour travailler sur un ancien programme écrit en Python 2, sachez qu’il existe quelques différences importantes entre Python 2 et Python 3. Le chapitre 21 Remarques complémentaires vous apportera plus de précisions.
1.2.2 Miniconda
Nous vous conseillons d’installer Miniconda 3, logiciel gratuit, disponible pour Windows, Mac OS X et Linux, et qui installera pour vous Python 3.
Avec le gestionnaire de paquets conda, fourni avec Miniconda, vous pourrez installer des modules supplémentaires qui sont très utiles en bioinformatique (NumPy, scipy, matplotlib, pandas, Biopython), mais également les notebooks Jupyter. Vous trouverez en ligne 4 une documentation pas à pas pour installer Miniconda, Python 3 et les modules supplémentaires qui seront utilisés dans ce cours.
1.2.3 Éditeur de texte
L’apprentissage d’un langage informatique comme Python va nécessiter d’écrire des lignes de codes à l’aide d’un éditeur de texte. Si vous êtes débutants, on vous conseille d’utiliser notepad++ sous Windows, BBEdit ou CotEditor sous Mac OS X et gedit sous Linux. La conﬁguration de ces éditeurs de texte est détaillée dans la rubrique Installation de Python disponible en ligne 5. Bien sur, si vous préférez d’autres éditeurs comme Atom, Visual Studio Code, Sublime Text, emacs, vim, geany. . . utilisez-les !
À toute ﬁn utile, on rappelle que les logiciels Microsoft Word, WordPad et LibreOfﬁce Writer ne sont pas des éditeurs de texte, ce sont des traitements de texte qui ne peuvent pas et ne doivent pas être utilisés pour écrire du code informatique.

1.3 Notations utilisées
Dans cet ouvrage, les commandes, les instructions Python, les résultats et les contenus de ﬁchiers sont indiqués avec cette police pour les éléments ponctuels ou
1 sous cette forme , 2 sur plusieurs lignes , 3 pour les éléments les plus longs.
Pour ces derniers, le numéro à gauche indique le numéro de la ligne et sera utilisé pour faire référence à une instruction particulière. Ce numéro n’est bien sûr là qu’à titre indicatif.
Par ailleurs, dans le cas de programmes, de contenus de ﬁchiers ou de résultats trop longs pour être inclus dans leur intégralité, la notation [...] indique une coupure arbitraire de plusieurs caractères ou lignes.

1.4 Introduction au shell
Un shell est un interpréteur de commandes interactif permettant d’interagir avec l’ordinateur. On utilisera le shell pour lancer l’interpréteur Python.
Pour approfondir la notion de shell, vous pouvez consulter les pages Wikipedia : — du shell Unix 6 fonctionnant sous Mac OS X et Linux ; — du shell PowerShell 7 fonctionnant sous Windows. Un shell possède toujours une invite de commande, c’est-à-dire un message qui s’afﬁche avant l’endroit où on entre des commandes. Dans tout cet ouvrage, cette invite est représentée systématiquement par le symbole dollar $, et ce quel que soit le système d’exploitation. Par exemple, si on vous demande de lancer l’instruction suivante : $ python il faudra taper seulement python sans le $ ni l’espace après le $.
3. https://conda.io/miniconda.html 4. https://python.sdv.univ-paris-diderot.fr/livre-dunod 5. https://python.sdv.univ-paris-diderot.fr/livre-dunod 6. https://fr.wikipedia.org/wiki/Shell_Unix 7. https://fr.wikipedia.org/wiki/Windows_PowerShell

8

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

1.5. Premier contact avec Python

Chapitre 1. Introduction

1.5 Premier contact avec Python
Python est un langage interprété, c’est-à-dire que chaque ligne de code est lue puis interprétée aﬁn d’être exécutée par l’ordinateur. Pour vous en rendre compte, ouvrez un shell puis lancez la commande :
python La commande précédente va lancer l’interpréteur Python. Vous devriez obtenir quelque chose de ce style pour Windows :
1 PS C:\Users\pierre > python 2 Python 3.7.1 (default , Dec 10 2018, 22:54:23) [MSC v.1915 64 bit (AMD64)] [...] 3 Type "help", "copyright", "credits" or "license" for more information. 4 >>>
pour Mac OS X :
1 iMac -de -pierre:Downloads$ python 2 Python 3.7.1 (default , Dec 14 2018, 19:28:38) 3 [Clang 4.0.1 (tags/RELEASE_401/final)] :: Anaconda , Inc. on darwin 4 Type "help", "copyright", "credits" or "license" for more information. 5 >>>
ou pour Linux :
1 pierre@jeera:~$ python 2 Python 3.7.1 (default , Dec 14 2018, 19:28:38) 3 [GCC 7.3.0] :: Anaconda , Inc. on linux 4 Type "help", "copyright", "credits" or "license" for more information. 5 >>>
Les blocs — PS C:\Users\pierre> pour Windows, — iMac-de-pierre:Downloads$ pour Mac OS X, — pierre@jeera:~$ pour Linux. représentent l’invite de commande de votre shell. Par la suite, cette invite de commande sera représentée simplement par le caractère $, que vous soyez sous Windows, Mac OS X ou Linux. Le triple chevron >>> est l’invite de commande de l’interpréteur Python (prompt en anglais). Ici, Python attend une commande que vous devez saisir au clavier. Tapez par exemple l’instruction : print("Hello world!") puis validez cette commande en appuyant sur la touche Entrée. Python a exécuté la commande directement et a afﬁché le texte Hello world!. Il attend ensuite votre prochaine instruction en afﬁchant l’invite de l’interpréteur Python (>>>). En résumé, voici ce qui a dû apparaître sur votre écran :
1 >>> print("Hello world!") 2 Hello world! 3 >>>
Vous pouvez refaire un nouvel essai en vous servant cette fois de l’interpréteur comme d’une calculatrice :
1 >>> 1+1 22 3 >>> 6*3 4 18
À ce stade, vous pouvez entrer une autre commande ou bien quitter l’interpréteur Python, soit en tapant la commande exit() puis en validant en appuyant sur la touche Entrée, soit en pressant simultanément les touches Ctrl et D sous Linux et Mac OS X ou Ctrl et Z puis Entrée sous Windows.
L’interpréteur Python est donc un système interactif dans lequel vous pouvez entrer des commandes, que Python exécutera sous vos yeux (au moment où vous validerez la commande en appuyant sur la touche Entrée).
Il existe de nombreux autres langages interprétés comme que Perl 8 ou R 9. Le gros avantage de ce type de langage est qu’on peut immédiatement tester une commande à l’aide de l’interpréteur, ce qui est très utile pour débugger (c’est-à-dire trouver et corriger les éventuelles erreurs d’un programme). Gardez bien en mémoire cette propriété de Python qui pourra parfois vous faire gagner un temps précieux !
8. http://www.perl.org 9. http://www.r-project.org

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

9

Chapitre 1. Introduction

1.6. Premier programme

1.6 Premier programme
Bien sûr, l’interpréteur présente vite des limites dès lors que l’on veut exécuter une suite d’instructions plus complexe. Comme tout langage informatique, on peut enregistrer ces instructions dans un ﬁchier, que l’on appelle communément un script (ou programme) Python.
Pour reprendre l’exemple précédent, ouvrez un éditeur de texte (pour choisir et conﬁgurer un éditeur de texte, reportezvous si nécessaire à la rubrique Installation de Python en ligne 10) et entrez le code suivant :
print("Hello world!") Ensuite, enregistrez votre ﬁchier sous le nom test.py, puis quittez l’éditeur de texte.

Remarque L’extension de ﬁchier standard des scripts Python est .py.

Pour exécuter votre script, ouvrez un shell et entrez la commande : python test.py
Vous devriez obtenir un résultat similaire à ceci :
1 $ python test.py 2 Hello world!
Si c’est bien le cas, bravo ! Vous avez exécuté votre premier programme Python.

1.7 Commentaires
Dans un script, tout ce qui suit le caractère # est ignoré par Python jusqu’à la ﬁn de la ligne et est considéré comme un commentaire.
Les commentaires doivent expliquer votre code dans un langage humain. L’utilisation des commentaires est rediscutée dans le chapitre 15 Bonnes pratiques en programmation Python.
Voici un exemple :
1 # Votre premier commentaire en Python. 2 print( Hello world! )
3
4 # D autres commandes plus utiles pourraient suivre.

Remarque On appelle souvent à tord le caractère # « dièse ». On devrait plutôt parler de « croisillon 11 ».

1.8 Notion de bloc d’instructions et d’indentation
En programmation, il est courant de répéter un certain nombre de choses (avec les boucles, voir le chapitre 5 Boucles et comparaisons) ou d’exécuter plusieurs instructions si une condition est vraie (avec les tests, voir le chapitre 6 Tests).
Par exemple, imaginons que nous souhaitions afﬁcher chacune des bases d’une séquence d’ADN, les compter puis afﬁcher le nombre total de bases à la ﬁn. Nous pourrions utiliser l’algorithme présenté en pseudo-code dans la ﬁgure 1.1.
Pour chaque base de la séquence ATCCGACTG, nous souhaitons effectuer deux actions : d’abord afﬁcher la base puis compter une base de plus. Pour indiquer cela, on décalera vers la droite ces deux instructions par rapport à la ligne précédente (pour chaque base [...]). Ce décalage est appelé indentation, et l’ensemble des lignes indentées constitue un bloc d’instructions.
Une fois qu’on aura réalisé ces deux actions sur chaque base, on pourra passer à la suite, c’est-à-dire afﬁcher la taille de la séquence. Pour bien préciser que cet afﬁchage se fait à la ﬁn, donc une fois l’afﬁchage puis le comptage de chaque base terminés, la ligne correspondante n’est pas indentée (c’est-à-dire qu’elle n’est pas décalée vers la droite).
10. https://python.sdv.univ-paris-diderot.fr/livre-dunod 11. https://fr.wikipedia.org/wiki/Croisillon_(signe)

10

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

1.9. Autres ressources

Chapitre 1. Introduction

FIGURE 1.1 – Notion d’indentation et de bloc d’instructions.
Pratiquement, l’indentation en Python doit être homogène (soit des espaces, soit des tabulations, mais pas un mélange des deux). Une indentation avec 4 espaces est le style d’indentation recommandé (voir le chapitre 15 Bonnes pratiques en programmation Python).
Si tout cela semble un peu complexe, ne vous inquiétez pas. Vous allez comprendre tous ces détails chapitre après chapitre.
1.9 Autres ressources
Pour compléter votre apprentissage de Python, n’hésitez pas à consulter d’autres ressources complémentaires à cet ouvrage. D’autres auteurs abordent l’apprentissage de Python d’une autre manière. Nous vous conseillons les ressources suivantes en langue française :
— Le livre Apprendre à programmer avec Python 3 de Gérard Swinnen. Cet ouvrage est téléchargeable gratuitement sur le site de Gérard Swinnen 12. Les éditions Eyrolles proposent également la version papier de cet ouvrage.
— Le livre Apprendre à programmer en Python avec PyZo et Jupyter Notebook de Bob Cordeau et Laurent Pointal, publié aux éditions Dunod. Une partie de cet ouvrage est téléchargeable gratuitement sur le site de Laurent Pointal 13.
— Le livre Apprenez à programmer en Python de Vincent Legoff 14 que vous trouverez sur le site Openclassroms. Et pour terminer, une ressource incontournable en langue anglaise : — Le site www.python.org 15. Il contient énormément d’informations et de liens sur Python. La page d’index des mo-
dules 16 est particulièrement utile (et traduite en français).

12. http://www.inforef.be/swi/python.htm 13. https://perso.limsi.fr/pointal/python:courspython3 14. https://openclassrooms.com/fr/courses/235344-apprenez-a-programmer-en-python 15. http://www.python.org 16. https://docs.python.org/fr/3/py-modindex.html

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

11

Chapitre 2
Variables
2.1 Déﬁnition
Une variable est une zone de la mémoire de l’ordinateur dans laquelle une valeur est stockée. Aux yeux du programmeur, cette variable est déﬁnie par un nom, alors que pour l’ordinateur, il s’agit en fait d’une adresse, c’est-à-dire d’une zone particulière de la mémoire.
En Python, la déclaration d’une variable et son initialisation (c’est-à-dire la première valeur que l’on va stocker dedans) se font en même temps. Pour vous en convaincre, testez les instructions suivantes après avoir lancé l’interpréteur :
1 >>> x = 2 2 >>> x 32
Ligne 1. Dans cet exemple, nous avons déclaré, puis initialisé la variable x avec la valeur 2. Notez bien qu’en réalité, il s’est passé plusieurs choses :
— Python a « deviné » que la variable était un entier. On dit que Python est un langage au typage dynamique. — Python a alloué (réservé) l’espace en mémoire pour y accueillir un entier. Chaque type de variable prend plus ou moins
d’espace en mémoire. Python a aussi fait en sorte qu’on puisse retrouver la variable sous le nom x. — Enﬁn, Python a assigné la valeur 2 à la variable x. Dans d’autres langages (en C par exemple), il faut coder ces différentes étapes une par une. Python étant un langage dit de haut niveau, la simple instruction x = 2 a sufﬁ à réaliser les 3 étapes en une fois ! Lignes 2 et 3. L’interpréteur nous a permis de connaître le contenu de la variable juste en tapant son nom. Retenez ceci car c’est une spéciﬁcité de l’interpréteur Python, très pratique pour chasser (debugger) les erreurs dans un programme. Par contre, la ligne d’un script Python qui contient seulement le nom d’une variable (sans aucune autre indication) n’afﬁchera pas la valeur de la variable à l’écran (pour autant, cette instruction reste valide et ne générera pas d’erreur). Sachez par ailleurs que l’opérateur d’affectation = s’utilise dans un certain sens. Par exemple, l’instruction x = 2 signiﬁe qu’on attribue la valeur située à droite de l’opérateur = (ici, 2) à la variable située à gauche (ici, x). D’autres langages de programmation comme R utilisent les symboles <- pour rendre l’affectation d’une variable plus explicite, par exemple x <2. Enﬁn, dans l’instruction x = y - 3, l’opération y - 3 est d’abord évaluée et ensuite le résultat de cette opération est affecté à la variable x.
2.2 Les types de variables
Le type d’une variable correspond à la nature de celle-ci. Les trois principaux types dont nous aurons besoin dans un premier temps sont les entiers (integer ou int), les nombres décimaux que nous appellerons ﬂoats et les chaînes de caractères (string ou str). Bien sûr, il existe de nombreux autres types (par exemple, les booléens, les nombres complexes, etc.). Si vous n’êtes pas effrayés, vous pouvez vous en rendre compte ici 1.
Dans l’exemple précédent, nous avons stocké un nombre entier (int) dans la variable x, mais il est tout à fait possible de stocker des ﬂoats, des chaînes de caractères (string ou str) ou de nombreux autres types de variable que nous verrons par la suite :
1. https://docs.python.org/fr/3.7/library/stdtypes.html
12

2.3. Nommage

Chapitre 2. Variables

1 >>> y = 3.14

2 >>> y

3 3.14

4 >>> a = "bonjour"

5 >>> a

6 bonjour

7 >>> b = salut

8 >>> b

9 salut

10 >>> c = """ girafe """

11 > > > c

12 girafe

13 > > > d =

lion

14 > > > d

15 lion

Remarque Python reconnaît certains types de variable automatiquement (entier, ﬂoat). Par contre, pour une chaîne de caractères, il
faut l’entourer de guillemets (doubles, simples, voire trois guillemets successifs doubles ou simples) aﬁn d’indiquer à Python le début et la ﬁn de la chaîne de caractères.
Dans l’interpréteur, l’afﬁchage direct du contenu d’une chaîne de caractères se fait avec des guillemets simples, quel que soit le type de guillemets utilisé pour déﬁnir la chaîne de caractères.
En Python, comme dans la plupart des langages de programmation, c’est le point qui est utilisé comme séparateur décimal. Ainsi, 3.14 est un nombre reconnu comme un ﬂoat en Python alors que ce n’est pas le cas de 3,14.

2.3 Nommage
Le nom des variables en Python peut être constitué de lettres minuscules (a à z), de lettres majuscules (A à Z), de nombres (0 à 9) ou du caractère souligné (_). Vous ne pouvez pas utiliser d’espace dans un nom de variable.
Par ailleurs, un nom de variable ne doit pas débuter par un chiffre et il n’est pas recommandé de le faire débuter par le caractère _ (sauf cas très particuliers).
De plus, il faut absolument éviter d’utiliser un mot « réservé » par Python comme nom de variable (par exemple : print, range, for, from, etc.).
Enﬁn, Python est sensible à la casse, ce qui signiﬁe que les variables TesT, test ou TEST sont différentes.
2.4 Opérations
2.4.1 Opérations sur les types numériques
Les quatre opérations arithmétiques de base se font de manière simple sur les types numériques (nombres entiers et ﬂoats) :
1 >>> x = 45 2 >>> x + 2 3 47 4 >>> x - 2 5 43 6 >>> x * 3 7 135 8 >>> y = 2.5 9 >>> x - y 10 42.5 11 >>> ( x * 10) + y 12 452.5
Remarquez toutefois que si vous mélangez les types entiers et ﬂoats, le résultat est renvoyé comme un ﬂoat (car ce type est plus général). Par ailleurs, l’utilisation de parenthèses permet de gérer les priorités.
L’opérateur / effectue une division. Contrairement aux opérateurs +, - et *, celui-ci renvoie systématiquement un ﬂoat :
1 >>> 3 / 4 2 0.75 3 >>> 2.5 / 2 4 1.25
L’opérateur puissance utilise les symboles ** :

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

13

Chapitre 2. Variables

2.4. Opérations

1 >>> 2**3 28 3 >>> 2**4 4 16
Pour obtenir le quotient et le reste d’une division entière (voir ici 2 pour un petit rappel sur la division entière), on utilise respectivement les symboles // et modulo % :
1 >>> 5 // 4 21 3 >>> 5 % 4 41 5 >>> 8 // 4 62 7 >>> 8 % 4 80
Les symboles +, -, *, /, **, // et % sont appelés opérateurs, car ils réalisent des opérations sur les variables. Enﬁn, il existe des opérateurs « combinés » qui effectue une opération et une affectation en une seule étape :
1 >>> i = 0 2 >>> i = i + 1 3 >>> i 41 5 >>> i += 1 6 >>> i 72 8 >>> i += 2 9 >>> i 10 4
L’opérateur += effectue une addition puis affecte le résultat à la même variable. Cette opération s’appelle une « incrémentation ».
Les opérateurs -=, *= et /= se comportent de manière similaire pour la soustraction, la multiplication et la division.
2.4.2 Opérations sur les chaînes de caractères
Pour les chaînes de caractères, deux opérations sont possibles, l’addition et la multiplication :
1 >>> chaine = "Salut" 2 >>> chaine 3 Salut 4 >>> chaine + " Python" 5 Salut Python 6 >>> chaine * 3 7 SalutSalutSalut
L’opérateur d’addition + concatène (assemble) deux chaînes de caractères. L’opérateur de multiplication * entre un nombre entier et une chaîne de caractères duplique (répète) plusieurs fois une chaîne de caractères.
Attention Vous observez que les opérateurs + et * se comportent différemment selon qu’il s’agisse d’entiers ou de chaînes de
caractères : 2 + 2 est une addition alors que "2" + "2" est une concaténation. On appelle ce comportement redéﬁnition des opérateurs. Nous serons amenés à revoir cette notion dans le chapitre 19 Avoir la classe avec les objets.

2.4.3 Opérations illicites
Attention à ne pas faire d’opération illicite car vous obtiendriez un message d’erreur :
1 >>> "toto" * 1.3 2 Traceback (most recent call last): 3 File "<stdin >", line 1, in <module > 4 TypeError: can t multiply sequence by non -int of type float 5 >>> "toto" + 2 6 Traceback (most recent call last): 7 File "<stdin >", line 1, in <module > 8 TypeError: can only concatenate str (not "int") to str
Notez que Python vous donne des informations dans son message d’erreur. Dans le second exemple, il indique que vous devez utiliser une variable de type str c’est-à-dire une chaîne de caractères et pas un int, c’est-à-dire un entier.
2. https://fr.wikipedia.org/wiki/Division_euclidienne

14

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

2.5. La fonction type()

Chapitre 2. Variables

2.5 La fonction type()
Si vous ne vous souvenez plus du type d’une variable, utilisez la fonction type() qui vous le rappellera.
1 >>> x = 2 2 >>> type(x) 3 <class int > 4 >>> y = 2.0 5 >>> type(y) 6 <class float > 7 >>> z = 2 8 >>> type(z) 9 <class str >
Nous verrons plus tard ce que signiﬁe le mot class.
Attention Pour Python, la valeur 2 (nombre entier) est différente de 2.0 (ﬂoat) et est aussi différente de 2 (chaîne de caractères).

2.6 Conversion de types
En programmation, on est souvent amené à convertir les types, c’est-à-dire passer d’un type numérique à une chaîne de caractères ou vice-versa. En Python, rien de plus simple avec les fonctions int(), float() et str(). Pour vous en convaincre, regardez ces exemples :
1 >>> i = 3 2 >>> str(i) 33 4 >>> i = 456 5 >>> int(i) 6 456 7 >>> float(i) 8 456.0 9 >>> i = 3.1416 10 >>> float ( i ) 11 3 . 1 4 1 6
On verra au chapitre 7 Fichiers que ces conversions sont essentielles. En effet, lorsqu’on lit ou écrit des nombres dans un ﬁchier, ils sont considérés comme du texte, donc des chaînes de caractères.
Toute conversion d’une variable d’un type en un autre est appelé casting en anglais, il se peut que vous croisiez ce terme si vous consultez d’autres ressources.
2.7 Note sur la division de deux nombres entiers
Notez bien qu’en Python 3, la division de deux nombres entiers renvoie par défaut un ﬂoat :
1 >>> x = 3 / 4 2 >>> x 3 0.75 4 >>> type(x) 5 <class float >
Remarque Ceci n’était pas le cas en Python 2. Pour en savoir plus sur ce point, vous pouvez consulter le chapitre 21 Remarques
complémentaires.

2.8 Note sur le vocabulaire et la syntaxe
Nous avons vu dans ce chapitre la notion de variable qui est commune à tous les langages de programmation. Toutefois, Python est un langage dit « orienté objet », il se peut que dans la suite du cours nous employions le mot objet pour désigner

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

15

Chapitre 2. Variables

2.9. Exercices

une variable. Par exemple, « une variable de type entier » sera pour nous équivalent à « un objet de type entier ». Nous verrons dans le chapitre 19 Avoir la classe avec les objets ce que le mot « objet » signiﬁe réellement (tout comme le mot « classe »).
Par ailleurs, nous avons rencontré plusieurs fois des fonctions dans ce chapitre, notamment avec type(), int(), float() et str(). Dans le chapitre 1 Introduction, nous avons également vu la fonction print(). On reconnaît qu’il s’agit d’une fonction car son nom est suivi de parenthèses (par exemple, type()). En Python, la syntaxe générale est fonction().
Ce qui se trouve entre les parenthèses d’une fonction est appelé argument et c’est ce que l’on « passe » à la fonction. Dans l’instruction type(2), c’est l’entier 2 qui est l’argument passé à la fonction type(). Pour l’instant, on retiendra qu’une fonction est une sorte de boîte à qui on passe un argument, qui effectue une action et qui peut renvoyer un résultat ou plus généralement un objet. Par exemple, la fonction type() renvoie le type de la variable qu’on lui a passé en argument.
Si ces notions vous semblent obscures, ne vous inquiétez pas, au fur et à mesure que vous avancerez dans le cours, tout
deviendra limpide.

2.9 Exercices
Conseil : utilisez l’interpréteur Python pour les exercices suivants.
2.9.1 Prédire le résultat : opérations
Essayez de prédire le résultat de chacune des instructions suivantes, puis vériﬁez-le dans l’interpréteur Python : — (1+2)**3 — "Da" * 4 — "Da" + 3 — ("Pa"+"La") * 2 — ("Da"*4) / 2 —5/2 — 5 // 2 —5%2
2.9.2 Prédire le résultat : opérations et conversions de types
Essayez de prédire le résultat de chacune des instructions suivantes, puis vériﬁez-le dans l’interpréteur Python : — str(4) * int("3") — int("3") + float("3.2") — str(3) * float("3.2") — str(3/4) * 2

16

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

Chapitre 3
Afﬁchage
3.1 La fonction print()
Dans le chapitre 1, nous avons rencontré la fonction print() qui afﬁche une chaîne de caractères (le fameux "Hello world!"). En fait, la fonction print() afﬁche l’argument qu’on lui passe entre parenthèses et un retour à ligne. Ce retour à ligne supplémentaire est ajouté par défaut. Si toutefois, on ne veut pas afﬁcher ce retour à la ligne, on peut utiliser l’argument par « mot-clé » end :
1 >>> print("Hello world!") 2 Hello world! 3 >>> print("Hello world!", end ="") 4 Hello world!>>>
Ligne 1. On a utilisé l’instruction print() classiquement en passant la chaîne de caractères "Hello world!" en argument.
Ligne 3. On a ajouté un second argument end="", en précisant le mot-clé end. Nous aborderons les arguments par mot-clé dans le chapitre 9 Fonctions. Pour l’instant, dites-vous que cela modiﬁe le comportement par défaut des fonctions.
Ligne 4. L’effet de l’argument end="" est que les trois chevrons >>> se retrouvent collés après la chaîne de caractères "Hello world!".
Une autre manière de s’en rendre compte est d’utiliser deux fonctions print() à la suite. Dans la portion de code suivante, le caractère « ; » sert à séparer plusieurs instructions Python sur une même ligne :
1 >>> print("Hello") ; print("Joe") 2 Hello 3 Joe 4 >>> print("Hello", end="") ; print("Joe") 5 HelloJoe 6 >>> print("Hello", end=" ") ; print("Joe") 7 Hello Joe
La fonction print() peut également afﬁcher le contenu d’une variable quel que soit son type. Par exemple, pour un entier :
1 >>> var = 3 2 >>> print(var) 33
Il est également possible d’afﬁcher le contenu de plusieurs variables (quel que soit leur type) en les séparant par des virgules :
1 >>> x = 32 2 >>> nom = "John" 3 >>> print(nom , "a" , x , "ans") 4 John a 32 ans
Python a écrit une phrase complète en remplaçant les variables x et nom par leur contenu. Vous remarquerez que pour afﬁcher plusieurs éléments de texte sur une seule ligne, nous avons utilisé le séparateur « , » entre les différents éléments. Python a également ajouté un espace à chaque fois que l’on utilisait le séparateur « , ». On peut modiﬁer ce comportement en passant à la fonction print() l’argument par mot-clé sep :
1 >>> x = 32 2 >>> nom = "John" 3 >>> print(nom , "a" , x , "ans", sep="")
17

Chapitre 3. Afﬁchage

3.2. Écriture formatée

4 Johna32ans 5 >>> print(nom , "a" , x , "ans", sep="-") 6 John -a-32-ans
Pour afﬁcher deux chaînes de caractères l’une à côté de l’autre, sans espace, on peut soit les concaténer, soit utiliser l’argument par mot-clé sep avec une chaîne de caractères vide :
1 >>> ani1 = "chat" 2 >>> ani2 = "souris" 3 >>> print(ani1 , ani2) 4 chat souris 5 >>> print(ani1 + ani2) 6 chatsouris 7 >>> print(ani1 , ani2 , sep="") 8 chatsouris

3.2 Écriture formatée
La méthode .format() permet une meilleure organisation de l’afﬁchage des variables (nous expliquerons à la ﬁn de ce chapitre ce que le terme « méthode » signiﬁe en Python).
Si on reprend l’exemple précédent :
1 >>> x = 32 2 >>> nom = "John" 3 >>> print ("{} a {} ans".format(nom , x)) 4 John a 32 ans
— Dans la chaîne de caractères, les accolades vides {} précisent l’endroit où le contenu de la variable doit être inséré. — Juste après la chaîne de caractères, l’instruction .format(nom, x) fournie la liste des variables à insérer, d’abord la
variable nom puis la variable x. La méthode .format() agit sur la chaîne de caractères à laquelle elle est attachée par le point.
Remarque Il est possible d’indiquer entre les accolades {} dans quel ordre afﬁcher les variables, avec 0 pour la variable à afﬁcher en
premier, 1 pour la variable à afﬁcher en second, etc. (attention, Python commence à compter à 0). Cela permet de modiﬁer l’ordre dans lequel sont afﬁchées les variables.
1 >>> x = 32 2 >>> nom = "John" 3 >>> print ("{0} a {1} ans". format(nom , x)) 4 John a 32 ans 5 >>> print ("{1} a {0} ans". format(nom , x)) 6 32 a John ans

Imaginez maintenant que vous vouliez calculer, puis afﬁcher, la proportion de GC d’un génome. La proportion de GC s’obtient comme la somme des bases Guanine (G) et Cytosine (C) divisée par le nombre total de bases (A, T, C, G) du génome considéré. Si on a, par exemple, 4500 bases G et 2575 bases C, pour un total de 14800 bases, vous pourriez procéder comme suit (notez bien l’utilisation des parenthèses pour gérer les priorités des opérateurs) :
1 >>> prop_GC = (4500 + 2575) / 14800 2 >>> print("La proportion de GC est", prop_GC) 3 La proportion de GC est 0.4780405405405405
Le résultat obtenu présente trop de décimales (seize dans le cas présent). Pour écrire le résultat plus lisiblement, vous pouvez spéciﬁer dans les accolades {} le format qui vous intéresse. Dans le cas présent, vous voulez formater un ﬂoat pour l’afﬁcher avec deux puis trois décimales :
1 >>> print("La proportion de GC est {:.2f}". format(prop_GC)) 2 Le proportion de GC est 0.48 3 >>> print("La proportion de GC est {:.3f}". format(prop_GC)) 4 La proportion de GC est 0.478
Détaillons le contenu des accolades de la première ligne ({:.2f}) : — Les deux points : indiquent qu’on veut préciser le format. — La lettre f indique qu’on souhaite afﬁcher la variable sous forme d’un ﬂoat. — Les caractères .2 indiquent la précision voulue, soit ici deux chiffres après la virgule.

18

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

3.2. Écriture formatée

Chapitre 3. Afﬁchage

Notez enﬁn que le formatage avec .xf (x étant un entier positif) renvoie un résultat arrondi. Il est par ailleurs possible de combiner le formatage (à droite des 2 points) ainsi que l’emplacement des variables à substituer (à gauche des 2 points), par exemple :
1 >>> print("prop GC(2 déci.) = {0:.2f}, prop GC(3 déci.) = {0:.3f}". format(prop_GC)) 2 prop GC(2 déci.) = 0.48, prop GC(3 déci.) = 0.478
Vous remarquerez qu’on utilise ici la même variable (prop_GC) à deux endroits différents. Vous pouvez aussi formater des entiers avec la lettre d :
1 >>> nb_G = 4500 2 >>> print("Ce génome contient {:d} guanines".format(nb_G)) 3 Ce génome contient 4500 guanines
ou mettre plusieurs nombres dans une même chaîne de caractères.
1 >>> nb_G = 4500 2 >>> nb_C = 2575 3 >>> print("Ce génome contient {:d} G et {:d} C, soit une prop de GC de {:.2f}" \ 4 ... .format(nb_G ,nb_C ,prop_GC)) 5 Ce génome contient 4500 G et 2575 C, soit une prop de GC de 0.48 6 >>> perc_GC = prop_GC * 100 7 >>> print "Ce génome contient {:d} G et {:d} C, soit un %GC de {:.2f} %" \ 8 ... .format(nb_G ,nb_C ,perc_GC) 9 Ce génome contient 4500 G et 2575 C, soit un %GC de 47.80 %

Remarque Le signe \ en ﬁn de ligne permet de poursuivre la commande sur la ligne suivante. Cette syntaxe est pratique lorsque vous
voulez taper une commande longue.

Enﬁn, il est possible de préciser sur combien de caractères vous voulez qu’un résultat soit écrit et comment se fait l’alignement (à gauche, à droite ou centré). Dans la portion de code suivante, le caractère ; sert de séparateur entre les instructions sur une même ligne :

1 >>> print(10) ; print(1000)

2 10

3 1000

4 >>> print("{:>6d}".format (10)) ; print("{:>6d}".format (1000))

5

10

6 1000

7 >>> print("{:<6d}".format (10)) ; print("{:<6d}".format (1000))

8 10

9 1000

10 >>> print ("{:^6 d }". format (10)) ; print ("{:^6 d }". format (1000))

11 10

12 1000

13 >>> print ("{:*^6 d }". format (10)) ; print ("{:*^6 d }". format (1000))

14 * * 1 0 * *

15 * 1 0 0 0 *

16 >>> print ("{:0 >6 d }". format (10)) ; print ("{:0 >6 d }". format (1000))

17 0 0 0 0 1 0

18 0 0 1 0 0 0

Notez que > spéciﬁe un alignement à droite, < spéciﬁe un alignement à gauche et ˆ spéciﬁe un alignement centré. Il est également possible d’indiquer le caractère qui servira de remplissage lors des alignements (l’espace est le caractère par défaut).
Ce formatage est également possible sur des chaînes de caractères, notées s (comme string) :
1 >>> print("atom HN") ; print("atom HDE1") 2 atom HN 3 atom HDE1 4 >>> print("atom {:>4s}". format("HN")) ; print("atom {:>4s}". format("HDE1")) 5 atom HN 6 atom HDE1

Vous voyez tout de suite l’énorme avantage de l’écriture formatée. Elle vous permet d’écrire en colonnes parfaitement alignées. Nous verrons que ceci est très pratique si l’on veut écrire les coordonnées des atomes d’une molécule au format PDB (pour en savoir plus sur ce format, reportez-vous à l’annexe A Quelques formats de données rencontrés en biologie).
Pour les ﬂoats, il est possible de combiner le nombre de caractères à afﬁcher avec le nombre de décimales :

1 >>> print ("{:7.3f}". format(perc_GC))

2 47.804

3 >>> print ("{:10.3f}". format(perc_GC))

4

47.804

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

19

Chapitre 3. Afﬁchage

3.3. Ancienne méthode de formatage des chaînes de caractères

L’instruction 7.3f signiﬁe que l’on souhaite écrire un ﬂoat avec 3 décimales et formaté sur 7 caractères (par défaut justiﬁés à droite). L’instruction 10.3f fait la même chose sur 10 caractères. Remarquez que le séparateur décimal . compte pour un caractère.
Enﬁn, si on veut afﬁcher des accolades littérales et utiliser la méthode .format() en même temps, il faut doubler les accolades pour échapper au formatage :
1 >>> print("Accolades littérales {{}} et pour le formatage {}". format (10)) 2 Accolades littérales {} et pour le formatage 10

La méthode .format() agit sur la chaîne de caractères à laquelle elle est attachée par un point et n’a rien à voir avec la fonction print(). Si on donne une chaîne de caractères suivie d’un .format() à la fonction print(), Python évalue d’abord le formatage et c’est la chaîne de caractères qui en résulte qui est afﬁchée à l’écran. Tout comme dans l’instruction print(5*5), c’est d’abord la multiplication (5*5) qui est évaluée, puis son résultat qui est afﬁché à l’écran. On peut s’en rendre compte de la manière suivante dans l’interpréteur :

1 >>> "{:10.3f}".format(perc_GC)

2

47.804

3 >>> type ("{:10.3f}". format(perc_GC))

4 <class str >

Python afﬁche le résultat de l’instruction "{:10.3f}".format(perc_GC) comme une chaîne de caractères et la fonction type() nous le conﬁrme.

3.3 Ancienne méthode de formatage des chaînes de caractères
Conseil : Pour les débutants, vous pouvez passer cette rubrique. Dans d’anciens livres ou programmes Python, il se peut que vous rencontriez l’écriture formatée avec le style suivant :
1 >>> x = 32 2 >>> nom = "John" 3 >>> print ("%s a %d ans" % (nom , x)) 4 John a 32 ans 5 >>> nb_G = 4500 6 >>> nb_C = 2575 7 >>> prop_GC = (nb_G + nb_C)/14800 8 >>> print("On a %d G et %d C -> prop GC = %.2f" % (nb_G , nb_C , prop_GC)) 9 On a 4500 G et 2575 C -> prop GC = 0.48
La syntaxe est légèrement différente. Le symbole % est d’abord appelé dans la chaîne de caractères (dans l’exemple cidessus %d, %d et %.2f) pour :
— Désigner l’endroit où sera placée la variable dans la chaîne de caractères. — Préciser le type de variable à formater, d pour un entier (i fonctionne également) ou f pour un ﬂoat. — Éventuellement pour indiquer le format voulu. Ici .2 signiﬁe une précision de deux décimales. Le signe % est rappelé une seconde fois (% (nb_G, nb_C, prop_GC)) pour indiquer les variables à formater. Cette ancienne façon de formater une chaîne de caractères vous est présentée à titre d’information. Ne l’utilisez pas dans vos programmes.

3.4 Note sur le vocabulaire et la syntaxe
Revenons quelques instants sur la notion de méthode abordée dans ce chapitre avec .format(). En Python, on peut considérer chaque variable comme un objet sur lequel on peut appliquer des méthodes. Une méthode est simplement une fonction qui utilise et/ou agit sur l’objet lui-même, les deux étant connectés par un point. La syntaxe générale est de la forme objet.méthode().
Dans l’exemple suivant :
1 >>> "Joe a {} ans".format (20) 2 Joe a 20 ans
la méthode .format() est liée à "Joe a {} ans" qui est un objet de type chaîne de caractères. La méthode renvoie une nouvelle chaîne de caractères avec le bon formatage (ici, Joe a 20 ans ).
Nous aurons de nombreuses occasions de revoir cette notation objet.méthode().

20

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

3.5. Exercices

Chapitre 3. Afﬁchage

3.5 Exercices
Conseil : utilisez l’interpréteur Python pour les exercices 2 à 5.

3.5.1 Afﬁchage dans l’interpréteur et dans un programme
Ouvrez l’interpréteur Python et tapez l’instruction 1+1. Que se passe-t-il ? Écrivez la même chose dans un script test.py que vous allez créer avec un éditeur de texte. Exécutez ce script en tapant python test.py dans un shell. Que se passe-t-il ? Pourquoi ? Faites en sorte d’afﬁcher le résultat de l’addition 1+1 en exécutant le script dans un shell.

3.5.2 Poly-A
Générez une chaîne de caractères représentant un brin d’ADN poly-A (c’est-à-dire qui ne contient que des bases A) de 20 bases de longueur, sans taper littéralement toutes les bases.

3.5.3 Poly-A et poly-GC
Sur le modèle de l’exercice précédent, générez en une ligne de code un brin d’ADN poly-A (AAAA. . . ) de 20 bases suivi d’un poly-GC régulier (GCGCGC. . . ) de 40 bases.

3.5.4 Écriture formatée
En utilisant l’écriture formatée, afﬁchez en une seule ligne les variables a, b et c dont les valeurs sont respectivement la chaîne de caractères "salut", le nombre entier 102 et le ﬂoat 10.318. La variable c sera afﬁchée avec 2 décimales.

3.5.5 Écriture formatée 2

Dans un script percGC.py, calculez un pourcentage de GC avec l’instruction suivante : perc_GC = ((4500 + 2575)/14800)*100 Ensuite, afﬁchez le contenu de la variable perc_GC à l’écran avec 0, 1, 2 puis 3 décimales sous forme arrondie en utilisant .format(). On souhaite que le programme afﬁche la sortie suivante :

1 Le pourcentage de GC est 48

%

2 Le pourcentage de GC est 47.8 %

3 Le pourcentage de GC est 47.80 %

4 Le pourcentage de GC est 47.804 %

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

21

Chapitre 4
Listes

4.1 Déﬁnition
Une liste est une structure de données qui contient une série de valeurs. Python autorise la construction de liste contenant des valeurs de types différents (par exemple entier et chaîne de caractères), ce qui leur confère une grande ﬂexibilité. Une liste est déclarée par une série de valeurs (n’oubliez pas les guillemets, simples ou doubles, s’il s’agit de chaînes de caractères) séparées par des virgules, et le tout encadré par des crochets. En voici quelques exemples :
1 >>> animaux = [ girafe , tigre , singe , souris ] 2 >>> tailles = [5, 2.5, 1.75, 0.15] 3 >>> mixte = [ girafe , 5, souris , 0.15] 4 >>> animaux 5 [ girafe , tigre , singe , souris ] 6 >>> tailles 7 [5, 2.5, 1.75, 0.15] 8 >>> mixte 9 [ girafe , 5, souris , 0.15]
Lorsque l’on afﬁche une liste, Python la restitue telle qu’elle a été saisie.

4.2 Utilisation

Un des gros avantages d’une liste est que vous pouvez appeler ses éléments par leur position. Ce numéro est appelé indice

(ou index) de la liste.

1 liste : [ girafe , tigre , singe , souris ]

2 indice :

0

1

2

3

Soyez très attentifs au fait que les indices d’une liste de n éléments commence à 0 et se termine à n-1. Voyez l’exemple
suivant :
1 >>> animaux = [ girafe , tigre , singe , souris ] 2 >>> animaux[0] 3 girafe 4 >>> animaux[1] 5 tigre 6 >>> animaux[3] 7 souris

Par conséquent, si on appelle l’élément d’indice 4 de notre liste, Python renverra un message d’erreur :
1 >>> animaux[4] 2 Traceback (innermost last): 3 File "<stdin >", line 1, in ? 4 IndexError: list index out of range

N’oubliez pas ceci ou vous risquez d’obtenir des bugs inattendus !

4.3 Opération sur les listes
Tout comme les chaînes de caractères, les listes supportent l’opérateur + de concaténation, ainsi que l’opérateur * pour la duplication :

22

4.4. Indiçage négatif

Chapitre 4. Listes

1 >>> ani1 = [ girafe , tigre ] 2 >>> ani2 = [ singe , souris ] 3 >>> ani1 + ani2 4 [ girafe , tigre , singe , souris ] 5 >>> ani1 * 3 6 [ girafe , tigre , girafe , tigre ,

girafe ,

tigre ]

L’opérateur + est très pratique pour concaténer deux listes. Vous pouvez aussi utiliser la méthode .append() lorsque vous souhaitez ajouter un seul élément à la ﬁn d’une liste. Dans l’exemple suivant nous allons créer une liste vide :
1 >>> a = [] 2 >>> a 3 []

puis lui ajouter deux éléments, l’un après l’autre, d’abord avec la concaténation :
1 >>> a = a + [15] 2 >>> a 3 [15] 4 >>> a = a + [-5] 5 >>> a 6 [15, -5]

puis avec la méthode .append() :
1 >>> a.append(13) 2 >>> a 3 [15, -5, 13] 4 >>> a.append(-3) 5 >>> a 6 [15, -5, 13, -3]

Dans l’exemple ci-dessus, nous ajoutons des éléments à une liste en utilisant l’opérateur de concaténation + ou la méthode .append(). Nous vous conseillons dans ce cas précis d’utiliser la méthode .append() dont la syntaxe est plus élégante.
Nous reverrons en détail la méthode .append() dans le chapitre 11 Plus sur les listes.

4.4 Indiçage négatif

La liste peut également être indexée avec des nombres négatifs selon le modèle suivant :

1 liste

: [ girafe , tigre , singe , souris ]

2 indice positif :

0

1

2

3

3 indice négatif :

-4

-3

-2

-1

ou encore :

1 liste

:[A,B,C,D,E,F]

2 indice positif : 0 1 2 3 4 5

3 indice négatif : -6 -5 -4 -3 - 2 -1

Les indices négatifs reviennent à compter à partir de la ﬁn. Leur principal avantage est que vous pouvez accéder au dernier élément d’une liste à l’aide de l’indice -1 sans pour autant connaître la longueur de cette liste. L’avant-dernier élément a lui l’indice -2, l’avant-avant dernier l’indice -3, etc.
1 >>> animaux = [ girafe , tigre , singe , souris ] 2 >>> animaux[-1] 3 souris 4 >>> animaux[-2] 5 singe

Pour accéder au premier élément de la liste avec un indice négatif, il faut par contre connaître le bon indice :
1 >>> animaux[-4] 2 girafe

Dans ce cas, on utilise plutôt animaux[0].

4.5 Tranches
Un autre avantage des listes est la possibilité de sélectionner une partie d’une liste en utilisant un indiçage construit sur le modèle [m:n+1] pour récupérer tous les éléments, du émième au énième (de l’élément m inclus à l’élément n+1 exclu). On dit alors qu’on récupère une tranche de la liste, par exemple :

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

23

Chapitre 4. Listes

4.6. Fonction len()

1 >>> animaux = [ girafe , tigre , singe , 2 >>> animaux[0:2] 3 [ girafe , tigre ] 4 >>> animaux[0:3] 5 [ girafe , tigre , singe ] 6 >>> animaux[0:] 7 [ girafe , tigre , singe , souris ] 8 >>> animaux[:] 9 [ girafe , tigre , singe , souris ] 10 >>> animaux [1:] 11 [ tigre , singe , souris ] 12 >>> animaux [1: -1] 13 [ tigre , singe ]

souris ]

Notez que lorsqu’aucun indice n’est indiqué à gauche ou à droite du symbole deux-points, Python prend par défaut tous les éléments depuis le début ou tous les éléments jusqu’à la ﬁn respectivement.
On peut aussi préciser le pas en ajoutant un symbole deux-points supplémentaire et en indiquant le pas par un entier.

1 >>> animaux = [ girafe , tigre , singe , 2 >>> animaux[0:3:2] 3 [ girafe , singe ] 4 >>> x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 5 >>> x 6 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 7 >>> x[::1] 8 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 9 >>> x[::2] 10 [0 , 2 , 4 , 6 , 8] 11 >>> x [::3] 12 [0 , 3 , 6 , 9] 13 >>> x [1:6:3] 14 [1 , 4]

souris ]

Finalement, on se rend compte que l’accès au contenu d’une liste fonctionne sur le modèle liste[début:fin:pas].

4.6 Fonction len()

L’instruction len() vous permet de connaître la longueur d’une liste, c’est-à-dire le nombre d’éléments que contient la liste. Voici un exemple d’utilisation :

1 >>> animaux = [ girafe , tigre , 2 >>> len(animaux) 34 4 >>> len([1, 2, 3, 4, 5, 6, 7, 8]) 58

singe ,

souris ]

4.7 Les fonctions range() et list()
L’instruction range() est une fonction spéciale en Python qui génère des nombres entiers compris dans un intervalle. Lorsqu’elle est utilisée en combinaison avec la fonction list(), on obtient une liste d’entiers. Par exemple :
1 >>> list(range(10)) 2 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
La commande list(range(10)) a généré une liste contenant tous les nombres entiers de 0 inclus à 10 exclu. Nous verrons l’utilisation de la fonction range() toute seule dans le chapitre 5 Boucles et comparaisons.
Dans l’exemple ci-dessus, la fonction range() a pris un argument, mais elle peut également prendre deux ou trois arguments, voyez plutôt :
1 >>> list(range(0,5)) 2 [0, 1, 2, 3, 4] 3 >>> list(range(15,20)) 4 [15, 16, 17, 18, 19] 5 >>> list(range(0,1000,200)) 6 [0, 200, 400, 600, 800] 7 >>> list(range(2,-2,-1)) 8 [2, 1, 0, -1]

24

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

4.8. Listes de listes

Chapitre 4. Listes

L’instruction range() fonctionne sur le modèle range([début,] fin[, pas]). Les arguments entre crochets sont optionnels. Pour obtenir une liste de nombres entiers, il faut l’utiliser systématiquement avec la fonction list().
Enﬁn, prenez garde aux arguments optionnels par défaut (0 pour début et 1 pour pas) :
1 >>> list(range(10,0)) 2 []
Ici la liste est vide car Python a pris la valeur du pas par défaut qui est de 1. Ainsi, si on commence à 10 et qu’on avance par pas de 1, on ne pourra jamais atteindre 0. Python génère ainsi une liste vide. Pour éviter ça, il faudrait, par exemple, préciser un pas de -1 pour obtenir une liste d’entiers décroissants :
1 >>> list(range(10,0,-1)) 2 [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]

4.8 Listes de listes
Pour ﬁnir, sachez qu’il est tout à fait possible de construire des listes de listes. Cette fonctionnalité peut parfois être très pratique. Par exemple :
1 >>> enclos1 = [ girafe , 4] 2 >>> enclos2 = [ tigre , 2] 3 >>> enclos3 = [ singe , 5] 4 >>> zoo = [enclos1 , enclos2 , enclos3] 5 >>> zoo 6 [[ girafe , 4], [ tigre , 2], [ singe , 5]]
Dans cet exemple, chaque sous-liste contient une catégorie d’animal et le nombre d’animaux pour chaque catégorie. Pour accéder à un élément de la liste, on utilise l’indiçage habituel :
1 >>> zoo[1] 2 [ tigre , 2]
Pour accéder à un élément de la sous-liste, on utilise un double indiçage :
1 >>> zoo[1][0] 2 tigre 3 >>> zoo[1][1] 42
On verra un peu plus loin qu’il existe en Python des dictionnaires qui sont également très pratiques pour stocker de l’information structurée. On verra aussi qu’il existe un module nommé NumPy qui permet de créer des listes ou des tableaux de nombres (vecteurs et matrices) et de les manipuler.
4.9 Exercices
Conseil : utilisez l’interpréteur Python.
4.9.1 Jours de la semaine
Constituez une liste semaine contenant les 7 jours de la semaine.
1. À partir de cette liste, comment récupérez-vous seulement les 5 premiers jours de la semaine d’une part, et ceux du week-end d’autre part ? Utilisez pour cela l’indiçage.
2. Cherchez un autre moyen pour arriver au même résultat (en utilisant un autre indiçage). 3. Trouvez deux manières pour accéder au dernier jour de la semaine. 4. Inversez les jours de la semaine en une commande.
4.9.2 Saisons
Créez 4 listes hiver, printemps, ete et automne contenant les mois correspondants à ces saisons. Créez ensuite une liste saisons contenant les listes hiver, printemps, ete et automne. Prévoyez ce que renvoient les instructions suivantes, puis vériﬁez-le dans l’interpréteur :

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

25

Chapitre 4. Listes

4.9. Exercices

1. saisons[2] 2. saisons[1][0] 3. saisons[1:2] 4. saisons[:][1]. Comment expliquez-vous ce dernier résultat ?
4.9.3 Table de multiplication par 9
Afﬁchez la table de multiplication par 9 en une seule commande avec les instructions range() et list().
4.9.4 Nombres pairs
Répondez à la question suivante en une seule commande. Combien y a-t-il de nombres pairs dans l’intervalle [2 , 10000] inclus ?

26

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

Chapitre 5
Boucles et comparaisons

5.1 Boucles for

5.1.1 Principe

En programmation, on est souvent amené à répéter plusieurs fois une instruction. Incontournables à tout langage de pro-
grammation, les boucles vont nous aider à réaliser cette tâche de manière compacte et efﬁcace.
Imaginez par exemple que vous souhaitiez afﬁcher les éléments d’une liste les uns après les autres. Dans l’état actuel de
vos connaissances, il faudrait taper quelque chose du style :
1 animaux = [ girafe , tigre , singe , souris ] 2 print(animaux[0]) 3 print(animaux[1]) 4 print(animaux[2]) 5 print(animaux[3])

Si votre liste ne contient que 4 éléments, ceci est encore faisable mais imaginez qu’elle en contienne 100 voire 1000 ! Pour remédier à cela, il faut utiliser les boucles. Regardez l’exemple suivant :

1 >>> animaux = [ girafe , tigre , singe , souris ]

2 >>> for animal in animaux:

3 ...

print(animal)

4 ...

5 girafe

6 tigre

7 singe

8 souris

Commentons en détails ce qu’il s’est passé dans cet exemple : La variable animal est appelée variable d’itération, elle prend successivement les différentes valeurs de la liste animaux à chaque itération de la boucle. On verra un peu plus loin dans ce chapitre que l’on peut choisir le nom que l’on veut pour cette variable. Celle-ci est créée par Python la première fois que la ligne contenant le for est exécutée (si elle existait déjà son contenu serait écrasé). Une fois la boucle terminée, cette variable d’itération animal ne sera pas détruite et contiendra ainsi la dernière valeur de la liste animaux (ici la chaîne de caractères souris). Notez bien les types des variables utilisées ici : animaux est une liste sur laquelle on itère, et animal est une chaîne de caractères car chaque élément de la liste est une chaîne de caractères. Nous verrons plus loin que la variable d’itération peut être de n’importe quel type selon la liste parcourue. En Python, une boucle itère toujours sur un objet dit séquentiel
(c’est-à-dire un objet constitué d’autres objets) tel qu’une liste. Nous verrons aussi plus tard d’autres objets séquentiels sur
lesquels on peut itérer dans une boucle. D’ores et déjà, prêtez attention au caractère deux-points « : » à la ﬁn de la ligne débutant par for. Cela signiﬁe que la
boucle for attend un bloc d’instructions, en l’occurrence toutes les instructions que Python répétera à chaque itération de la boucle On appelle ce bloc d’instructions le corps de la boucle. Comment indique-t-on à Python où ce bloc commence et se termine ? Cela est signalé uniquement par l’indentation, c’est-à-dire le décalage vers la droite de la (ou des) ligne(s) du bloc
d’instructions.

Remarque Les notions de bloc d’instruction et d’indentations avait été abordées rapidement dans le chapitre 1 Introduction.

27

Chapitre 5. Boucles et comparaisons

5.1. Boucles for

Dans l’exemple suivant, le corps de la boucle contient deux instructions : print(animal) et print(animal*2) car elles sont indentées par rapport à la ligne débutant par for :

1 for animal in animaux:

2

print(animal)

3

print ( animal *2)

4 print("C est fini")

La ligne 4 print("C est fini") ne fait pas partie du corps de la boucle car elle est au même niveau que le for (c’està-dire non indentée par rapport au for). Notez également que chaque instruction du corps de la boucle doit être indentée de la même manière (ici 4 espaces).

Remarque Outre une meilleure lisibilité, les deux-points et l’indentation sont formellement requis en Python. Même si on peut in-
denter comme on veut (plusieurs espaces ou plusieurs tabulations, mais pas une combinaison des deux), les développeurs recommandent l’utilisation de quatre espaces. Vous pouvez consulter à ce sujet le chapitre 15 Bonnes pratiques de programmation en Python.
Faites en sorte de conﬁgurer votre éditeur de texte favori de façon à écrire quatre espaces lorsque vous tapez sur la touche Tab (tabulation).

Si on oublie l’indentation, Python renvoie un message d’erreur :

1 >>> for animal in animaux:

2 ... print(animal)

3 File "<stdin >", line 2

4

print(animal)

5

^

6 IndentationError: expected an indented block

Dans les exemples ci-dessus, nous avons exécuté une boucle en itérant directement sur une liste. Une tranche d’une liste étant elle même une liste, on peut également itérer dessus :

1 >>> animaux = [ girafe , tigre , singe , souris ]

2 >>> for animal in animaux [1:3]:

3 ...

print(animal)

4 ...

5 tigre

6 singe

On a vu que les boucles for pouvaient utiliser une liste contenant des chaînes de caractères, mais elles peuvent tout aussi bien utiliser des listes contenant des entiers (ou n’importe quel type de variable).

1 >>> for i in [1,2,3]:

2 ...

print(i)

3 ...

41

52

63

5.1.2 Fonction range()

Python possède la fonction range() que nous avons rencontrée précédemment dans le chapitre 4 sur les Listes et qui est aussi bien commode pour faire une boucle sur une liste d’entiers de manière automatique :

1 >>> for i in range (4):

2 ...

print(i)

3 ...

40

51

62

73

Dans cet exemple, nous pouvons faire plusieurs remarques importantes : Contrairement à la création de liste avec list(range(4)), la fonction range() peut être utilisée telle quelle dans une boucle. Il n’est pas nécessaire de taper for i in list(range(4)): même si cela fonctionnerait également.

28

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

5.1. Boucles for

Chapitre 5. Boucles et comparaisons

Comment cela est-ce possible ? Et bien range() est une fonction qui a été spécialement conçue pour cela 1, c’est-àdire que l’on peut itérer directement dessus. Pour Python, il s’agit d’un nouveau type, par exemple dans l’instruction x = range(3) la variable x est de type range (tout comme on avait les types int, ﬂoat, str ou list) à utiliser spécialement avec les
boucles. L’instruction list(range(4)) se contente de transformer un objet de type range en un objet de type list. Si vous vous
souvenez bien, il s’agit d’une fonction de casting, qui convertit un type en un autre (voir chapitre 2 Variables). Il n’y aucun intérêt à utiliser dans une boucle la construction for i in list(range(4)):. C’est même contre-productif. En effet, range() se contente de stocker l’entier actuel, le pas pour passer à l’entier suivant, et le dernier entier à parcourir, ce qui revient à stocker seulement 3 nombres entiers et ce quelle que soit la longueur de la séquence, même avec un range(1000000). Si on utilisait list(range(1000000)), Python construirait d’abord une liste de 1 million d’éléments dans la mémoire puis
itérerait dessus, d’où une énorme perte de temps !

5.1.3 Nommage de la variable d’itération
Dans l’exemple précédent, nous avons choisi le nom i pour la variable d’itération. Ceci est une habitude en informatique et indique en général qu’il s’agit d’un entier (le nom i vient sans doute du mot indice ou index en anglais). Nous vous conseillons de suivre cette convention aﬁn d’éviter les confusions, si vous itérez sur les indices vous pouvez appeler la variable d’itération i (par exemple dans for i in range(4):).
Si, par contre, vous itérez sur une liste comportant des chaînes de caractères, mettez un nom explicite pour la variable d’itération. Par exemple :
for prenom in [ Joe , Bill , John ]:

5.1.4 Itération sur les indices

Revenons à notre liste animaux. Nous allons maintenant parcourir cette liste, mais cette fois par une itération sur ses indices :

1 >>> animaux = [ girafe , tigre ,

2 >>> for i in range (4):

3 ...

print ( animaux [i ])

4 ...

5 girafe

6 tigre

7 singe

8 souris

singe ,

souris ]

La variable i prendra les valeurs successives 0, 1, 2 et 3 et on accèdera à chaque élément de la liste animaux par son indice (i.e. animaux[i]). Notez à nouveau le nom i de la variable d’itération car on itère sur les indices.
Quand utiliser l’une ou l’autre des 2 méthodes ? La plus efﬁcace est celle qui réalise les itérations directement sur les éléments :

1 >>> animaux = [ girafe , tigre , singe , souris ]

2 >>> for animal in animaux:

3 ...

print(animal)

4 ...

5 girafe

6 tigre

7 singe

8 souris

Toutefois, il se peut qu’au cours d’une boucle vous ayez besoin des indices, auquel cas vous devrez itérer sur les indices :

1 >>> animaux = [ girafe , tigre , singe , souris ]

2 >>> for i in range(len(animaux )):

3 ...

print("L animal {} est un(e) {}". format(i, animaux[i]))

4 ...

5 L animal 0 est un(e) girafe

6 L animal 1 est un(e) tigre

7 L animal 2 est un(e) singe

8 L animal 3 est un(e) souris

Python possède toutefois la fonction enumerate() qui vous permet d’itérer sur les indices et les éléments eux-mêmes.

1 >>> animaux = [ girafe , tigre , singe , souris ]

2 >>> for i, animal in enumerate(animaux):

3 ...

print("L animal {} est un(e) {}". format(i, animal))

4 ...

1. https://docs.python.org/fr/3/library/stdtypes.html#typesseq-range

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

29

Chapitre 5. Boucles et comparaisons
5 L animal 0 est un(e) girafe 6 L animal 1 est un(e) tigre 7 L animal 2 est un(e) singe 8 L animal 3 est un(e) souris

5.2. Comparaisons

5.2 Comparaisons
Avant de passer à une autre sorte de boucles (les boucles while), nous abordons tout de suite les comparaisons. Celles-ci seront reprises dans le chapitre 6 sur les Tests.
Python est capable d’effectuer toute une série de comparaisons entre le contenu de deux variables, telles que :

Syntaxe Python
== != > >= < <=

Signiﬁcation
égal à différent de supérieur à supérieur ou égal à inférieur à inférieur ou égal à

Observez les exemples suivants avec des nombres entiers.
1 >>> x = 5 2 >>> x == 5 3 True 4 >>> x > 10 5 False 6 >>> x < 10 7 True
Python renvoie la valeur True si la comparaison est vraie et False si elle est fausse. True et False sont des booléens (un nouveau type de variable).
Faites bien attention à ne pas confondre l’opérateur d’affectation = qui affecte une valeur à une variable et l’opérateur de comparaison == qui compare les valeurs de deux variables.
Vous pouvez également effectuer des comparaisons sur des chaînes de caractères.
1 >>> animal = "tigre" 2 >>> animal == "tig" 3 False 4 >>> animal != "tig" 5 True 6 >>> animal == tigre 7 True
Dans le cas des chaînes de caractères, a priori seuls les tests == et != ont un sens. En fait, on peut aussi utiliser les opérateurs <, >, <= et >=. Dans ce cas, l’ordre alphabétique est pris en compte, par exemple :
1 >>> "a" < "b" 2 True
"a" est inférieur à "b" car le caractère a est situé avant le caractère b dans l’ordre alphabétique. En fait, c’est l’ordre ASCII 2 des caractères qui est pris en compte (à chaque caractère correspond un code numérique), on peut donc aussi comparer des caractères spéciaux (comme # ou ~) entre eux. Enﬁn, on peut comparer des chaînes de caractères de plusieurs caractères :
1 >>> "ali" < "alo" 2 True 3 >>> "abb" < "ada" 4 True
Dans ce cas, Python compare les deux chaînes de caractères, caractère par caractère, de la gauche vers la droite (le premier caractère avec le premier, le deuxième avec le deuxième, etc). Dès qu’un caractère est différent entre l’une et l’autre des deux chaînes, il considère que la chaîne la plus petite est celle qui présente le caractère ayant le plus petit code ASCII (les caractères suivants de la chaîne de caractères sont ignorés dans la comparaison), comme dans l’exemple "abb" < "ada" ci-dessus.
2. http://fr.wikipedia.org/wiki/American_Standard_Code_for_Information_Interchange

30

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

5.3. Boucles while

Chapitre 5. Boucles et comparaisons

5.3 Boucles while

Une autre alternative à l’instruction for couramment utilisée en informatique est la boucle while. Le principe est simple. Une série d’instructions est exécutée tant qu’une condition est vraie. Par exemple :

1 >>> i = 1

2 >>> while i <= 4:

3 ...

print(i)

4 ...

i=i+1

5 ...

61

72

83

94

Remarquez qu’il est encore une fois nécessaire d’indenter le bloc d’instructions correspondant au corps de la boucle (ici, les instructions lignes 3 et 4).
Une boucle while nécessite généralement trois éléments pour fonctionner correctement :

1. Initialisation de la variable de test avant la boucle (ligne 1). 2. Test de la variable associée à l’instruction while (ligne 2). 3. Mise à jour de la variable de test dans le corps de la boucle (ligne 4).

Faites bien attention aux tests et à l’incrémentation que vous utilisez car une erreur mène souvent à des « boucles inﬁnies » qui ne s’arrêtent jamais. Vous pouvez néanmoins toujours stopper l’exécution d’un script Python à l’aide de la combinaison de touches Ctrl-C (c’est-à-dire en pressant simultanément les touches Ctrl et C). Par exemple :

1i = 0

2 while i < 10:

3

print("Le python c est cool !")

Ici, nous avons omis de mettre à jour la variable i dans le corps de la boucle. Par conséquent, la boucle ne s’arrêtera jamais (sauf en pressant Ctrl-C) puisque la condition i < 10 sera toujours vraie.
La boucle while combinée à la fonction input() peut s’avérer commode lorsqu’on souhaite demander à l’utilisateur une valeur numérique. Par exemple :

1 >>> i = 0

2 >>> while i < 10:

3 ...

reponse = input("Entrez un entier supérieur à 10 : ")

4 ...

i = int(reponse)

5 ...

6 Entrez un entier supérieur à 10 : 4

7 Entrez un entier supérieur à 10 : -3

8 Entrez un entier supérieur à 10 : 15

9 >>> i

10 15

La fonction input() prend en argument un message (sous la forme d’une chaîne de caractères), demande à l’utilisateur d’entrer une valeur et renvoie celle-ci sous forme d’une chaîne de caractères. Il faut ensuite convertir cette dernière en entier (avec la fonction int()).

5.4 Exercices
Conseil : pour ces exercices, créez des scripts puis exécutez-les dans un shell.
5.4.1 Boucles de base
Soit la liste [ vache , souris , levure , bacterie ]. Afﬁchez l’ensemble des éléments de cette liste (un élément par ligne) de trois manières différentes (deux avec for et une avec while).
5.4.2 Boucle et jours de la semaine
Constituez une liste semaine contenant les 7 jours de la semaine. Écrivez une série d’instructions afﬁchant les jours de la semaine (en utilisant une boucle for), ainsi qu’une autre série d’instructions afﬁchant les jours du week-end (en utilisant une boucle while).

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

31

Chapitre 5. Boucles et comparaisons

5.4. Exercices

5.4.3 Nombres de 1 à 10 sur une ligne
Avec une boucle, afﬁchez les nombres de 1 à 10 sur une seule ligne. Conseil : n’hésitez pas à relire le début du chapitre 3 Afﬁchage qui discute de la fonction print().
5.4.4 Nombres pairs et impairs
Soit impairs la liste de nombres [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21]. Écrivez un programme qui, à partir de la liste impairs, construit une liste pairs dans laquelle tous les éléments de impairs sont incrémentés de 1.
5.4.5 Calcul de la moyenne
Voici les notes d’un étudiant [14, 9, 6, 8, 12]. Calculez la moyenne de ces notes. Utilisez l’écriture formatée pour afﬁcher la valeur de la moyenne avec deux décimales.
5.4.6 Produit de nombres consécutifs
Avez les fonctions list() et range(), créez la liste entiers contenant les nombres entiers pairs de 2 à 20 inclus. Calculez ensuite le produit des nombres consécutifs deux à deux de entiers en utilisant une boucle. Exemple pour les premières itérations :
18 2 24 3 48 4 [...]

5.4.7 Triangle
Créez un script qui dessine un triangle comme celui-ci :
1* 2 ** 3 *** 4 **** 5 ***** 6 ****** 7 ******* 8 ******** 9 ********* 10 * * * * * * * * * *

5.4.8 Triangle inversé
Créez un script qui dessine un triangle comme celui-ci :
1 ********** 2 ********* 3 ******** 4 ******* 5 ****** 6 ***** 7 **** 8 *** 9 ** 10 *

5.4.9 Triangle gauche

Créez un script qui dessine un triangle comme celui-ci :

1

*

2

**

3

***

4

****

5

*****

6

******

7

*******

8 ********

9 *********

10 * * * * * * * * * *

32

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

5.4. Exercices

Chapitre 5. Boucles et comparaisons

FIGURE 5.1 – Parcours d’une matrice.

5.4.10 Pyramide

Créez un script pyra.py qui dessine une pyramide comme celle-ci :

1

*

2

***

3

*****

4

*******

5

*********

6

***********

7

*************

8 ***************

9 *****************

10 * * * * * * * * * * * * * * * * * * *

Essayez de faire évoluer votre script pour dessiner la pyramide à partir d’un nombre arbitraire de lignes N. Vous pourrez demander à l’utilisateur le nombre de lignes de la pyramide avec les instructions suivantes qui utilisent la fonction input() :
1 reponse = input("Entrez un nombre de lignes (entier positif): ") 2 N = int(reponse)

5.4.11 Parcours de matrice

Imaginons que l’on souhaite parcourir tous les éléments d’une matrice carrée, c’est-à-dire d’une matrice qui est constituée d’autant de lignes que de colonnes.
Créez un script qui parcourt chaque élément de la matrice et qui afﬁche le numéro de ligne et de colonne uniquement avec des boucles for.
Pour une matrice 2 × 2, le schéma de la ﬁgure 5.1 vous indique comment parcourir une telle matrice. L’afﬁchage attendu est :

1 ligne colonne

2

1

1

3

1

2

4

2

1

5

2

2

Attention à bien respecter l’alignement des chiffres qui doit être justiﬁé à droite sur 4 caractères. Testez pour une matrice 3 × 3, puis 5 × 5, et enﬁn 10 × 10.
Créez une seconde version de votre script, cette fois-ci avec deux boucles while.

5.4.12 Parcours de demi-matrice sans la diagonale (exercice ++)
En se basant sur le script précédent, on souhaite réaliser le parcours d’une demi-matrice carrée sans la diagonale. On peut noter que cela produit tous les couples possibles une seule fois (1 et 2 est équivalent à 2 et 1), en excluant par ailleurs chaque élément avec lui même (1 et 1, 2 et 2, etc). Pour mieux comprendre ce qui est demandé, la ﬁgure 5.2 indique les cases à parcourir en gris :
Créez un script qui afﬁche le numéro de ligne et de colonne, puis la taille de la matrice N × N et le nombre total de cases parcourues. Par exemple pour une matrice 4 × 4 (N=4) :

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

33

Chapitre 5. Boucles et comparaisons

5.4. Exercices

FIGURE 5.2 – Demi-matrice sans la diagonale (en gris).

FIGURE 5.3 – Sauts de puce.

1 ligne colonne

2

1

2

3

1

3

4

1

4

5

2

3

6

2

4

7

3

4

8 Pour une matrice 4x4 , on a parcouru 6 cases

Testez votre script avec N=3, puis N=4 et enﬁn N=5. Concevez une seconde version à partir du script précédent, où cette fois on n’afﬁche plus tous les couples possibles mais simplement la valeur de N, et le nombre de cases parcourues. Afﬁchez cela pour des valeurs de N allant de 2 à 10. Pouvez-vous trouver une formule générale reliant le nombre de cases parcourues à N ?

5.4.13 Sauts de puce
On imagine une puce qui se déplace aléatoirement sur une ligne, en avant ou en arrière, par pas de 1 ou -1. Par exemple, si elle est à l’emplacement 0, elle peut sauter à l’emplacement 1 ou -1 ; si elle est à l’emplacement 2, elle peut sauter à l’emplacement 3 ou 1, etc.
Avec une boucle while, simuler le mouvement de cette puce de l’emplacement initial 0 à l’emplacement ﬁnal 5 (voir le schéma de la ﬁgure 5.3). Combien de sauts sont nécessaires pour réaliser ce parcours ? Relancez plusieurs fois le programme. Trouvez-vous le même nombre de sauts à chaque exécution ?
Conseil : vous utiliserez l’instruction random.choice([-1,1]) qui renvoie au hasard les valeurs -1 ou 1 avec la même probabilité. Avant d’utiliser cette instruction vous mettrez au tout début de votre script la ligne import random Nous reverrons la signiﬁcation de cette syntaxe particulière dans le chapitre 8 Modules.

5.4.14 Suite de Fibonacci (exercice +++)
La suite de Fibonacci 3 est une suite mathématique qui porte le nom de Leonardo Fibonacci, un mathématicien italien du XIIIe siècle. Initialement, cette suite a été conçue pour décrire la croissance d’une population de lapins, mais elle peut
3. https://fr.wikipedia.org/wiki/Suite_de_Fibonacci

34

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

5.4. Exercices

Chapitre 5. Boucles et comparaisons

également être utilisée pour décrire certains motifs géométriques retrouvés dans la nature (coquillages, ﬂeurs de tournesol. . . ).
Pour la suite de Fibonacci (xn), le terme au rang n (avec n > 1) est la somme des nombres aux rangs n − 1 et n − 2 : xn = xn−1 + xn−2 Par déﬁnition, les deux premiers termes sont x0 = 0 et x1 = 1. À titre d’exemple, les 10 premiers termes de la suite de Fibonacci sont donc 0, 1, 1, 2, 3, 5, 8, 13, 21 et 34. Créez un script qui construit une liste fibo avec les 15 premiers termes de la suite de Fibonacci puis l’afﬁche. Améliorez ce script en afﬁchant, pour chaque élément de la liste fibo avec n > 1, le rapport entre l’élément de rang n et l’élément de rang n − 1. Ce rapport tend-il vers une constante ? Si oui, laquelle ?

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

35

Chapitre 6
Tests

6.1 Déﬁnition

Les tests sont un élément essentiel à tout langage informatique si on veut lui donner un peu de complexité car ils permettent à l’ordinateur de prendre des décisions. Pour cela, Python utilise l’instruction if ainsi qu’une comparaison que nous avons abordée au chapitre précédent. Voici un premier exemple :

1 >>> x = 2

2 >>> if x == 2:

3 ...

print("Le test est vrai !")

4 ...

5 Le test est vrai !

et un second :

1 >>> x = "souris"

2 >>> if x == "tigre":

3 ...

print("Le test est vrai !")

4 ...

Il y a plusieurs remarques à faire concernant ces deux exemples : — Dans le premier exemple, le test étant vrai, l’instruction print("Le test est vrai !") est exécutée. Dans le
second exemple, le test est faux et rien n’est afﬁché. — Les blocs d’instruction dans les tests doivent forcément être indentés comme pour les boucles for et while. L’inden-
tation indique la portée des instructions à exécuter si le test est vrai. — Et comme avec les boucles for et while, la ligne qui contient l’instruction if se termine par le caractère deux-points
« :».

6.2 Tests à plusieurs cas

Parfois, il est pratique de tester si la condition est vraie ou si elle est fausse dans une même instruction if. Plutôt que d’utiliser deux instructions if, on peut se servir des instructions if et else :

1 >>> x = 2

2 >>> if x == 2:

3 ...

print("Le test est vrai !")

4 ... else:

5 ...

print("Le test est faux !")

6 ...

7 Le test est vrai !

8 >>> x = 3

9 >>> if x == 2:

10 ...

print("Le test est vrai !")

11 ... else :

12 ...

print("Le test est faux !")

13 ...

14 Le test est faux !

On peut utiliser une série de tests dans la même instruction if, notamment pour tester plusieurs valeurs d’une même variable.

36

6.4. Tests multiples

Chapitre 6. Tests

Par exemple, on se propose de tirer au sort une base d’ADN puis d’afﬁcher le nom de cette dernière. Dans le code suivant, nous utilisons l’instruction random.choice(liste) qui renvoie un élément choisi au hasard dans une liste. L’instruction import random sera vue plus tard dans le chapitre 8 Modules, admettez pour le moment qu’elle est nécessaire.

1 >>> import random

2 >>> base = random.choice(["a", "t", "c", "g"])

3 >>> if base == "a":

4 ...

print("choix d une adénine")

5 ... elif base == "t":

6 ...

print("choix d une thymine")

7 ... elif base == "c":

8 ...

print("choix d une cytosine")

9 ... elif base == "g":

10 ...

print("choix d une guanine")

11 ...

12 choix d une cytosine

Dans cet exemple, Python teste la première condition, puis, si et seulement si elle est fausse, teste la deuxième et ainsi de suite. . . Le code correspondant à la première condition vériﬁée est exécuté puis Python sort du bloc d’instructions du if.

6.3 Importance de l’indentation

De nouveau, faites bien attention à l’indentation ! Vous devez être très rigoureux sur ce point. Pour vous en convaincre, exécutez ces deux exemples de code :
Code 1

1 nombres = [4, 5, 6]

2 for nb in nombres:

3

if nb == 5:

4

print("Le test est vrai")

5

print("car la variable nb vaut {}". format(nb))

Résultat :
1 Le test est vrai 2 car la variable nb vaut 5

Code 2

1 nombres = [4, 5, 6]

2 for nb in nombres:

3

if nb == 5:

4

print("Le test est vrai")

5

print("car la variable nb vaut {}". format(nb))

Résultat :
1 car la variable nb vaut 4 2 Le test est vrai 3 car la variable nb vaut 5 4 car la variable nb vaut 6

Les deux codes pourtant très similaires produisent des résultats très différents. Si vous observez avec attention l’indentation
des instructions sur la ligne 5, vous remarquerez que dans le code 1, l’instruction est indentée deux fois, ce qui signiﬁe qu’elle appartient au bloc d’instructions du test if. Dans le code 2, l’instruction de la ligne 5 n’est indentée qu’une seule fois, ce qui fait qu’elle appartient au bloc d’instructions de la boucle for, d’où l’afﬁchage de car la variable nb vaut xx pour toutes les valeurs de nb.

6.4 Tests multiples
Les tests multiples permettent de tester plusieurs conditions en même temps en utilisant des opérateurs booléens. Les deux opérateurs les plus couramment utilisés sont le OU et le ET. Voici un petit rappel sur le fonctionnement de l’opérateur OU :

Condition 1
Vrai Vrai Faux Faux

Opérateur
OU OU OU OU

Condition 2
Vrai Faux Vrai Faux

Résultat
Vrai Vrai Vrai Faux

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

37

Chapitre 6. Tests et de l’opérateur ET :

6.5. Instructions break et continue

Condition 1
Vrai Vrai Faux Faux

Opérateur
ET ET ET ET

Condition 2
Vrai Faux Vrai Faux

Résultat
Vrai Faux Faux Faux

En Python, on utilise le mot réservé and pour l’opérateur ET et le mot réservé or pour l’opérateur OU. Respectez bien la casse des opérateurs and et or qui, en Python, s’écrivent en minuscule. En voici un exemple d’utilisation :

1 >>> x = 2

2 >>> y = 2

3 >>> if x == 2 and y == 2:

4 ...

print("le test est vrai")

5 ...

6 le test est vrai

Notez que le même résultat serait obtenu en utilisant deux instructions if imbriquées :

1 >>> x = 2

2 >>> y = 2

3 >>> if x == 2:

4 ...

if y == 2:

5 ...

print("le test est vrai")

6 ...

7 le test est vrai

Vous pouvez aussi tester directement l’effet de ces opérateurs à l’aide de True et False (attention à respecter la casse).
1 >>> True or False 2 True

Enﬁn, on peut utiliser l’opérateur logique de négation not qui inverse le résultat d’une condition :
1 >>> not True 2 False 3 >>> not False 4 True 5 >>> not (True and True) 6 False

6.5 Instructions break et continue

Ces deux instructions permettent de modiﬁer le comportement d’une boucle (for ou while) avec un test. L’instruction break stoppe la boucle.

1 >>> for i in range (5):

2 ...

if i > 2:

3 ...

break

4 ...

print(i)

5 ...

60

71

82

L’instruction continue saute à l’itération suivante, sans exécuter la suite du bloc d’instructions de la boucle.

1 >>> for i in range (5):

2 ...

if i == 2:

3 ...

continue

4 ...

print(i)

5 ...

60

71

83

94

38

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

6.6. Tests de valeur sur des ﬂoats

Chapitre 6. Tests

6.6 Tests de valeur sur des ﬂoats
Lorsque l’on souhaite tester la valeur d’une variable de type ﬂoat, le premier réﬂexe serait d’utiliser l’opérateur d’égalité comme :
1 >>> 1/10 == 0.1 2 True
Toutefois, nous vous le déconseillons formellement. Pourquoi ? Python stocke les valeurs numériques des ﬂoats sous forme de nombres ﬂottants (d’où leur nom !), et cela mène à certaines limitations 1. Observez l’exemple suivant :
1 >>> (3 - 2.7) == 0.3 2 False 3 >>> 3 - 2.7 4 0.2999999999999998
Nous voyons que le résultat de l’opération 3 - 2.7 n’est pas exactement 0.3 d’où le False ligne 2. En fait, ce problème ne vient pas de Python, mais plutôt de la manière dont un ordinateur traite les nombres ﬂottants (comme un rapport de nombres binaires). Ainsi certaines valeurs de ﬂoat ne peuvent être qu’approchées. Une manière de s’en rendre compte est d’utiliser l’écriture formatée en demandant l’afﬁchage d’un grand nombre de décimales :
1 >>> 0.3 2 0.3 3 >>> "{:.5f}".format (0.3) 4 0.30000 5 >>> "{:.60f}".format (0.3) 6 0.299999999999999988897769753748434595763683319091796875000000 7 >>> "{:.60f}".format(3.0 - 2.7) 8 0.299999999999999822364316059974953532218933105468750000000000
On observe que lorsqu’on tape 0.3, Python afﬁche une valeur arrondie. En réalité, le nombre réel 0.3 ne peut être qu’approché lorsqu’on le code en nombre ﬂottant. Il est donc essentiel d’avoir cela en tête lorsque l’on effectue un test .
Conseil Pour les raisons évoquées ci-dessus, il ne faut surtout pas tester si un ﬂoat est égal à une certaine valeur. La bonne pratique
est de vériﬁer si un ﬂoat est compris dans un intervalle avec une certaine précision. Si on appelle cette précision delta, on peut procéder ainsi :
1 >>> delta = 0.0001 2 >>> var = 3.0 - 2.7 3 >>> 0.3 - delta < var < 0.3 + delta 4 True 5 >>> abs(var - 0.3) < delta 6 True
Ici on teste si var est compris dans l’intervalle 0.3±delta. Les deux méthodes mènent à un résultat strictement équivalent : — La ligne 3 est intuitive car elle ressemble à un encadrement mathématique. — La ligne 5 utilise la fonction valeur absolue abs() et est plus compacte.

6.7 Exercices
Conseil : pour ces exercices, créez des scripts puis exécutez-les dans un shell.
6.7.1 Jours de la semaine
Constituez une liste semaine contenant le nom des sept jours de la semaine. En utilisant une boucle, écrivez chaque jour de la semaine ainsi que les messages suivants : — Au travail s’il s’agit du lundi au jeudi ; — Chouette c est vendredi s’il s’agit du vendredi ; — Repos ce week-end s’il s’agit du samedi ou du dimanche. Ces messages ne sont que des suggestions, vous pouvez laisser libre cours à votre imagination.
1. https://docs.python.org/fr/3/tutorial/floatingpoint.html

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

39

Chapitre 6. Tests

6.7. Exercices

6.7.2 Séquence complémentaire d’un brin d’ADN
La liste ci-dessous représente la séquence d’un brin d’ADN : ["A","C","G","T","T","A","G","C","T","A","A","C","G"] Créez un script qui transforme cette séquence en sa séquence complémentaire. Rappel : la séquence complémentaire s’obtient en remplaçant A par T, T par A, C par G et G par C.

6.7.3 Minimum d’une liste
La fonction min() de Python renvoie l’élément le plus petit d’une liste constituée de valeurs numériques ou de chaînes de caractères. Sans utiliser cette fonction, créez un script qui détermine le plus petit élément de la liste [8, 4, 6, 1, 5].

6.7.4 Fréquence des acides aminés
La liste ci-dessous représente une séquence d’acides aminés : ["A","R","A","W","W","A","W","A","R","W","W","R","A","G"] Calculez la fréquence des acides aminés alanine (A), arginine (R), tryptophane (W) et glycine (G) dans cette séquence.

6.7.5 Notes et mention d’un étudiant
Voici les notes d’un étudiant : 14, 9, 13, 15 et 12. Créez un script qui afﬁche la note maximum (utilisez la fonction max()), la note minimum (utilisez la fonction min()) et qui calcule la moyenne.
Afﬁchez la valeur de la moyenne avec deux décimales. Afﬁchez aussi la mention obtenue sachant que la mention est « passable » si la moyenne est entre 10 inclus et 12 exclus, « assez bien » entre 12 inclus et 14 exclus et « bien » au-delà de 14.

6.7.6 Nombres pairs
Construisez une boucle qui parcourt les nombres de 0 à 20 et qui afﬁche les nombres pairs inférieurs ou égaux à 10 d’une part, et les nombres impairs strictement supérieurs à 10 d’autre part.
Pour cet exercice, vous pourrez utiliser l’opérateur modulo % qui renvoie le reste de la division entière entre deux nombres et dont voici quelques exemples d’utilisation :
1 >>> 4 % 3 21 3 >>> 5 % 3 42 5 >>> 4 % 2 60 7 >>> 5 % 2 81 9 >>> 6 % 2 10 0 11 > > > 7 % 2 12 1
Vous remarquerez qu’un nombre est pair lorsque le reste de sa division entière par 2 est nul.

6.7.7 Conjecture de Syracuse (exercice +++)
La conjecture de Syracuse 2 est une conjecture mathématique qui reste improuvée à ce jour et qui est déﬁnie de la manière suivante.
Soit un entier positif n. Si n est pair, alors le diviser par 2. Si il est impair, alors le multiplier par 3 et lui ajouter 1. En répétant cette procédure, la suite de nombres atteint la valeur 1 puis se prolonge indéﬁniment par une suite de trois valeurs triviales appelée cycle trivial.
Jusqu’à présent, la conjecture de Syracuse, selon laquelle depuis n’importe quel entier positif la suite de Syracuse atteint 1, n’a pas été mise en défaut.
Par exemple, les premiers éléments de la suite de Syracuse si on prend comme point de départ 10 sont : 10, 5, 16, 8, 4, 2, 1. . .
2. http://fr.wikipedia.org/wiki/Conjecture_de_Syracuse

40

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

6.7. Exercices

Chapitre 6. Tests

Créez un script qui, partant d’un entier positif n (par exemple 10 ou 20), crée une liste des nombres de la suite de Syracuse. Avec différents points de départ (c’est-à-dire avec différentes valeurs de n), la conjecture de Syracuse est-elle toujours vériﬁée ? Quels sont les nombres qui constituent le cycle trivial ?
Remarque
1. Pour cet exercice, vous avez besoin de faire un nombre d’itérations inconnu pour que la suite de Syracuse atteigne le chiffre 1 puis entame son cycle trivial. Vous pourrez tester votre algorithme avec un nombre arbitraire d’itérations, typiquement 20 ou 100, suivant votre nombre n de départ.
2. Un nombre est pair lorsque le reste de sa division entière (opérateur modulo %) par 2 est nul.

6.7.8 Attribution de la structure secondaire des acides aminés d’une protéine (exercice +++)
Dans une protéine, les différents acides aminés sont liés entre eux par une liaison peptidique. Les angles phi et psi sont deux angles mesurés autour de cette liaison peptidique. Leurs valeurs sont utiles pour déﬁnir la conformation spatiale (appelée « structure secondaire ») adoptée par les acides aminés.
Par exemples, les angles phi et psi d’une conformation en « hélice alpha » parfaite ont une valeur de -57 degrés et -47 degrés respectivement. Bien sûr, il est très rare que l’on trouve ces valeurs parfaites dans une protéine, et il est habituel de tolérer une déviation de ± 30 degrés autour des valeurs idéales de ces angles.
Vous trouverez ci-dessous une liste de listes contenant les valeurs des angles phi et psi de 15 acides aminés de la protéine 1TFE 3 :
1 [[48.6,53.4],[-124.9,156.7],[-66.2,-30.8], \ 2 [-58.8,-43.1],[-73.9,-40.6],[-53.7,-37.5], \ 3 [-80.6,-26.0],[-68.5,135.0],[-64.9,-23.5], \ 4 [-66.9,-45.5],[-69.6,-41.0],[-62.7,-37.5], \ 5 [-68.2,-38.3],[-61.2,-49.1],[-59.7,-41.1]]
Pour le premier acide aminé, l’angle phi vaut 48.6 et l’angle psi 53.4. Pour le deuxième, l’angle phi vaut -124.9 et l’angle psi 156.7, etc.
En utilisant cette liste, créez un script qui teste, pour chaque acide aminé, s’il est ou non en hélice et afﬁche les valeurs des angles phi et psi et le message adapté est en hélice ou n’est pas en hélice.
Par exemple, pour les 3 premiers acides aminés :
1 [48.6, 53.4] n est pas en hélice 2 [-124.9, 156.7] n est pas en hélice 3 [-66.2, -30.8] est en hélice
D’après vous, quelle est la structure secondaire majoritaire de ces 15 acides aminés ?
Remarque Pour en savoir plus sur le monde merveilleux des protéines, n’hésitez pas à consulter la page Wikipedia sur la structure
secondaire des protéines 4.

6.7.9 Détermination des nombres premiers inférieurs à 100 (exercice +++)
Voici un extrait de l’article sur les nombres premiers tiré de l’encyclopédie en ligne wikipédia 5. Un nombre premier est un entier naturel qui admet exactement deux diviseurs distincts entiers et positifs (qui sont alors 1 et lui-même). Cette déﬁnition exclut 1, qui n’a qu’un seul diviseur entier positif. Par opposition, un nombre non nul produit de deux nombres entiers différents de 1 est dit composé. Par exemple 6 = 2 × 3 est composé, tout comme 21 = 3 × 7, mais 11 est premier car 1 et 11 sont les seuls diviseurs de 11. Les nombres 0 et 1 ne sont ni premiers ni composés. Déterminez les nombres premiers inférieurs à 100. Combien y a-t-il de nombres premiers entre 0 et 100 ? Pour vous aider, nous vous proposons plusieurs méthodes.
3. https://www.rcsb.org/structure/1TFE 4. https://fr.wikipedia.org/wiki/Structure_des_prot%C3%A9ines#Angles_di%C3%A8dres_et_structure_secondaire 5. http://fr.wikipedia.org/wiki/Nombre_premier

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

41

Chapitre 6. Tests

6.7. Exercices

Méthode 1 (peu optimale mais assez intuitive)
Pour chaque nombre de 2 à 100, calculez le reste de la division entière (avec l’opérateur modulo %) depuis 1 jusqu’à lui-même. Si c’est un nombre premier, il aura exactement deux nombres pour lesquels le reste de la division entière est égal à 0 (1 et lui-même). Si ce n’est pas un nombre premier, il aura plus de deux nombres pour lesquels le reste de la division entière est égal à 0.
Méthode 2 (plus optimale et plus rapide, mais un peu plus compliquée)
Parcourez tous les nombres de 2 à 100 et vériﬁez si ceux-ci sont composés, c’est-à-dire qu’ils sont le produit de deux nombres premiers. Pratiquement, cela consiste à vériﬁer que le reste de la division entière (opérateur modulo %) entre le nombre considéré et chaque nombre premier déterminé jusqu’à maintenant est nul. Le cas échéant, ce nombre n’est pas premier. Attention, pour cette méthode, il faudra initialiser la liste de nombres premiers avec le premier nombre premier (donc 2 !).
6.7.10 Recherche d’un nombre par dichotomie (exercice +++)
La recherche par dichotomie 6 est une méthode qui consiste à diviser (en général en parties égales) un problème pour en trouver la solution. À titre d’exemple, voici une discussion entre Pierre et Patrick dans laquelle Pierre essaie de deviner le nombre (compris entre 1 et 100 inclus) auquel Patrick a pensé.
— [Patrick] « C’est bon, j’ai pensé à un nombre entre 1 et 100. » — [Pierre] « OK, je vais essayer de le deviner. Est-ce que ton nombre est plus petit ou plus grand que 50 ? » — [Patrick] « Plus grand. » — [Pierre] « Est-ce que ton nombre est plus petit, plus grand ou égal à 75 ? » — [Patrick] « Plus grand. » — [Pierre] « Est-ce que ton nombre est plus petit, plus grand ou égal à 87 ? » — [Patrick] « Plus petit. » — [Pierre] « Est-ce que ton nombre est plus petit, plus grand ou égal à 81 ? » — [Patrick] « Plus petit. » — [Pierre] « Est-ce que ton nombre est plus petit, plus grand ou égal à 78 ? » — [Patrick] « Plus grand. » — [Pierre] « Est-ce que ton nombre est plus petit, plus grand ou égal à 79 ? » — [Patrick] « Égal. C’est le nombre auquel j’avais pensé. Bravo ! » Pour arriver rapidement à deviner le nombre, l’astuce consiste à prendre à chaque fois la moitié de l’intervalle dans lequel se trouve le nombre. Voici le détail des différentes étapes :
1. le nombre se trouve entre 1 et 100, on propose 50 (100 / 2).
2. le nombre se trouve entre 50 et 100, on propose 75 ( 50 + (100-50)/2 ).
3. le nombre se trouve entre 75 et 100, on propose 87 ( 75 + (100-75)/2 ).
4. le nombre se trouve entre 75 et 87, on propose 81 ( 75 + (87-75)/2 ).
5. le nombre se trouve entre 75 et 81, on propose 78 ( 75 + (81-75)/2 ).
6. le nombre se trouve entre 78 et 81, on propose 79 ( 78 + (81-78)/2 ).
Créez un script qui reproduit ce jeu de devinettes. Vous pensez à un nombre entre 1 et 100 et l’ordinateur essaie de le deviner par dichotomie en vous posant des questions.
Votre programme utilisera la fonction input() pour interagir avec l’utilisateur. Voici un exemple de son fonctionnement :
1 >>> lettre = input("Entrez une lettre : ") 2 Entrez une lettre : P 3 >>> print(lettre) 4P
Pour vous guider, voici ce que donnerait le programme avec la conversation précédente :
1 Pensez à un nombre entre 1 et 100. 2 Est -ce votre nombre est plus grand , plus petit ou égal à 50 ? [+/ -/=] + 3 Est -ce votre nombre est plus grand , plus petit ou égal à 75 ? [+/ -/=] + 4 Est -ce votre nombre est plus grand , plus petit ou égal à 87 ? [+/ -/=] 5 Est -ce votre nombre est plus grand , plus petit ou égal à 81 ? [+/ -/=] -
6. https://fr.wikipedia.org/wiki/Dichotomie

42

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

6.7. Exercices

Chapitre 6. Tests

6 Est -ce votre nombre est plus grand , plus petit ou égal à 78 ? [+/ -/=] + 7 Est -ce votre nombre est plus grand , plus petit ou égal à 79 ? [+/ -/=] = 8 J ai trouvé en 6 questions !
Les caractères [+/-/=] indiquent à l’utilisateur comment il doit interagir avec l’ordinateur, c’est-à-dire entrer soit le caractère + si le nombre choisi est plus grand que le nombre proposé par l’ordinateur, soit le caractère - si le nombre choisi est plus petit que le nombre proposé par l’ordinateur, soit le caractère = si le nombre choisi est celui proposé par l’ordinateur (en appuyant ensuite sur la touche Entrée).

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

43

Chapitre 7
Fichiers

7.1 Lecture dans un ﬁchier

Une grande partie de l’information en biologie est stockée sous forme de ﬁchiers. Pour traiter cette information, vous devez le plus souvent lire ou écrire dans un ou plusieurs ﬁchiers. Python possède pour cela de nombreux outils qui vous simpliﬁent la vie.
Avant de passer à un exemple concret, créez un ﬁchier dans un éditeur de texte que vous enregistrerez dans votre répertoire courant avec le nom zoo.txt et le contenu suivant :
1 girafe 2 tigre 3 singe 4 souris

Ensuite, testez le code suivant dans l’interpréteur Python :
1 >>> filin = open("zoo.txt", "r") 2 >>> filin 3 <_io.TextIOWrapper name= zoo.txt mode= r encoding= UTF -8 > 4 >>> filin.readlines() 5 [ girafe\n , tigre\n , singe\n , souris\n ] 6 >>> filin.close() 7 >>> filin.readlines() 8 Traceback (most recent call last): 9 File "<stdin >", line 1, in <module > 10 ValueError : I / O operation on closed file .

Il y a plusieurs commentaires à faire sur cet exemple : Ligne 1. L’instruction open() ouvre le ﬁchier zoo.txt. Ce ﬁchier est ouvert en lecture seule, comme l’indique le second argument r (pour read) de la fonction open(). Remarquez que le ﬁchier n’est pas encore lu, mais simplement ouvert (un peu comme lorsqu’on ouvre un livre, mais qu’on ne l’a pas encore lu). Le curseur de lecture est prêt à lire le premier caractère du ﬁchier. L’instruction open("zoo.txt", "r") suppose que le ﬁchier zoo.txt est dans le répertoire depuis lequel l’interpréteur Python a été lancé. Si ce n’est pas le cas, il faut préciser le chemin d’accès au ﬁchier. Par exemple, /home/pierre/zoo.txt pour Linux ou Mac OS X ou C:\Users\pierre\zoo.txt pour Windows. Ligne 2. Lorsqu’on afﬁche le contenu de la variable filin, on se rend compte que Python la considère comme un objet de type ﬁchier ouvert (ligne 3). Ligne 4. Nous utilisons à nouveau la syntaxe objet.méthode() (présentée dans le chapitre 3 Afﬁchage). Ici la méthode .readlines() agit sur l’objet filin en déplaçant le curseur de lecture du début à la ﬁn du ﬁchier, puis elle renvoie une liste contenant toutes les lignes du ﬁchier (dans notre analogie avec un livre, ceci correspondrait à lire toutes les lignes du livre). Ligne 6. Enﬁn, on applique la méthode .close() sur l’objet filin, ce qui, vous vous en doutez, ferme le ﬁchier (ceci correspondrait à fermer le livre). Vous remarquerez que la méthode .close() ne renvoie rien mais modiﬁe l’état de l’objet filin en ﬁchier fermé. Ainsi, si on essaie de lire à nouveau les lignes du ﬁchier, Python renvoie une erreur car il ne peut pas lire un ﬁchier fermé (lignes 7 à 10).
Voici maintenant un exemple complet de lecture d’un ﬁchier avec Python.

1 >>> filin = open("zoo.txt", "r") 2 >>> lignes = filin.readlines() 3 >>> lignes 4 [ girafe\n , tigre\n , singe\n , 5 >>> for ligne in lignes:

souris\n ]

44

7.1. Lecture dans un ﬁchier

Chapitre 7. Fichiers

6 ...

print(ligne)

7 ...

8 girafe

9
10 tigre

11
12 singe

13
14 s o u r i s

15
16 >>> filin . close ()

Vous voyez qu’en cinq lignes de code, vous avez lu, parcouru le ﬁchier et afﬁché son contenu.

Remarque
— Chaque élément de la liste lignes est une chaîne de caractères. C’est en effet sous forme de chaînes de caractères que Python lit le contenu d’un ﬁchier.
— Chaque élément de la liste lignes se termine par le caractère \n. Ce caractère un peu particulier correspond au « saut de ligne 1 » qui permet de passer d’une ligne à la suivante. Ceci est codé par un caractère spécial que l’on représente par \n. Vous pourrez parfois rencontrer également la notation octale \012. Dans la suite de cet ouvrage, nous emploierons aussi l’expression « retour à la ligne » que nous trouvons plus intuitive.
— Par défaut, l’instruction print() afﬁche quelque chose puis revient à la ligne. Ce retour à la ligne dû à print() se cumule alors avec celui de la ﬁn de ligne (\n) de chaque ligne du ﬁchier et donne l’impression qu’une ligne est sautée à chaque fois.

Il existe en Python le mot-clé with qui permet d’ouvrir et de fermer un ﬁchier de manière efﬁcace. Si pour une raison ou une autre l’ouverture ou la lecture du ﬁchier conduit à une erreur, l’utilisation de with garantit la bonne fermeture du ﬁchier, ce qui n’est pas le cas dans le code précédent. Voici donc le même exemple avec with :

1 >>> with open("zoo.txt", r ) as filin:

2 ...

lignes = filin.readlines()

3 ...

for ligne in lignes:

4 ...

print(ligne)

5 ...

6 girafe

7
8 tigre

9
10 singe

11
12 s o u r i s

13
14 > > >

Remarque — L’instruction with introduit un bloc d’indentation. C’est à l’intérieur de ce bloc que nous effectuons toutes les opérations sur le ﬁchier. — Une fois sorti du bloc d’indentation, Python fermera automatiquement le ﬁchier. Vous n’avez donc plus besoin d’utiliser la méthode .close().

7.1.1 Méthode .read()

Il existe d’autres méthodes que .readlines() pour lire (et manipuler) un ﬁchier. Par exemple, la méthode .read() lit tout le contenu d’un ﬁchier et renvoie une chaîne de caractères unique.

1 >>> with open("zoo.txt", "r") as filin:

2 ...

filin . read ()

3 ...

4 girafe\ntigre\nsinge\nsouris\n

5 >>>

1. https://fr.wikipedia.org/wiki/Saut_de_ligne

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

45

Chapitre 7. Fichiers

7.2. Écriture dans un ﬁchier

7.1.2 Méthode .readline()

La méthode .readline() (sans s à la ﬁn) lit une ligne d’un ﬁchier et la renvoie sous forme d’une chaîne de caractères. À chaque nouvel appel de .readline(), la ligne suivante est renvoyée. Associée à la boucle while, cette méthode permet de lire un ﬁchier ligne par ligne.

1 >>> with open("zoo.txt", "r") as filin:

2 ...

ligne = filin.readline()

3 ...

while ligne != "":

4 ...

print(ligne)

5 ...

ligne = filin.readline()

6 ...

7 girafe

8
9 tigre

10
11 singe

12
13 s o u r i s

14
15 > > >

7.1.3 Itérations directe sur le ﬁchier

Python essaie de vous faciliter la vie au maximum. Voici un moyen à la fois simple et élégant de parcourir un ﬁchier.

1 >>> with open("zoo.txt", "r") as filin:

2 ...

for ligne in filin:

3 ...

print(ligne)

4 ...

5 girafe

6
7 tigre

8
9 singe

10
11 s o u r i s

12
13 > > >

La boucle for va demander à Python d’aller lire le ﬁchier ligne par ligne. Privilégiez cette méthode par la suite.

Remarque Les méthodes abordées précédemment permettent d’accéder au contenu d’un ﬁchier, soit ligne par ligne (méthode .readline()),
soit globalement en une seule chaîne de caractères (méthode .read()), soit globalement avec les lignes différenciées sous forme d’une liste de chaînes de caractères (méthode .readlines()). Il est également possible en Python de se rendre à un endroit particulier d’un ﬁchier avec la méthode .seek() mais qui sort du cadre de cet ouvrage.

7.2 Écriture dans un ﬁchier

Écrire dans un ﬁchier est aussi simple que de le lire. Voyez l’exemple suivant :

1 >>> animaux2 = ["poisson", "abeille", "chat"]

2 >>> with open("zoo2.txt", "w") as filout:

3 ...

for animal in animaux2:

4 ...

filout.write(animal)

5 ...

67

77

84

Quelques commentaires sur cet exemple : Ligne 1. Création de liste de chaînes de caractères animaux2. Ligne 2. Ouverture du ﬁchier zoo2.txt en mode écriture, avec le caractère w pour write. L’instruction with crée un bloc
d’instructions qui doit être indenté. Ligne 3. Parcours de la liste animaux2 avec une boucle for. Ligne 4. À chaque itération de la boucle, nous avons écrit chaque élément de la liste dans le ﬁchier. La méthode .write()
s’applique sur l’objet filout. Notez qu’à chaque utilisation de la méthode .write(), celle-ci nous afﬁche le nombre d’octets

46

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

7.3. Ouvrir deux ﬁchiers avec l’instruction with

Chapitre 7. Fichiers

(équivalent au nombre de caractères) écrits dans le ﬁchier (lignes 6 à 8). Ceci est valable uniquement dans l’interpréteur, si vous créez un programme avec les mêmes lignes de code, ces valeurs ne s’afﬁcheront pas à l’écran.
Si nous ouvrons le ﬁchier zoo2.txt avec un éditeur de texte, voici ce que nous obtenons : poissonabeillechat Ce n’est pas exactement le résultat attendu car implicitement nous voulions le nom de chaque animal sur une ligne. Nous avons oublié d’ajouter le caractère ﬁn de ligne après chaque nom d’animal. Pour ce faire, nous pouvons utiliser l’écriture formatée :

1 >>> animaux2 = ["poisson", "abeille", "chat"]

2 >>> with open("zoo2.txt", "w") as filout:

3 ...

for animal in animaux2:

4 ...

filout.write ("{}\n".format(animal))

5 ...

68

78

85

Ligne 4. L’écriture formatée vue au chapitre 3 Afﬁchage permet d’ajouter un retour à la ligne (\n) après le nom de chaque animal.
Lignes 6 à 8. Le nombre d’octets écrits dans le ﬁchier est augmenté de 1 par rapport à l’exemple précédent car le caractère retour à la ligne compte pour un seul octet.
Le contenu du ﬁchier zoo2.txt est alors :
1 poisson 2 abeille 3 chat

Vous voyez qu’il est extrêmement simple en Python de lire ou d’écrire dans un ﬁchier.

7.3 Ouvrir deux ﬁchiers avec l’instruction with

On peut avec l’instruction with ouvrir deux ﬁchiers (ou plus) en même temps. Voyez l’exemple suivant :

1 with open("zoo.txt", "r") as fichier1 , open("zoo2.txt", "w") as fichier2:

2

for ligne in fichier1:

3

fichier2.write("* " + ligne)

Si le ﬁchier zoo.txt contient le texte suivant :
1 souris 2 girafe 3 lion 4 singe

alors le contenu de zoo2.txt sera :
1 * souris 2 * girafe 3 * lion 4 * singe

Dans cet exemple, with permet une notation très compacte en s’affranchissant de deux méthodes .close(). Si vous souhaitez aller plus loin, sachez que l’instruction with est plus générale et est utilisable dans d’autres contextes 2.

7.4 Note sur les retours à la ligne sous Unix et sous Windows
Conseil : si vous êtes débutant, vous pouvez sauter cette rubrique. On a vu plus haut que le caractère spécial \n correspondait à un retour à la ligne. C’est le standard sous Unix (Mac OS X et Linux). Toutefois, Windows utilise deux caractères spéciaux pour le retour à la ligne : \r correspondant à un retour chariot (hérité des machines à écrire) et \n comme sous Unix. Si vous avez commencé à programmer en Python 2, vous aurez peut-être remarqué que selon les versions, la lecture de ﬁchier supprimait parfois les \r et d’autres fois les laissait. Heureusement, la fonction open() dans Python 3 3 gère tout ça automatiquement et renvoie uniquement des sauts de ligne sous forme de \n (même si le ﬁchier a été conçu sous Windows et qu’il contient initialement des \r).
2. https://docs.python.org/fr/3/reference/compound_stmts.html#the-with-statement 3. https://docs.python.org/fr/3/library/functions.html#open

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

47

Chapitre 7. Fichiers

7.5. Importance des conversions de types avec les ﬁchiers

7.5 Importance des conversions de types avec les ﬁchiers
Vous avez sans doute remarqué que les méthodes qui lisent un ﬁchier (par exemple .readlines()) vous renvoient systématiquement des chaînes de caractères. De même, pour écrire dans un ﬁchier il faut fournir une chaîne de caractères à la méthode .write().
Pour tenir compte de ces contraintes, il faudra utiliser les fonctions de conversions de types vues au chapitre 2 Variables : int(), float() et str(). Ces fonctions de conversion sont essentielles lorsqu’on lit ou écrit des nombres dans un ﬁchier.
En particulier, les nombres dans un ﬁchier sont considérés comme du texte, donc comme des chaînes de caractères, par la méthode .readlines(). Par conséquent, il faut les convertir (en entier ou en ﬂoat) si on veut effectuer des opérations numériques avec.

7.6 Du respect des formats de données et de ﬁchiers
Maintenant que vous savez lire et écrire des ﬁchiers en Python, vous êtes capables de manipuler beaucoup d’information en biologie. Prenez garde cependant aux formats de ﬁchiers, c’est-à-dire à la manière dont est stockée l’information biologique dans des ﬁchiers. Nous vous renvoyons pour cela à l’annexe A Quelques formats de données rencontrés en biologie.

7.7 Exercices
Conseil : pour ces exercices, créez des scripts puis exécutez-les dans un shell.
7.7.1 Moyenne des notes
Le ﬁchier notes.txt 4 contient les notes obtenues par des étudiants pour le cours de Python. Chaque ligne du ﬁchier ne contient qu’une note.
Téléchargez le ﬁchier notes.txt et enregistrez-le dans votre répertoire de travail. N’hésitez pas l’ouvrir avec un éditeur de texte pour voir à quoi il ressemble.
Créez un script Python qui lit chaque ligne de ce ﬁchier, extrait les notes sous forme de ﬂoat et les stocke dans une liste. Terminez le script en calculant et afﬁchant la moyenne des notes avec deux décimales.
7.7.2 Admis ou recalé
Le ﬁchier notes.txt 5 contient les notes obtenues par des étudiants pour le cours de Python. Chaque ligne du ﬁchier ne contient qu’une note.
Téléchargez le ﬁchier notes.txt et enregistrez-le dans votre répertoire de travail. N’hésitez pas l’ouvrir avec un éditeur de texte pour voir à quoi il ressemble.
Créez un script Python qui lit chaque ligne de ce ﬁchier, extrait les notes sous forme de ﬂoat et les stocke dans une liste. Le script réécrira ensuite les notes dans le ﬁchier notes2.txt avec une note par ligne suivie de « recalé » si la note est inférieure à 10 et « admis » si la note est supérieure ou égale à 10. Toutes les notes seront écrites avec une décimale. À titre d’exemple, voici les 3 premières lignes attendues pour le ﬁchier notes2.txt :
1 13.5 admis 2 17.0 admis 3 9.5 recalé

7.7.3 Spirale (exercice +++)
Créez un script spirale.py qui calcule les coordonnées cartésiennes d’une spirale. Les coordonnées cartésiennes xA et yA d’un point A sur un cercle de rayon r s’expriment en fonction de l’angle θ représenté sur la ﬁgure 7.1 comme :
xA = cos(θ ) × r
4. https://python.sdv.univ-paris-diderot.fr/data-files/notes.txt 5. https://python.sdv.univ-paris-diderot.fr/data-files/notes.txt

48

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

7.7. Exercices

Chapitre 7. Fichiers

FIGURE 7.1 – Point A sur le cercle de rayon r.

yA = sin(θ ) × r

Pour calculer les coordonnées cartésiennes qui décrivent la spirale, vous allez faire varier deux variables en même temps :
— l’angle θ , qui va prendre des valeurs de 0 à 4π par pas de 0.1, ce qui correspond à deux tours complets ; — le rayon du cercle r, qui va prendre comme valeur initiale 0.5 puis que vous allez incrémenter (c’est-à-dire augmenter)
par pas de 0.1. Les fonctions trigonométriques sinus et cosinus sont disponibles dans le module math que vous découvrirez plus en détails dans le chapitre 8 Modules. Pour les utiliser, vous ajouterez au début de votre script l’instruction : import math la fonction sinus sera math.sin() et la fonction cosinus math.cos(). Ces deux fonctions prennent comme argument une valeur d’angle en radian. La constante mathématique π sera également accessible grâce à ce module via math.pi. Sauvegardez ensuite les coordonnées cartésiennes dans le ﬁchier spirale.dat en respectant le format suivant : — un couple de coordonnées (xA et yA) par ligne ; — un espace entre les deux coordonnées xA et yA ; — les coordonnées afﬁchées sur 10 caractères avec 5 chiffres après la virgule. Les premières lignes de spirale.dat devrait ressembler à :

1

0.50000

0.00000

2

0.59700

0.05990

3

0.68605

0.13907

4

0.76427

0.23642

5

0.82895

0.35048

6

0.87758

0.47943

7

[...]

[...]

Une fois que vous avez généré le ﬁchier spirale.dat, visualisez votre spirale avec le code suivant (que vous pouvez recopier dans un autre script ou à la suite de votre script spirale.py) :

1 import matplotlib.pyplot as plt

2

3 x = []

4 y = []

5 with open("spirale.dat", "r") as f_in:

6

for line in f_in:

7

coords = line.split()

8

x. append ( float ( coords [0]))

9

y. append ( float ( coords [1]))

10

11 plt . figure ( figsize =(8 ,8))

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

49

Chapitre 7. Fichiers

7.7. Exercices

12 mini = min ( x + y ) * 1.2 13 maxi = max ( x + y ) * 1.2 14 plt . xlim ( mini , maxi ) 15 plt . ylim ( mini , maxi ) 16 plt . plot (x , y ) 17 plt . savefig (" spirale . png ")
Visualisez l’image spirale.png ainsi créée.
Remarque Le module matplotlib est utilisé ici pour la visualisation de la spirale. Son utilisation est détaillée dans le chapitre 17
Quelques modules d’intérêt en bioinformatique.

Essayez de jouer sur les paramètres θ et r, et leurs pas d’incrémentation, pour construire de nouvelles spirales.

50

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

Chapitre 8
Modules
8.1 Déﬁnition
Les modules sont des programmes Python qui contiennent des fonctions que l’on est amené à réutiliser souvent (on les appelle aussi bibliothèques ou libraries). Ce sont des « boîtes à outils » qui vont vous être très utiles.
Les développeurs de Python ont mis au point de nombreux modules qui effectuent une quantité phénoménale de tâches. Pour cette raison, prenez toujours le réﬂexe de vériﬁer si une partie du code que vous souhaitez écrire n’existe déjà pas sous forme de module.
La plupart de ces modules sont déjà installés dans les versions standards de Python. Vous pouvez accéder à une documentation exhaustive 1 sur le site de Python. N’hésitez pas à explorer un peu ce site, la quantité de modules disponibles est impressionnante (plus de 300).
8.2 Importation de modules
Dans les chapitres précédents, nous avons rencontré la notion de module plusieurs fois. Notamment lorsque nous avons voulu tirer un nombre aléatoire :
1 >>> import random 2 >>> random.randint(0, 10) 34
Regardons de plus près cet exemple : — Ligne 1, l’instruction import donne accès à toutes les fonctions du module random 2. — Ensuite, ligne 2, nous utilisons la fonction randint(0, 10) du module random. Cette fonction renvoie un nombre
entier tiré aléatoirement entre 0 inclus et 10 inclus. Nous avons également croisé le module math lors de l’exercice sur la spirale (voir chapitre 7 Fichiers). Ce module nous a donné accès aux fonctions trigonométriques et à la constante π :
1 >>> import math 2 >>> math.cos(math.pi / 2) 3 6.123233995736766e-17 4 >>> math.sin(math.pi / 2) 5 1.0
En résumé, l’utilisation de la syntaxe import module permet d’importer tout une série de fonctions organisées par « thèmes ». Par exemple, les fonctions gérant les nombres aléatoires avec random et les fonctions mathématiques avec math. Python possède de nombreux autres modules internes (c’est-à-dire présent de base lorsqu’on installe Python).
Remarque Dans le chapitre 3 Afﬁchage, nous avons introduit la syntaxe truc.bidule() avec truc étant un objet et .bidule() une
méthode. Nous vous avions expliqué qu’une méthode était une fonction un peu particulière : — elle était liée à un objet par un point ; — en général, elle agissait sur ou utilisait l’objet auquel elle était liée.
1. https://docs.python.org/3/py-modindex.html 2. https://docs.python.org/fr/3/library/random.html#module-random
51

Chapitre 8. Modules

8.2. Importation de modules

Par exemple, la méthode .format() dans l’instruction "{}".format(3.14) utilise l’objet chaîne de caractères "{}" (auquel elle est liée) pour ﬁnalement renvoyer une autre chaîne de caractères "3.14". Avec les modules, nous rencontrons une syntaxe similaire. Par exemple, dans l’instruction math.cos(), on pourrait penser que .cos() est aussi une méthode. En fait la documentation ofﬁcielle de Python 3 précise bien que dans ce cas .cos() est une fonction. Dans cet ouvrage, nous utiliserons systématiquement le mot fonction lorsqu’on évoquera des fonctions issues
de modules.
Si cela vous parait encore ardu, ne vous inquiétez pas, c’est à force de pratiquer et de lire que vous vous approprierez le vocabulaire. Ici, la syntaxe module.fonction() est là pour rappeler de quel module provient la fonction en un coup d’œil !

Il existe un autre moyen d’importer une ou plusieurs fonctions d’un module :
1 >>> from random import randint 2 >>> randint(0,10) 37
À l’aide du mot-clé from, on peut importer une fonction spéciﬁque d’un module donné. Remarquez que dans ce cas, il est inutile de répéter le nom du module, seul le nom de la fonction en question est requis.
On peut également importer toutes les fonctions d’un module :
1 >>> from random import * 2 >>> x = [1, 2, 3, 4] 3 >>> shuffle(x) 4 >>> x 5 [2, 3, 1, 4] 6 >>> shuffle(x) 7 >>> x 8 [4, 2, 1, 3] 9 >>> randint(0,50) 10 46 11 >>> uniform (0 ,2.5) 12 0 . 6 4 9 4 3 1 7 4 7 6 0 7 2 7 9 5 1
L’instruction from random import * importe toutes les fonctions du module random. On peut ainsi utiliser toutes ses fonctions directement, comme par exemple shuffle() qui permute une liste aléatoirement.
Dans la pratique, plutôt que de charger toutes les fonctions d’un module en une seule fois :
1 from random import *
nous vous conseillons de charger le module seul :
1 import random
puis d’appeler explicitement les fonctions voulues, par exemple :
1 random.randint(0,2)
Il est également possible de déﬁnir un alias (un nom plus court) pour un module :
1 >>> import random as rand 2 >>> rand.randint(1, 10) 36 4 >>> rand.uniform(1, 3) 5 2.643472616544236
Dans cet exemple, les fonctions du module random sont accessibles via l’alias rand. Enﬁn, pour vider de la mémoire un module déjà chargé, on peut utiliser l’instruction del :
1 >>> import random 2 >>> random.randint(0,10) 32 4 >>> del random 5 >>> random.randint(0,10) 6 Traceback (most recent call last): 7 File "<stdin >", line 1, in ? 8 NameError: name random is not defined
On constate alors qu’un rappel d’une fonction du module random après l’avoir vidé de la mémoire retourne un message d’erreur.
3. https://docs.python.org/3/tutorial/modules.html

52

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

8.3. Obtenir de l’aide sur les modules importés

8.3 Obtenir de l’aide sur les modules importés

Pour obtenir de l’aide sur un module rien de plus simple, il sufﬁt d’utiliser la commande help() :
1 >>> import random 2 >>> help(random) 3 ...

Ce qui renvoie quelque chose du type :

1 Help on module random:

2

3 NAME

4

random - Random variable generators.

5

6 MODULE REFERENCE

7

https://docs.python.org/3.7/ library/random

8

9

The following documentation is automatically generated from the Python

10

source files. It may be incomplete , incorrect or include features that

11

are considered implementation detail and may vary between Python

12

implementations. When in doubt , consult the module reference at the

13

location listed above.

14

15 D E S C R I P T I O N

16

integers

17

--------

18

uniform within range

19

20

sequences

21

---------

22

pick random element

23

pick random sample

Chapitre 8. Modules

Remarque — Pour vous déplacer dans l’aide, utilisez les ﬂèches du haut et du bas pour parcourir les lignes les unes après les autres, ou les touches page-up et page-down pour faire déﬁler l’aide page par page. — Pour quitter l’aide, appuyez sur la touche Q. — Pour chercher du texte, tapez / puis le texte que vous cherchez puis la touche Entrée. Par exemple, pour chercher l’aide sur la fonction randint(), tapez /randint puis Entrée. — Vous pouvez obtenir de l’aide sur une fonction particulière d’un module de la manière suivante : help(random.randint)

La commande help() est en fait une commande plus générale permettant d’avoir de l’aide sur n’importe quel objet chargé

en mémoire.

1 >>> t = [1, 2, 3] 2 >>> help(t) 3 Help on list object:

4

5 class list(object)

6 | list() -> new list

7 | list(sequence) -> new list initialized from sequence s items

8|

9 | Methods defined here:

10 |

11 | __add__ (...)

12 |

x.__add__(y) <==> x+y

13 |

14 ...

Enﬁn, pour connaître d’un seul coup d’œil toutes les méthodes ou variables associées à un objet, utilisez la fonction
dir() :
1 >>> import random 2 >>> dir(random) 3 [ BPF , LOG4 , NV_MAGICCONST , RECIP_BPF , Random , SG_MAGICCONST , 4 SystemRandom , TWOPI , WichmannHill , _BuiltinMethodType , _MethodT 5 ype , __all__ , __builtins__ , __doc__ , __file__ , __name__ , _ac 6 os , _ceil , _cos , _e , _exp , _hexlify , _inst , _log , _pi , 7 _random , _sin , _sqrt , _test , _test_generator , _urandom , _wa 8 rn , betavariate , choice , expovariate , gammavariate , gauss , g 9 etrandbits , getstate , jumpahead , lognormvariate , normalvariate , 10 paretovariate , randint , random , randrange , sample , seed , s 11 etstate , shuffle , uniform , vonmisesvariate , weibullvariate ] 12 > > >

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

53

Chapitre 8. Modules

8.4. Quelques modules courants

8.4 Quelques modules courants
Il existe une série de modules que vous serez probablement amenés à utiliser si vous programmez en Python. En voici une liste non exhaustive. Pour la liste complète, reportez-vous à la page des modules 4 sur le site de Python :
— math 5 : fonctions et constantes mathématiques de base (sin, cos, exp, pi. . . ). — sys 6 : interaction avec l’interpréteur Python, passage d’arguments. — os 7 : dialogue avec le système d’exploitation. — random 8 : génération de nombres aléatoires. — time 9 : accès à l’heure de l’ordinateur et aux fonctions gérant le temps. — urllib 10 : récupération de données sur internet depuis Python. — Tkinter 11 : interface python avec Tk. Création d’objets graphiques. — re 12 : gestion des expressions régulières. Nous vous conseillons d’aller explorer les pages de ces modules pour découvrir toutes leurs potentialités. Vous verrez dans le chapitre 14 Création de module comment créer votre propre module lorsque vous souhaitez réutiliser souvent vos propres fonctions. Enﬁn, notez qu’il existe de nombreux autres modules externes qui ne sont pas installés de base dans Python mais qui sont très utilisés en bioinformatique et en analyse de données. Citons-en quelques-uns : NumPy (manipulations de vecteurs, matrices, algèbre linéaire), Biopython (recherche dans les banques de données biologiques, manipulation de séquences ou de structures de biomolécules), matplotlib (construction de graphiques), pandas (analyse de données). . . Ces modules vous serons présentés dans le chapitre 17 Quelques modules d’intérêt en bioinformatique.

8.5 Module sys : passage d’arguments

Le module sys 13 contient des fonctions et des variables spéciﬁques à l’interpréteur Python lui-même. Ce module est particulièrement intéressant pour récupérer les arguments passés à un script Python lorsque celui-ci est appelé en ligne de commande.
Dans cet exemple, créons le court script suivant que l’on enregistrera sous le nom test.py :
1 import sys 2 print(sys.argv)

Ensuite, dans un shell, exécutons le script test.py suivi de plusieurs arguments. Par exemple :
1 $ python test.py salut girafe 42 2 [ test.py , salut , girafe , 42 ]

Ligne 1. Le caractère $ représente l’invite du shell, test.py est le nom du script Python, salut, girafe et 42 sont les arguments passés au script (tous séparés par un espace).
Ligne 2. Le script afﬁche le contenu de la variable sys.argv. Cette variable est une liste qui contient tous les arguments de la ligne de commande, y compris le nom du script lui-même qu’on retrouve comme premier élément de cette liste dans sys.argv[0]. On peut donc accéder à chacun des arguments du script avec sys.argv[1], sys.argv[2]. . .
Toujours dans le module sys, la fonction sys.exit() est utile pour quitter un script Python. On peut donner un argument à cette fonction (en général une chaîne de caractères) qui sera renvoyé au moment où Python quittera le script. Par exemple, si vous attendez au moins un argument en ligne de commande, vous pouvez renvoyer un message pour indiquer à l’utilisateur ce que le script attend comme argument :

1 import sys

2

3 if len(sys.argv) != 2:

4

sys.exit("ERREUR : il faut exactement un argument .")

5
6 print("Argument vaut : {}". format(sys.argv [1]))

4. https://docs.python.org/fr/3/py-modindex.html 5. https://docs.python.org/fr/3/library/math.html#module-math 6. https://docs.python.org/fr/3/library/sys.html#module-sys 7. https://docs.python.org/fr/3/library/os.html#module-os 8. https://docs.python.org/fr/3/library/random.html#module-random 9. https://docs.python.org/fr/3/library/time.html#module-time 10. https://docs.python.org/fr/3/library/urllib.html#module-urllib 11. https://docs.python.org/fr/3/library/tkinter.html#module-tkinter 12. https://docs.python.org/fr/3/library/re.html#module-re 13. https://docs.python.org/fr/3/library/sys.html#module-sys

54

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

8.6. Module os : interaction avec le système d’exploitation

Chapitre 8. Modules

Puis on l’exécute sans argument :
1 $ python test.py 2 ERREUR : il faut exactement un argument.

et avec un argument :
1 $ python test.py 42 2 Argument vaut : 42

Notez qu’ici on vériﬁe que le script possède deux arguments car le nom du script lui-même compte pour un argument (le tout premier).
L’intérêt de récupérer des arguments passés dans la ligne de commande à l’appel du script est de pouvoir ensuite les utiliser dans le script.
Voici à titre d’exemple le script compte_lignes.py qui va prendre comme argument le nom d’un ﬁchier puis afﬁcher le nombre de lignes qu’il contient.

1 import sys

2

3 if len(sys.argv) != 2:

4

sys.exit("ERREUR : il faut exactement un argument .")

5

6 nom_fichier = sys.argv[1]

7 taille = 0

8 with open(nom_fichier , "r") as f_in:

9

taille = len(f_in.readlines())

10
11 print ("{} contient {} lignes .". format ( nom_fichier , taille ))

Supposons que dans le même répertoire, nous ayons le ﬁchier zoo1.txt dont voici le contenu :
1 girafe 2 tigre 3 singe 4 souris

et le ﬁchier zoo2.txt qui contient :
1 poisson 2 abeille 3 chat

Utilisons maintenant notre script compte_lignes.py :
1 $ python compte_lignes.py 2 ERREUR : il faut exactement un argument. 3 $ python compte_lignes.py zoo1.txt 4 zoo1.txt contient 4 lignes. 5 $ python compte_lignes.py zoo2.txt 6 zoo2.txt contient 3 lignes.

Notre script est donc capable de : — Vériﬁer si un argument lui est donné et si ce n’est pas le cas d’afﬁcher un message d’erreur. — D’ouvrir le ﬁchier dont le nom est donné en argument, de compter puis d’afﬁcher le nombre de lignes. Par contre, le script ne vériﬁe pas si le ﬁchier existe bien :

1 $ python compte_lignes.py zoo3.txt

2 Traceback (most recent call last):

3 File "compte_lignes.py", line 8, in <module >

4

with open(nom_fichier , "r") as f_in:

5 FileNotFoundError: [Errno 2] No such file or directory:

zoo3 . txt

La lecture de la partie suivante va nous permettre d’améliorer notre script compte_lignes.py.

8.6 Module os : interaction avec le système d’exploitation
Le module os 14 gère l’interface avec le système d’exploitation. La fonction os.path.exists() est une fonction pratique de ce module qui vériﬁe la présence d’un ﬁchier sur le disque dur.
14. https://docs.python.org/fr/3/library/os.html#module-os

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

55

Chapitre 8. Modules

8.7. Exercices

1 >>> import sys

2 >>> import os

3 >>> if os.path.exists("toto.pdb"):

4 ...

print("le fichier est présent")

5 ... else:

6 ...

sys.exit("le fichier est absent")

7 ...

8 le fichier est absent

Dans cet exemple, si le ﬁchier n’existe pas sur le disque, on quitte le programme avec la fonction exit() du module sys
que nous venons de voir. La fonction os.getcwd() renvoie le répertoire (sous forme de chemin complet) depuis lequel est lancé Python :
1 >>> import os 2 >>> os.getcwd() 3 /home/pierre

Enﬁn, la fonction os.listdir() renvoie le contenu du répertoire depuis lequel est lancé Python :

1 >>> import os 2 >>> os.listdir() 3 [ 1BTA.pdb , demo.py ,

tests ]

Le résultat est renvoyé sous forme d’une liste contenant à la fois le nom des ﬁchiers et des répertoires.

8.7 Exercices
Conseils : pour les trois premiers exercices, utilisez l’interpréteur Python. Pour les exercices suivants, créez des scripts puis exécutez-les dans un shell.
8.7.1 Racine carrée
Afﬁchez sur la même ligne les nombres de 10 à 20 (inclus) ainsi que leur racine carrée avec 3 décimales. Utilisez pour cela le module math avec la fonction sqrt(). Exemple :
1 10 3.162 2 11 3.317 3 12 3.464 4 13 3.606 5 [...]
Documentation de la fonction math.sqrt() : https://docs.python.org/3/library/math.html#math.sqrt
8.7.2 Cosinus
Calculez le cosinus de π/2 en utilisant le module math avec la fonction cos() et la constante pi. Documentation de la fonction math.cos() : https://docs.python.org/fr/3/library/math.html#math.cos Documentation de la constante math.pi : https://docs.python.org/fr/3/library/math.html#math.pi
8.7.3 Nom et contenu du répertoire courant
Afﬁchez le nom et le contenu du répertoire courant (celui depuis lequel vous avez lancé l’interpréteur Python). Déterminez également le nombre total de ﬁchiers et de répertoires présents dans le répertoire courant. Documentation de la fonction os.getcwd() : https://docs.python.org/fr/3/library/os.html#os.getcwd Documentation de la fonction os.listdir() : https://docs.python.org/fr/3/library/os.html#os.listdir
8.7.4 Afﬁchage temporisé
Afﬁchez les nombres de 1 à 10 avec 1 seconde d’intervalle. Utilisez pour cela le module time et sa fonction sleep(). Documentation de la fonction time.sleep() : https://docs.python.org/fr/3/library/time.html#time.sleep

56

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

8.7. Exercices

Chapitre 8. Modules

8.7.5 Séquences aléatoires de chiffres
Générez une séquence aléatoire de 6 chiffres, ceux-ci étant des entiers tirés entre 1 et 4. Utilisez le module random avec la fonction randint().
Documentation de la fonction random.randint() : https://docs.python.org/fr/3/library/random.html#random.randint
8.7.6 Séquences aléatoires d’ADN
Générez une séquence aléatoire d’ADN de 20 bases de deux manières différentes. Utilisez le module random avec la fonction randint() ou choice().
Documentation de la fonction random.randint() : https://docs.python.org/fr/3/library/random.html#random.randint Documentation de la fonction random.choice() : https://docs.python.org/fr/3/library/random.html#random.choice
8.7.7 Séquences aléatoires d’ADN avec argument
Créez un script dna_random.py qui prend comme argument un nombre de bases, construit une séquence aléatoire d’ADN dont la longueur est le nombre de bases fourni en argument, puis afﬁche cette séquence.
Le script devra vériﬁer qu’un argument est bien fourni et renvoyer un message d’erreur si ce n’est pas le cas. Conseil : pour générer la séquence d’ADN, vous utiliserez, au choix, la fonction random.randint() ou random.choice() abordées dans l’exercice précédent.
8.7.8 Compteur de lignes
Améliorez le script compte_lignes.py dont le code a été donné précédemment de façon à ce qu’il renvoie un message d’erreur si le ﬁchier n’existe pas. Par exemple, si les ﬁchiers zoo1.txt et zoo2.txt sont bien dans le répertoire courant, mais pas zoo3.txt :
1 $ python compte_lignes.py zoo1.txt 2 zoo1.txt contient 4 lignes. 3 $ python compte_lignes.py zoo2.txt 4 zoo2.txt contient 3 lignes. 5 $ python compte_lignes.py zoo3.txt 6 ERREUR : zoo3.txt n existe pas.

8.7.9 Détermination du nombre pi par la méthode Monte Carlo (exercice +++)
Soit un cercle de rayon 1 (en trait plein sur la ﬁgure 8.1) inscrit dans un carré de côté 2 (en trait pointillé). Avec R = 1, l’aire du carré vaut (2R)2 soit 4 et l’aire du cercle vaut πR2 soit π. En choisissant N points aléatoires (à l’aide d’une distribution uniforme) à l’intérieur du carré, la probabilité que ces points se trouvent aussi dans le cercle est :
p = aire du cercle = π aire du carré 4
Soit n, le nombre de points effectivement dans le cercle, il vient alors
p= n = π, N4
d’où
n π =4× N. Déterminez une approximation de π par cette méthode. Pour cela, pour N itérations : — Choisissez aléatoirement les coordonnées x et y d’un point entre -1 et 1. Utilisez la fonction uniform() du module random. — Calculez la distance entre le centre du cercle et ce point. — Déterminez si cette distance est inférieure au rayon du cercle, c’est-à-dire si le point est dans le cercle ou pas.

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

57

Chapitre 8. Modules

8.7. Exercices

FIGURE 8.1 – Cercle de rayon 1 inscrit dans un carré de côté 2.
— Si le point est effectivement dans le cercle, incrémentez le compteur n. Finalement calculez le rapport entre n et N et proposez une estimation de π. Quelle valeur de π obtenez-vous pour pour 100 itérations ? 1000 itérations ? 10 000 itérations ? Comparez les valeurs obtenues à la valeur de π fournie par le module math. On rappelle que la distance d entre deux points A et B de coordonnées respectives (xA, yA) et (xB, yB) se calcule comme :
d = (xB − xA)2 + (yB − yA)2 Documentation de la fonction random.uniform() : https://docs.python.org/3/library/random.html#random.uniform

58

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

Chapitre 9
Fonctions
9.1 Principe et généralités
En programmation, les fonctions sont très utiles pour réaliser plusieurs fois la même opération au sein d’un programme. Elles rendent également le code plus lisible et plus clair en le fractionnant en blocs logiques.
Vous connaissez déjà certaines fonctions Python. Par exemple math.cos(angle) du module math renvoie le cosinus de la variable angle exprimé en radian. Vous connaissez aussi des fonctions internes à Python comme range() ou len(). Pour l’instant, une fonction est à vos yeux une sorte de « boîte noire » (voir ﬁgure 9.1) :
1. À laquelle vous passez aucune, une ou plusieurs variable(s) entre parenthèses. Ces variables sont appelées arguments. Il peut s’agir de n’importe quel type d’objet Python.
2. Qui effectue une action. 3. Et qui renvoie un objet Python ou rien du tout. Par exemple, si vous appelez la fonction len() de la manière suivante :
1 >>> len([0, 1, 2]) 23
voici ce qui se passe : 1. vous appelez len() en lui passant une liste en argument (ici [0, 1, 2]) ; 2. la fonction calcule la longueur de cette liste ; 3. elle vous renvoie un entier égal à cette longueur. Autre exemple, si vous appelez la méthode ma_liste.append() (n’oubliez pas, une méthode est une fonction qui agit sur l’objet auquel elle est attachée par un point) :
FIGURE 9.1 – Fonctionnement schématique d’une fonction.
59

Chapitre 9. Fonctions

9.2. Déﬁnition

1 >>> ma_liste.append(5)
1. Vous passez l’entier 5 en argument ;
2. la méthode append() ajoute l’entier 5 à l’objet ma_liste ;
3. et elle ne renvoie rien.
Aux yeux du programmeur au contraire, une fonction est une portion de code effectuant une suite d’instructions bien particulière. Mais avant de vous présenter la syntaxe et la manière de construire une fonction, revenons une dernière fois sur cette notion de « boîte noire » :
— Une fonction effectue une tâche. Pour cela, elle reçoit éventuellement des arguments et renvoie éventuellement quelque chose. L’algorithme utilisé au sein de la fonction n’intéresse pas directement l’utilisateur. Par exemple, il est inutile de savoir comment la fonction math.cos() calcule un cosinus. On a juste besoin de savoir qu’il faut lui passer en argument un angle en radian et qu’elle renvoie le cosinus de cet angle. Ce qui se passe à l’intérieur de la fonction ne regarde que le programmeur.
— Chaque fonction effectue en général une tâche unique et précise. Si cela se complique, il est plus judicieux d’écrire plusieurs fonctions (qui peuvent éventuellement s’appeler les unes les autres). Cette modularité améliore la qualité générale et la lisibilité du code. Vous verrez qu’en Python, les fonctions présentent une grande ﬂexibilité.
Pour ﬁnir sur les généralités, nous avons utilisé dans la Figure 9.1 le terme programme principal (main en anglais) pour désigner l’endroit depuis lequel on appelle une fonction (on verra plus tard que l’on peut en fait appeler une fonction de n’importe où). Le programme principal désigne le code qui est exécuté lorsqu’on lance le script Python, c’est-à-dire toute la suite d’instructions en dehors des fonctions. En général, dans un script Python, on écrit d’abord les fonctions puis le programme principal. Nous aurons l’occasion de revenir sur cette notion de programme principal plus tard dans ce chapitre ainsi que dans le chapitre 12 Plus sur les fonctions.

9.2 Déﬁnition

Pour déﬁnir une fonction, Python utilise le mot-clé def et si on veut que celle-ci renvoie quelque chose, il faut utiliser le mot-clé return. Par exemple :

1 >>> def carre(x):

2 ...

return x**2

3 ...

4 >>> print(carre(2))

54

Notez que la syntaxe de def utilise les deux-points comme les boucles for et while ainsi que les tests if, un bloc d’instructions est donc attendu. De même que pour les boucles et les tests, l’indentation de ce bloc d’instructions (qu’on appelle le corps de la fonction) est obligatoire.
Dans l’exemple précédent, nous avons passé un argument à la fonction carre() qui nous a renvoyé (ou retourné) une valeur que nous avons immédiatement afﬁchée à l’écran avec l’instruction print(). Que veut dire valeur renvoyée ? Et bien cela signiﬁe que cette dernière est récupérable dans une variable :
1 >>> res = carre(2) 2 >>> print(res) 34

Ici, le résultat renvoyé par la fonction est stocké dans la variable res. Notez qu’une fonction ne prend pas forcément un argument et ne renvoie pas forcément une valeur, par exemple :

1 >>> def hello():

2 ...

print (" bonjour ")

3 ...

4 >>> hello()

5 bonjour

Dans ce cas la fonction, hello() se contente d’afﬁcher la chaîne de caractères "bonjour" à l’écran. Elle ne prend aucun argument et ne renvoie rien. Par conséquent, cela n’a pas de sens de vouloir récupérer dans une variable le résultat renvoyé par une telle fonction. Si on essaie tout de même, Python affecte la valeur None qui signiﬁe rien en anglais :
1 >>> var = hello() 2 bonjour 3 >>> print(var) 4 None

Ceci n’est pas une faute car Python n’émet pas d’erreur, toutefois cela ne présente, la plupart du temps, guère d’intérêt.

60

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

9.3. Passage d’arguments

Chapitre 9. Fonctions

9.3 Passage d’arguments

Le nombre d’arguments que l’on peut passer à une fonction est variable. Nous avons vu ci-dessus des fonctions auxquelles on passait 0 ou 1 argument. Dans les chapitres précédents, vous avez rencontré des fonctions internes à Python qui prenaient au moins 2 arguments. Souvenez-vous par exemple de range(1, 10) ou encore range(1, 10, 2). Le nombre d’argument est donc laissé libre à l’initiative du programmeur qui développe une nouvelle fonction.
Une particularité des fonctions en Python est que vous n’êtes pas obligé de préciser le type des arguments que vous lui passez, dès lors que les opérations que vous effectuez avec ces arguments sont valides. Python est en effet connu comme étant un langage au « typage dynamique », c’est-à-dire qu’il reconnaît pour vous le type des variables au moment de l’exécution. Par exemple :

1 >>> def fois(x, y):

2 ...

return x*y

3 ...

4 >>> fois(2, 3)

56

6 >>> fois(3.1415, 5.23)

7 16.430045000000003

8 >>> fois( to , 2)

9 toto

L’opérateur * reconnaît plusieurs types (entiers, ﬂoats, chaînes de caractères). Notre fonction fois() est donc capable d’effectuer des tâches différentes ! Même si Python autorise cela, méﬁez-vous tout de même de cette grande ﬂexibilité qui pourrait conduire à des surprises dans vos futurs programmes. En général, il est plus judicieux que chaque argument ait un type précis (entiers, ﬂoats, chaînes de caractères, etc) et pas l’un ou l’autre.

9.4 Renvoi de résultats

Un énorme avantage en Python est que les fonctions sont capables de renvoyer plusieurs objets à la fois, comme dans cette fraction de code :

1 >>> def carre_cube(x):

2 ...

return x**2, x**3

3 ...

4 >>> carre_cube(2)

5 (4, 8)

En réalité Python ne renvoie qu’un seul objet, mais celui-ci peut être séquentiel, c’est-à-dire contenir lui même d’autres objets. Dans notre exemple Python renvoie un objet de type tuple, type que nous verrons dans le chapitre 13 Dictionnaires et tuples (mais grosso modo, il s’agit d’une sorte de liste avec des propriétés différentes). Notre fonction pourrait tout autant renvoyer une liste :

1 >>> def carre_cube2(x):

2 ...

return [x**2, x**3]

3 ...

4 >>> carre_cube2 (3)

5 [9, 27]

Renvoyer un tuple ou une liste de deux éléments (ou plus) est très pratique en conjonction avec l’affectation multiple, par exemple :
1 >>> z1 , z2 = carre_cube2 (3) 2 >>> z1 39 4 >>> z2 5 27

Cela permet de récupérer plusieurs valeurs renvoyées par une fonction et de les affecter à la volée à des variables différentes.

9.5 Arguments positionnels et arguments par mot-clé
Jusqu’à maintenant, nous avons systématiquement passé le nombre d’arguments que la fonction attendait. Que se passe-t-il si une fonction attend deux arguments et que nous ne lui en passons qu’un seul ?

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

61

Chapitre 9. Fonctions

9.5. Arguments positionnels et arguments par mot-clé

1 >>> def fois(x, y):

2 ...

return x*y

3 ...

4 >>> fois(2, 3)

56

6 >>> fois(2)

7 Traceback (most recent call last):

8 File "<stdin >", line 1, in <module >

9 TypeError: fois() missing 1 required positional argument: y

On constate que passer un seul argument à une fonction qui en attend deux conduit à une erreur.

Déﬁnition Lorsqu’on déﬁnit une fonction def fct(x, y): les arguments x et y sont appelés arguments positionnels (en anglais
positional arguments). Il est strictement obligatoire de les préciser lors de l’appel de la fonction. De plus, il est nécessaire de respecter le même ordre lors de l’appel que dans la déﬁnition de la fonction. Dans l’exemple ci-dessus, 2 correspondra à x et 3 correspondra à y. Finalement, tout dépendra de leur position, d’où leur qualiﬁcation de positionnel.

Mais il est aussi possible de passer un ou plusieurs argument(s) de manière facultative et de leur attribuer une valeur par défaut :

1 >>> def fct(x=1):

2 ...

return x

3 ...

4 >>> fct()

51

6 >>> fct(10)

7 10

Déﬁnition Un argument déﬁni avec une syntaxe def fct(arg=val): est appelé argument par mot-clé (en anglais keyword argu-
ment). Le passage d’un tel argument lors de l’appel de la fonction est facultatif. Ce type d’argument ne doit pas être confondu avec les arguments positionnels présentés ci-dessus, dont la syntaxe est def fct(arg):.

Il est bien sûr possible de passer plusieurs arguments par mot-clé :

1 >>> def fct(x=0, y=0, z=0):

2 ...

return x, y, z

3 ...

4 >>> fct()

5 (0, 0, 0)

6 >>> fct(10)

7 (10, 0, 0)

8 >>> fct(10, 8)

9 (10, 8, 0)

10 >>> fct (10 , 8 , 3)

11 (10 , 8 , 3)

On observe que pour l’instant, les arguments par mot-clé sont pris dans l’ordre dans lesquels on les passe lors de l’appel. Comment pourrions-nous faire si on souhaitait préciser l’argument par mot-clé z et garder les valeurs de x et y par défaut ? Simplement en précisant le nom de l’argument lors de l’appel :
1 >>> fct(z=10) 2 (0, 0, 10)

Python permet même de rentrer les arguments par mot-clé dans un ordre arbitraire :
1 >>> fct(z=10, x=3, y=80) 2 (3, 80, 10) 3 >>> fct(z=10, y=80) 4 (0, 80, 10)

Que se passe-t-il lorsque nous avons un mélange d’arguments positionnels et par mot-clé ? Et bien les arguments positionnels doivent toujours être placés avant les arguments par mot-clé :

1 >>> def fct(a, b, x=0, y=0, z=0):

2 ...

return a, b, x, y, z

3 ...

4 >>> fct(1, 1)

62

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

9.6. Variables locales et variables globales

Chapitre 9. Fonctions

5 (1, 1, 0, 0, 0) 6 >>> fct(1, 1, z=5) 7 (1, 1, 0, 0, 5) 8 >>> fct(1, 1, z=5, y=32) 9 (1, 1, 0, 32, 5)
On peut toujours passer les arguments par mot-clé dans un ordre arbitraire à partir du moment où on précise leur nom. Par contre, si les deux arguments positionnels a et b ne sont pas passés à la fonction, Python renvoie une erreur.
1 >>> fct(z=0) 2 Traceback (most recent call last): 3 File "<stdin >", line 1, in <module > 4 TypeError: fct() missing 2 required positional arguments: a and b

Conseil
Préciser le nom des arguments par mot-clé lors de l’appel d’une fonction est une pratique que nous vous recommandons. Cela les distingue clairement des arguments positionnels.

L’utilisation d’arguments par mot-clé est habituelle en Python. Elle permet de modiﬁer le comportement par défaut de nombreuses fonctions. Par exemple, si on souhaite que la fonction print() n’afﬁche pas un retour à la ligne, on peut utiliser l’argument end :
1 >>> print("Message ", end="") 2 Message >>>
Nous verrons, dans le chapitre 20 Fenêtres graphiques et Tkinter, que l’utilisation d’arguments par mot-clé est systématique lorsqu’on crée un objet graphique (une fenêtre, un bouton, etc.).

9.6 Variables locales et variables globales

Lorsqu’on manipule des fonctions, il est essentiel de bien comprendre comment se comportent les variables. Une variable est dite locale lorsqu’elle est créée dans une fonction. Elle n’existera et ne sera visible que lors de l’exécution de ladite fonction.
Une variable est dite globale lorsqu’elle est créée dans le programme principal. Elle sera visible partout dans le programme.
Ceci ne vous paraît pas clair ? Nous allons prendre un exemple simple qui vous aidera à mieux saisir ces concepts. Observez le code suivant :

1 # définition d une fonction carre()

2 def carre(x):

3

y = x**2

4

return y

5
6 # programme principal 7z = 5

8 resultat = carre(z)

9 print(resultat)

Pour la suite des explications, nous allons utiliser l’excellent site Python Tutor 1 qui permet de visualiser l’état des variables au fur et à mesure de l’exécution d’un code Python. Avant de poursuivre, nous vous conseillons de prendre 5 minutes pour tester ce site.
Regardons maintenant ce qui se passe dans le code ci-dessus, étape par étape :
— Étape 1 : Python est prêt à lire la première ligne de code.

1. http://www.pythontutor.com

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

63

Chapitre 9. Fonctions

9.6. Variables locales et variables globales

— Étape 2 : Python met en mémoire la fonction carre(). Notez qu’il ne l’exécute pas ! La fonction est mise dans un espace de la mémoire nommé Global frame, il s’agit de l’espace du programme principal. Dans cet espace, seront stockées toutes les variables globales créées dans le programme. Python est maintenant prêt à exécuter le programme principal.
— Étape 3 : Python lit et met en mémoire la variable z. Celle-ci étant créée dans le programme principal, il s’agira d’une variable globale. Ainsi, elle sera également stockée dans le Global frame.
— Étape 4 : La fonction carre() est appelée et on lui passe en argument l’entier z. La fonction s’exécute et un nouveau cadre est créé dans lequel Python Tutor va indiquer toutes les variables locales à la fonction. Notez bien que la variable passée en argument, qui s’appelle x dans la fonction, est créée en tant que variable locale. On remarquera aussi que les variables globales situées dans le Global frame sont toujours là.

64

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

9.6. Variables locales et variables globales — Étape 5 : Python est maintenant prêt à exécuter chaque ligne de code de la fonction.

Chapitre 9. Fonctions

— Étape 6 : La variable y est créée dans la fonction. Celle-ci est donc stockée en tant que variable locale à la fonction.

— Étape 7 : Python s’apprête à renvoyer la variable locale y au programme principal. Python Tutor nous indique le contenu de la valeur renvoyée.

— Étape 8 : Python quitte la fonction et la valeur renvoyée par celle-ci est affectée à la variable globale resultat. Notez bien que lorsque Python quitte la fonction, l’espace des variables alloué à la fonction est détruit. Ainsi, toutes les variables créées dans la fonction n’existent plus. On comprend pourquoi elles portent le nom de locales puisqu’elles n’existent que lorsque la fonction est exécutée.

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

65

Chapitre 9. Fonctions

9.7. Exercices

— Étape 9 : Python afﬁche le contenu de la variable resultat et l’exécution est terminée.

Nous espérons que cet exemple guidé facilitera la compréhension des concepts de variables locales et globales. Cela viendra aussi avec la pratique. Nous irons un peu plus loin sur les fonctions dans le chapitre 12. D’ici là, essayez de vous entraîner au maximum avec les fonctions. C’est un concept ardu, mais il est impératif de le maîtriser.
Enﬁn, comme vous avez pu le constater, Python Tutor nous a grandement aidé à comprendre ce qui se passait. N’hésitez pas à l’utiliser sur des exemples ponctuels, ce site vous aidera à visualiser ce qui se passe lorsqu’un code ne fait pas ce que vous attendez.

9.7 Exercices
Conseil : pour le premier exercice, utilisez Python Tutor. Pour les exercices suivants, créez des scripts puis exécutez-les dans un shell.

9.7.1 Carré et factorielle

Reprenez l’exemple précédent à l’aide du site Python Tutor 2 :

1 # définition d une fonction carre()

2 def carre(x):

3

y = x**2

4

return y

5
6 # programme principal 7z = 5

8 resultat = carre(z)

9 print(resultat)

Analysez ensuite le code suivant et tentez de prédire sa sortie :

1 def calc_factorielle(n):

2

fact = 1

3

for i in range(2,n+1):

4

fact = fact * i

5

return fact

6

7
8 # programme principal 9 nb = 4 10 f a c t o r i e l l e _ n b = c a l c _ f a c t o r i e l l e ( nb ) 11 print ("{}! = {}". format ( nb , f a c t o r i e l l e _ n b ))

2. http://www.pythontutor.com

66

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

9.7. Exercices

Chapitre 9. Fonctions

12 nb2 = 10 13 print ("{}! = {}". format ( nb2 , c a l c _ f a c t o r i e l l e ( nb2 )))
Testez ensuite cette portion de code avec Python Tutor en cherchant à bien comprendre chaque étape. Avez-vous réussi à prédire la sortie correctement ?

9.7.2 Puissance

Créez une fonction calc_puissance(x,y) qui renvoie xy en utilisant l’opérateur **. Pour rappel :
1 >>> 2**2 24 3 >>> 2**3 48 5 >>> 2**4 6 16

Dans le programme principal, calculez et afﬁchez à l’écran 2i avec i variant de 0 à 20 inclus. On veut que le résultat soit présenté avec le formatage suivant :

1 2^ 0 =

1

2 2^ 1 =

2

3 2^ 2 =

4

4 [...]

5 2^20 = 1048576

9.7.3 Pyramide
Reprenez l’exercice du chapitre 5 Boucles et comparaisons qui dessine une pyramide. Dans un script pyra.py, créez une fonction gen_pyramide() à laquelle vous passez un nombre entier N et qui renvoie une pyramide de N lignes sous forme de chaîne de caractères. Le programme principal demandera à l’utilisateur le nombre de lignes souhaitées (utilisez pour cela la fonction input()) et afﬁchera la pyramide à l’écran.
9.7.4 Nombres premiers
Reprenez l’exercice du chapitre 6 Tests sur les nombres premiers. Créez une fonction est_premier() qui prend comme argument un nombre entier positif n (supérieur à 2) et qui renvoie le booléen True si n est premier et False si n n’est pas premier. Déterminez tous les nombres premiers de 2 à 100. On souhaite avoir une sortie similaire à celle-ci :
1 2 est premier 2 3 est premier 3 4 n est pas premier 4 [...] 5 100 n est pas premier

9.7.5 Séquence complémentaire
Créez une fonction seq_comp() qui prend comme argument une liste de bases et qui renvoie la séquence complémentaire d’une séquence d’ADN sous forme de liste.
Dans le programme principal, à partir de la séquence d’ADN seq = ["A", "T", "C", "G", "A", "T", "C", "G", "A", "T", "C"] afﬁchez seq et sa séquence complémentaire (en utilisant votre fonction seq_comp()).
Rappel : la séquence complémentaire s’obtient en remplaçant A par T, T par A, C par G et G par C.
9.7.6 Distance 3D
Créez une fonction calc_distance_3D() qui calcule la distance euclidienn√e en trois dimensions entre deux atomes. Testez votre fonction sur les 2 points A(0,0,0) et B(1,1,1). Trouvez-vous bien 3 ?
On rappelle que la distance euclidienne d entre deux points A et B de coordonnées cartésiennes respectives (xA, yA, zA) et (xB, yB, zB) se calcule comme suit :
d = (xB − xA)2 + (yB − yA)2 + (zB − zA)2

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

67

Chapitre 9. Fonctions

9.7. Exercices

9.7.7 Distribution et statistiques
Créez une fonction gen_distrib() qui prend comme argument trois entiers : debut, ﬁn et n. La fonction renverra une liste de n ﬂoats aléatoires entre debut et ﬁn. Pour générer un nombre aléatoire dans un intervalle donné, utilisez la fonction uniform() du module random dont voici quelques exemple d’utilisation :
1 >>> import random 2 >>> random.uniform(1, 10) 3 8.199672607202174 4 >>> random.uniform(1, 10) 5 2.607528561528022 6 >>> random.uniform(1, 10) 7 9.000404025130946
Avec la fonction random.uniform(), les bornes passées en argument sont incluses, c’est-à-dire qu’ici, le nombre aléatoire renvoyé est dans l’intervalle [0, 10].
Créez une autre fonction calc_stat() qui prend en argument une liste de ﬂoats et qui renvoie une liste de trois éléments contenant respectivement le minimum, le maximum et la moyenne de la liste.
Dans le programme principal, générez 20 listes aléatoires de 100 ﬂoats compris entre 0 et 100 et afﬁchez le minimum (min()), le maximum (max()) et la moyenne pour chacune d’entre elles. La moyenne pourra être calculée avec les fonctions sum() et len().
Pour chacune des 20 listes, afﬁchez les statistiques (min, max, et moyenne) avec deux chiffres après la virgule :
1 Liste 1 : min = 0.17 ; max = 99.72 ; moyenne = 57.38 2 Liste 2 : min = 1.25 ; max = 99.99 ; moyenne = 47.41 3 [...] 4 Liste 19 : min = 1.05 ; max = 99.36 ; moyenne = 49.43 5 Liste 20 : min = 1.33 ; max = 97.63 ; moyenne = 46.53
Les écarts sur les statistiques entre les différentes listes sont-ils importants ? Relancez votre script avec des listes de 1000 éléments, puis 10 000 éléments. Les écarts changent-ils quand le nombre d’éléments par liste augmente ?

9.7.8 Distance à l’origine (exercice +++)

En reprenant votre fonction de calcul de distance euclidienne en 3D calc_distance_3D(), faites-en une version pour deux dimensions que vous appellerez calc_distance_2D().
Créez une autre fonction calc_dist2ori() à laquelle vous passez en argument deux listes de ﬂoats list_x et list_y représentant les coordonnées d’une fonction mathématique (par exemple x et sin(x)). Cette fonction renverra une liste de ﬂoats représentant la distance entre chaque point de la fonction et l’origine (de coordonnées (0, 0)).
La ﬁgure 9.2 montre un exemple sur quelques points de la fonction sin(x) (courbe en trait épais). Chaque trait pointillé représente la distance que l’on cherche à calculer entre les points de la courbe et l’origine du repère de coordonnées (0, 0).
Votre programme générera un ﬁchier sin2ori.dat qui contiendra deux colonnes : la première représente les x, la seconde la distance entre chaque point de la fonction sin(x) à l’origine.
Enﬁn, pour visualiser votre résultat, ajoutez le code suivant tout à la ﬁn de votre script :

1 # création d une image pour la visualisation du résultat 2 import matplotlib.pyplot as plt

3

4 x = []

5 y = []

6 with open("sin2ori.dat", "r") as f_in:

7

for line in f_in:

8

coords = line.split()

9

x. append ( float ( coords [0]))

10

y. append ( float ( coords [1]))

11 plt . figure ( figsize =(8 ,8))

12 plt . plot (x , y )

13 plt . xlabel (" x ")

14 plt . ylabel (" Distance de sin ( x ) à l origine ")

15 plt . savefig (" sin2ori . png ")

Ouvrez l’image sin2ori.png.

Remarque Le module matplotlib sera expliqué en détail dans le chapitre 17 Quelques modules d’intérêt en bioinformatique.

68

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

9.7. Exercices

Chapitre 9. Fonctions

FIGURE 9.2 – Illustration de la distance à l’origine.

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

69

Chapitre 10
Plus sur les chaînes de caractères
10.1 Préambule
Nous avons déjà abordé les chaînes de caractères dans les chapitres 2 Variables et 3 Afﬁchage. Ici nous allons un peu plus loin, notamment avec les méthodes associées aux chaînes de caractères 1.
10.2 Chaînes de caractères et listes
Les chaînes de caractères peuvent être considérées comme des listes (de caractères) un peu particulières :
1 >>> animaux = "girafe tigre" 2 >>> animaux 3 girafe tigre 4 >>> len(animaux) 5 12 6 >>> animaux[3] 7a
Nous pouvons donc utiliser certaines propriétés des listes comme les tranches :
1 >>> animaux = "girafe tigre" 2 >>> animaux[0:4] 3 gira 4 >>> animaux[9:] 5 gre 6 >>> animaux[:-2] 7 girafe tig
Mais a contrario des listes, les chaînes de caractères présentent toutefois une différence notable, ce sont des listes non modiﬁables. Une fois une chaîne de caractères déﬁnie, vous ne pouvez plus modiﬁer un de ses éléments. Le cas échéant, Python renvoie un message d’erreur :
1 >>> animaux = "girafe tigre" 2 >>> animaux[4] 3f 4 >>> animaux[4] = "F" 5 Traceback (most recent call last): 6 File "<stdin >", line 1, in <module > 7 TypeError: str object does not support item assignment
Par conséquent, si vous voulez modiﬁer une chaîne de caractères, vous devez en construire une nouvelle. Pour cela, n’oubliez pas que les opérateurs de concaténation (+) et de duplication (*) (introduits dans le chapitre 2 Variables) peuvent vous aider. Vous pouvez également générer une liste, qui elle est modiﬁable, puis revenir à une chaîne de caractères.
10.3 Caractères spéciaux
Il existe certains caractères spéciaux comme \n que nous avons déjà vu (pour le retour à la ligne). Le caractère \t produit une tabulation. Si vous voulez écrire des guillemets simples ou doubles et que ceux-ci ne soient pas confondus avec les
1. https://docs.python.org/fr/3.7/library/string.html
70

10.4. Méthodes associées aux chaînes de caractères

Chapitre 10. Plus sur les chaînes de caractères

guillemets de déclaration de la chaîne de caractères, vous pouvez utiliser \ ou \" ou utiliser respectivement des guillemets doubles ou simples pour déclarer votre chaîne de caractères.

1 >>> print("Un retour à la ligne\npuis une tabulation\t puis un guillemet \"")

2 Un retour à la ligne

3 puis une tabulation

puis un guillemet"

4 >>> print( J\ affiche un guillemet simple )

5 J affiche un guillemet simple

6 >>> print("Un brin d ADN")

7 Un brin d ADN

8 >>> print( Python est un "super" langage de programmation )

9 Python est un "super" langage de programmation

Quand on souhaite écrire un texte sur plusieurs lignes, il est très commode d’utiliser les guillemets triples qui conservent
le formatage (notamment les retours à la ligne) :
1 >>> x = """souris 2 ... chat 3 ... abeille""" 4 >>> x 5 souris\nchat\nabeille 6 >>> print(x) 7 souris 8 chat 9 abeille

10.4 Méthodes associées aux chaînes de caractères

Voici quelques méthodes 2 spéciﬁques aux objets de type str :
1 >>> x = "girafe" 2 >>> x.upper() 3 GIRAFE 4 >>> x 5 girafe 6 >>> TIGRE .lower() 7 tigre

Les méthodes .lower() et .upper() renvoient un texte en minuscule et en majuscule respectivement. On remarque que l’utilisation de ces fonctions n’altère pas la chaîne de caractères de départ mais renvoie une chaîne de caractères transformée.
Pour mettre en majuscule la première lettre seulement, vous pouvez faire :
1 >>> x[0]. upper() + x[1:] 2 Girafe

ou encore plus simple avec la méthode adéquate :
1 >>> x.capitalize() 2 Girafe

Il existe une méthode associée aux chaînes de caractères qui est particulièrement pratique, la méthode .split() :

1 >>> animaux = "girafe tigre singe souris"

2 >>> animaux.split()

3 [ girafe , tigre , singe , souris ]

4 >>> for animal in animaux.split():

5 ...

print(animal)

6 ...

7 girafe

8 tigre

9 singe

10 s o u r i s

La méthode .split() découpe une chaîne de caractères en plusieurs éléments appelés champs, en utilisant comme séparateur n’importe quelle combinaison « d’espace(s) blanc(s) ».

Déﬁnition Un espace blanc 3 (whitespace en anglais) correspond aux caractères qui sont invisibles à l’œil, mais qui occupent de
l’espace dans un texte. Les espaces blancs les plus classiques sont l’espace, la tabulation et le retour à la ligne.

Il est possible de modiﬁer le séparateur de champs, par exemple :
2. https://docs.python.org/fr/3/library/string.html 3. https://en.wikipedia.org/wiki/Whitespace_character

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

71

Chapitre 10. Plus sur les chaînes de caractères

10.4. Méthodes associées aux chaînes de caractères

1 >>> animaux = "girafe:tigre:singe::souris" 2 >>> animaux.split(":") 3 [ girafe , tigre , singe , , souris ]

Attention, dans cet exemple, le séparateur est un seul caractères : (et non pas une combinaison de un ou plusieurs :) menant ainsi à une chaîne vide entre singe et souris.
Il est également intéressant d’indiquer à .split() le nombre de fois qu’on souhaite découper la chaîne de caractères avec l’argument maxsplit() :
1 >>> animaux = "girafe tigre singe souris" 2 >>> animaux.split(maxsplit=1) 3 [ girafe , tigre singe souris ] 4 >>> animaux.split(maxsplit=2) 5 [ girafe , tigre , singe souris ]

La méthode .find(), quant à elle, recherche une chaîne de caractères passée en argument :
1 >>> animal = "girafe" 2 >>> animal.find("i") 31 4 >>> animal.find("afe") 53 6 >>> animal.find("z") 7 -1 8 >>> animal.find("tig") 9 -1

Si l’élément recherché est trouvé, alors l’indice du début de l’élément dans la chaîne de caractères est renvoyé. Si l’élément n’est pas trouvé, alors la valeur -1 est renvoyée.
Si l’élément recherché est trouvé plusieurs fois, seul l’indice de la première occurrence est renvoyé :
1 >>> animaux = "girafe tigre" 2 >>> animaux.find("i") 31

On trouve aussi la méthode .replace() qui substitue une chaîne de caractères par une autre :
1 >>> animaux = "girafe tigre" 2 >>> animaux.replace("tigre", "singe") 3 girafe singe 4 >>> animaux.replace("i", "o") 5 gorafe togre

La méthode .count() compte le nombre d’occurrences d’une chaîne de caractères passée en argument :
1 >>> animaux = "girafe tigre" 2 >>> animaux.count("i") 32 4 >>> animaux.count("z") 50 6 >>> animaux.count("tigre") 71

La méthode .startswith() vériﬁe si une chaîne de caractères commence par une autre chaîne de caractères :
1 >>> chaine = "Bonjour monsieur le capitaine !" 2 >>> chaine.startswith("Bonjour") 3 True 4 >>> chaine.startswith("Au revoir") 5 False

Cette méthode est particulièrement utile lorsqu’on lit un ﬁchier et que l’on veut récupérer certaines lignes commençant

par un mot-clé. Par exemple dans un ﬁchier PDB, les lignes contenant les coordonnées des atomes commencent par le mot-clé ATOM.
Enﬁn, la méthode .strip() permet de « nettoyer les bords » d’une chaîne de caractères :

1 >>> chaine = " Comment enlever les espaces au début et à la fin ?

"

2 >>> chaine.strip()

3 Comment enlever les espaces au début et à la fin ?

La méthode .strip() enlève les espaces situés sur les bords de la chaîne de caractère mais pas ceux situés entre des caractères visibles. En réalité, cette méthode enlève n’importe quel combinaison « d’espace(s) blanc(s) » sur les bords, par exemple :
1 >>> chaine = " \tfonctionne avec les tabulations et les retours à la ligne\n" 2 >>> chaine.strip() 3 fonctionne avec les tabulations et les retours à la ligne

La méthode .strip() est très pratique quand on lit un ﬁchier et qu’on veut se débarrasser des retours à la ligne.

72

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

10.5. Extraction de valeurs numériques d’une chaîne de caractères

Chapitre 10. Plus sur les chaînes de caractères

10.5 Extraction de valeurs numériques d’une chaîne de caractères
Une tâche courante en Python est de lire une chaîne de caractères (provenant par exemple d’un ﬁchier), d’extraire des valeurs de cette chaîne de caractères puis ensuite de les manipuler.
On considère par exemple la chaîne de caractères val :
1 >>> val = "3.4 17.2 atom"
On souhaite extraire les valeurs 3.4 et 17.2 pour ensuite les additionner. Dans un premier temps, on découpe la chaîne de caractères avec l’instruction .split() :
1 >>> val2 = val.split() 2 >>> val2 3 [ 3.4 , 17.2 , atom ]
On obtient alors une liste de chaînes de caractères. On transforme ensuite les deux premiers éléments de cette liste en ﬂoats (avec la fonction float()) pour pouvoir les additionner :
1 >>> float(val2[0]) + float(val2[1]) 2 20.599999999999998

10.6 Conversion d’une liste de chaînes de caractères en une chaîne de caractères
On a vu dans le chapitre 2 Variables la conversion d’un type simple (entier, ﬂoat et chaîne de caractères) en un autre avec les fonctions int(), float() et str(). La conversion d’une liste de chaînes de caractères en une chaîne de caractères est un peu particulière puisqu’elle fait appelle à la méthode .join().
1 >>> seq = ["A", "T", "G", "A", "T"] 2 >>> seq 3[A, T, G, A, T] 4 >>> "-".join(seq) 5 A-T-G-A-T 6 >>> " ".join(seq) 7 ATGAT 8 >>> "".join(seq) 9 ATGAT
Les éléments de la liste initiale sont concaténés les uns à la suite des autres et intercalés par un séparateur qui peut être n’importe quelle chaîne de caractères. Ici, on a utilisé un tiret, un espace et rien.
Attention, la méthode .join() ne s’applique qu’à une liste de chaînes de caractères.
1 >>> maliste = ["A", 5, "G"] 2 >>> " ".join(maliste) 3 Traceback (most recent call last): 4 File "<stdin >", line 1, in <module > 5 TypeError: sequence item 1: expected string , int found
On espère qu’après ce petit tour d’horizon vous serez convaincu de la richesse des méthodes associées aux chaînes de caractères. Pour avoir une liste exhaustive de l’ensemble des méthodes associées à une variable particulière, vous pouvez utiliser la fonction dir().
1 >>> animaux = "girafe tigre" 2 >>> dir(animaux) 3 [ __add__ , __class__ , __contains__ , __delattr__ , __dir__ , 4 __doc__ , __eq__ , __format__ , __ge__ , __getattribute__ , _ 5 _getitem__ , __getnewargs__ , __gt__ , __hash__ , __init__ , _ 6 _init_subclass__ , __iter__ , __le__ , __len__ , __lt__ , __mo 7 d__ , __mul__ , __ne__ , __new__ , __reduce__ , __reduce_ex__ 8 , __repr__ , __rmod__ , __rmul__ , __setattr__ , __sizeof__ , 9 __str__ , __subclasshook__ , capitalize , casefold , center , 10 count , encode , endswith , expandtabs , find , format , for 11 mat_map , index , isalnum , isalpha , isdecimal , isdigit , i 12 sidentifier , islower , isnumeric , isprintable , isspace , is 13 title , isupper , join , ljust , lower , lstrip , maketrans , 14 partition , replace , rfind , rindex , rjust , rpartition , 15 rsplit , rstrip , split , splitlines , startswith , strip , 16 swapcase , title , translate , upper , zfill ]
Pour l’instant, vous pouvez ignorer les méthodes qui commencent et qui se terminent par deux tirets bas (underscores) __. Vous pouvez également accéder à l’aide et à la documentation d’une méthode particulière avec help(), par exemple pour la méthode .split() :

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

73

Chapitre 10. Plus sur les chaînes de caractères

10.7. Exercices

1 >>> help(animaux.split) 2 Help on built -in function split:

3

4 split(...)

5

S.split([sep [,maxsplit ]]) -> list of strings

6

7

Return a list of the words in the string S, using sep as the

8

delimiter string. If maxsplit is given , at most maxsplit

9

splits are done. If sep is not specified or is None , any

10

whitespace string is a separator.

11 ( END )

Attention à ne pas mettre les parenthèses à la suite du nom de la méthode. L’instruction correcte est help(animaux.split) et pas help(animaux.split()).

10.7 Exercices
Conseil : pour ces exercices, créez des scripts puis exécutez-les dans un shell.
10.7.1 Parcours d’une liste de chaînes de caractères
Soit la liste [ girafe , tigre , singe , souris ]. Avec une boucle, afﬁchez chaque élément ainsi que sa taille (nombre de caractères).
10.7.2 Lecture d’une séquence à partir d’un ﬁchier FASTA
Le ﬁchier UBI4_SCerevisiae.fasta 4 contient une séquence d’ADN au format FASTA. Créez une fonction lit_fasta() qui prend comme argument le nom d’un ﬁchier FASTA sous la forme d’une chaîne de caractères, lit la séquence dans le ﬁchier FASTA et la renvoie sous la forme d’une chaîne de caractères. Utilisez ensuite cette fonction pour récupérer la séquence d’ADN dans la variable sequence puis pour afﬁcher les informations suivantes : — le nom du ﬁchier FASTA, — la longueur de la séquence (c’est-à-dire le nombre de bases qu’elle contient), — un message vériﬁant que le nombre de base est (ou non) un multiple de 3, — le nombre de codons (on rappelle qu’un codon est un bloc de 3 bases), — les 10 premières bases, — les 10 dernières bases. La sortie produite par le script devrait ressembler à ça :
1 UBI4_SCerevisiae.fasta 2 La séquence contient WWW bases 3 La longueur de la séquence est un multiple de 3 nucléotides 4 La séquence possède XXX codons 5 10 premières bases : YYYYYYYYYY 6 10 dernières bases : ZZZZZZZZZZ
où WWW et XXX sont des entiers et YYYYYYYYYY et ZZZZZZZZZZ sont des bases. Conseil : vous trouverez des explications sur le format FASTA et des exemples de code dans l’annexe A Quelques formats de données rencontrés en biologie.
10.7.3 Fréquence des bases dans une séquence d’ADN
Soit la séquence d’ADN ATATACGGATCGGCTGTTGCCTGCGTAGTAGCGT. On souhaite calculer la fréquence de chaque base A, T, C et G dans cette séquence et afﬁcher le résultat à l’écran.
Créez pour cela une fonction calc_composition() à laquelle vous passez en argument votre séquence d’ADN sous forme d’une chaîne de caractères et qui renvoie une liste de quatre ﬂoats indiquant respectivement la fréquence en bases A, T, G et C.
4. https://python.sdv.univ-paris-diderot.fr/data-files/UBI4_SCerevisiae.fasta

74

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

10.7. Exercices

Chapitre 10. Plus sur les chaînes de caractères

10.7.4 Conversion des acides aminés du code à trois lettres au code à une lettre
Créez une fonction convert_3_lettres_1_lettre() qui prend en argument une chaîne de caractères avec des acides aminés en code à trois lettres et renvoie une chaîne de caractères avec les acides aminés en code à 1 lettre.
Utilisez cette fonction pour convertir la séquence protéique ALA GLY GLU ARG TRP TYR SER GLY ALA TRP.
Rappel de la nomenclature des acides aminés :

Acide aminé
Alanine Arginine Asparagine Aspartate Cystéine Glutamate Glutamine Glycine Histidine Isoleucine Leucine Lysine Méthionine Phénylalanine Proline Sérine Thréonine Tryptophane Tyrosine Valine

Code 3-lettres
Ala Arg Asn Asp Cys Glu Gln Gly His Ile Leu Lys Met Phe Pro Ser Thr Trp Tyr Val

Code 1-lettre
A R N D C E Q G H I L K M F P S T W Y V

10.7.5 Distance de Hamming
La distance de Hamming 5 mesure la différence entre deux séquences de même taille en comptant le nombre de positions qui, pour chaque séquence, ne correspondent pas au même acide aminé.
Créez la fonction dist_hamming() qui prend en argument deux chaînes de caractères et qui renvoie la distance de Hamming (sous la forme d’un entier) entre ces deux chaînes de caractères.
Calculez la distance de Hamming entre les séquences AGWPSGGASAGLAIL et IGWPSAGASAGLWIL puis entre les séquences ATTCATACGTTACGATT et ATACTTACGTAACCATT.
10.7.6 Palindrome
Un palindrome est un mot ou une phrase dont l’ordre des lettres reste le même si on le lit de gauche à droite ou de droite à gauche. Par exemple, « ressasser » et « Engage le jeu que je le gagne » sont des palindromes.
Créez la fonction test_palindrome() qui prend en argument une chaîne de caractères et qui afﬁche xxx est un palindrome si la chaîne de caractères xxx passée en argument est un palindrome ou xxx n est pas un palindrome sinon. Pensez à vous débarrasser au préalable des majuscules et des espaces.
Testez ensuite si les expressions suivantes sont des palindromes : — Radar — Never odd or even — Karine alla en Iran — Un roc si biscornu
5. http://en.wikipedia.org/wiki/Hamming_distance

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

75

Chapitre 10. Plus sur les chaînes de caractères

10.7. Exercices

10.7.7 Mot composable
Un mot est composable à partir d’une séquence de lettres si la séquence contient toutes les lettres du mot. Chaque lettre de la séquence ne peut être utilisée qu’une seule fois. Par exemple, coucou est composable à partir de « uocuoceokzefhu ».
Écrivez la fonction test_composable() qui prend en argument un mot (sous la forme d’une chaîne de caractères) et une séquence de lettres (aussi comme une chaîne de caractères) et qui afﬁche Le mot xxx est composable à partir de yyy si le mot (xxx) est composable à partir de la séquence de lettres (yyy) ou Le mot xxx n est pas composable à partir de yyy sinon.
Testez cette fonction avec les mots et les séquences suivantes :

Mot
python python coucou fonction

Séquence
aophrtkny aeiouyhpq uocuoceokzezh nhwfnitvkloco

10.7.8 Alphabet et pangramme
Les codes ASCII des lettres minuscules de l’alphabet vont de 97 (lettre « a ») à 122 (lettre « z »). La fonction chr() prend en argument un code ASCII sous la forme d’un entier et renvoie le caractère correspondant (sous la forme d’une chaîne de caractères). Ainsi chr(97) renvoie a , chr(98) renvoie b et ainsi de suite.
Créez la fonction get_alphabet() qui utilise une boucle et la fonction chr() et qui renvoie une chaîne de caractères contenant toutes les lettres de l’alphabet.
Un pangramme 6 est une phrase comportant au moins une fois chaque lettre de l’alphabet. Par exemple, « Portez ce vieux whisky au juge blond qui fume » est un pangramme.
Créez la fonction pangramme() qui utilise la fonction get_alphabet() précédente, qui prend en argument une chaîne de caractères (xxx) et qui renvoie xxx est un pangramme si cette chaîne de caractères est un pangramme ou xxx n est pas un pangramme sinon. Pensez à vous débarrasser des majuscules le cas échéant.
Testez ensuite si les expressions suivantes sont des pangrammes : — Portez ce vieux whisky au juge blond qui fume — Monsieur Jack vous dactylographiez bien mieux que votre ami Wolf — Buvez de ce whisky que le patron juge fameux

10.7.9 Lecture d’une séquence à partir d’un ﬁchier GenBank (exercice +++)

On cherche à récupérer la séquence d’ADN du chromosome I de la levure Saccharomyces cerevisiae contenu dans le ﬁchier au format GenBank NC_001133.gbk 7.
Le format GenBank est présenté en détails dans l’annexe A Quelques formats de données rencontrés en biologie. Pour cet exercice, vous devez savoir que la séquence démarre après la ligne commençant par le mot ORIGIN et se termine avant la ligne commençant par les caractères // :

1 ORIGIN

2

1 ccacaccaca cccacacacc cacacaccac accacacacc acaccacacc cacacacaca

3

61 catcctaaca ctaccctaac acagccctaa tctaaccctg gccaacctgt ctctcaactt

4 [...]

5

230101 tgttagtgtt agtattaggg tgtggtgtgt gggtgtggtg tgggtgtggg tgtgggtgtg

6

230161 ggtgtgggtg tgggtgtggt gtggtgtgtg ggtgtggtgt gggtgtggtg tgtgtggg

7 //

Pour extraire la séquence d’ADN, nous vous proposons d’utiliser un algorithme de « drapeau », c’est-à-dire une variable qui sera à True lorsqu’on lira les lignes contenant la séquence et à False pour les autres lignes.
Créez une fonction lit_genbank() qui prend comme argument le nom d’un ﬁchier GenBank sous la forme d’une chaîne de caractères, lit la séquence dans le ﬁchier GenBank et la renvoie sous la forme d’une chaîne de caractères.
Utilisez ensuite cette fonction pour récupérer la séquence d’ADN dans la variable sequence dans le programme principal. Le script afﬁchera :

6. http://fr.wikipedia.org/wiki/Pangramme 7. https://python.sdv.univ-paris-diderot.fr/data-files/NC_001133.gbk

76

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

10.7. Exercices

Chapitre 10. Plus sur les chaînes de caractères

1 NC_001133.gbk 2 La séquence contient XXX bases 3 10 premières bases : YYYYYYYYYY 4 10 dernières bases : ZZZZZZZZZZ

où XXX est un entier et YYYYYYYYYY et ZZZZZZZZZZ sont des bases. Vous avez toutes les informations pour effectuer cet exercice. Si toutefois vous coincez sur la mise en place du drapeau, voici l’algorithme en pseudo-code pour vous aider :

1 drapeau <- Faux

2 seq <- chaîne de caractères vide

3 Lire toutes les lignes du fichier:

4

si la ligne contient //:

5

drapeau <- Faux

6

si drapeau est Vrai:

7

on ajoute à seq la ligne (sans espaces , chiffres et retour à la ligne)

8

si la ligne contient ORIGIN

9

drapeau <- Vrai

10.7.10 Afﬁchage des carbones alpha d’une structure de protéine
Téléchargez le ﬁchier 1bta.pdb 8 qui correspond à la structure tridimensionnelle de la protéine barstar 9 sur le site de la Protein Data Bank (PDB).
Créez la fonction trouve_calpha() qui prend en argument le nom d’un ﬁchier PDB (sous la forme d’une chaîne de caractères), qui sélectionne uniquement les lignes contenant des carbones alpha, qui stocke ces lignes dans une liste et les renvoie sous la forme d’une liste de chaînes de caractères.
Utilisez la fonction trouve_calpha() pour afﬁcher à l’écran les carbones alpha des deux premiers résidus (acides aminés).
Conseil : vous trouverez des explications sur le format PDB et des exemples de code pour lire ce type de ﬁchier en Python dans l’annexe A Quelques formats de données rencontrés en biologie.
10.7.11 Calcul des distances entre les carbones alpha consécutifs d’une structure de protéine (exercice +++)
En utilisant la fonction trouve_calpha() précédente, calculez la distance interatomique entre les carbones alpha des deux premiers résidus (avec deux chiffres après la virgule).
Rappel : la distance euclidienne d entre deux points A et B de coordonnées cartésiennes respectives (xA, yA, zA) et (xB, yB, zB) se calcule comme suit :
d = (xB − xA)2 + (yB − yA)2 + (zB − zA)2
Créez ensuite la fonction calcule_distance() qui prend en argument la liste renvoyée par la fonction trouve_calpha(), qui calcule les distances interatomiques entre carbones alpha consécutifs et afﬁche ces distances sous la forme :
numero_calpha_1 numero_calpha_2 distance Les numéros des carbones alpha seront afﬁchés sur 2 caractères. La distance sera afﬁchée avec deux chiffres après la virgule. Voici un exemple avec les premiers carbones alpha :
1 1 2 3.80 2 2 3 3.80 3 3 4 3.83 4 4 5 3.82
Modiﬁez maintenant la fonction calcule_distance() pour qu’elle afﬁche à la ﬁn la moyenne des distances. La distance inter-carbone alpha dans les protéines est très stable et de l’ordre de 3,8 angströms. Observez avec attention les valeurs que vous avez calculées pour la protéine barstar. Repérez une valeur surprenante. Essayez de l’expliquer. Conseil : vous trouverez des explications sur le format PDB et des exemples de code pour lire ce type de ﬁchier en Python dans l’annexe A Quelques formats de données rencontrés en biologie.

8. https://files.rcsb.org/download/1BTA.pdb 9. http://www.rcsb.org/pdb/explore.do?structureId=1BTA

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

77

Chapitre 11
Plus sur les listes
11.1 Méthodes associées aux listes
Comme pour les chaînes de caractères, les listes possèdent de nombreuses méthodes qui leur sont propres et qui peuvent se révéler très pratiques. On rappelle qu’une méthode est une fonction qui agit sur l’objet auquel elle est attachée par un point.
11.1.1 .append()
La méthode .append(), que l’on a déjà vu au chapitre 4 Listes, ajoute un élément à la ﬁn d’une liste :
1 >>> a = [1,2,3] 2 >>> a.append(5) 3 >>> a 4 [1, 2, 3, 5]
qui est équivalent à :
1 >>> a = [1,2,3] 2 >>> a = a + [5] 3 >>> a 4 [1, 2, 3, 5]
Conseil : préférez la version avec .append() qui est plus compacte et facile à lire.
11.1.2 .insert()
La méthode .insert() insère un objet dans une liste avec un indice déterminé :
1 >>> a.insert(2,-15) 2 >>> a 3 [1, 2, -15, 3, 5]
11.1.3 del
L’instruction del supprime un élément d’une liste à un indice déterminé :
1 >>> del a[1] 2 >>> a 3 [1, -15, 3, 5]
Remarque Contrairement aux autres méthodes associées aux listes, del est une instruction générale de Python, utilisable pour d’autres
objets que des listes. Celle-ci ne prend pas de parenthèse.
78

11.2. Construction d’une liste par itération
11.1.4 .remove()
La méthode .remove() supprime un élément d’une liste à partir de sa valeur :
1 >>> a.remove(5) 2 >>> a 3 [1, -15, 3]

Chapitre 11. Plus sur les listes

11.1.5 .sort()
La méthode .sort() trie une liste :
1 >>> a.sort() 2 >>> a 3 [-15, 1, 3]

11.1.6 .reverse()
La méthode .reverse() inverse une liste :
1 >>> a.reverse() 2 >>> a 3 [3, 1, -15]

11.1.7 .count()
La méthode .count() compte le nombre d’éléments (passés en argument) dans une liste :
1 >>> a=[1, 2, 4, 3, 1, 1] 2 >>> a.count(1) 33 4 >>> a.count(4) 51 6 >>> a.count(23) 70

11.1.8 Actions sur les listes
De nombreux méthodes ci-dessus (.append(), .sort(), etc.) modiﬁent la liste mais ne renvoient rien, c’est-à-dire qu’elles ne renvoient pas d’objet récupérable dans une variable. Il s’agit d’un exemple d’utilisation de méthode (donc de fonction particulière) qui fait une action mais qui ne renvoie rien. Pensez-y dans vos utilisations futures des listes.
Certaines méthodes ou instructions des listes décalent les indices d’une liste (par exemple .insert(), del, etc.). Enﬁn, pour obtenir une liste exhaustive des méthodes disponibles pour les listes, utilisez la fonction dir(ma_liste) (ma_liste étant une liste).
11.2 Construction d’une liste par itération
La méthode .append() est très pratique car on peut l’utiliser pour construire une liste au fur et à mesure des itérations d’une boucle.
Pour cela, il est commode de déﬁnir préalablement une liste vide de la forme maliste = []. Voici un exemple où une chaîne de caractères est convertie en liste :
1 >>> seq = "CAAAGGTAACGC" 2 >>> seq_list = [] 3 >>> seq_list 4 [] 5 >>> for base in seq: 6 ... seq_list.append(base) 7 ... 8 >>> seq_list 9[C, A, A, A, G, G, T, A, A, C, G, C]
Remarquez que dans cet exemple, vous pouvez directement utiliser la fonction list() qui prend n’importe quel objet séquentiel (liste, chaîne de caractères, etc.) et qui renvoie une liste :

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

79

Chapitre 11. Plus sur les listes

11.3. Test d’appartenance

FIGURE 11.1 – Copie de liste.
1 >>> seq = "CAAAGGTAACGC" 2 >>> list(seq) 3[C, A, A, A, G, G, T, A, A, C, G, C]
Cette méthode est certes plus simple, mais il arrive parfois qu’on doive utiliser des boucles tout de même, comme lorsqu’on lit un ﬁchier. On rappelle que l’instruction list(seq) convertit un objet de type chaîne de caractères en un objet de type liste (il s’agit donc d’une opération de casting). De même que list(range(10)) convertit un objet de type range en un objet de type list.
11.3 Test d’appartenance
L’opérateur in teste si un élément fait partie d’une liste.
1 liste = [1, 3, 5, 7, 9] 2 >>> 3 in liste 3 True 4 >>> 4 in liste 5 False 6 >>> 3 not in liste 7 False 8 >>> 4 not in liste 9 True
La variation avec not permet, a contrario, de vériﬁer qu’un élément n’est pas dans une liste.
11.4 Copie de listes
Il est très important de savoir que l’affectation d’une liste (à partir d’une liste préexistante) crée en réalité une référence et non une copie :
1 >>> x = [1,2,3] 2 >>> y = x 3 >>> y 4 [1, 2, 3] 5 >>> x[1] = -15 6 >>> x 7 [1, -15, 3] 8 >>> y 9 [1, -15, 3]
Vous voyez que la modiﬁcation de x modiﬁe y aussi ! Pour comprendre ce qui se passe nous allons de nouveau utiliser le site Python Tutor avec cet exemple (Figure 11.1) :
Techniquement, Python utilise des pointeurs (comme dans le langage de programmation C) vers les mêmes objets. Python Tutor l’illustre avec des ﬂèches qui partent des variables x et y et qui pointent vers la même liste. Donc, si on modiﬁe la liste x, la liste y est modiﬁée de la même manière. Rappelez-vous de ceci dans vos futurs programmes car cela pourrait avoir des effets désastreux !
Pour éviter ce problème, il va falloir créer une copie explicite de la liste initiale. Observez cet exemple :
1 >>> x = [1,2,3] 2 >>> y = x[:] 3 >>> x[1] = -15

80

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

11.4. Copie de listes

Chapitre 11. Plus sur les listes

FIGURE 11.2 – Copie de liste avec une tranche [:] et la fonction list().
4 >>> y 5 [1, 2, 3]
L’instruction x[:] a créé une copie « à la volée » de la liste x. Vous pouvez utiliser aussi la fonction list() qui renvoie explicitement une liste :
1 >>> x = [1,2,3] 2 >>> y = list(x) 3 >>> x[1] = -15 4 >>> y 5 [1, 2, 3]
Si on regarde à nouveau dans Python Tutor (Figure 11.2), on voit clairement que l’utilisation des tranches [:] ou de la fonction list() crée des copies explicites. Chaque ﬂèche pointe vers une liste différente, indépendante des autres.
Attention, les deux techniques précédentes ne fonctionnent que pour les listes à une dimension, autrement dit les listes qui ne contiennent pas elles-mêmes d’autres listes. Voyez par exemple :
1 >>> x = [[1,2],[3,4]] 2 >>> x 3 [[1, 2], [3, 4]] 4 >>> y = x[:] 5 >>> x[1][1] = 55 6 >>> x 7 [[1, 2], [3, 55]] 8 >>> y 9 [[1, 2], [3, 55]]
et
1 >>> y = list(x) 2 >>> x[1][1] = 77 3 >>> x 4 [[1, 2], [3, 77]] 5 >>> y 6 [[1, 2], [3, 77]]
La méthode de copie qui fonctionne à tous les coups consiste à appeler la fonction deepcopy() du module copy.
1 >>> import copy 2 >>> x = [[1,2],[3,4]] 3 >>> x 4 [[1, 2], [3, 4]] 5 >>> y = copy.deepcopy(x) 6 >>> x[1][1] = 99 7 >>> x 8 [[1, 2], [3, 99]] 9 >>> y 10 [[1 , 2] , [3 , 4]]

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

81

Chapitre 11. Plus sur les listes
11.5 Exercices
Conseil : pour ces exercices, créez des scripts puis exécutez-les dans un shell.

11.5. Exercices

11.5.1 Tri de liste
Soit la liste de nombres [8, 3, 12.5, 45, 25.5, 52, 1]. Triez les nombres de cette liste par ordre croissant, sans utiliser la fonction sort(). Les fonctions et méthodes min(), .append() et .remove() vous seront utiles.

11.5.2 Séquence d’ADN aléatoire
Créez une fonction seq_alea() qui prend comme argument un entier positif taille représentant le nombre de bases de la séquence et qui renvoie une séquence d’ADN aléatoire sous forme d’une liste de bases. Utilisez la méthode .append() pour ajouter les différentes bases à la liste et la fonction random.choice() du module random pour choisir une base parmi les 4 possibles.
Utilisez cette fonction pour générer aléatoirement une séquence d’ADN de 15 bases.

11.5.3 Séquence d’ADN complémentaire inverse
Créez une fonction comp_inv() qui prend comme argument une séquence d’ADN sous la forme d’une chaîne de caractères, qui renvoie la séquence complémentaire inverse sous la forme d’une autre chaîne de caractères et qui utilise des méthodes associées aux listes.
Utilisez cette fonction pour transformer la séquence d’ADN TCTGTTAACCATCCACTTCG en sa séquence complémentaire inverse.
Rappel : la séquence complémentaire inverse doit être « inversée ». Par exemple, la séquence complémentaire inverse de la séquence ATCG est CGAT.

11.5.4 Doublons
Soit la liste de nombres [5, 1, 1, 2, 5, 6, 3, 4, 4, 4, 2]. Retirez les doublons de cette liste, triez-la et afﬁchez-la.

11.5.5 Séquence d’ADN aléatoire 2
Créez une fonction seq_alea_2() qui prend comme argument un entier et quatre ﬂoats représentant respectivement la longueur de la séquence et les pourcentages de chacune des 4 bases A, T, G et C. La fonction générera aléatoirement une séquence d’ADN qui prend en compte les contraintes fournies en arguments et renverra la séquence sous forme d’une liste.
Utilisez cette fonction pour générer aléatoirement une séquence d’ADN de 50 bases contenant 10 % de A, 30 % de T, 50 % de G et 10 % de C.
Conseil : la fonction random.shuffle() du module random vous sera utile.

11.5.6 Le nombre mystère
Trouvez le nombre mystère qui répond aux conditions suivantes : — Il est composé de 3 chiffres. — Il est strictement inférieur à 300. — Il est pair. — Deux de ses chiffres sont identiques. — La somme de ses chiffres est égale à 7. On vous propose d’employer une méthode dite « brute force », c’est-à-dire d’utiliser une boucle et à chaque itération de tester les différentes conditions.

82

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

11.5. Exercices

Chapitre 11. Plus sur les listes

11.5.7 Triangle de Pascal (exercice +++)
Voici le début du triangle de Pascal :
11 21 1 31 2 1 41 3 3 1 51 4 6 4 1 6 1 5 10 10 5 1 7 [...]
Déduisez comment une ligne est construite à partir de la précédente. Par exemple, à partir de la ligne 2 (1 1), construisez la ligne suivante (ligne 3 : 1 2 1) et ainsi de suite.
Implémentez cette construction en Python. Généralisez à l’aide d’une boucle. Écrivez dans un ﬁchier pascal.out les 10 premières lignes du triangle de Pascal.

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

83

Chapitre 12
Plus sur les fonctions

Avant d’aborder ce chapitre, nous vous conseillons de relire le chapitre 9 Fonctions et de bien en assimiler toutes les notions (et aussi d’en faire les exercices). Nous avons vu dans ce chapitre 9 le concept puissant et incontournable que représentent les fonctions. Nous avons également introduit la notion de variables locales et globales.
Dans ce chapitre, nous allons aller un peu plus loin sur la visibilité de ces variables dans et hors des fonctions, et aussi voir ce qui se passe lorsque ces variables sont des listes. Attention, la plupart des lignes de code ci-dessous sont données à titre d’exemple pour bien comprendre ce qui se passe, mais nombre d’entre elles sont des aberrations en terme de programmation. Nous ferons un récapitulatif des bonnes pratiques à la ﬁn du chapitre. Enﬁn, nous vous conseillons de tester tous les exemples ci-dessous avec le site Python Tutor 1 aﬁn de suivre l’état des variables lors de l’exécution des exemples.

12.1 Appel d’une fonction dans une fonction

Dans le chapitre 9 nous avons vu des fonctions qui étaient appelées depuis le programme principal. Il est en fait possible d’appeler une fonction depuis une autre fonction. Et plus généralement, on peut appeler une fonction de n’importe où à partir du moment où elle est visible par Python (c’est-à-dire chargée dans la mémoire). Observez cet exemple :

1 # définition des fonctions

2 def polynome(x):

3

return (x**2 - 2*x + 1)

4

5 def calc_vals(debut , fin):

6

liste_vals = []

7

for x in range(debut ,fin + 1):

8

liste_vals . append ( polynome (x ))

9

return liste_vals

10
11 # programme principal

12 print ( calc_vals ( -5 ,5))

Nous appelons depuis le programme principal la fonction calc_vals(), puis à l’intérieur de celle-ci nous appelons l’autre fonction polynome(). Regardons ce que Python Tutor nous montre lorsque la fonction polynome() est exécutée (Figure 12.1) :
L’espace mémoire alloué à polynome() est grisé, indiquant que cette fonction est en cours d’exécution. La fonction appelante calc_vals() est toujours là (sur un fond blanc) car son exécution n’est pas terminée. Elle est en quelque sorte ﬁgée dans le même état qu’avant l’appel de polynome(), et on pourra ainsi noter que ses variables locales (debut, fin, liste_vals et x) sont toujours là . De manière générale, les variables locales d’une fonction ne seront détruites que lorsque l’exécution de celle-ci sera terminée. Dans notre exemple, les variables locales de calc_vals() ne seront détruites que lorsque la boucle sera terminée et que la liste liste_vals sera retournée au programme principal. Enﬁn, notez bien que la fonction calc_vals() appelle la fonction polynome() à chaque itération de la boucle.
Ainsi, le programmeur est libre de faire tous les appels qu’il souhaite. Une fonction peut appeler une autre fonction, cette
dernière peut appeler une autre fonction et ainsi de suite (et autant de fois qu’on le veut). Une fonction peut même s’appeler elle-même, cela s’appelle une fonction récursive (voir la rubrique suivante). Attention toutefois à retrouver vos petits si vous
vous perdez dans les appels successifs !

1. http://www.pythontutor.com/

84

12.2. Fonctions récursives

Chapitre 12. Plus sur les fonctions

FIGURE 12.1 – Appel d’une fonction dans une fonction.

12.2 Fonctions récursives

Conseil : pour les débutants, vous pouvez passer cette rubrique.
Une fonction récursive est une fonction qui s’appelle elle-même. Les fonctions récursives permettent d’obtenir une efﬁcacité redoutable dans la résolution de certains algorithmes comme le tri rapide 2 (en anglais quicksort).
Oublions la recherche d’efﬁcacité pour l’instant et concentrons-nous sur l’exemple de la fonction mathématique factorielle. Nous vous rappelons que factorielle s’écrit avec ! et produit les résultats suivants :

3! =3 × 2 × 1 = 6 4! =4 × 3 × 2 × 1 = 30 n! =n × n − 1 × . . . × 2 × 1

Si nous essayons de coder cette fonction mathématique en Python, voici ce que nous pourrions écrire :

1 def calc_factorielle(nb):

2

if nb == 1:

3

return 1

4

else:

5

return nb * calc_factorielle(nb - 1)

6
7 # prog principal 8 print(calc_factorielle (4))

Pas très facile à comprendre, n’est-ce pas ? À nouveau, demandons l’aide à Python Tutor pour visualiser ce qui se passe
(nous vous conseillons bien sûr de tester vous-même cet exemple) : Ligne 8, on appelle la fonction calc_factorielle() en passant comme argument l’entier 4. Dans la fonction, la variable
locale qui récupère cet argument est nb. Au sein de la fonction, celle-ci se rappelle elle-même (ligne 5), mais cette fois-ci en passant la valeur 3. Au prochain appel, ce sera avec la valeur 2, puis ﬁnalement 1. Dans ce dernier cas, le test if nb == 1: est vrai et l’instruction return 1 sera exécutée. À ce moment précis de l’exécution, les appels successifs forment une sorte de pile (voir la ﬁgure 12.2). La valeur 1 sera ainsi renvoyée au niveau de l’appel précédent, puis le résultat 2 × 1 = 2 (où 2 correspond à nb et 1 provient de calc_factorielle(nb - 1) soit 1) va être renvoyé à l’appel précédent, puis 3 × 2 = 6 (où 3 correspond à nb et 2 provient de calc_factorielle(nb - 1) soit 2) va être renvoyé à l’appel précédent, pour ﬁnir par 4 × 6 = 24 (où 4 correspond à nb et 6 provient de calc_factorielle(nb - 1) soit 6), soit la valeur de !4. Les appels
successifs vont donc se « dépiler » et nous reviendrons dans le programme principal.

2. https://fr.wikipedia.org/wiki/Tri_rapide

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

85

Chapitre 12. Plus sur les fonctions

12.3. Portée des variables

FIGURE 12.2 – Fonction récursive : factorielle.
Même si les fonctions récursives peuvent être ardues à comprendre, notre propos est ici de vous illustrer qu’une fonction qui en appelle une autre (ici il s’agit d’elle-même) reste « ﬁgée » dans le même état, jusqu’à ce que la fonction appelée lui renvoie une valeur.

12.3 Portée des variables

Il est très important, lorsque l’on manipule des fonctions, de connaître la portée des variables. On a vu que les variables créées au sein d’une fonction ne sont pas visibles à l’extérieur de celle-ci car elles étaient locales à la fonction. Observez le code suivant :

1 >>> def ma_fonction():

2 ...

x=2

3 ...

print( x vaut {} dans la fonction .format(x))

4 ...

5 >>> ma_fonction()

6 x vaut 2 dans la fonction

7 >>> print(x)

8 Traceback (most recent call last):

9 File "<stdin >", line 1, in <module >

10 NameError : name x is not defined

Lorsque Python exécute le code de la fonction, il connaît le contenu de la variable x. Par contre, de retour dans le module principal (dans ce cas, il s’agit de l’interpréteur Python), il ne la connaît plus, d’où le message d’erreur.
De même, une variable passée en argument est considérée comme locale lorsqu’on arrive dans la fonction :

1 >>> def ma_fonction(x):

2 ...

print( x vaut {} dans la fonction .format(x))

3 ...

4 >>> ma_fonction (2)

5 x vaut 2 dans la fonction

6 >>> print(x)

7 Traceback (most recent call last):

8 File "<stdin >", line 1, in ?

9 NameError: name x is not defined

Lorsqu’une variable est déclarée à la racine du module (c’est aussi comme cela que l’on appelle un programme Python), elle est visible dans tout le module. On a vu qu’on parlait de variable globale :

86

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

12.4. Portée des listes

Chapitre 12. Plus sur les fonctions

1 >>> def ma_fonction():

2 ...

print(x)

3 ...

4 >>> x = 3

5 >>> ma_fonction()

63

7 >>> print(x)

83

Dans ce cas, la variable x est visible dans le module principal et dans toutes les fonctions du module. Toutefois, Python ne permet pas la modiﬁcation d’une variable globale dans une fonction :

1 >>> def ma_fonction():

2 ...

x=x+1

3 ...

4 >>> x = 1

5 >>> ma_fonction()

6 Traceback (most recent call last):

7 File "<stdin >", line 1, in <module >

8 File "<stdin >", line 2, in fct

9 UnboundLocalError: local variable x

referenced before assignment

L’erreur renvoyée montre que Python pense que x est une variable locale qui n’a pas été encore assignée. Si on veut vraiment modiﬁer une variable globale dans une fonction, il faut utiliser le mot-clé global :

1 >>> def ma_fonction():

2 ...

global x

3 ...

x=x+1

4 ...

5 >>> x = 1

6 >>> ma_fonction()

7 >>> x

82

Dans ce dernier cas, le mot-clé global a forcé la variable x à être globale plutôt que locale au sein de la fonction.

12.4 Portée des listes

Attention Les exemples de cette partie représentent des absurdités en termes de programmation. Ils sont donnés à titre indicatif pour
comprendre ce qui se passe, mais il ne faut surtout pas s’en inspirer !

Soyez extrêmement attentifs avec les types modiﬁables (tels que les listes) car vous pouvez les changer au sein d’une fonction :

1 >>> def ma_fonction():

2 ...

liste[1] = -127

3 ...

4 >>> liste = [1,2,3]

5 >>> ma_fonction()

6 >>> liste

7 [1, -127, 3]

De même, si vous passez une liste en argument, elle est modiﬁable au sein de la fonction :

1 >>> def ma_fonction(x):

2 ...

x[1] = -15

3 ...

4 >>> y = [1,2,3]

5 >>> ma_fonction(y)

6 >>> y

7 [1, -15, 3]

Si vous voulez éviter ce problème, utilisez des tuples (ils seront présentés dans le chapitre 13 Dictionnaires et tuples), Python renverra une erreur puisque ces derniers sont non modiﬁables.
Une autre solution pour éviter la modiﬁcation d’une liste, lorsqu’elle est passée comme argument à une fonction, est de la passer explicitement (comme nous l’avons fait pour la copie de liste) aﬁn qu’elle reste intacte dans le programme principal.

1 >>> def ma_fonction(x):

2 ...

x[1] = -15

3 ...

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

87

Chapitre 12. Plus sur les fonctions

12.5. Règle LGI

4 >>> y = [1,2,3] 5 >>> ma_fonction(y[:]) 6 >>> y 7 [1, 2, 3] 8 >>> ma_fonction(list(y)) 9 >>> y 10 [1 , 2 , 3]
Dans ces deux derniers exemples, une copie de y est créée à la volée lorsqu’on appelle la fonction, ainsi la liste y du module principal reste intacte.

12.5 Règle LGI

Lorsque Python rencontre une variable, il va traiter la résolution de son nom avec des priorités particulières. D’abord il va regarder si la variable est locale, puis si elle n’existe pas localement, il vériﬁera si elle est globale et enﬁn si elle n’est pas globale, il testera si elle est interne (par exemple la fonction len() est considérée comme une fonction interne à Python, elle existe à chaque fois que vous lancez Python). On appelle cette règle la règle LGI pour locale, globale, interne. En voici un exemple :

1 >>> def ma_fonction():

2 ...

x=4

3 ...

print( Dans la fonction x vaut {} .format(x))

4 ...

5 >>> x = -15

6 >>> ma_fonction()

7 Dans la fonction x vaut 4

8 >>> print( Dans le module principal x vaut {} .format(x))

9 Dans le module principal x vaut -15

Dans la fonction, x a pris la valeur qui lui était déﬁnie localement en priorité sur la valeur déﬁnie dans le module principal.

Conseil Même si Python peut reconnaître une variable ayant le même nom que ses propres fonctions ou variables internes, évitez
de les utiliser car ceci rendra votre code confus !

De manière générale la règle LGI découle de la manière dont Python gère ce que l’on appelle « les espaces de noms ». Nous en parlerons plus longuement dans le chapitre 19 Avoir la classe avec les objets.
12.6 Recommandations
Dans ce chapitre nous avons joué avec les fonctions (et les listes) aﬁn de vous montrer comment Python réagit. Toutefois, notez bien que l’utilisation de variables globales est à bannir déﬁnitivement de votre pratique de la programmation.
Parfois on veut faire vite et on crée une variable globale visible partout dans le programme (donc dans toutes les fonctions), car « Ça va plus vite, c’est plus simple ». C’est un très mauvais calcul, ne serait-ce que parce que vos fonctions ne seront pas réutilisables dans un autre contexte si elles utilisent des variables globales ! Ensuite, arriverez-vous à vous relire dans six mois ? Quelqu’un d’autre pourrait-il comprendre votre programme ? Il existe de nombreuses autres raisons 3 que nous ne développerons pas ici, mais libre à vous de consulter de la documentation externe.
Heureusement, Python est orienté objet et permet « d’encapsuler » des variables dans des objets et de s’affranchir déﬁnitivement des variables globales (nous verrons cela dans le chapitre 19 Avoir la classe avec les objets). En attendant, et si vous ne souhaitez pas aller plus loin sur les notions d’objet (on peut tout à fait « pythonner » sans cela), retenez la chose suivante sur les fonctions et les variables globales :
Plutôt que d’utiliser des variables globales, passez vos variables explicitement aux fonctions comme des argument(s).
Vous connaissez maintenant les fonctions sous tous leurs angles. Comme indiqué en introduction du chapitre 9, elles sont incontournables et tout programmeur se doit de les maîtriser. Voici les derniers conseils que nous pouvons vous donnez :
— Lorsque vous débutez un nouveau projet de programmation, posez-vous la question : « Comment pourrais-je décomposer en blocs chaque tâche à effectuer, chaque bloc pouvant être une fonction ? ». Et n’oubliez pas que si une fonction s’avère trop complexe, vous pouvez également la décomposer en d’autres fonctions.
3. http://wiki.c2.com/?GlobalVariablesAreBad

88

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

12.7. Exercices

Chapitre 12. Plus sur les fonctions

— Au risque de nous répéter, forcez-vous à utiliser des fonctions en permanence. Pratiquez, pratiquez. . . et pratiquez encore !

12.7 Exercices
Conseil : pour le second exercice, créez un scripts puis exécutez-le dans un shell.
12.7.1 Prédire la sortie
Prédisez le comportement des codes suivant, sans les recopier dans un script ni dans l’interpréteur Python :
Code 1
1 def hello(prenom): 2 print("Bonjour {}". format(prenom))
3 4
5 # Programme principal. 6 hello("Patrick") 7 print(x)
Code 2
1 def hello(prenom): 2 print("Bonjour {}". format(prenom))
3 4
5 # Programme principal. 6 x = 10 7 hello("Patrick") 8 print(x)
Code 3
1 def hello(prenom): 2 print("Bonjour {}". format(prenom)) 3 print(x)
4 5
6 # Programme principal. 7 x = 10 8 hello("Patrick") 9 print(x)
Code 4
1 def hello(prenom): 2 x = 42 3 print("Bonjour {}". format(prenom)) 4 print(x)
5 6
7 # Programme principal. 8 x = 10 9 hello("Patrick") 10 print ( x )
12.7.2 Passage de liste à une fonction
Créez une fonction ajoute_nb_alea() qui prend en argument une liste et qui ajoute un nombre entier aléatoire entre -10 et 10 (inclus) à chaque élément. La fonction afﬁchera à l’écran cette nouvelle liste modiﬁée.
Dans le programme principal, on effectuera les actions suivantes :
1. Créez une variable ma_liste = [7, 3, 8, 4, 5, 1, 9, 10, 2, 6]. 2. Afﬁchez ma_liste à l’écran. 3. Appelez la fonction ajoute_nb_alea() en lui passant ma_liste en argument. 4. Afﬁchez à nouveau ma_liste à l’écran.
Comment expliquez-vous le résultat obtenu ?

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

89

Chapitre 13
Dictionnaires et tuples

13.1 Dictionnaires

Les dictionnaires se révèlent très pratiques lorsque vous devez manipuler des structures complexes à décrire et que les listes présentent leurs limites. Les dictionnaires sont des collections non ordonnées d’objets, c’est-à-dire qu’il n’y a pas de notion d’ordre (i.e. pas d’indice). On accède aux valeurs d’un dictionnaire par des clés. Ceci semble un peu confus ? Regardez l’exemple suivant :

1 >>> ani1 = {} 2 >>> ani1["nom"] = "girafe" 3 >>> ani1["taille"] = 5.0 4 >>> ani1["poids"] = 1100 5 >>> ani1 6 { nom : girafe , taille : 5.0,

poids : 1100}

En premier, on déﬁnit un dictionnaire vide avec les accolades {} (tout comme on peut le faire pour les listes avec []). Ensuite, on remplit le dictionnaire avec différentes clés ("nom", "taille", "poids") auxquelles on affecte des valeurs ("girafe", 5.0, 1100). Vous pouvez mettre autant de clés que vous voulez dans un dictionnaire (tout comme vous pouvez
ajouter autant d’éléments que vous voulez dans une liste).

Remarque Un dictionnaire est afﬁché sans ordre particulier.

On peut aussi initialiser toutes les clés et les valeurs d’un dictionnaire en une seule opération :
1 >>> ani2 = {"nom":"singe", "poids":70, "taille ":1.75}
Mais rien ne nous empêche d’ajouter une clé et une valeur supplémentaire :
1 >>> ani2["age"] = 15
Pour récupérer la valeur associée à une clé donnée, il sufﬁt d’utiliser la syntaxe suivante dictionnaire["cle"]. Par exemple :
1 >>> ani1["taille"] 2 5.0

Remarque Toutes les clés de dictionnaire utilisées jusqu’à présent étaient des chaînes de caractères. Rien n’empêche d’utiliser d’autres
types d’objets comme des entiers ou des ﬂoats, cela peut parfois s’avérer très utile. Néanmoins, nous vous conseillons, autant que possible, d’utiliser systématiquement des chaînes de caractères pour vos
clés de dictionnaire.

90

13.2. Tuples

13.1.1 Itération sur les clés pour obtenir les valeurs

Il est possible d’obtenir toutes les valeurs d’un dictionnaire à partir de ses clés :

1 >>> ani2 = { nom : singe , poids :70,

2 >>> for key in ani2:

3 ...

print(key , ani2[key])

4 ...

5 poids 70

6 nom singe

7 taille 1.75

taille :1.75}

Chapitre 13. Dictionnaires et tuples

13.1.2 Méthodes .keys() et .values()
Les méthodes .keys() et .values() renvoient, comme vous pouvez vous en doutez, les clés et les valeurs d’un dictionnaire :
1 >>> ani2.keys() 2 dict_keys([ poids , nom , taille ]) 3 >>> ani2.values() 4 dict_values([70, singe , 1.75])
Les mentions dict_keys et dict_values indiquent que nous avons affaire à des objets un peu particuliers. Si besoin, nous pouvons les transformer en liste avec la fonction list() :
1 >>> ani2.values() 2 dict_values([ singe , 70, 1.75]) 3 >>> list(ani2.values()) 4 [ singe , 70, 1.75]

13.1.3 Existence d’une clé

Pour vériﬁer si une clé existe dans un dictionnaire, on peut utiliser le test d’appartenance avec l’instruction in :

1 >>> if "poids" in ani2:

2 ...

print("La clé poids existe pour ani2")

3 ...

4 La clé poids existe pour ani2

5 >>> if "age" in ani2:

6 ...

print("La clé age existe pour ani2")

7 ...

8 >>>

Dans le second test (lignes 5 à 7), le message n’est pas afﬁché car la clé age n’est pas présente dans le dictionnaire ani2.

13.1.4 Liste de dictionnaires

En créant une liste de dictionnaires qui possèdent les mêmes clés, on obtient une structure qui ressemble à une base de données :

1 >>> animaux = [ani1 , ani2]

2 >>> animaux

3 [{ nom : girafe , poids : 1100,

4 poids : 70, taille : 1.75}]

5 >>>

6 >>> for ani in animaux:

7 ...

print(ani[ nom ])

8 ...

9 girafe

10 singe

taille : 5.0}, { nom :

singe ,

Vous constater ainsi que les dictionnaires permettent de gérer des structures complexes de manière plus explicite que les listes.

13.2 Tuples
Les tuples correspondent aux listes à la différence qu’ils sont non modiﬁables. On a vu dans le chapitre 11 Plus sur les listes que les listes pouvaient être modiﬁées par références, notamment lors de la copie de listes. Les tuples s’affranchissent de ce problème puisqu’ils sont non modiﬁables. Pratiquement, ils utilisent les parenthèses au lieu des crochets :

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

91

Chapitre 13. Dictionnaires et tuples

13.3. Exercices

1 >>> x = (1,2,3) 2 >>> x 3 (1, 2, 3) 4 >>> x[2] 53 6 >>> x[0:2] 7 (1, 2) 8 >>> x[2] = 15 9 Traceback (innermost last): 10 File " < stdin >" , line 1 , in ? 11 TypeError : object doesn t support item assignment
L’affectation et l’indiçage fonctionnent comme avec les listes. Mais si on essaie de modiﬁer un des éléments du tuple,
Python renvoie un message d’erreur. Si vous voulez ajouter un élément (ou le modiﬁer), vous devez créer un autre tuple :
1 >>> x = (1,2,3) 2 >>> x + (2,) 3 (1, 2, 3, 2)

Remarque Pour utiliser un tuple d’un seul élément, vous devez utiliser une syntaxe avec une virgule (element,), ceci pour éviter
une ambiguïté avec une simple expression. Autre particularité des tuples, il est possible d’en créer de nouveaux sans les parenthèses, dès lors que ceci ne pose pas
d’ambiguïté avec une autre expression :
1 >>> x = (1,2,3) 2 >>> x 3 (1, 2, 3) 4 >>> x = 1,2,3 5 >>> x 6 (1, 2, 3)
Toutefois, nous vous conseillons d’utiliser systématiquement les parenthèses aﬁn d’éviter les confusions.

Enﬁn, on peut utiliser la fonction tuple(sequence) qui fonctionne exactement comme la fonction list(), c’est-à-dire qu’elle prend en argument un objet séquentiel et renvoie le tuple correspondant (opération de casting) :
1 >>> tuple([1,2,3]) 2 (1, 2, 3) 3 >>> tuple("ATGCCGCGAT") 4(A, T, G, C, C, G, C, G, A, T)

Remarque Les listes, les dictionnaires et les tuples sont des objets qui peuvent contenir des collections d’autres objets. On peut donc
construire des listes qui contiennent des dictionnaires, des tuples ou d’autres listes, mais aussi des dictionnaires contenant des tuples, des listes, etc.

Pratiquement, nous avons déjà croisé les tuples avec la fonction enumerate() dans le chapitre 5 Boucles et comparaisons qui renvoie l’indice de l’élément et l’élément d’une liste, ainsi dans le chapitre 9 Fonctions lorsqu’on voulait qu’une fonction renvoie plusieurs valeurs (par exemple dans l’instruction return x,y, le couple x,y est un tuple). Cela revenait à faire une affectation multiple du type x, y = 1, 2.

13.3 Exercices
Conseil : pour ces exercices, créez des scripts puis exécutez-les dans un shell.
13.3.1 Composition en acides aminés
En utilisant un dictionnaire, déterminez le nombre d’occurrences de chaque acide aminé dans la séquence AGWPSGGASAGLAILWGASAIMPGA Le dictionnaire ne doit contenir que les acides aminés présents dans la séquence.

92

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

13.3. Exercices

Chapitre 13. Dictionnaires et tuples

13.3.2 Mots de 2 et 3 lettres dans une séquence d’ADN
Créez une fonction compte_mots_2_lettres() qui prend comme argument une séquence sous la forme d’une chaîne de caractères et qui renvoie tous les mots de 2 lettres qui existent dans la séquence sous la forme d’un dictionnaire. Par exemple pour la séquence ACCTAGCCCTA, le dictionnaire renvoyée serait : { AC : 1, CC : 3, CT : 2, TA : 2, AG : 1, GC : 1}
Créez une nouvelle fonction compte_mots_3_lettres() qui a un comportement similaire à compte_mots_2_lettres() mais avec des mots de 3 lettres.
Utilisez ces fonctions pour afﬁchez les mots de 2 et 3 lettres et leurs occurrences trouvés dans la séquence d’ADN : ACCTAGCCATGTAGAATCGCCTAGGCTTTAGCTAGCTCTAGCTAGCTG
Voici un exemple de sortie attendue :
1 Mots de 2 lettres 2 AC : 1 3 CC : 3 4 CT : 8 5 [...] 6 Mots de 3 lettres 7 ACC : 1 8 CCT : 2 9 CTA : 5 10 [...]

13.3.3 Mots de 2 lettres dans la séquence du chromosome I de Saccharomyces cerevisiae
Créez une fonction lit_fasta() qui prend comme argument le nom d’un ﬁchier FASTA sous la forme d’une chaîne de caractères, lit la séquence dans le ﬁchier FASTA et la renvoie sous la forme d’une chaîne de caractères. N’hésitez pas à vous inspirer d’un exercice similaire du chapitre 10 Plus sur les chaînes de caractères.
Utilisez cette fonction et la fonction compte_mots_2_lettres() de l’exercice précédent pour extraire les mots de 2 lettres et leurs occurrences dans la séquence du chromosome I de la levure du boulanger Saccharomyces cerevisiae (ﬁchier NC_001133.fna 1).
Le génome complet est fourni au format FASTA. Vous trouverez des explications sur ce format et des exemples de code dans l’annexe A Quelques formats de données rencontrés en biologie.
13.3.4 Mots de n lettres dans un ﬁchier FASTA
Créez un script extract-words.py qui prend comme arguments le nom d’un ﬁchier FASTA suivi d’un entier compris entre 1 et 4. Ce script doit extraire du ﬁchier FASTA tous les mots et leurs occurrences en fonction du nombre de lettres passé en option.
Utilisez pour ce script la fonction lit_fasta() de l’exercice précédent. Créez également la fonction compte_mots_n_lettres() qui prend comme argument une séquence sous la forme d’une chaîne de caractères et le nombre de lettres des mots sous la forme d’un entier.
Testez ce script avec : — la séquence du chromosome I de la levure du boulanger Saccharomyces cerevisiae (ﬁchier NC_001133.fna 2) — le génome de la bactérie Escherichia coli (ﬁchier NC_000913.fna 3) Les deux ﬁchiers sont au format FASTA. Cette méthode vous paraît-elle efﬁcace sur un génome assez gros comme celui d’Escherichia coli ?
13.3.5 Atomes carbone alpha d’un ﬁchier PDB
Téléchargez le ﬁchier 1bta.pdb 4 qui correspond à la structure tridimensionnelle de la protéine barstar 5 sur le site de la Protein Data Bank (PDB).
Créez la fonction trouve_calpha() qui prend en argument le nom d’un ﬁchier PDB (sous la forme d’une chaîne de caractères), qui sélectionne uniquement les lignes contenant des carbones alpha et qui les renvoie sous la forme d’une liste de dictionnaires. Chaque dictionnaire contient quatre clés :
1. https://python.sdv.univ-paris-diderot.fr/data-files/NC_001133.fna 2. https://python.sdv.univ-paris-diderot.fr/data-files/NC_001133.fna 3. https://python.sdv.univ-paris-diderot.fr/data-files/NC_000913.fna 4. https://files.rcsb.org/download/1BTA.pdb 5. http://www.rcsb.org/pdb/explore.do?structureId=1BTA

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

93

Chapitre 13. Dictionnaires et tuples

13.3. Exercices

— le numéro du résidu (resid) avec une valeur entière, — la coordonnée atomique x (x) avec une valeur ﬂoat, — la coordonnée atomique y (y) avec une valeur ﬂoat, — la coordonnée atomique z (z) avec une valeur ﬂoat. Utilisez la fonction trouve_calpha() pour afﬁcher à l’écran le nombre total de carbones alpha de la barstar ainsi que les coordonnées atomiques des carbones alpha des deux premiers résidus (acides aminés).
Conseil : vous trouverez des explications sur le format PDB et des exemples de code pour lire ce type de ﬁchier en Python
dans l’annexe A Quelques formats de données rencontrés en biologie.

13.3.6 Barycentre d’une protéine (exercice +++)

Téléchargez le ﬁchier 1bta.pdb 6 qui correspond à la structure tridimensionnelle de la protéine barstar 7 sur le site de la Protein Data Bank (PDB).
Un atome de carbone alpha est présent dans chaque résidu (acide aminé) d’une protéine. On peut obtenir une bonne approximation du barycentre d’une protéine en calculant le barycentre de ses carbones alpha.
Le barycentre G de coordonnées (Gx, Gy, Gz) est obtenu à partir des n carbones alpha (CA) de coordonnées (CAx, CAy, CAz) avec :

1n

∑ Gx

=

n

CAi,x
i=1

1n

∑ Gy

=

n

CAi,y
i=1

1n

∑ Gz

=

n

CAi,z
i=1

Créez une fonction calcule_barycentre() qui prend comme argument une liste de dictionnaires dont les clés (resid, x, y et z) sont celles de l’exercice précédent et qui renvoie les coordonnées du barycentre sous la forme d’une liste de ﬂoats.
Utilisez la fonction trouve_calpha() de l’exercice précédent et la fonction calcule_barycentre()pour afﬁcher, avec deux chiffres signiﬁcatifs, les coordonnées du barycentre des carbones alpha de

la barstar.

6. https://files.rcsb.org/download/1BTA.pdb 7. http://www.rcsb.org/pdb/explore.do?structureId=1BTA

94

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

Chapitre 14
Création de modules

14.1 Pourquoi créer ses propres modules ?
Dans le chapitre 8 Modules, nous avons découvert quelques modules existants dans Python comme random, math, etc. Nous avons vu par ailleurs dans les chapitres 9 Fonctions et 12 Plus sur les fonctions que les fonctions sont utiles pour réutiliser une fraction de code plusieurs fois au sein d’un même programme sans avoir à dupliquer ce code. On peut imaginer qu’une fonction bien écrite pourrait être judicieusement réutilisée dans un autre programme Python. C’est justement l’intérêt de créer un module. On y met un ensemble de fonctions que l’on peut être amené à utiliser souvent. En général, les modules sont regroupés autour d’un thème précis. Par exemple, on pourrait concevoir un module d’analyse de séquences biologiques ou encore de gestion de ﬁchiers PDB.

14.2 Création d’un module

En Python, la création d’un module est très simple. Il sufﬁt d’écrire un ensemble de fonctions (et/ou de constantes) dans un ﬁchier, puis d’enregistrer ce dernier avec une extension .py (comme n’importe quel script Python). À titre d’exemple, nous allons créer un module simple que nous enregistrerons sous le nom message.py :

1 """Module inutile qui affiche des messages :-)."""

2
3 DATE = 16092008

4

5

6 def bonjour(nom):

7

"""Dit Bonjour."""

8

return "Bonjour " + nom

9

10

11 def ciao ( nom ):

12

"""Dit Ciao."""

13

return "Ciao " + nom

14

15

16 def hello ( nom ):

17

"""Dit Hello."""

18

return "Hello " + nom

Les chaînes de caractères entre triple guillemets en tête du module et en tête de chaque fonction sont facultatives mais elles jouent néanmoins un rôle essentiel dans la documentation du code.

Remarque
Une constante est, par déﬁnition, une variable dont la valeur n’est pas modiﬁée. Par convention en Python, le nom des constantes est écrit en majuscules (comme DATE dans notre exemple).

95

Chapitre 14. Création de modules

14.3. Utilisation de son propre module

14.3 Utilisation de son propre module
Pour appeler une fonction ou une variable de ce module, il faut que le ﬁchier message.py soit dans le répertoire courant (dans lequel on travaille) ou bien dans un répertoire listé par la variable d’environnement PYTHONPATH. Ensuite, il sufﬁt d’importer le module et toutes ses fonctions (et constantes) vous sont alors accessibles.
Remarque Avec Mac OS X et Linux, il faut taper la commande suivante depuis un shell Bash pour modiﬁer la variable d’environne-
ment PYTHONPATH : export PYTHONPATH=$PYTHONPATH:/chemin/vers/mon/super/module
Avec Windows, mais depuis un shell PowerShell, il faut taper la commande suivante : $env:PYTHONPATH += ";C:\chemin\vers\mon\super\module"
Une fois cette manipulation effectuée, vous pouvez contrôler que le chemin vers le répertoire contenant vos modules a bien été ajouté à la variable d’environnement PYTHONPATH :
— sous Mac OS X et Linux : echo $PYTHONPATH — sous Windows : echo $env:PYTHONPATH

Le chargement du module se fait avec la commande import message. Notez que le ﬁchier est bien enregistré avec une extension .py et pourtant on ne la précise pas lorsqu’on importe le module. Ensuite, on peut utiliser les fonctions comme avec
un module classique.
1 >>> import message 2 >>> message.hello("Joe") 3 Hello Joe 4 >>> message.ciao("Bill") 5 Ciao Bill 6 >>> message.bonjour("Monsieur") 7 Bonjour Monsieur 8 >>> message.DATE 9 16092008

Remarque
La première fois qu’un module est importé, Python crée un répertoire nommé __pycache__ contenant un ﬁchier avec une extension .pyc qui contient le bytecode 1, c’est-à-dire le code précompilé du module.

14.4 Les docstrings

Lorsqu’on écrit un module, il est important de créer de la documentation pour expliquer ce que fait le module et comment utiliser chaque fonction. Les chaînes de caractères entre triple guillemets situées en début du module et de chaque fonction sont là pour cela, on les appelle docstrings. Ces docstrings permettent notamment de fournir de l’aide lorsqu’on invoque la commande help() :

1 >>> help(message)

2
3 Help on module message:

4

5 NAME

6

message - Module inutile qui affiche des messages :-).

7

8 FUNCTIONS

9

bonjour(nom)

10

Dit Bonjour.

11

12

ciao(nom)

13

Dit Ciao.

14

15

hello(nom)

16

Dit Hello.

17

18 DATA

19

DATE = 16092008

1. https://docs.python.org/fr/3/glossary.html

96

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

14.5. Visibilité des fonctions dans un module

Chapitre 14. Création de modules

20

21 FILE

22

/ home / pierre / message . py

Remarque Pour quitter l’aide, pressez la touche Q.

Vous remarquez que Python a généré automatiquement cette page d’aide, tout comme il est capable de le faire pour les modules internes à Python (random, math, etc.) et ce grâce aux docstrings. Notez que l’on peut aussi appeler l’aide pour une seule fonction :

1 >>> help(message.ciao)

2
3 Help on function ciao in module message:

4

5 ciao(nom)

6

Dit Ciao.

En résumé, les docstrings sont destinés aux utilisateurs du module. Leur but est différent des commentaires qui, eux, sont destinés à celui qui lit le code (pour en comprendre les subtilités). Une bonne docstring de fonction doit contenir tout ce dont un utilisateur a besoin pour utiliser cette fonction. Une liste minimale et non exhaustive serait :
— ce que fait la fonction, — ce qu’elle prend en argument, — ce qu’elle renvoie. Pour en savoir plus sur les docstrings et comment les écrire, nous vous recommandons de lire le chapitre 15 Bonnes pratiques en programmation Python.

14.5 Visibilité des fonctions dans un module
La visibilité des fonctions au sein des modules suit des règles simples : — Les fonctions dans un même module peuvent s’appeler les unes les autres. — Les fonctions dans un module peuvent appeler des fonctions situées dans un autre module s’il a été préalablement
importé. Par exemple, si la commande import autremodule est utilisée dans un module, il est possible d’appeler une fonction avec autremodule.fonction(). Toutes ces règles viennent de la manière dont Python gère les espaces de noms. De plus amples explications sont données sur ce concept dans le chapitre 19 Avoir la classe avec les objets.

14.6 Module ou script ?

Vous avez remarqué que notre module message ne contient que des fonctions et une constante. Si on l’exécutait comme un script classique, cela ne renverrait rien :
1 $ python message.py 2$

Cela s’explique par l’absence de programme principal, c’est-à-dire, de lignes de code que l’interpréteur exécute lorsqu’on lance le script.
À l’inverse, que se passe-t-il alors si on importe un script en tant que module alors qu’il contient un programme principal avec des lignes de code ? Prenons par exemple le script message2.py suivant :

1 """ Script de test ."""

2

3

4 def bonjour(nom):

5

"""Dit Bonjour."""

6

return "Bonjour " + nom

7

8
9 # programme principal

10 print ( bonjour (" Joe "))

Si on l’importe dans l’interpréteur, on obtient :

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

97

Chapitre 14. Création de modules

14.7. Exercice

1 >>> import message2 2 Bonjour Joe

Ceci n’est pas le comportement voulu pour un module car on n’attend pas d’afﬁchage particulier (par exemple la commande import math n’afﬁche rien dans l’interpréteur).

Aﬁn de pouvoir utiliser un code Python en tant que module ou en tant que script, nous vous conseillons la structure

suivante :

1 """ Script de test ."""

2

3

4 def bonjour(nom):

5

"""Dit Bonjour."""

6

return "Bonjour " + nom

7

8

9 if __name__ == "__main__":

10

print ( bonjour (" Joe "))

À la ligne 9, l’instruction if __name__ == "__main__": indique à Python : — Si le programme message2.py est exécuté en tant que script dans un shell, le résultat du test if sera alors True et le
bloc d’instructions correspondant (ligne 10) sera exécuté :
1 $ python message2.py 2 Bonjour Joe

— Si le programme message2.py est importé en tant que module, le résultat du test if sera alors False (et le bloc d’instructions correspondant ne sera pas exécuté) :
1 >>> import message2 2 >>>

À nouveau, ce comportement est possible grâce à la gestion des espaces de noms par Python (pour plus détails, consultez le chapitre 19 Avoir la classe avec les objets).
Au delà de la commodité de pouvoir utiliser votre script en tant que programme ou en tant que module, cela présente l’avantage de bien voir où se situe le programme principal quand on lit le code. Ainsi, plus besoin d’ajouter un commentaire # programme principal comme nous vous l’avions suggéré dans les chapitres 9 Fonctions et 12 Plus sur les fonctions. L’utilisation de la ligne if __name__ == "__main__": est une bonne pratique que nous vous recommandons !

14.7 Exercice
14.7.1 Module ADN
Dans le script adn.py, construisez un module qui va contenir les fonctions et constantes suivantes. — Fonction lit_fasta() : prend en argument un nom de ﬁchier sous forme d’une chaîne de caractères et renvoie la
séquence d’ADN lue dans le ﬁchier sous forme d’une chaîne de caractères. — Fonction seq_alea() : prend en argument une taille de séquence sous forme d’un entier et renvoie une séquence
d’ADN de la taille correspondante sous forme d’une chaîne de caractères. — Fonction comp_inv() : prend en argument une séquence d’ADN sous forme d’une chaîne de caractères et renvoie la
séquence complémentaire inverse (aussi sous forme d’une chaîne de caractères). — Fonction prop_gc() : prend en argument une séquence d’ADN sous forme d’une chaîne de caractères et renvoie la
proportion en GC de la séquence sous forme d’un ﬂoat. Nous vous rappelons que la proportion de GC s’obtient comme la somme des bases Guanine (G) et Cytosine (C) divisée par le nombre total de bases (A, T, C, G). — Constante BASE_COMP : dictionnaire qui contient la complémentarité des bases d’ADN (A→T, T→C, G→C et C→G). Ce dictionnaire sera utilisé par la fonction comp_inv(). À la ﬁn de votre script, proposez des exemples d’utilisation des fonctions que vous aurez créées. Ces exemples d’utilisation ne devront pas être exécutés lorsque le script est chargé comme un module. Conseils : — Dans cet exercice, on supposera que toutes les séquences sont manipulées comme des chaînes de caractères en majuscules. — Pour les fonctions seq_alea() et comp_inv(), n’hésitez pas à jeter un œil aux exercices correspondants dans le chapitre 11 Plus sur les listes. — Voici un exemple de ﬁchier FASTA adn.fasta 2 pour tester la fonction lit_fasta().
2. https://python.sdv.univ-paris-diderot.fr/data-files/adn.fasta

98

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

Chapitre 15
Bonnes pratiques en programmation Python
Comme vous l’avez constaté dans tous les chapitres précédents, la syntaxe de Python est très permissive. Aﬁn d’uniformiser l’écriture de code en Python, la communauté des développeurs Python recommande un certain nombre de règles aﬁn qu’un code soit lisible. Lisible par quelqu’un d’autre, mais également, et surtout, par soi-même. Essayez de relire un code que vous avez écrit « rapidement » il y a un 1 mois, 6 mois ou un an. Si le code ne fait que quelques lignes, il se peut que vous vous y retrouviez, mais s’il fait plusieurs dizaines voire centaines de lignes, vous serez perdus.
Dans ce contexte, le créateur de Python, Guido van Rossum, part d’un constat simple : « code is read much more often than it is written » (« le code est plus souvent lu qu’écrit »). Avec l’expérience, vous vous rendrez compte que cela est parfaitement vrai. Alors plus de temps à perdre, voyons en quoi consistent ces bonnes pratiques.
Plusieurs choses sont nécessaires pour écrire un code lisible : la syntaxe, l’organisation du code, le découpage en fonctions (et possiblement en classes que nous verrons dans le chapitre 19 Avoir la classe avec les objets), mais souvent, aussi, le bon sens. Pour cela, les « PEP » peuvent nous aider.
Déﬁnition Aﬁn d’améliorer le langage Python, la communauté qui développe Python publie régulièrement des Python Enhance-
ment Proposal 1 (PEP), suivi d’un numéro. Il s’agit de propositions concrètes pour améliorer le code, ajouter de nouvelles fonctionnalités, mais aussi des recommandations sur la manière d’utiliser Python, bien écrire du code, etc.
On va aborder dans ce chapitre sans doute la plus célèbre des PEP, à savoir la PEP 8, qui est incontournable lorsque l’on veut écrire du code Python correctement.
Déﬁnition On parle de code pythonique lorsque ce dernier respecte les règles d’écriture déﬁnies par la communauté Python mais
aussi les règles d’usage du langage.
15.1 De la bonne syntaxe avec la PEP 8
La PEP 8 Style Guide for Python Code 2 est une des plus anciennes PEP (les numéros sont croissants avec le temps). Elle consiste en un nombre important de recommandations sur la syntaxe de Python. Il est vivement recommandé de lire la PEP 8 en entier au moins une fois pour avoir une bonne vue d’ensemble. On ne présentera ici qu’un rapide résumé de cette PEP 8.
15.1.1 Indentation
On a vu que l’indentation est obligatoire en Python pour séparer les blocs d’instructions. Cela vient d’un constat simple, l’indentation améliore la lisibilité d’un code. Dans la PEP 8, la recommandation pour la syntaxe de chaque niveau d’indentation est très simple : 4 espaces. N’utilisez pas autre chose, c’est le meilleur compromis.
1. https://www.python.org/dev/peps/ 2. https://www.python.org/dev/peps/pep-0008/
99

Chapitre 15. Bonnes pratiques en programmation Python

15.1. De la bonne syntaxe avec la PEP 8

Attention
Aﬁn de toujours utiliser cette règle des 4 espaces pour l’indentation, il est essentiel de régler correctement votre éditeur de texte. Consultez pour cela l’annexe Installation de Python disponible en ligne 3). Avant d’écrire la moindre ligne de code, faites en sorte que lorsque vous pressez la touche tabulation, cela ajoute 4 espaces (et non pas un caractère tabulation).

15.1.2 Importation des modules
Comme on l’a vu au chapitre 8 Modules, le chargement d’un module se fait avec l’instruction import module plutôt qu’avec from module import *.
Si on souhaite ensuite utiliser une fonction d’un module, la première syntaxe conduit à module.fonction() ce qui rend explicite la provenance de la fonction. Avec la seconde syntaxe, il faudrait écrire fonction() ce qui peut :
— mener à un conﬂit si une de vos fonctions à le même nom ; — rendre difﬁcile la recherche de documentation si on ne sait pas d’où vient la fonction, notamment si plusieurs modules
sont chargés avec l’instruction from module import * Par ailleurs, la première syntaxe déﬁnit un « espace de noms » (voir chapitre 19 Avoir la classe avec les objets) spéciﬁque au module. Dans un script Python, on met en général un module par ligne. D’abord les modules internes (classés par ordre alphabétique), c’est-à-dire les modules de base de Python, puis les modules externes (ceux que vous avez installés en plus). Si le nom du module est trop long, on peut utiliser un alias. L’instruction from est tolérée si vous n’importez que quelques fonctions clairement identiﬁée. En résumé :
1 import module_interne_1 2 import module_interne_2 3 from module_interne_3 import fonction_spécifique 4 from module_interne_4 import constante_1 , fonction_1 , fonction_2
5
6 import module_externe_1 7 import module_externe_2 8 import module_externe_3_qui_a_un_nom_long as mod3
15.1.3 Règles de nommage
Les noms de variables, de fonctions et de modules doivent être de la forme :
1 ma_variable 2 fonction_test_27 () 3 mon_module
c’est-à-dire en minuscules avec un caractère « souligné » (« tiret du bas » ou underscore en anglais) pour séparer les différents « mots » dans le nom.
Les constantes sont écrites en majuscules :
1 MA_CONSTANTE 2 VITESSE_LUMIERE
Les noms de classes (chapitre 19) et les exceptions (chapitre 21) sont de la forme :
1 MaClasse 2 MyException
Remarque Le style recommandé pour nommer les variables et les fonctions en Python est appelé snake_case. Il est différent du
CamelCase utilisé pour les noms des classes et des exceptions.
Pensez à donner à vos variables des noms qui ont du sens. Évitez autant que possible les a1, a2, i, truc, toto. . . Les noms de variables à un caractère sont néanmoins autorisés pour les boucles et les indices :
3. https://python.sdv.univ-paris-diderot.fr/livre-dunod

100

Cours de Python / Université Paris Diderot - Paris 7 / UFR Sciences du Vivant

