Internet of Things
IN 5 DAYS

Antonio Liñán Colina

Alvaro Vives Marco Zennaro

Antoine Bagula

Ermanno Pietrosemoli

Table of Contents
About the Release ....................................................................................................... ix About the Book ........................................................................................................... xi The Internet of Things (IoT) ........................................................................................ xiii 1. Introduction to IPv6 .................................................................................................. 1
1.1. A little bit of History ....................................................................................... 1 1.2. IPv6 Concepts .............................................................................................. 2
1.2.1. IPv6 packet ........................................................................................ 3 1.2.2. IPv6 addressing ................................................................................. 6 1.2.3. IPv6 network prefix ............................................................................. 8 1.3. What is IPv6 used for? ................................................................................ 10 1.4. Network Example ........................................................................................ 12 1.5. Short intro to Wireshark ............................................................................... 13 1.6. IPv6 Exercises ............................................................................................ 17 1.7. Addressing Exercises .................................................................................. 19 1.8. Connecting our IPv6 Network to the Internet ................................................. 20 2. Introduction to 6LoWPAN ....................................................................................... 27 2.1. Overview of LoWPANs ................................................................................ 28 2.2. About the use of IP on LoWPANs ................................................................ 29 2.3. 6LoWPAN ................................................................................................... 31 2.4. IPv6 Interface Identifier (IID) ........................................................................ 33 2.5. Header Compression ................................................................................... 34 2.6. NDP optimization ......................................................................................... 38 3. Introduction to Contiki ............................................................................................. 41 3.1. Install Contiki .............................................................................................. 41 3.1.1. Install from sources .......................................................................... 42 3.1.2. Instant Contiki Virtual Machine .......................................................... 43 3.2. Test Contiki installation ................................................................................ 44 3.3. Contiki structure .......................................................................................... 45 3.4. Run Contiki on real hardware ....................................................................... 45 3.4.1. Zolertia Zoul module and the RE-Mote development platform ............... 46 3.4.2. Zolertia Z1 mote ............................................................................... 47 3.4.3. What are the differences between the RE-Mote and the Z1 platforms? ... 48 3.5. Start with Contiki! ........................................................................................ 48 3.5.1. Hello world explained ........................................................................ 49 3.5.2. Makefile explained ............................................................................ 50 3.5.3. Adding an LED to the example .......................................................... 51
iii

Internet of Things (IoT) in 5 days
3.5.4. Printing messages to the console ...................................................... 53 3.5.5. Adding button events ........................................................................ 54 3.5.6. Timers .............................................................................................. 55 3.5.7. Sensors ............................................................................................ 56 3.6. Emulate Contiki with Cooja .......................................................................... 67 3.7. Create a new simulation .............................................................................. 68 3.8. Add motes to the simulation ......................................................................... 68 4. Wireless with Contiki .............................................................................................. 69 4.1. Preparing your device .................................................................................. 69 4.1.1. Device addressing ............................................................................ 70 4.1.2. Set the bandwidth and channel ......................................................... 72 4.1.3. Set the transmission power ............................................................... 76 4.1.4. Checking the wireless link ................................................................. 81 4.2. Configure the MAC layer ............................................................................. 85 4.2.1. MAC driver ....................................................................................... 87 4.2.2. RDC driver ....................................................................................... 88 4.2.3. Framer driver ................................................................................... 89 4.3. IPv6 and Routing ........................................................................................ 90 4.3.1. IPv6 ................................................................................................. 90 4.3.2. RPL ................................................................................................. 91 4.3.3. Set up a sniffer ................................................................................ 94 4.3.4. The Border Router ............................................................................ 98 4.4. UDP and TCP basics ................................................................................ 100 4.4.1. The UDP API ................................................................................. 101 4.4.2. Hands on: UDP example ................................................................. 104 4.4.3. Hands on: connecting an IPv6 UDP network to our host .................... 108 4.4.4. What is TCP? ................................................................................. 112 5. CoAP, MQTT and HTTP ....................................................................................... 121 5.1. CoAP example .......................................................................................... 121 5.1.1. CoAP API ....................................................................................... 122 5.1.2. Hands on: CoAP server and Copper ................................................ 125 5.2. MQTT example ......................................................................................... 133 5.2.1. MQTT API ...................................................................................... 134 5.2.2. Hands on: MQTT and mosquitto ...................................................... 138 5.3. Hands on: connecting to a real world IoT platform (HTTP-based) .................. 146 5.4. Ubidots IPv6 example in native Contiki ....................................................... 146 ACRONYMS ............................................................................................................ 151 Bibliography ............................................................................................................. 153
iv

List of Figures
1. Internet-connected devices and the future evolution (Source: Cisco, 2011) ................. xiii 2. IoT Layered Architecture (Source: ITU-T) ................................................................ xiv 3. IoT 3_Dimensional View (Source: [IoT]) ................................................................... xv 1.1. Internet Protocol stack ........................................................................................... 3 1.2. Data flow in the protocol stack ............................................................................... 4 1.3. IPv6 Header ......................................................................................................... 5 1.4. IPv6 Extension headers ......................................................................................... 6 1.5. IPv6 address ......................................................................................................... 7 1.6. Network and Interface ID ....................................................................................... 9 1.7. Packet exchange in IPv6 ..................................................................................... 11 1.8. Simple IPv6 network ............................................................................................ 12 1.9. Wireshark logo .................................................................................................... 13 1.10. Wireshark Screenshot ........................................................................................ 14 1.11. Ethernet packet ................................................................................................. 15 1.12. IPv6 packet ....................................................................................................... 15 1.13. Wireshark Filter ................................................................................................. 15 1.14. Wireshark Captured packets .............................................................................. 16 1.15. Wireshark statistics ............................................................................................ 16 1.16. Wireshark charts ............................................................................................... 17 1.17. LAN Example .................................................................................................... 19 1.18. IPv6 Connectivity ............................................................................................... 21 1.19. Native IPv6 ....................................................................................................... 22 1.20. IPv4 tunneled IPv6 ............................................................................................ 23 1.21. Local router does not support IPv6 ..................................................................... 24 1.22. Simplified Scenario ............................................................................................ 25 2.1. 6LoWPAN in the protocol stack ............................................................................ 31 2.2. 6LoWPAN headers .............................................................................................. 33 2.3. EUI-64 derived IID ............................................................................................... 34 2.4. IPv6IID ................................................................................................................ 34 2.5. Header compression ............................................................................................ 35 2.6. LoWPAN header ................................................................................................. 37 3.1. Zolertia Zoul module and the RE-Mote platform ..................................................... 46 3.2. Zolertia Z1 mote .................................................................................................. 47 3.3. Analogue sensors ................................................................................................ 58 3.4. Pin assignement .................................................................................................. 60 3.5. Light sensor ........................................................................................................ 61
v

Internet of Things (IoT) in 5 days
3.6. Connecting sensor .............................................................................................. 63 3.7. Temperature and humidity sensor ........................................................................ 66 4.1. IEEE 802.15.4 2.4 GHz regulation requirements (electronicdesign.com, 2013) ......... 73 4.2. Thread layers and standards (Thread group, 2015) ............................................... 74 4.3. Channel assignment ............................................................................................ 75 4.4. Link quality estimation process ............................................................................. 81 4.5. Packet rejection rate versus received signal strenght indicator ................................ 83 4.6. Packet rejection rate versus link quality indicator ................................................... 85 4.7. Contiki MAC stack ............................................................................................... 87 4.8. RPL in the protocol stack .................................................................................... 92 4.9. Sniffer packet capture .......................................................................................... 94 4.10. Capture options ................................................................................................. 96 4.11. Interface settings ............................................................................................... 97 4.12. Captured frames ................................................................................................ 97 4.13. Wireshark filters ................................................................................................. 98 4.14. The border router .............................................................................................. 98 4.15. Z1 mote talking to the PC host ......................................................................... 112 5.1. Copper CoAP plugin Screenshot ........................................................................ 133 5.2. MQTT publish/suscribe ...................................................................................... 133 5.3. MQTT with Mosquitto ......................................................................................... 138 5.4. Ubidots endpoint IPv4/IPv6 addresses ................................................................ 147 5.5. Ubidots graphs .................................................................................................. 149
vi

List of Tables
4.1. CC2538 Transmission power recommended values (from SmartRF Studio) ............. 77 4.2. CC2420 Transmission power (CC2420 datasheet, page 51) ................................... 78 4.3. CC1200 Transmission power recommended values (from SmartRF Studio) ............. 79
vii

viii

About the Release
This "IoT in five days" release version correspond to: Version: 1.0 Date: 7th February 2016
This book and sources are distributed under the terms of the Creative Commons AttributionNonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) 1 .
1 https://creativecommons.org/licenses/by-nc-sa/4.0/
ix

x

About the Book
The "IoT in five days" book is in active development by a joint effort from both academia and industrial collaborators, acknowledging that the Internet of Things of the future will be built on top of scalable and mature protocols, such as IPv6, 6LoWPAN and IEEE 802.15.4. Open Source Operating Systems as Contiki, with more than 10 years of history and actively supported by universities and research centers, have been paving the Internet of Things road since the early beginnings of Wireless Sensor Networks and M2M communication, enabling the new IoT paradigm.
The content of the book are Open Source as well, feedback and contribution is more than welcome! Please engage visiting IoT in five days GitHub repository 1
The book has been developed in asciidoc, and it can be compiled from its sources to produce HTML, PDF, eBook and others formats.
The following are the authors who contributed to this book:
Antonio Liñán defines himself as "an engineer at day, maker at night" (he would do both for free). He has more than 8 years of experience,having worked in over than 20 projects of in Wireless Sensor Networks (WSN), Internet of Things (IoT) applications and embedded firmware development; employed at Zolertia as both senior R+D engineer and CTO, buf if you ask him he just "makes things blink and chat". In his free time he’s normally engaged in Coursera, collecting hardware platforms, dwelling in hackathons or preaching about GIT. He has a Master at the University of Los Andes (Colombia), has worked in European Projects related to Smart Cities, Internet of Things and Security, and currently is a prominent contributor in severals Open Source communities, like the one focusing on Contiki.
Alvaro Vives loves technology, problem solving, learning and teaching. Doing these things he has become a consultant, a network and systems engineer, and a trainer. As a consultant, he has worked on projects in several countries, at ISPs, content providers, public organizations and enterprises. As a trainer, since 2006 has lectured at more than 46 workshops in 18 countries directed to ISPs, content providers, public organizations, enterprises as well as in events like LACNIC/LACNOG, SANOG, WALC, and ESNOG. As network and systems administrator he has been in charge of production networks and services in several companies using different technologies from a variety of vendors. At present, he is working with WSN and IoT as a consequence of the convergence of IPv6 and IoT.
1 https://github.com/marcozennaro/IPv6-WSN-book
xi

Antoine Bagula obtained his doctoral degree in 2006 from the KTH-Royal Institute of Technology in Sweden. He held lecturing positions at StellenboschUniversity (SUN) and the University of Cape Town (UCT) before joining the Computer Science department at the University of the Western Cape in January 2014. Since 2006, He has been a frequent consultant of the UNESCO through its International Centre for Theoretical Physics in Trieste, Italy, the World Bank and other international organizations on different telecommunication projects. His research interest lies on the Internet-of-Things, Big Data and Cloud Computing, Network security and Network protocols for wireless, wired and hybrid networks.
Marco Zennaro received his M.Sc. degree in Electronic Engineering from University of Trieste in Italy. He defended his PhD thesis on “Wireless Sensor Networks for Development: Potentials and Open Issues” at KTH-Royal Institute of Technology, Stockholm, Sweden. His research interest is in ICT4D, the use of ICT for development. In particular, he is interested in Wireless Networks and in Wireless Sensor Networks in developing countries. He has been giving lectures on Wireless technologies in more than 20 countries.
When not traveling, he is the editor of the wsnblog.com 2 . He is coauthor of the book “Wireless Networking for the Developing World”.
Ermanno Pietrosemoli is currently a researcher at the Telecommunications/ICT for Development Lab of the International Centre for Theoretical Physics in Trieste, Italy, and President of Fundación Escuela Latinoamericana de Redes, “EsLaRed”, a non-profit organization that promotes ICT in Latin America through training and development projects. EsLaRed was awarded the 2008 Jonathan B.Postel Service Award by the Internet Society.
Ermanno has been deploying wireless data communication networks focusing on low cost technology, participating in the planning and building of wireless data networks in Argentina, Colombia, Ecuador, Italy, Lesotho, Malawi, Mexico, Micronesia, Morocco, Mozambique, Nicaragua, Peru, Trinidad, U.S.A., Venezuela and Zambia. He has presented in many conferences, published several papers related to wireless data communication, and is coauthor and technical reviewer of the (freely available) book “Wireless Networking for the Developing World” 3 . Ermanno holds a Master’s degree from Stanford University and was Professor of Telecommunications at Universidad de los Andes in Venezuela from 1970 to 2000.
2 http://wsnblog.com 3 http://wndw.net
xii

The Internet of Things (IoT)
Building upon a complex network connecting billions of devices and humans into a multitechnology, multi-protocol and multi-platform infrastructure, the Internet-of-Things (IoT) main vision is to create an intelligent world where the physical, the digital and the virtual are converging to create smart environments that provide more intelligence to the energy, health, transport, cities, industry, buildings and many other areas of our daily life. The expectation is that of interconnecting millions of islands of smart networks enabling access to the information not only “anytime” and “anywhere” but also using “anything” and “anyone” ideally through any “path”, “network” and “any service”. This will be achieved by having the objects that we manipulate daily to be outfitted with sensing, identification and positioning devices and endowed with an IP address to become smart objects, capable of communicating with not only other smart objects but also with humans with the expectation of reaching areas that we could never reach without the advances made in the sensing, identification and positioning technologies. While being globally discoverable and queried, these smart objects can similarly discover and interact with external entities by querying humans, computers and other smart objects. The smart objects can also obtain intelligence by making or enabling context related decisions taking advantage of the available communication channels to provide information about themselves while also accessing information that has been aggregated by other smart objects.
Figure 1. Internet-connected devices and the future evolution (Source: Cisco, 2011)
As revealed by Figure 1, the IoT is the new essential infrastructure which is predicted to connect 50 billion of smart objects in 2020 when the world population will reach 7.6 billion.
xiii

As suggested by the ITU, such essential infrastructure will be built around a multi-layered architecture where the smart objects will be used to deliver different services through the four main layers depicted by Figure 2: a device layer, a network layer, a support layer and the application layer. In the device layer lie devices (sensors, actuators, RFID devices) and gateways used to collect the sensor readings for further processing while the network layer provides the necessary transport and networking capabilities for routing the IoT data to processing places. The support layer is a middleware layer that serves to hide the complexity of the lower layers to the application layer and provide specific and generic services such as storage in different forms (database management systems and/or cloud computing systems) and many other services such as translation.
Figure 2. IoT Layered Architecture (Source: ITU-T)
As depicted in Figure 3, the IoT can be perceived as an infrastructure driving a number of applications services which are enabled by a number of technologies. Its application services expand across many domains such as smart cities, smart transport, smart buildings, smart energy, smart industry and smart health while it is enabled by different technologies such as sensing, nanoeletronics, wireless sensor network (WSN), radio frequency identification (RFID), localization, storage and cloud. The IoT systems and applications are designed to provide security, privacy, safety, integrity, trust, dependability, transparency, anonymity and are bound by ethics constraints.
xiv

Figure 3. IoT 3_Dimensional View (Source: [IoT])
Experts say we are heading towards what can be called a "ubiquitous network society", one in which networks and networked devices are omnipresent. RFID and wireless sensors promise a world of networked and interconnected devices that provide relevant content and information whatever the location of the user. Everything from tires to toothbrushes will be in communications range, heralding the dawn of a new era, one in which today’s Internet (of data and people) gives way to tomorrow’s Internet of Things.
At the dawn of the Internet revolution, users were amazed at the possibility of contacting people and information across the world and across time zones. The next step in this technological revolution (connecting people any-time, anywhere) is to connect inanimate objects to a communication network. This vision underlying the Internet of things will allow the information to be accessed not only "anytime" and "anywhere" but also by "anything". This will be facilitated by using WSNs and RFID tags to extend the communication and monitoring potential of the network of networks, as well as the introduction of computing power in everyday items such as razors, shoes and packaging.
WSNs are an early form of ubiquitous information and communication networks. They are one of building blocks of the Internet of things.
Wireless Sensor Networks
A Wireless Sensor Network (WSN) is a self-configuring network of small sensor nodes (socalled motes) communicating among them using radio signals, and deployed in quantity to sense the physical world. Sensor nodes are essentially small computers with extremely basic functionality. They consist of a processing unit with limited computational power and limited memory, a radio communication device, a power source and one or more sensors.
Motes come in different sizes and shapes, depending on their foreseen use. They can be very small, if they are to be deployed in big numbers and need to have little visual impact. They can
xv

have a rechargeable battery power source if they are to be used in a lab. The integration of these tiny, ubiquitous electronic devices in the most diverse scenarios ensures a wide range of applications. Some of the application areas are environmental monitoring, agriculture, health and security.
In a typical application, a WSN is scattered in a region where it is meant to collect data through its sensor nodes. These networks provide a bridge between the physical world and the virtual world. They promise unprecedented abilities to observe and understand large scale, realworld phenomena at a fine spatio-temporal resolution. This is so because one deploys sensor nodes in large numbers directly in the field, where the experiments take place. All motes are composed of five main elements as shown below:
1. Processor: the task of this unit is to process locally sensed information and information sensed by other devices. At present the processors are limited in terms of computational power, but given Moore’s law, future devices will come in smaller sizes, will be more powerful and consume less energy. The processor can run in different modes: sleep is used most of the time to save power, idle is used when data can arrive from other motes, and active is used when data is sensed or sent to / received from other motes.
2. Power source: motes are meant to be deployed in various environments, including remote and hostile regions so they must use little power. Sensor nodes typically have little energy storage, so networking protocols must emphasize power conservation. They also must have built-in mechanisms that allow the end user the option of prolonging network lifetime at the cost of lower throughput. Sensor nodes may be equipped with effective power scavenging methods, such as solar cells, so they may be left unattended for months, or years. Common sources of power are rechargeable batteries, solar panels and capacitors.
3. Memory: it is used to store both programs (instructions executed by the processor) and data (raw and processed sensor measurements).
4. Radio: WSN devices include a low-rate, short-range wireless radio. Typical rates are 10-100 kbps, and range is less than 100 meters. Radio communication is often the most power-intensive task, so it is a must to incorporate energy-efficient techniques such as wake-up modes. Sophisticated algorithms and protocols are employed to address the issues of lifetime maximization, robustness and fault tolerance.
5. Sensors: sensor networks may consist of many different types of sensors capable of monitoring a wide variety of ambient conditions. Table 1 classifies the three main categories of sensors based on field-readiness and scalability. While scalability reveals if the sensors are small and inexpensive enough to scale up to many distributed systems, the field-readiness describes the sensor’s engineering efficiency with relation to field
xvi

deployment. In terms of the engineering efficiency, Table 1 reveals high field-readiness for most physical sensors and for a few chemical sensors since most chemical sensors lie in the medium and low levels, while biological sensors have low field-readiness.

Sensor Category Physical Chemical
Biological

Parameter

Field-Readiness

Temperature

High

Moisture Content

High

Flow rate, Flow velocity

High

Pressure

High

Light Transmission (Turb)

High

Dissolved Oxygen High

Electrical Conductivity

High

pH

High

Oxydation Reduction Medium Potential

Major Ionic Species Low-Medium (Cl-, Na+)

Nutrientsa (Nitrate, Ammonium)

Low-Medium

Heavy metals

Low

Small Organic

Low

Compounds

Large Organic

Low

Compounds

Microorganisms

Low

Biologically active Low contaminants

Scalability High High Med-High
High High
High High
High High
High
Low-High
Low Low
Low
Low Low

Common applications include the sensing of temperature, humidity, light, pressure, noise levels, acceleration, soil moisture, etc. Due to bandwidth and power constraints, devices primarily support low-data-units with limited computational power and limited rate of sensing.

xvii

Some applications require multi-mode sensing, so each device may have several sensors on board.
Following is a short description of the technical characteristics of WSNs that make this technology attractive.
1. Wireless Networking: motes communicate with each other via radio in order to exchange and process data collected by their sensing unit. In some cases, they can use other nodes as relays, in which case the network is said to be multi-hop. If nodes communicate only directly with each other or with the gateway, the network is said to be single-hop. Wireless connectivity allows to retrieve data in real-time from locations that are difficult to access. It also makes the monitoring system less intrusive in places where wires would disturb the normal operation of the environment to monitor. It reduces the costs of installation: it has been estimated that wireless technology could eliminate up to 80 % of this cost.
2. Self-organization: motes organize themselves into an ad-hoc network, which means they do not need any pre-existing infrastructure. In WSNs, each mote is programmed to run a discovery of its neighborhood, to recognize which are the nodes that it can hear and talk to over its radio. The capacity of organizing spontaneously in a network makes them easy to deploy, expand and maintain, as well as resilient to the failure of individual points.
3. Low-power: WSNs can be installed in remote locations where power sources are not available. They must therefore rely on power given by batteries or obtained by energy harvesting techniques such as solar panels. In order to run for several months of years, motes must use low-power radios and processors and implement power efficient schemes. The processor must go to sleep mode as long as possible, and the Medium-Access layer must be designed accordingly. Thanks to these techniques, WSNs allow for long-lasting deployments in remote locations.
Applications of Wireless Sensor Networks
The integration of these tiny, ubiquitous electronic devices in the most diverse scenarios ensures a wide range of applications. Some of the most common application areas are environmental monitoring, agriculture, health and security. In a typical application, a WSN include:
1. Tracking the movement of animals. A large sensor network has been deployed to study the effect of micro climate factors in habitat selection of sea birds on Great Duck Island in Maine, USA. Researchers placed their sensors in burrows and used heat to detect the presence of nesting birds, providing invaluable data to biological researchers. The deployment was heterogeneous in that it employed burrow nodes and weather nodes.
xviii

2. Forest fire detection. Since sensor nodes can be strategically deployed in a forest, sensor nodes can relay the exact origin of the fire to the end users before the fire is spread uncontrollable. Researchers from the University of California, Berkeley, demonstrated the feasibility of sensor network technology in a fire environment with their FireBug application.
3. Flood detection. An example is the ALERT system deployed in the US. It uses sensors that detect rainfall, water level and weather conditions. These sensors supply information to a centralized database system.
4. Geophysical research. A group of researchers from Harvard deployed a sensor network on an active volcano in South America to monitor seismic activity and similar conditions related to volcanic eruptions.
5. Agricultural applications of WSN include precision agriculture and monitoring conditions that affect crops and livestock. Many of the problems in managing farms to maximize production while achieving environmental goals can only be solved with appropriate data. WSN can also be used in retail control, particularly in goods that require being maintained under controlled conditions (temperature, humidity, light intensity, etc) [SusAgri].
6. An application of WSN in security is predictive maintenance. BP’s Loch Rannoch project developed a commercial system to be used in refineries. This system monitors critical rotating machinery to evaluate operation conditions and report when wear and tear is detected. Thus one can understand how a machine is wearing and perform predictive maintenance. Sensor networks can be used to detect chemical agents in the air and water. They can also help to identify the type, concentration and location of pollutants.
7. An example of the use of WSN in health applications is the Bi-Fi, embedded system architecture for patient monitoring in hospitals and out-patient care. It has been conceived at UCLA and is based on the SunSPOT architecture by Sun. The motes measure highrate biological data such as neural signals, pulse oximetry and electrocardiographs. The data is then interpreted, filtered, and transmitted by the motes to enable early warnings.
Roles in a Wireless Sensor Network
Nodes in a WSN can play different roles.
1. Sensor nodes are used to sense their surroundings and transmit the sensor readings to a sink node, also called "base station". They are typically equipped with different kinds of sensors. A mote is endowed with on-board processing, communication capabilities and sensing capabilities.
2. Sink nodes or "base stations" are tasked to collect the sensor readings of the other nodes and pass these readings to a gateway to which they are directly connected for
xix

further processing/analysis. A sink node is endowed with minimal on-board processing and communication capabilities but does not have sensing capabilities. 3. Actuators are devices which are used to control the environment, based on triggers revealed by the sensor readings or by other inputs. An actuator may have the same configuration as a mote but it is also endowed with controlling capabilities, for example to switch a light on under low luminosity. Gateways often connected to sink nodes and are usually fed by a stable power supply since they consume considerable energy. These entities are normal computing devices such as laptops, notebooks, desktops, mobile phones or other emerging devices which are able to store, process and route the sensor readings to the processing place. However, they may not be endowed with sensing capabilities. Being range-limited, sensor motes require multi-hop communication capabilities to allow: 1) spanning distances much larger than the transmission range of a single node through localized communication between neighbor nodes 2) adaptation to network changes, for example, by routing around a failed node using a different path in order to improve performance and 3) using less transmitter power as a result of the shorter distance to be spanned by each node. They are deployed in three forms : (1) Sensor node used to sense the environment (2) Relay node used as relay for the sensor readings received from other nodes and (3) Sink node also often called base station which is connected to a gateway (laptop, tablet, iPod, Smart phone, desktop) with higher energy budget capable of either processing the sensor readings locally or to transmit these readings to remote processing places.
xx

Chapter 1. Introduction to IPv6
IPv6 stands for Internet Protocol version 6, so the importance of IPv6 is implicit in its name, it’s as important as the Internet! The Internet Protocol (IP from now on) was intended as a solution to the need to interconnect different data networks, and has become the “de facto” standard for all kinds of digital communications. Nowadays IP is present in most devices that are able to send and receive digital information, not only the Internet.
IP is standardized by the IETF (Internet Engineering Task Force), the organization in charge of all the Internet standards, guaranteeing the interoperability among software from different vendors. The fact that IP is a standard is of vital importance, because today everything is getting connected to the Internet using IP. All common Operating Systems and networking libraries support IP to send and receive data. As part of this "everything-connected-to-Internet" is the IoT, so now you know why you are reading this chapter about IPv6, the last version of the Internet Protocol. In other words, today, the easiest way to send and receive data is by means of the standards used in the Internet, including IP.
The objectives of this chapter are:
• Briefly describe the history of the Internet Protocol.
• Find out what IPv6 is used for.
• Get the IPv6 related concepts needed to understand the rest of the book.
• Provide a practical overview of IPv6, including addresses and a glimpse of how an IPv6 network looks like.
1.1. A little bit of History
ARPAnet was the first attempt of the US Department of Defense (DoD) to devise a decentralized network more resilient to an attack, while able to interconnect completely different systems. ARPAnet was created in the seventies, but it was in 1983 when a brand new protocol stack was introduced, TCP/IP. The first widely used network protocol version was IPv4 (Internet Protocol version 4) which paved the way to the civilian Internet. Initially only research centers and universities were connected, supported by the NSF (National Science Foundation), and commercial applications where not allowed, but when the network started growing exponentially the NSF decided to transfer its operation and funding to private operators, lifting the restrictions to commercial traffic. While the main applications were email
1

IPv6 Concepts
and file transfer, it was with the development of the World Wide Web based on the HTML protocol and specifically with the MOSAIC graphic interface browser and its successors that the traffic really exploded and the Internet began to be used by the masses. As a consequence there was a rapid depletion in the number of IP addresses available under IPv4, which was not designed to scale to these levels.
In order to allow for more addresses, you need a longer IP address space (greater number of bits to specify the address), which means a new architecture, which means changes to most of the routing and network software. After examining a number of proposals, the IETF settled on IPv6, described in the January 1995 RFC (Request for Comment, the official IETF documentation naming) 1752, sometimes also referred to as the Next Generation Internet Protocol, or IPng. The IETF updated the IPv6 standard in 1998 with the current definition covered in RFC 2460. By 2004, IPv6 was widely available from industry and supported by most new network equipment. Today IPv6 coexists with IPv4 in the Internet and the amount of IPv6 traffic is quickly growing as more and more ISPs and content providers have started supporting IPv6.
As you can see, the history of IP and Internet are almost the same, and because of this the growth of Internet is been hampered by the limitations of IPv4, and has led to the development of a new version of IP, IPv6, as the protocol to be used to interconnect all sorts of devices to send and/or receive information. There are even some technologies that are being developed only with IPv6 in mind, a good example in the context of the IoT is 6LowPAN.
From now on we will only center on IPv6. If you know something about IPv4, then you have half the way done, if not, don’t worry we will cover the main concepts briefly and gently.
1.2. IPv6 Concepts
We will cover the the minimum you need to know about the last version of the Internet Protocol to understand why it’s so useful for the IoT and how it’s related with other protocols like 6LowPAN discussed later. We will assume that you are familiar with bits, bytes, networking stack, network layer, packets, IP header, etc. You should understand that IPv6 is a different protocol, non-compatible with IPv4.
In the following figure we represent the layered model used in the Internet.
2

IPv6 packet
Figure 1.1. Internet Protocol stack
IPv6 sits in layer 3, called network layer. The pieces of data handled by layer 3 are called packets. Devices connected to the Internet can be hosts or routers. A host can be a PC, a laptop or a sensor board, sending and/or receiving data packets. Hosts will be the source or destination of the packets. Routers instead are in charge of packet forwarding, and are responsible of choosing the next router that will forward them towards the final destination. Internet is composed of a lot of interconnected routers, which receive data packets in one interface and send then as quick as possible using another interface towards another forwarding router.
1.2.1. IPv6 packet
The first thing you should know is what an IPv6 packet looks like. In the layered model we saw before, each layer introduces its own information in the packet, and this information is intended for, and can only be processed by the same layer in another IP device. This "conversation" between layers at the same level on different devices must follow a protocol. The Internet layers are: • Application: Here resides the software developed by programmers, that will use network
services offered by the network stack. An example is the web browser that opens a network connection towards a web server. Another example is the web server software that runs in a server somewhere in the Internet waiting to answer request from client’s browsers. Examples of application protocols are HTTP and DNS. • Transport: Is a layer above the network layer that offers additional to it, for example, retransmission of lost packets or guaranteeing that the packets are received in the same order they were sent. This layer will be the one that shows a "network service" to the application layer, a service they can use to send or receive data. TCP and UDP are the most common transport protocols used in Internet.
3

IPv6 packet
• Network: This is the layer in charge of the correct delivery of the data received from the transport layer to its destination, as well as the reception of the received data from the link layer at the data destination. Internet uses only one protocol in this layer, namely IP. Source and destination are identified by means of the IP addresses.
• Link: Link layer is in charge of sending and receiving frames, a collection of bytes sent from the network layer, in the realm of a local area network or LAN. It specifies the mecanism used to share the medim among diffrent nodes. This layer has its own addresses, which depend on the technology deployed.
• Physical: This layer is in charge of the details of the electromagnetic signal, codifications, etc. needed for the digital information to go from one node to another. All physical media are included, both wired and wireless.
The following figure illustrates the idea that each of the layers described receive some bytes from the layer above and adds some specific information pertaining that layer to be processed in the receiving host. In the figure data originating at the application layer is sent to the physical layer of another node.
Figure 1.2. Data flow in the protocol stack
The bytes sent and received in the IP packet follow a standard format. The following figure shows the basic IPv6 header:
4

IPv6 packet
Figure 1.3. IPv6 Header
First you have the basic IPv6 header with a fixed size of 40 bytes, followed by upper layer data and optionally by some extension headers, which will be described later. As you can see there are several fields in the packet header, providing some improvements as compared with IPv4 header: • The number of fields has been reduced from 12 to 8. • The basic IPv6 header has a fixed size of 40 bytes and is aligned with 64 bits, allowing a
faster hardware-based packet forwarding on routers. • The size of addresses increased from 32 to 128 bits. The most important fields are the source and destination addresses. As you already know, every IP device has a unique IP address that identifies it in the Internet. This IP address is used by routers to take their forwarding decisions. IPv6 header has 128 bits for each IPv6 address, this allows for 2128 addresses (approximately 3.4×1038,i.e., 3.4 followed by 38 zeroes), whereas IPv4 uses 32 bits to encode each of the 232 addresses (4,294,967,296) allowed. We have seen the basic IPv6 header, and mentioned the extension headers. To keep the basic header simple and of a fixed size, additional features are added to IPv6 by means of extension headers.
5

IPv6 addressing
Figure 1.4. IPv6 Extension headers
Several extension headers have been defined, as you can see in the previous figure, and they have to follow the order shown. Extensions headers: • Provide flexibility, for example, to enable security by ciphering the data in the packet. • Optimize the processing of the packet, because with the exception of the hop by hop
header, extensions are processed only by end nodes, (source and final destination of the packet), not by every router in the path. • They are located as a "chain of headers" starting always in the basic IPv6 header, that use the field next header to point to the following extension header.
1.2.2. IPv6 addressing
1. The use of 128 bits for addresses brings some benefits: • Provides many more addresses, to satisfy current and future needs, with ample space for innovation. • Simplifies address auto-configuration mechanisms. • Easier address management/delegation. • Room for more levels of hierarchy and for route aggregation. • Ability to do end-to-end IPsec.
IPv6 addresses are classified into the following categories (which also exist in IPv4): 6

IPv6 addressing
• Unicast (one-to-one): used to send a packet from the source to a single destination. They are the commonest ones and we will talk more about them and their sub-classes.
• Multicast (one-to-many): used to send a packet from the source to several destinations. This is possible by means of multicast routing that enable packets to replicate in some places.
• Anycast (one-to-nearest): used to send a packet from the source to the nearest destination from a set of them.
• Reserved: Addresses or groups of them for special uses, for example addresses to be used on documentation and examples.
Before entering into more detail about IPv6 addresses and the types of unicast addresses, let’s see how do they look like and what are the notation rules. You need to have them clear because probably the first problem you will find in practice when using IPv6 is how to write an address.
Figure 1.5. IPv6 address
IPv6 addresses notation rules are: • 8 Groups of 16 bits separated by “:”. • Hexadecimal notation of each nibble (4 bits). • Non case sensitive. • Network Prefixes (group of addresses) are written Prefix / Prefix Length, i.e., prefix length
indicate the number of bits of the address that are common for the group. • Leftmost zeroes within each group can be eliminated. • One or more all-zero-groups can be substituted by “::”. This can be done only once. The first three rules tell you the basis of IPv6 address notation. They use hexadecimal notation, i.e., numbers are represented by sixteen symbols between 0 and F. You will have eight groups
7

IPv6 network prefix
of four hexadecimal symbols, each group separated by a colon ":". The last two rules are for address notation compression, we will see how this works in the following.
Let’s see some examples:
1) If we represent all the address bits we have the preferred form, for example: 2001:0db8:4004:0010:0000:0000:6543:0ffd
2) If we use squared brackets around the address we have the literal form of the address: [2001:0db8:4004:0010:0000:0000:6543:0ffd]
3) If we apply the fourth rule, allowing compression within each group by eliminating leftmost zeroes, we have: 2001:db8:4004:10:0:0:6543:ffd
4) If we apply the fifth rule, allowing compression of one or more consecutive groups of zeroes using "::", we have: 2001:db8:4004:10::6543:ffd
Care should be taken when compressing and decompressing IPv6 addresses. The process should be reversible. It’s very common to have some mistakes. For example, the following address 2001:db8:A:0:0:12:0:80 could be compressed even more using "::". we have two options:
a) 2001:db8:A::12:0:80 b) 2001:db8:A:0:0:12::80
Both are correct IPv6 addresses. But the address 2001:db8:A::12::80 is wrong, since it does not follow the last compression rule we saw above. The problem with this badly compressed address is that we can’t be sure how to expand it, its ambiguous. We can’t know if it expands to 2001:db8:A:0:12:0:0:80 or to 2001:db8:A:0:0:12:0:80 .
1.2.3. IPv6 network prefix
Last but not least you have to understand the concept of a network prefix, that indicates some fixed bits and some non-defined bits that could be used to create new sub-prefixes or to define complete IPv6 addresses assigned to hosts.
Let’s see some examples:
1) The network prefix 2001:db8:1::/48 (the compressed form of 2001:0db8:0001:0000:0000:0000:0000:0000 ) indicates that the first 48 bits will always be the same ( 2001:0db8:0001 ) but that we can play with the other 80 bits, for example, to obtain two smaller prefixes: 2001:db8:1:a::/64 and 2001:db8:1:b::/64 .
8

IPv6 network prefix
2) If we take one of the smaller prefixes defined above, 2001:db8:1:b::/64 , where the first 64 bits are fixed we have the rightmost 64 bits to assign, for example, to an IPv6 interface in a host: 2001:db8:1:b:1:2:3:4 . This last example allow us to introduce a basic concept in IPv6: * A /64 prefix is always used in a LAN (Local Area Network) . *The rightmost 64 bits, are called the interface identifier (IID) because they uniquely identify a host’s interface in the local network defined by the /64 prefix. The following figure illustrates this statement:
Figure 1.6. Network and Interface ID
Now that you have seen your first IPv6 addresses we can enter into more detail about two types of addresses you will find when you start working with IPv6: reserved and unicast.
• The unspecified address, used as a placeholder when no address is available: 0:0:0:0:0:0:0:0 (::/128)
• The loopback address, is used by a node to send an IPv6 packet to itself: 0:0:0:0:0:0:0:1 (::1/128)
• Documentation Prefix: 2001:db8::/32 . This prefix is reserved to be used in examples and documentation, you have already seen it in this chapter.
As specified in [RFC6890] IANA maintains a registry of special purpose IPv6 addresses [IANAIPV6-SPEC].
The following are some other types of unicast addresses [RFC4291]:
• Link-local: Link-local addresses are always present in an IPv6 interface that is connected to a network. They all start with the prefix FE80::/10 and can be used to communicate with other hosts on the same local network, i.e., all hosts connected to the same switch. They cannot be used to communicate with other networks, i.e., to send or receive packets through a router.
• ULA (Unique Local Address) [RFC4193]: All ULA addresses start with the prefix FC00::/7, which in practice means that you could see FC00::/8 or FD00::/8 . Intended for local communications, usually inside a single site, they are not expected to be routable on the global Internet butused only inside a more limited environment.
• Global Unicast: Equivalent to the IPv4 public addresses, they are unique in the whole Internet and can be used to send a packet from one site to any destination in Internet.
9

What is IPv6 used for?
1.3. What is IPv6 used for?
As we have seen IPv6 has some features that facilitates things like global addressing and host’s address autoconfiguration. Because IPv6 provides as many addresses as we may need for some hundreds of years, we can put a global unicast IPv6 address on almost anything we may think of. This brings back the initial Internet paradigm that every IP device could communicate with every IP device. This end-to-end communication allows bidirectional communication all over the Internet and between any IP device, which could result in collaborative applications and new ways of storing, sending and accessing the information.
In the context of this book we can, for example, contemplate IPv6 sensors all around the world collecting, sending and being accessed from different places to create a world-wide mesh of physical values measured, stored and processed.
The availability of a huge amount of addresses has allowed a new mechanism called stateless address autoconfiguration (SLAAC) that didn’t exist with IPv4. Here is a brief summary of different ways to configure an address on an IPv6 interface:
• Statically: You can decide which address you will give to your IP device and then manually configure it into the device using any kind of interface: web, command line, etc. Normally you also have to configure other network parameters like the gateway to use to send packets out of your network.
• DHCPv6 (Dynamic Host Configuration Protocol for IPv6) [RFC3315]: A porting of the similar mechanism already available in IPv4. You need to configure a dedicated server that after a brief negotiation with the device assigns an IP address to it. DHCPv6 allows IP devices to be configured automatically, this is why it is named stateful address autoconfiguration, because the DHCPv6 server maintains a state of assigned addresses.
• SLAAC: Stateless address autoconfiguration [RFC4862] is a new mechanism introduced with IPv6 that allows to configure automatically all network parameters on an IP device using the router that gives connectivity to a network.
The advantage of SLAAC is that it simplifies the configuration of "dumb" devices, like sensors, cameras or any other device with low processing power. You don’t need to use any interface in the IP device to configure anything, just "plug and net". It also simplifies the network infrastructure needed to build a basic IPv6 network, because you don’t need additional device/ server, you use the same router you need to send packets outside your network to configure the IP devices. We are not going to enter into details, but you just need to know that in a LAN (Local Area Network), connected to Internet by means of a router, this router is in
10

What is IPv6 used for?
charge of sending all the configuration information needed to its hosts using an RA (Router Advertisement) message. The router will send RAs periodically, but in order to expedite the process a host can send an RS (Router Solicitation) message when its interface gets connected to the network. The router will send an RA immediately in response to the RS. The following figure show the packet exchange between a host that has just connected to a local network and some IPv6 destination in the Internet:
Figure 1.7. Packet exchange in IPv6
1) R1 is the router that gives connectivity to the host in the LAN and is periodically sending RAs. 2) Both R1 and Host have a link-local address in their interfaces connected to the host’s LAN, this address is configured automatically when the interface is ready. Our host creates it’s linklocal address by combining the 64 leftmost bits of the link-local’s prefix ( fe80::/64 ) and the 64 rightmost bits of a locally generated IID ( :3432:7ff1:c001:c2a1 ). These link-local addresses can be used in the LAN to exchange packets, but not to send packets outside the LAN. 3) The hosts needs two basic things to be able to send packets to other networks: a global IPv6 address and the address of a gateway, i.e., a router to which send the packets it wants to get routed outside its network. 4) Although R1 is sending RAs periodically (usually every several seconds) when the host get connected and has configured its link-local address, it sends an RS to which R1 responds immediately with an RA containing two things: 1. A global prefix of length 64 bits that is intended for SLAAC. The host takes the
received prefix and adds to it a locally generated IID, usually the same one used for link-
11

Network Example
local address. This way a global IPv6 address is configured in the host and now can communicate with the IPv6 Internet 2. Implicitly included is the link-local address of R1, because it is the source address of the RA. Our host can use this address to configure the default gateway, the place to which send the packets by default, to reach an IPv6 host somewhere in Internet. 5) Once both the gateway and global IPv6 address are configured, the host can receive or send information. In the figure it has something to send (Tx Data) to a host in Internet, so it creates an IPv6 packet with the destination address of the recipient host and as source address the just autoconfigured global address, which is sent to its gateway, R1’s link-local address. The destination host can answer with some data (Rx Data).
1.4. Network Example
Following we show how a simple IPv6 network looks like, displaying IPv6 addresses for all the networking devices.
Figure 1.8. Simple IPv6 network
We have four hosts, (sensors, or other devices), and we want to put a pair of them in two different places, for example two floors in a building. We are dealing with four IP devices but you can have up to 264 (18,446,744,073,709,551,616) devices connected on the same LAN. We create two LANs with a router on each one, both routers connected to a central router (R1) that provides connectivity to Internet. LAN1 is served by R2 (with link-local address fe80::2c:f3f4:1214:a on that LAN) and uses the prefix 2001:db8:1:2::/64 announced by SLAAC. LAN2 is served by R3 (with link-local address
12

Short intro to Wireshark
fe80::1b:fff4:3344:b on that LAN) and uses the prefix 2001:db8:1:3::/64 announced by SLAAC. All hosts have both a link-local IPv6 address and a global IPv6 address autoconfigured using the prefix provided by the corresponding router by means of RAs. In addition, remember that each host also configures the gateway using the link-local address used by the router for the RA. Link-local address can be used for communication among hosts inside a LAN, but for communicating with hosts in other LANs or any other network outside its own LAN a global IPv6 address is needed.
1.5. Short intro to Wireshark
What is Wireshark?
Figure 1.9. Wireshark logo
Wireshark is a free and open-source packet analyzer, which allows packet traces to be sniffed, captured, and analyzed. A packet trace is a record of traffic at some location on the network, as if a snapshot was taken of all the bits that passed across a particular wire. The packet trace records a timestamp for each packet, along with the bits that make up the packet, from the low-layer headers to the higher-layer contents. Wireshark runs on most operating systems, including Windows, MAC and Linux. It provides a graphical user interface that shows the sequence of packets and the meaning of the bits when interpreted as protocol headers and data. The packets are color-coded to convey their meaning, and Wireshark includes various ways to filter and analyze them to let you investigate different aspects of behavior. It is widely used to troubleshoot networks. A common usage scenario is when a person wants to troubleshoot network problems or look at the internal workings of a network protocol. A user could, for example,
13

Short intro to Wireshark
see exactly what happens when he or she opens up a website or sets up a wireless sensor network. It is also possible to filter and search for given packet attributes, which facilitates the debugging process. More information and installation instructions are available at Wireshark site 1 .
Figure 1.10. Wireshark Screenshot
When you open Wireshark, there are four main areas, from top to bottom: menus and filters, list of captured packets, detailed information about the selected packet, including its full content in hexadecimal and ASCII. Online directly links you to the Wiresharks site, where you can find a handy user guide and information on the security of Wireshark. Under Files, you’ll find Open, which lets you open previously captured files,, and Sample Captures. You can download any of the sample captures through this website, and study the data. This will help you understand what kind of packets Wireshark can capture. The Capture section let you choose your Interface from the available ones. It’ll also show you which ones are active. Clicking details will show you some pretty generic information about that interface. Under Start, you can choose one or more interfaces to check out. Capture Options allows you to customize what information you see during a capture. Here you can choose a filter, a capture file, and more. Under Capture Help, you can read up on how to capture, and you can check info on Network Media about which interfaces work on which platforms. Let’s select an interface and click Start. To stop a capture, press the red square in the top toolbar. If you want to start a new capture, hit the green triangle which looks like a shark fin
1 https://www.wireshark.org/
14

Short intro to Wireshark
next to it. Now that you have got a finished capture, you can click File, and save, open, or merge the capture. You can print it, you can quit the program, and you can export your packet capture in a variety of ways. You can find a certain packet, copy packets, mark (highlight) any specific packet or all the packets. Another interesting thing you can do under Edit, is resetting the time value. You’ll notice that the time is in seconds incrementing. You can reset it from the packet you’ve clicked on. You can add a comment to a packet, configure profiles and preferences. When we select a packet from the list of captured ones, Wireshark shows detailed information of the different protocols used by that packet, for example Ethernet:
Figure 1.11. Ethernet packet
Or IPv6, where we can see the fields we mentioned before: Version, Traffic class, flowlabel, payload length, next header, etc.:
Figure 1.12. IPv6 packet
There are two methods to apply filters to the list of captured packets: • Write a filter expression on the specific box and then apply it. Protocols can be
specified (ip,ipv6, icmp, icmpv6), fields of a protocol (ipv6.dst, ipv6.src) and even complex expressions can be created using operators like AND (&&), OR (||) or the negation (|).
Figure 1.13. Wireshark Filter
• Another option to create filters is to right click in one filed of a captured packet, in the list of captured packets. There will appear a menu option "Apply as filter", with several options on how to use that field.
15

Short intro to Wireshark
Figure 1.14. Wireshark Captured packets
Another useful and interesting option of Wireshark is the possibility to see statistics about the captured traffic. If we have applied filters, the statistics will be about the filtered traffic. Just go to the Statistics menu and select, for example, Protocol Hierarchy:
Figure 1.15. Wireshark statistics
Other interesting options are: • Conversation List → IPv6 • Statistics → Endpoint List → IPv6 • Statistics → IO Graph This last option allow to create graphs with different lines for different types of traffic and save the image:
16

IPv6 Exercises
Figure 1.16. Wireshark charts
1.6. IPv6 Exercises
Let’s test your IPv6 knowledge with the following exercises: 1) What is the size of IPv4 and IPv6 addresses? a. 32-bits, 128-bits b. 32-bits, 64-bits c. 32-bits, 112-bits d. 32-bits, 96-bits e. none of these 2) Which of the following is a valid IPv6 address notation rule? a. Zeroes on the right inside a group of 16 bits can be eliminated b. The address is divided in 5 groups of 16 bits separated by ":" c. The address is divided in 8 groups of 16 bits separated by "." d. One or more groups of all zeroes could be substituted by "::" e. Decimal notation is used grouping bits in 4 (nibbles) 3) Interface Identifiers (IID) or the rightmost bits of an IPv6 address used on a LAN will be 64 bits long. a. True b. False 4) Which of the following is a correct IPv6 address?
17

IPv6 Exercises
a. 2001:db8:A:B:C:D::1 b. 2001:db8:000A:B00::1:3:2:F c. 2001:db8:G1A:A:FF3E::D d. 2001:0db8::F:A::B
5) Which ones of the following sub-prefixes belong to the prefix 2001:db8:0A00::/48 ? (Choose all that apply) a. 2001:db9:0A00:0200::/56 b. 2001:db8:0A00:A10::/64 c. 2001:db8:0A:F:E::/64 d. 2001:db8:0A00::/64 6) IPv6 has a basic header with more fields than IPv4 header a. True b. False 7) Extension headers can be added in any order a. True b. False 8) Autoconfiguration of IP devices is the same in IPv4 and IPv6 a. True b. False 9) Which one is not an option for configuring an IPv6 address in an interface? a. DHCPv6 b. Fixed address configured by vendor c. Manually d. SLAAC (Stateless Address Autoconfiguration) 10) Which packets are used by SLAAC to autoconfigure an IPv6 host? a. NS/NA (Neighbor Solicitation / Neighbor Advertisement) b. RS/RA (Router Solicitation / Router Advertisement)
18

Addressing Exercises c. Redirect messages d. NS / RA (Neighbor Solicitation / Router Advertisement)
1.7. Addressing Exercises
A) Use the two compression rules for the utmost compression of the following addresses: 1. 2001:0db8:00A0:7200:0fe0:000B:0000:0005 2. 2001:0db8::DEFE:0000:C000 3. 2001:db8:DAC0:0FED:0000:0000:0B00:12 B) Apply maximum decompression (representing all the 32 nibbles in hexadecimal) to the following addresses: 1. 2001:db8:0:50::A:123 2. 2001:db8:5::1 3. 2001:db8:C00::222:0CC0 C) You receive the following IPv6 prefix for your network: 2001:db8:A:0100::/56 , shown in the following figure:
Figure 1.17. LAN Example
19

Connecting our IPv6 Network to the Internet
Please determine:
a. IPv6 prefix for LAN1, a /64 prefix taken from the /56 you have. b. IPv6 prefix for LAN2, a /64 prefix taken from the /56 you have. c. IPv6 prefix for LAN3, a /64 prefix taken from the /56 you have. d. A global IPv6 address using the LAN1 prefix for H1 host (added to the link-local address
already used). e. A global IPv6 address using the LAN2 prefix for H2 host (added to the link-local address
already used). f. A global IPv6 address using the LAN3 prefix for H3 host (added to the link-local address
already used).
Hint: To divide the /56 prefix into /64 prefixes, you have to change the value of the bits 57 to 64, i.e., the XY values in 2001:db8:A:01XY::/64 .
1.8. Connecting our IPv6 Network to the Internet
As said in the introduction of this book, network communications is one of the four basic elements of an IoT system. We already have seen that IPv6 brings the possibility of giving an IP address to almost anything we can think of, and can do this making it easy to autoconfoigure network parameters on our devices.
Once we have all our "things" connected using IPv6, they can use it to communicate among them locally or with any other "thing" on the IPv6 Internet. In this chapter we will focus on the Internet side of the communication of the "things" composing the Internet of Things.
As we will see in this book, the capability of connecting our devices to the Internet allows new possibilities and services. For example, we can connect our wireless sensors networks to a centralized repository, where all the sensed information can be processed and stored for historical records, which will uncover underlying patterns and maybe predict future events. This basic idea is what nowadays is called "Big Data" and has a whole set of its own concepts and techniques.
20

Connecting our IPv6 Network to the Internet
Figure 1.18. IPv6 Connectivity
Getting back to the network connectivity domain, our objective is to connect IoT devices to the Internet using IPv6, allowing communication with other IoT devices, collecting servers or even with people. Related with the IPv6 connectivity to Internet is an important idea: communication between IoT devices and the IPv6 Internet could be bidirectional. This is important to remark because with IPv4, connectivity is oftentimes designed as a one direction channel between a client and a server. This changes with IPv6. Having a bidirectional communication with the IoT devices allows useful possibilities, because its not just that the device can send information to somewhere in the Internet, but that anybody in the Internet could be able to send information, requests or commands to the IoT device. This can be used in different scenarios: • Management: To manage the IoT device performing some status tests, updating some
parameters/configuration/firmware remotely allowing for a better and efficient use of the hardware platform and improving the infrastructure security. • Control: Send commands or control actuators to make the IoT device perform an action. • Communication: Send information to the IoT device, that can be displayed using some kind of interface. IIPv6 is still being deployed all over the different networks that compose the Internet, which means that different scenarios can be found when deciding how to connect our network to
21

Connecting our IPv6 Network to the Internet
the IPv6 Internet. Following are the three most common scenarios, in preferred order, being Native IPv6 connectivity the best choice. • Native IPv6 Connectivity: This scenario applies when both the ISP providing connectivity
to the Internet and the router(s) and networks devices used in our network support of IPv6. Native IPv6 means that the IPv6 packets will flow without being changed or tunnelled anywhere in its path from origin to destination. It is common to find what is called dualstack networks, where both native IPv6 and native IPv4 are being used at the same time in the same interfaces and devices. This native IPv6 scenario covers both cases: IPv6only and dual-stack.
Figure 1.19. Native IPv6
As seen in the figure, our IoT devices cloud is connected to a router (R2) that provides them a prefix creating a LAN (LAN2). The router that provides connectivity to the IPv6 Internet (R1) will also be in charge of autoconfiguring IPv6 devices in LAN1 (including R2), by sending RAs (Router Advertisements) as detailed when SLAAC was explained. • No IPv6 connectivity: In this scenario we face a common problem nowadays, the lack of
IPv6 connectivity from an ISP. Although we have IPv6 support on the router that connects our network to Internet, the ISP supports only IPv4. The solution is to use one of the so called IPv6 Transition Mechanism. The most simple and useful in this case would be the 6in4 tunnel, based on creating a point-to-point static tunnel that encapsulates IPv6 packets into IPv4.
22

Connecting our IPv6 Network to the Internet
Figure 1.20. IPv4 tunneled IPv6
The figure shows this solution created by making a tunnel from R1 to a "remote tunnel end point" where the IPv4 meets the IPv6 Internet. This will be a router having connectivity to both the IPv4 and IPv6 Internet. The native IPv6 traffic from our networks (LAN1 and LAN2) will reach R1, which will take the whole IPv6 packet with its data, and put it inside a new IPv4 packet with the IPv4 destination address corresponding to the tunnel end router. The tunnel end router will grab the IPv6 packet and convey it as native IPv6 traffic into the IPv6 Internet. Similar encapsulation is applied with the IPv6 traffic sent over Ipv4 from the IPv6 Internet to our networks • No IPv6 connectivity and no IPv6 capable router: This scenario covers the case where
there is no IPv6 connectivity from the ISP, nor IPv6 support on the router connecting our network to the Internet. As seen before, to solve the lack of IPv6 connectivity from the ISP we can use a 6in4 tunnel, but in this scenario we also have to face the lack of IPv6 support on the router which prevents the creation of the tunnel. The solution is to add a new router that supports both IPv6 and IPv4, and create a 6in4 tunnel from this router to a tunnel end router somewhere on the IPv4 Internet.
23

Connecting our IPv6 Network to the Internet
Figure 1.21. Local router does not support IPv6
In this scenario a new router (R3) is added to create a 6in4 tunnel towards the tunnel end router, which also serves as an IPv6 gateway to our networks, sending RAs to autoconfigure IPv6 devices in LAN1. The encapsulation/decapsulation process will work exactly the same as in the previous scenario. The main difference here is that the 6in4 tunnel needs a public IPv4 address, so R3 will need to have a public IPv4 besides the IPv6 address. This is easy to get in routers connected to ISPs, but not so common inside our network where we might have only private addresses using NAT. The scenarios showed above are based on a good infrastructure, where we have at least two routers and a couple of LANs. All three scenarios could be simplified into a just one router scenario shown in the following figure:
24

Connecting our IPv6 Network to the Internet
Figure 1.22. Simplified Scenario
Considerations about lack of IPv6 connectivity from the ISP and IPv6 support on the router are the same as in the previous case, although for the latter the solution is to change the R1 router by one that supports also IPv6. The last case is common because IoT or WSN could be deployed anywhere, including in remote networks connected using some sort of wireless technology. In this scenario there are severe restrictions on the number of devices, power consumption, etc. For example, a cloud of sensors could be deployed in the country to sense temperature and moisture, all of them getting connectivity through just one router connected using an IPv6 mobile phone network (GPRS, 3G or LTE).
25

26

Chapter 2. Introduction to 6LoWPAN
One of the drivers of the IoT, where anything can be connected, is the use of wireless technologies to create a communication channel to send and receive information. This wide adoption of wireless technologies allows increasing the number of connected devices but results in limitations in terms of cost, battery life, power consumption, and communication distance for the devices. New technologies and protocols should tackle a new environment, usually called Low power and Lossy networks (LLNs), with the following characteristics:
1. Significantly more devices than those on current local area networks. 2. Severely limited code and ram space in devices. 3. Networks with limited communications distance (range), power and processing resources. 4. All elements should work together to optimize energy consumption and bandwidth usage.
Another factor that is being widely adopted within IoT is the use of IP as the network protocol. The use of IP provides several advantages, because it is an open standard that is widely available, allowing for easy and cheap adoption, good interoperability and easy application layer development. The use of a common standard like an end-to-end IP-based solution avoids the problem of non-interoperable networks.
For wireless communication technology, the IEEE 802.15.4 standard [IEEE802.15.4] is very promising for the lower (link and physical) layers, although others are also being considered as good options like Low Power WiFi, Bluetooth ® Low Energy, DECT Ultra Low Energy, ITUT G.9959 networks, and NFC (Near Field Communication).
One component of the IoT that has received significant support from vendors and standardization organizations is that of WSN (Wireless Sensor Networks).
The IETF has different working groups (WGs) developing standards to be used by WSN:
1. 6lowpan: IPv6 over Low-power Wireless Personal Area Networks [sixlowpan], defines the standards for IPv6 communication over the IEEE 802.15.4 wireless communication technology. 6lowpan acts as an adaptation layer between the standard IPv6 world and the low power and lossy wireless communications medium offered by IEEE 802.15.4. Note that this standard is only defined with IPv6 in mind, no IPv4 support is available.
2. roll: Routing Over Low power and Lossy networks [roll]. LLNs have specific routing requirements that could not be satisfied with existing routing protocols. This WG focuses on routing solutions for a subset of all possible application areas of LLNs (industrial, connected
27

Overview of LoWPANs
home, building and urban sensor networks), and protocols are designed to satisfy their application-specific routing requirements. Here again the WG focuses only on the IPv6 routing architectural framework. 3. 6lo: IPv6 over Networks of Resource-constrained Nodes [sixlo]. This WG deals with IPv6 connectivity over constrained node networks. It extends the work of the 6lowpan WG, defining IPv6-over-foo adaptation layer specifications using 6LoWPAN for link layer in constrained node networks.
As seen, 6LoWPAN is the basis of the work carried out in standardization at IETF to communicate constrained resources nodes in LLNs using IPv6. The work on 6LoWPAN has been completed and is being further complemented by the roll WG to satisfy routing needs and the 6lo WG to extend the 6lowpan standards to any other link layer technology. Following are more details about 6LoWPAN, as the first step into the IPv6 based WSN/IoT. 6LoWPAN and related standards are concerned about providing IP connectivity to devices, irrelevantly of the upper layers, except for the UDP transport layer protocol that is specifically considered.
2.1. Overview of LoWPANs
Low-power and lossy networks (LLNs) is the term commonly used to refer to networks made of highly constrained nodes (limited CPU, memory, power) interconnected by a variety of "lossy" links (low-power radio links). They are characterized by low speed, low performance, low cost, and unstable connectivity.
A LoWPAN is a particular instance of an LLN, formed by devices complying with the IEEE 802.15.4 standard.
The typical characteristics of devices in a LoWPAN are:
1. Limited Processing Capability: Different types and clock speeds processors, starting at 8-bits.
2. Small Memory Capacity: From few kilobytes of RAM with a few dozen kilobytes of ROM/ flash memory, it’s expected to grow in the future, but always trying to keep at the minimum necessary.
3. Low Power: In the order of tens of milliamperes. 4. Short Range: The Personal Operating Space (POS) defined by IEEE 802.15.4 implies
a range of 10 meters. For real implementations it can reach over 100 meters in line-ofsight situations. 5. Low Cost: This drives some of the other characteristics such as low processing, low memory, etc.
28

About the use of IP on LoWPANs
All this constraints on the nodes are expected to change as technology evolves, but compared to other fields it’s expected that the LoWPANs will always try to use very restricted devices to allow for low prices and long life which implies hard restrictions in all other features.
A LoWPAN typically includes devices that work together to connect the physical environment to real-world applications, e.g., wireless sensors, although a LoWPAN is not necessarily comprised of sensor nodes only, since it may also contain actuators.
It’s also important to identify the characteristics of LoWPANs, because they will be the constraints guiding all the technical work:
1. Small packet size: Given that the maximum physical layer frame is 127 bytes, the resulting maximum frame size at the media access control layer is 102 octets. Link-layer security imposes further overhead, which leaves a maximum of 81 octets for data packets.
2. IEEE 802.15.4 defines several addressing modes: It allows the use of either IEEE 64bit extended addresses or (after an association event) 16-bit addresses unique within the PAN (Personal Area Network).
3. Low bandwidth: Data rates of 250 kbps, 40 kbps, and 20 kbps for each of the currently defined physical layers (2.4GHz, 915MHz, and 868MHz, respectively).
4. Topologies include star and mesh. 5. Large number of devices expected to be deployed during the lifetime of the technology.
Location of the devices is typically not predefined, as they tend to be deployed in an adhoc fashion. Sometimes the location of these devices may not be easily accessible or they may move to new locations. 6. Devices within LoWPANs tend to be unreliable due to variety of reasons: uncertain radio connectivity, battery drain, device lockups, physical tampering, etc. 7. Sleeping mode: Devices may sleep for long periods of time in order to conserve energy, and are unable to communicate during these sleep periods.
2.2. About the use of IP on LoWPANs
As said before, it seems that the use of IP, and specifically IPv6, is being widely adopted because it offers several advantages. 6LoWPANs are IPv6-based LoWPAN networks.
In this section we will see these advantages as well as some problems raised by the use of IP over LoWPANs.
The application of IP technology and, in particular, IPv6 networking is assumed to provide the following benefits to LoWPANs:
29

About the use of IP on LoWPANs
a. The pervasive nature of IP networks allows leveraging existing infrastructure. b. IP-based technologies already exist, are well-known, proven to be working and widely
available. This allows for an easier and cheaper adoption, good interoperability and easier application layer development. c. IP networking technology is specified in open and freely available specifications, which is able to be better understood by a wider audience than proprietary solutions. d. Tools for IP networks already exist. e. IP-based devices can be connected readily to other IP-based networks, without the need for intermediate entities like protocol translation gateways or proxies. f. The use of IPv6, specifically, allows for a huge amount of addresses and provides for easy network parameters autoconfiguration (SLAAC). This is paramount for 6LoWPANs where large number of devices should be supported.
On the counter side using IP communication in LoWPANs raise some issues that should be taken into account:
a. IP Connectivity: One of the characteristics of 6LoWPANs is the limited packet size, which implies that headers for IPv6 and layers above must be compressed whenever possible.
b. Topologies: LoWPANs must support various topologies including mesh and star: Mesh topologies imply multi-hop routing to a desired destination. In this case, intermediate devices act as packet forwarders at the link layer. Star topologies include provisioning a subset of devices with packet forwarding functionality. If, in addition to IEEE 802.15.4, these devices use other kinds of network interfaces such as Ethernet or IEEE 802.11, the goal is to seamlessly integrate the networks built over those different technologies. This, of course, is a primary motivation to use IP to begin with.
c. Limited Packet Size: Applications within LoWPANs are expected to originate small packets. Adding all layers for IP connectivity should still allow transmission in one frame, without incurring excessive fragmentation and reassembly. Furthermore, protocols must be designed or chosen so that the individual "control/protocol packets" fit within a single 802.15.4 frame.
d. Limited Configuration and Management: Devices within LoWPANs are expected to be deployed in exceedingly large numbers. Additionally, they are expected to have limited display and input capabilities. Furthermore, the location of some of these devices may be hard to reach. Accordingly, protocols used in LoWPANs should have minimal configuration, preferably work "out of the box", be easy to bootstrap, and enable the network to self heal given the inherent unreliable characteristic of these devices.
30

6LoWPAN e. Service Discovery: LoWPANs require simple service discovery network protocols to
discover, control and maintain services provided by devices. f. Security: IEEE 802.15.4 mandates link-layer security based on AES, but it omits any details
about topics like bootstrapping, key management, and security at higher layers. Of course, a complete security solution for LoWPAN devices must consider application needs very carefully.
2.3. 6LoWPAN
We have seen that there is a lower layer (physical and link layers on TCP/IP stack model) that provide connectivity to devices in what is called a LoWPAN. Also that using IPv6 over this layer would bring several benefits. The main reason for developing the IETF standards mentioned in the introduction is that between the IP (network layer) and the lower layer there are some important issues that need to be solved by means of an adaptation layer, the 6lowpan.
Figure 2.1. 6LoWPAN in the protocol stack
31

6LoWPAN
The main goals of 6lowpan are:
1. Fragmentation and Reassembly layer: IPv6 specification [RFC2460] establishes that the minimum MTU that a link layer should offer to the IPv6 layer is 1280 bytes. The protocol data units may be as small as 81 bytes in IEEE 802.15.4. To solve this difference a fragmentation and reassembly adaptation layer must be provided at the layer below IP.
2. Header Compression: Given that in the worst case the maximum size available for transmitting IP packets over an IEEE 802.15.4 frame is 81 octets, and that the IPv6 header is 40 octets long, (without optional extension headers), this leaves only 41 octets for upperlayer protocols, like UDP and TCP. UDP uses 8 octets in the header and TCP uses 20 octets. This leaves 33 octets for data over UDP and 21 octets for data over TCP. Additionally, as pointed above, there is also a need for a fragmentation and reassembly layer, which will use even more octets leaving very few octets for data. Thus, if one were to use the protocols as is, it would lead to excessive fragmentation and reassembly, even when data packets are just 10s of octets long. This points to the need for header compression.
3. Address Autoconfiguration: specifies methods for creating IPv6 stateless address auto configuration (in contrast to stateful) that is attractive for 6LoWPANs, because it reduces the configuration overhead on the hosts. There is a need for a method to generate the IPv6 IID (Interface Identifier) from the EUI-64 assigned to the IEEE 802.15.4 device.
4. Mesh Routing Protocol: A routing protocol to support a multi-hop mesh network is necessary. Care should be taken when using existing routing protocols (or designing new ones) so that the routing packets fit within a single IEEE 802.15.4 frame. The mechanisms defined by 6lowpan IETF WG are based on some requirements for the IEEE 802.15.4 layer:
5. IEEE 802.15.4 defines four types of frames: beacon frames, MAC command frames, acknowledgement frames and data frames. IPv6 packets must be carried on data frames.
6. Data frames may optionally request that they be acknowledged. It is recommended that IPv6 packets be carried in frames for which acknowledgements are requested so as to aid link-layer recovery.
7. The specification allows for frames in which either the source or destination addresses (or both) are elided. Both source and destination addresses are required to be included in the IEEE 802.15.4 frame header.
8. The source or destination PAN ID fields may also be included. 6LoWPAN standard assumes that a PAN maps to a specific IPv6 link.
32

IPv6 Interface Identifier (IID)
9. Both 64-bit extended addresses and 16-bit short addresses are supported, although additional constraints are imposed on the format of the 16-bit short addresses.
10.Multicast is not supported natively in IEEE 802.15.4. Hence, IPv6 level multicast packets must be carried as link-layer broadcast frames in IEEE 802.15.4 networks. This must be done such that the broadcast frames are only heeded by devices within the specific PAN of the link in question.
The 6LoWPAN adaptation format was specified to carry IPv6 datagrams over constrained links, taking into account limited bandwidth, memory, or energy resources that are expected in applications such as wireless sensor networks. For each of these goals and requirements there is a solution provided by the 6lowpan specification:
1. A Mesh Addressing header to support sub-IP forwarding. 2. A Fragmentation header to support the IPv6 minimum MTU requirement. 3. A Broadcast Header to be used when IPv6 multicast packets must be sent over the IEEE
802.15.4 network. 4. Stateless header compression for IPv6 datagrams to reduce the relatively large IPv6 and
UDP headers down to (in the best case) several bytes. These header are used as the LoWPAN encapsulation, and could be used at the same time forming what is called the header stack. Each header in the header stack contains a header type followed by zero or more header fields. When more than one LoWPAN header is used in the same packet, they must appear in the following order: Mesh Addressing Header, Broadcast Header, and Fragmentation Header.
Figure 2.2. 6LoWPAN headers
2.4. IPv6 Interface Identifier (IID)
As already said an IEEE 802.15.4 device could have two types of addresses. For each one there is a different way of generating the IPv6 IID.
1. IEEE EUI-64 address: All devices have this one. In this case, the Interface Identifier is formed from the EUI-64, complementing the "Universal/Local" (U/L) bit, which is the next-
33

Header Compression to-lowest order bit of the first octet of the EUI-64. Complementing this bit will generally change a 0 value to a 1.
Figure 2.3. EUI-64 derived IID
1. 16-bit short addresses: Possible but not always used. The IPv6 IID is formed using the PAN (or zeroes in case of not knowing the PAN) and the 16 bit short address as in the figure below.
Figure 2.4. IPv6IID
2.5. Header Compression
Two encoding formats are defined for compression of IPv6 packets: LOWPAN_IPHC and LOWPAN_NHC, an encoding format for arbitrary next headers. 34

Header Compression
To enable effective compression, LOWPAN_IPHC relies on information pertaining to the entire 6LoWPAN. LOWPAN_IPHC assumes the following will be the common case for 6LoWPAN communication: 1. Version is 6. 2. Traffic Class and Flow Label are both zero. 3. Payload Length can be inferred from lower layers from either the 6LoWPAN Fragmentation
header or the IEEE 802.15.4 header. 4. Hop Limit will be set to a well-known value by the source. 5. Addresses assigned to 6LoWPAN interfaces will be formed using the link-local prefix or a
small set of routable prefixes assigned to the entire 6LoWPAN. 6. Addresses assigned to 6LoWPAN interfaces are formed with an IID derived directly from
either the 64-bit extended or the 16-bit short IEEE 802.15.4 addresses. Depending on how closely the packet matches this common case, different fields may not be compressible thus needing to be carried "in-line" as well. The base format used in LOWPAN_IPHC encoding is shown in the figure below.
Figure 2.5. Header compression
Where: • TF: Traffic Class, Flow Label. • NH: Next Header. • HLIM: Hop Limit. • CID: Context Identifier Extension. • SAC: Source Address Compression. • SAM: Source Address Mode. • M: Multicast Compression.
35

Header Compression
• DAC: Destination Address Compression. • DAM: Destination Address Mode.
Not going into details, it’s important to understand how 6LoWPAN compression works. To this end, let’s see two examples:
1. HLIM (Hop Limit): Is a two bits field that can have four values, three of them make the hop limit field to be compressed from 8 to 2 bits: a. 00: Hop Limit field carried in-line. There is no compression and the whole field is carried in-line after the LOWPAN_IPHC. b. 01: Hop Limit field compressed and the hop limit is 1. c. 10: Hop Limit field compressed and the hop limit is 64. d. 11: Hop Limit field compressed and the hop limit is 255.
2. SAC/DAC used for the source IPv6 address compression. SAC indicates which address compression is used, stateless (SAC=0) or stateful context-based (SAC=1). Depending on SAC, DAC is used in the following way: a. If SAC=0, then SAM: • 00: 128 bits. Full address is carried in-line. No compression. • 01: 64 bits. First 64-bits of the address are elided, the link-local prefix. The remaining 64 bits are carried in-line. • 10: 16 bits. First 112 bits of the address are elided. First 64 bits is the link-local prefix. The following 64 bits are 0000:00ff:fe00:XXXX, where XXXX are the 16 bits carried in-line. • 11: 0 bits. Address is fully elided. First 64 bits of the address are the link-local prefix. The remaining 64 bits are computed from the encapsulating header (e.g., 802.15.4 or IPv6 source address). b. If SAC=1, then SAM: • 00: 0 bits. The unspecified address (::). • 01: 64 bits. The address is derived using context information and the 64 bits carried in-line. Bits covered by context information are always used. Any IID bits not covered by context information are taken directly from the corresponding bits carried in-line. • 10: 16 bits. The address is derived using context information and the 16 bits carried in-line. Bits covered by context information are always used. Any IID bits not covered by context information are taken directly from their corresponding bits in the 16-bit
36

Header Compression
to IID mapping given by 0000:00ff:fe00:XXXX, where XXXX are the 16 bits carried in-line. • 11: 0 bits. The address is fully elided and it is derived using context information and the encapsulating header (e.g., 802.15.4 or IPv6 source address). Bits covered by context information are always used. Any IID bits not covered by context information are computed from the encapsulating header. The base format is two bytes (16 bits) long. If the CID (Context Identifier Extension) field has a value of 1, it means that an additional 8-bit Context Identifier Extension field immediately follows the Destination Address Mode (DAM) field. This would make the length be 24 bits or three bytes. This additional octet identifies the pair of contexts to be used when the IPv6 source and/or destination address is compressed. The context identifier is 4 bits for each address, supporting up to 16 contexts. Context 0 is the default context. The two fields on the Context Identifier Extension are: • SCI: Source Context Identifier. Identifies the prefix that is used when the IPv6 source address is statefully compressed. • DCI: Destination Context Identifier. Identifies the prefix that is used when the IPv6 destination address is statefully compressed. The Next Header field in the IPv6 header is treated in two different ways, depending on the values indicated in the NH (Next Header) field of the LOWPAN_IPHC enconding shown above. If NH = 0, then this field is not compressed and all the 8 bits are carried in-line after the LOWPAN_IPHC. If NH = 1, then the Next Header field is compressed and the next header is encoded using LOWPAN_NHC encoding. This results in the structure shown in the figure below.
Figure 2.6. LoWPAN header
For IPv6 Extension headers the LOWPAN_NHC has the format shown in the figure, where: • EID: IPv6 Extension Header ID:
37

NDP optimization
◦ 0: IPv6 Hop-by-Hop Options Header. ◦ 1: IPv6 Routing Header. ◦ 2: IPv6 Fragment Header. ◦ 3: IPv6 Destination Options Header. ◦ 4: IPv6 Mobility Header. ◦ 5: Reserved. ◦ 6: Reserved. ◦ 7: IPv6 Header. • NH: Next Header ◦ 0: Full 8 bits for Next Header are carried in-line. ◦ 1: Next Header field is elided and is encoded using LOWPAN_NHC. For the most part,
the IPv6 Extension Header is carried unmodified in the bytes immediately following the LOWPAN_NHC octet.
2.6. NDP optimization
IEEE 802.15.4 and other similar link technologies have limited or no usage of multicast signalling due to energy conservation. In addition, the wireless network may not strictly follow the traditional concept of IP subnets and IP links. IPv6 Neighbor Discovery was not designed for non-transitive wireless links, since its reliance on the traditional IPv6 link concept and its heavy use of multicast make it inefficient and sometimes impractical in a low-power and lossy network.
For this reasons, some simple optimizations have been defined for IPv6 Neighbor Discovery, its addressing mechanisms and duplicate address detection for LoWPANs [RFC6775]:
1. Host-initiated interactions to allow for sleeping hosts. 2. Elimination of multicast-based address resolution for hosts. 3. A host address registration feature using a new option in unicast Neighbor Solicitation (NS)
and Neighbor Advertisement (NA) messages. 4. A new Neighbor Discovery option to distribute 6LoWPAN header compression context to
hosts. 5. Multihop distribution of prefix and 6LoWPAN header compression context.
38

NDP optimization 6. Multihop Duplicate Address Detection (DAD), which uses two new ICMPv6 message
types. The two multihop items can be substituted by a routing protocol mechanism if that is desired. Three new ICMPv6 message options are defined: 1. The Address Registration Option (ARO). 2. The Authoritative Border Router Option (ABRO). 3. The 6LoWPAN Context Option (6CO) Also two new ICMPv6 message types are defined: 1. The Duplicate Address Request (DAR). 2. The Duplicate Address Confirmation (DAC)
39

40

Chapter 3. Introduction to Contiki
Contiki is an open source operating system for the Internet of Things, it connects tiny low-cost, low-power microcontrollers to the Internet.
Contiki provides powerful low-consumption Internet communication, it supports fully standard IPv6 and IPv4, along with the recent low-power wireless standards: 6lowpan, RPL, CoAP. With Contiki’s ContikiMAC and sleepy routers, even wireless routers can be battery-operated.
With Contiki, development is easy and fast: Contiki applications are written in standard C, with the Cooja simulator Contiki networks can be emulated before burned into hardware, and Instant Contiki provides an entire development environment in a single download. Visit the Contiki OS site 1 for more information.
The remainder of the chapter intends to be a thoughtful introduction to Contiki 3.0, its core components and features. The following references are the must-go places to search for detailed information: • The Contiki wiki page 2 • The Contiki mailing list3 • Zolertia Wiki page 4
3.1. Install Contiki
There are several ways to install Contiki, from scratch by installing from sources or using virtual environments, depending on the flavour and time availability.
To work with Contiki you will need three items:
• The Contiki source code. • A target platform (virtual platform or a real hardware one). • A toolchain to compile the source code for such target platform.
The remainder of the book assumes Contiki will run in an Unix environment, as the virtualized environments run on Ubuntu.
1 http://contiki-os.org 2 https://github.com/contiki-os/contiki/wiki 3 http://sourceforge.net/p/contiki/mailman/contiki-developers 4 https://github.com/Zolertia/Resources/wiki
41

Install from sources
3.1.1. Install from sources
Contiki source code is actively supported by contributors from universities, research centers and developers from all over the world. The source code is hosted at Contiki GitHub repository 5 : To grab the source code open a terminal and execute the following:
sudo apt-get -y install git git clone --recursive https://github.com/contiki-os/contiki.git
What is git?
Git is a free and open source distributed version control system, designed for speed and efficiency. The main difference with other change control tools is the possibility to work locally since your local copy is a repository, and you can commit to it and get all benefits of source control. There are some great tutorials online to learn more about git: • Code School & GitHub "try Git"6 • Roger Dudler’s Git simple guide 7 GitHub is a GIT repository web-based hosting service, which offers all of the distributed revision control and source code management (SCM) functionality of Git as well as adding its own features. GitHub provides a web-based graphical interface and desktop as well as mobile integration. It also provides access control and several collaboration features such as wikis, task management, bug tracking and feature requests for every project. The advantage of using GIT and hosting the code at github is that of allowing people to fork the code, further develop it, and then contribute back to share their improvements.
5 https://github.com/contiki-os/contiki 6 http://try.github.io 7 http://rogerdudler.github.io/git-guide/
42

Instant Contiki Virtual Machine

To install the toolchain and required dependencies, run in a terminal the following:

sudo echo "deb http://ppa.launchpad.net/terry.guo/gcc-arm-embedded/ubuntu trusty main" > /etc/apt/sources.list.d/gcc-arm-embedded.list
sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-key FE324A81C208C89497EFC6246D1D8367A3421AFB
sudo apt-get update sudo apt-get -y install build-essential automake gettext sudo apt-get -y install gcc-arm-none-eabi curl graphviz unzip wget sudo apt-get -y install gcc gcc-msp430 sudo apt-get -y install openjdk-7-jdk openjdk-7-jre ant

This will install support for the ARM Cortex-M3 and MSP430 platforms, as well as support for Cooja, the Contiki’s emulator to be discussed in the next sections.

3.1.2. Instant Contiki Virtual Machine

Instant Contiki is an entire Contiki development environment in a single download. It is an Ubuntu Linux virtual machine and has Contiki OS and all the development tools, compilers, and simulators required already pre-installed.
Grab Instant Contiki from the Contiki website:
http://www.contiki-os.org/start.html
The latest Instant Contiki release is 3.0, following the Contiki 3.0 source code release.
This book is heavily based on this release, the use of earlier versions is not recommended.
The release tag is available at:
https://github.com/contiki-os/contiki/tree/release-3-0
Nevertheless you should use the latest commit available, as Contiki releases are produced on a yearly base. Many bug fixes, new features and improved support is normally present on the latest master branch.
At the moment of this release, the current Contiki commit corresponds to the daa83ee3ef32f5b48f647e1c614fe6523ab440bb HASH. You can use the following GIT command to place yourself on this commit:

git daa83ee3ef32f5b48f647e1c614fe6523ab440bb

checkout

43

Test Contiki installation
As Contiki ensures the platform and application support by using a strict code revision procedure and regression tests, this is a safe point if you encounter any problem. Be sure to update your Contiki local repository if using Instant Contiki ! Download VMWare player for Windowws and Linux 8 to run Contiki’s virtual machine, it is free and widely used. In OSX you can download VMWare Fusion 9 Using VMWare just open the Instant_Contiki_Ubuntu_12.04_32-bit.vmx file, if prompted about the VM source just choose I copied it then wait for the virtual Ubuntu Linux boot up. Log into Instant Contiki. The password and user name is user . Don’t upgrade right now. Remember to update the Contiki repository and get the latest upgrades:
cd /home/user/contiki git fetch origin git pull origin master
3.2. Test Contiki installation
Let us first check the toolchain installation. The MSP430 toolchain can be tested with:
msp430-gcc --version msp430-gcc (GCC) 4.7.0 20120322 (mspgcc dev 20120716) Copyright (C) 2012 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
And for the ARM Cortex-M3 toolchain:
arm-gcc-none-eabi-gcc --version arm-none-eabi-gcc (GNU Tools for ARM Embedded Processors) 4.9.3 20150529 (release)
[ARM/embedded-4_9-branch revision 224288]
8 https://my.vmware.com/web/vmware/free#desktop_end_user_computing/vmware_player/6_0 9 http://www.vmware.com/products/fusion
44

Contiki structure

Copyright (C) 2014 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

3.3. Contiki structure

Contiki has the following file structure:

Folder examples
app cpu dev platform
core
tools
doc
regression-tests

Description

Zolertia files

Ready to build examples

examples/zolertia, examples/cc2538-common

Contiki applications

-

Specific MCU files

msp430, cc2538

External chip and devices cc2420, cc1200

Specific files and platform drivers

z1, zoul

Contiki core files and

-

libraries

Tools for flashing, debuging, zolertia, sky simulating, etc.

Self-generated doxygen

-

documentation

nightly regression tests -

In the following sections we will cover the examples and specific platform files for the Zolertia platforms.
3.4. Run Contiki on real hardware

For the remainder of the book we will use Zolertia Z1 and RE-Mote hardware development platforms. Other platforms can be used as well, but are out of the scope of this book.
Contiki drivers and libraries are (normally) platform independent, most examples can be run in both Z1 and RE-Mote platforms by taking into consideration specific platform settings.
There are platform-specific examples for the Z1 platform at examples/zolertia/z1 , and at examples/zolertia/zoul for the RE-Mote. Additionaly CC2538 specific examples

45

Zolertia Zoul module and the RE-Mote development platform can be found at examples/cc2538-common . This folder has CC2538 ARM Cortex-M3 related examples and applications. More information about both platforms and updates guides can be found at: • Zolertia website 10 • Zolertia RE-Mote wiki page 11 • Zolertia Z1 wiki page 12
3.4.1. Zolertia Zoul module and the RE-Mote development platform
The Zoul is a module based in the CC2538 ARM Cortex-M3 system on chip (SoC), with an on-board 2.4 GHz IEEE 802.15.4 RF interface, running at up to 32 MHz with 512 kB of programmable flash and 32 kB of RAM, bundled with a CC1200 868/915 MHz RF transceiver to allow dual band operation. The Zoul allows fast reusability on designs and quick scaling from prototyping to production.
Figure 3.1. Zolertia Zoul module and the RE-Mote platform
The RE-Mote has a Zoul on board and also packs: • ISM 2.4-GHz IEEE 802.15.4 & Zigbee compliant radio. • ISM 863-950-MHz ISM/SRD band radio.
10 http://www.zolertia 11 https://github.com/Zolertia/Resources/wiki/RE-Mote 12 https://github.com/Zolertia/Resources/wiki#the-z1-mote
46

Zolertia Z1 mote
• AES-128/256, SHA2 Hardware Encryption Engine. • ECC-128/256, RSA Hardware Acceleration Engine for Secure Key Exchange. • Consumption down to 150 nA using the shutdown mode. • Programming over BSL without requiring to press any button to enter bootloader mode. • Built-in battery charger (500 mA), facilitating Energy Harvesting and direct connection to
Solar Panels and to standards LiPo batteries. • Wide range DC Power input: 2-16 V. • Small form-factor. • MicroSD over SPI. • On board RTC (programmable real time clock) and external watchdog timer (WDT). • Programmable RF switch to connect an external antenna either to the 2.4 GHz or to the
Sub 1 GHz RF interface through the RP-SMA connector. The RE-Mote has been developed jointly with universities and industrial partners in the frame of the European research project RERUM(RERUM: REliable, Resilient and secUre IoT for sMart city applications).
3.4.2. Zolertia Z1 mote
The Z1 mote features a second generation MSP430F2617 low power 16-bit RISC CPU @ 16 MHz MCU, 8 kB RAM and a 92 kB Flash memory. It includes the well known CC2420 transceiver, IEEE 802.15.4 compliant, which operates at 2.4 GHz with an effective data rate of 250 kbps.
Figure 3.2. Zolertia Z1 mote
47

What are the differences between the RE-Mote and the Z1 platforms?
The Zolertia Z1 mote can run TinyOS, Contiki OS, OpenWSN and RIOT, and has been used actively for over 5 years in universities, research and development centers and in commercial products in more than 43 countries, being featured in more than 50 scientific publications. The Z1 mote is fully emulated in both MSPSIM and Cooja.
3.4.3. What are the differences between the RE-Mote and the Z1 platforms?
In a nutshell: power and coolness. The RE-Mote has 4 times more RAM than the Z1 mote, 5 times more flash memory, twice the frequency of operation and 120 times less power consumption in its lowest power mode (shutdown mode). Another major difference is that (at the time of writing this book) the Z1 mote is supported by Cooja, the Contiki emulator, while the RE-Mote is not. However efforts are on going to provide emulation framework support in the EMUL8 13 project. To check in depth the differences between the RE-Mote and the Z1 mote, and also obtain guidelines to port applications developed for the Z1 to the RE-Mote, visit the "Migrate from Z1 to RE-Mote" wiki page 14 .
3.5. Start with Contiki!
Let’s compile our first Contiki example! Open a terminal and write:
cd examples/hello-world make TARGET=zoul savetarget
This will tell Contiki to compile the hello world example for the RE-Mote platform from now on. Alternatively, to use the Z1 mote instead, just run:
make TARGET=z1 savetarget
You need to do this only once per application. Not let’s compile the application:
make hello-world
13 http://emul8.org/ 14 https://github.com/Zolertia/Resources/wiki/Migrate-From-Z1-to-RE-Mote
48

Hello world explained

To start compiling the code (ignore the warnings), if everything works OK you should see something like:

CC

symbols.c

AR

contiki-z1.a

CC

hello-world.c

CC

../../platform/z1/./contiki-z1-main.c

LD

hello-world.z1

rm obj_z1/contiki-z1-main.o hello-world.co

The hello-world.z1 file should have been created and we are ready to flash the application to the device.
At any given point you can override the saved target and redefine at compilation time by running instead:

make TARGET=zoul hello-world

CC

hello-world.c

LD

hello-world.elf

arm-none-eabi-objcopy -O binary --gap-fill 0xff hello-world.elf hello-world.bin

This will ignore the saved Makefile.target file and use the target zoul instead.
In the following sections and chapters the examples can be compiled for both the Z1 and REMote platform, unless specified otherwise.
The RE-Mote takes two arguments: TARGET and BOARD , while the Z1 mote only uses the first one with the z1 string as noted before. For the RE-Mote, TARGET is always zoul and BOARD is remote , but when compiling, if the BOARD flag is not explicitly defined, it will default to remote . This approach is because there are other Zoul based platforms which share the same code base and modules, but the RE-Mote has its own specific platform files and definitions.
3.5.1. Hello world explained
Let’s see the main components of the Hello World example. Browse the code with:

gedit hello-world.c
Or your preferred text editor.

49

Makefile explained
When starting Contiki, you declare processes with a name. In each code you can have several processes. You declare the process like this:
PROCESS(hello_world_process, "Hello world process"); AUTOSTART_PROCESSES(&hello_world_process);
hello_world_process is the name of the process and "Hello world process" is the readable name of the process when you print it to the terminal. The AUTOSTART_PROCESSES(&hello_world_process) tells Contiki to start that process when it finishes booting.
/*-------------------------------------------------*/ PROCESS(hello_world_process, "Hello world process"); AUTOSTART_PROCESSES(&hello_world_process); /*-------------------------------------------------*/ PROCESS_THREAD(hello_world_process, ev, data) {
PROCESS_BEGIN(); printf("Hello, world\n"); PROCESS_END(); }
You declare the content of the process in the process thread. You have the name of the process and callback functions (event handler and data handler). Inside the thread you begin the process, do what you want and finally end the process.
3.5.2. Makefile explained
Applications require a Makefile to compile, let us take a look at the hello-world Makefile:
CONTIKI_PROJECT = hello-world all: $(CONTIKI_PROJECT) CONTIKI = ../.. include $(CONTIKI)/Makefile.include
Tells the build system which application to compile If using make all it will compile the defined applications
50

Adding an LED to the example
Specify our indentation level respect to Contiki root folder The system-wide Contiki Makefile, also points out to the platform’s Makefile We can define specific compilation flags in the Makefile, although the recommended way would be to add a project-conf.h header, and define there any compilation flag or value. This is done by adding this to the Makefile:
DEFINES+=PROJECT_CONF_H=\"project-conf.h\"
And then creating a project-conf.h header file in the example location.
Before you embark in Contiki, it is useful to remember that normally the drivers have a switch like:
#define DEBUG 0 #if DEBUG #define PRINTF(...) printf(__VA_ARGS__) #else #define PRINTF(...) #endif
Enable the DEBUG by changing to 1 or DEBUG_PRINT , this will print debug information to the console. Normally you should do it in every driver file you wish to debug.
3.5.3. Adding an LED to the example
The next step is adding an LED (light emitting diode) to interact with our application.
You have to add the dev/leds.h which is the library to manage the LEDs. To check the available functions go to core/dev/leds.h .
Available LEDs commands:
unsigned char leds_get(void); void leds_set(unsigned char leds); void leds_on(unsigned char leds); void leds_off(unsigned char leds); void leds_toggle(unsigned char leds);
Normally all platforms comply to the following available LEDs:
51

Adding an LED to the example
LEDS_GREEN LEDS_RED LEDS_BLUE LEDS_ALL
In the Z1 mote these LEDs are defined in platform/z1/platform-conf.h , as well as other hardware definitions.
The RE-Mote uses an RGB LED, basically 3-channel LEDs in a single device, allowing to show any color by the proper combination of Blue, Red and Green. In platforms/zoul/ remote/board.h header the following are defined:
LEDS_LIGHT_BLUE LEDS_YELLOW LEDS_PURPLE LEDS_WHITE
Now try to turn on only the red LED and see what happens, create a new example named test-leds.c :
#include "contiki.h" #include "dev/leds.h" #include <stdio.h> /*-------------------------------------------------*/ PROCESS(test_leds_process, "Test LEDs"); AUTOSTART_PROCESSES(&test_leds_process); /*-------------------------------------------------*/ PROCESS_THREAD(test_leds_process, ev, data) {
PROCESS_BEGIN(); leds_on(LEDS_RED); PROCESS_END(); }
Now let’s compile and upload the new project with:
make clean && make test-leds.upload
The make clean command is used to erase previously compiled objects.
Now the red LED should be on!
52

Printing messages to the console
If you make changes to the source code, you must rebuild the files, otherwise your change might not be pulled in. It is always recommended to do a make clean command before compiling.
Exercise: try to switch on the other LEDs.
3.5.4. Printing messages to the console
You can use printf to visualize on the console what is happening in your application. It is really useful to debug your code, as you can print values of variables, when certain block of code is being executed, etc.
Let’s try to print the status of the LED, using the unsigned char leds_get(void); function that is available in the documented functions (see above).
Get the LED status and print it on the screen, modify the current test-leds.c file as follows:
#include "contiki.h" #include "dev/leds.h" #include <stdio.h> char hello[] = "hello from the mote!"; /*-------------------------------------------------*/ PROCESS(test_leds_process, "Test LEDs"); AUTOSTART_PROCESSES(&test_leds_process); /*-------------------------------------------------*/ PROCESS_THREAD(test_leds_process, ev, data) {
PROCESS_BEGIN(); leds_on(LEDS_RED); printf("%s\n", hello); printf("The LED %u is %u\n", LEDS_RED, leds_get()); PROCESS_END(); }
If one LED is on, you will get the LED number, which is defined by each platform in its platform-conf.h or board.h header.
Exercise: what happens when you turn on more than one LED? What number do you get? are these the same numbers for the Z1 and the RE-Mote?
53

Adding button events
3.5.5. Adding button events
We now want to detect if the user button has been pressed.
The button in Contiki is regarded as a sensor. We are going to use the core/dev/buttonsensor.h library.
The RE-Mote platform has extra button functionalities, such as detect long-press sequences, enabling to further expand the events that can be triggered using the button. Check platform/zoul/dev/ button-sensor.c for more details, and examples/zolertia/ zoul/zoul-demo.c for an example.
Create a new example called test-button.c and add the dev/button-sensor.h header and button event as follows:
#include "contiki.h" #include "dev/leds.h" #include "dev/button-sensor.h" #include <stdio.h> /*-------------------------------------------------*/ PROCESS(test_button_process, "Test button"); AUTOSTART_PROCESSES(&test_button_process); /*-------------------------------------------------*/ PROCESS_THREAD(test_button_process, ev, data) {
PROCESS_BEGIN(); SENSORS_ACTIVATE(button_sensor); while(1) {
PROCESS_WAIT_EVENT_UNTIL((ev==sensors_event) && (data == &button_sensor));
printf("I pushed the button!\n"); } PROCESS_END(); }
This process has an infinite loop, given by the wait() , to wait for the button the be pressed. The two conditions have to be met (event from a sensor and that event is the button being pressed), as soon as you press the button, you get the string printed.
Exercise: switch on the LED when the button is pressed. Switch off the LED when the button is pressed again.
54

Timers
3.5.6. Timers
Using timers will allow us to trigger events at a given time, speeding up the transition from one state to another and automating a given process or task, for example blinking an LED every 5 seconds, without the user having to press the button each time.
Contiki OS provides 4 kind of timers:
• Simple timer: A simple ticker, the application should check manually if the timer has expired. More information at core/sys/timer.h .
• Callback timer: When a timer expires it can callback a given function. More information at core/sys/ctimer.h .
• Event timer: Same as above, but instead of calling a function, when the timer expires it posts an event signalling its expiration. More information at core/sys/etimer.h .
• Real time timer: The real-time module handles the scheduling and execution of real-time tasks, there’s only 1 timer available at the moment. More information at core/sys/ rtimer.h
For our implementation we are going to choose the event timer, because we want to change the application behavior when the timer expires every given period.
We create a timer structure and set the timer to expire after a given number of seconds. When the timer expires we execute the code and restart the timer.
Create an example called test-timer.c as follows:
#include "contiki.h" #include "dev/leds.h" #include <stdio.h> /*-------------------------------------------------*/ #define SECONDS 2 /*-------------------------------------------------*/ PROCESS(test_timer_process, "Test timer"); AUTOSTART_PROCESSES(&test_timer_process); /*-------------------------------------------------*/ PROCESS_THREAD(test_timer_process, ev, data) {
PROCESS_BEGIN(); static struct etimer et; while(1) {
etimer_set(&et, CLOCK_SECOND*SECONDS); PROCESS_WAIT_EVENT();
55

Sensors

if(etimer_expired(&et)) { printf("Hello world!\n"); etimer_reset(&et);
} } PROCESS_END(); }
CLOCK_SECOND is a value related to the number of the microcontroller’s ticks per second. As Contiki runs on different platforms with different hardware, the value of CLOCK_SECOND also differs. PROCESS_WAIT_EVENT() waits for any event to happen.
Exercise: can you print the value of CLOCK_SECOND to count how many ticks you have in one second? Try to blink the LED for a certain number of seconds. Make a new application that starts only when the button is pressed and stops when the button is pressed again.
3.5.7. Sensors
A sensor is a transducer whose purpose is to sense or detect a characteristic of its environment, providing a corresponding output, generally as an electrical or optical signal, related to the quantity of the measured variable.
Sensors in Contiki are implemented as follow:

SENSORS_SENSOR (sensor, SENSOR_NAME, value, configure, status);
This means that a method to configure the sensor, poll the sensor status and request a value have to be implemented. The sensor structure contains pointers to these functions. The arguments for each function are shown below.

struct sensors_sensor {

char *

type;

int

(* value)

(int type);

int

(* configure) (int type, int value);

int

(* status) (int type);

};

To better understand please refer to the platform/zoul/dev/adc-sensors.c , for an example of how analogue external sensors can be implemented (to be further discussed in the next sections).

56

Sensors
The following functions and macros can be used to work with the sensor:
SENSORS_ACTIVATE(sensor) SENSORS_DEACTIVATE(sensor) sensor.value(type);
Enable the sensor, typically configures and turns the sensor on Disables the sensor, it is useful to save power Request a value to the sensor. As one sensor chip might have different types of readings (temperature, humidity, etc.), this is used to specify which measure to take.
Although this is the default way to implement sensors in Contiki, there might be alternatives, depending on the sensor and developer. Always check the specific sensor driver implementation for details. Normally sensors are provided in the same location as the example, in the dev folder, or in the platform/zoul/dev directory for example. The SENSORS macro provides external linkage to the sensors defined for the platform and application, allowing to iterate between the available sensors. The following are the sensors defined as default for the RE-Mote platform:
SENSORS (&button_sensor, &vdd3_sensor, &cc2538_temp_sensor, &adc_sensors);
The button is considered a sensor in Contiki, and it shares the same sensor implementation
This macro extends to:
const struct sensors_sensor *sensors[] = { &button_sensor, &vdd3_sensor, &cc2538_temp_sensor, &adc_sensors, ((void *)0)
};
The number of sensors can be found with the SENSORS_NUM macro:
#define SENSORS_NUM (sizeof(sensors) / sizeof(struct sensors_sensor *))
57

Sensors
Sensors can be of two types: analogue or digital. In the following sections examples will be shown for both types, detailing how to connect and use both the platform’s internal sensors as well as the external ones.
Analogue Sensors
Analogue sensors typically require being connected to an ADC (analogue to digital converter) to translate the analogue (continuous) reading to an equivalent digital value in millivolts. The quality and resolution of the measure depends on both the ADC resolution (up to 12 bits in the Z1 and RE-Mote) and the sampling frequency. As a rule of thumb, the sampling frequency must be at least twice that of the phenomenon you are measuring. As an example, if you want to sample human speech (which may contain frequencies up to 8 kHz) you need to sample at twice that frequency (16 kHz).
The Z1 mote has a built-in voltage sensor provided as an ADC input channel, as well as a generic implementation to read external analogue sensors.
Analogue sensors can be connected to both the Z1 and the REMote over phidget ports, which are basically 3-pin connectors (Ground, VCC and signal) with 2.54 mm spacing. This is a legacy name from the Z1 release, as these ports were meant for the commercially available Phidget sensors. Nowadays there are also sensors from other providers, such as seeedstudio that have the same pin-out but with a different pin spacing (2 mm). This is not a problem, as there are cables to adapt the pin spacing.
Figure 3.3. Analogue sensors
The ADC results in the RE-Mote returns the reading in voltage.
58

Sensors
For the Z1 mote the ADC output must be converted by means of the following formula: We multiply the measured value by the voltage reference and divide the product by the ADC’s maximum output. As the resolution of the ADC is 12 bits (212 = 4096), we get:
Voltage, mV = (units * Vref) / 4096;
The voltage reference limits the range of our measure, meaning if we use a Vref of 2.5 V, the sensor will saturate when reading a higher voltage. The reference can be chosen while configuring the ADC, for both the Z1 and RE-Mote normally 3.3 V is used. Both the Z1 and the RE-Mote allow up to 6 analogue sensors to be connected, but only two phidget connectors can be soldered at the same time. For the RE-Mote it is possible to have one phidget connector for a 3.3 V analogue sensor (ADC1) and another for 5 V sensors (ADC3).
The RE-Mote is based on an ARM Cortex-M3, this allows to map any given pin to a controller (as opposite to the MSP430, for which a pin has predefined functions other than GPIO), but only pins in the PA port can be used as ADC. For the Z1 mote is possible to have the following combinations (see Figure below): • Two phidget connectors for 3.3 V sensors. • Two phidget connectors for 5 V sensors. • Two phidget connectors, one for 3.3 V and one for 5 V sensors.
59

Sensors
Figure 3.4. Pin assignement
In the snippet below the ADC channels ADC0 (5V1), ADC3 (5V2), ADC1 (3V1) and ADC7 (3V2) are mapped by default to be used as input for external analogue sensors.
/* MemReg6 == P6.0/A0 == 5V 1 */ ADC12MCTL0 = (INCH_0 + SREF_0); /* MemReg7 == P6.3/A3 == 5V 2 */ ADC12MCTL1 = (INCH_3 + SREF_0); /* MemReg8 == P6.1/A1 == 3V 1 */ ADC12MCTL2 = (INCH_1 + SREF_0); /* MemReg9 == P6.7/A7 == 3V_2 */ ADC12MCTL3 = (INCH_7 + SREF_0);
To read from a sensor connected to the ADC7 channel of the Z1 mote, in my code I would need to make the following steps:
#include "dev/z1-phidgets.h" SENSORS_ACTIVATE(phidgets); printf("Phidget 5V 1:%d\n", phidgets.value(PHIDGET3V_2));
60

Sensors Include the driver header Enable the ADC sensors, as default all 4 ADC channels are enabled Request a reading The Z1 is powered at 3.3 V, but when connected over the USB (standard voltage 5 V) it allows to connect 5 V sensors to the phidget ports, namely 5V1 (ADC3) and 5V2 (ADC0) as there is a voltage divider in the input to adapt the reading from 5 V to 3.3 V. Details about the Z1 implementation of the analogue sensors driver are available at platform/z1/dev/z1-phidgets.c .There is also a driver for the MSP430 internal voltage sensor at platform/z1/dev/battery-sensor.c , with an example at examples/zolertia/z1/test-battery.c . to see the ADC implementation with an example, let’s connect the Phidget 1142 precision Light Sensor.
Figure 3.5. Light sensor
The example called test-phidgets.c in examples/zolertia/z1 will read values from an analog sensor and print them to the terminal. Connect the light sensor to the 3V2 Phidget connector and compile the example:
make clean && make test-phidgets.upload && make z1-reset && make login
61

Sensors

You can pipeline commands to be executed one after another, in this case the make z1-reset restarts the mote after flashed, then make login prints to console the output of any printf command in our code. You may need to use the argument MOTES=/dev/ttyUSB[0…
9] to specify a mote over a particular USB port.
This is the result:

Starting 'Test Button & Phidgets' Please press the User Button Phidget 5V 1:123 Phidget 5V 2:301 Phidget 3V 1:1710 Phidget 3V 2:2202

The light sensor is connected to the 3V2 connector, so the raw value is 2202. Try to illuminate the sensor with a flashlight (from your mobile phone, for example) and then cover it with your hand so that no light can reach it.
From the Phidget website we have the following information about the sensor:

Parameter Sensor type Light level min Supply Voltage Min Supply Voltage Max Max current consumption Light level max (3.3 V) Light level max (5 V)

Value Light 1 lux 2.4 V 5.5 V 5mA 660 lux 1000 lux

As you can see, the light sensor can be connected to either the 5 V or the 3.3 V Phidget connector. The max measurable value depends on where you connect it.
The formula to translate SensorValue into luminosity is: Luminosity(lux)=SensorValue
The RE-Mote platform also allows to connect 5 V sensors to the ADC3 port, using the same voltage divider as the Z1 mote. As seen in the next snippet, the ADC3 port is mapped to the PA2 pin.

62

Sensors
/* * This driver supports analogue sensors connected to ADC1, ADC2 and AND3 inputs * This is controlled by the type argument of the value() function. Possible * choices are: * - REMOTE_SENSORS_ADC1 (channel 5) * - REMOTE_SENSORS_ADC2 (channel 4) * - REMOTE_SENSORS_ADC3 (channel 2) */
Figure 3.6. Connecting sensor
Then to read data from an attached sensor (as we did in the previous example):
#include "dev/zoul-sensors.h" adc_sensors.configure(SENSORS_HW_INIT, REMOTE_SENSORS_ADC_ALL); printf("Phidget ADC2 = %d raw\n", adc_sensors.value(REMOTE_SENSORS_ADC2)); printf("Phidget ADC3 = %d raw\n", adc_sensors.value(REMOTE_SENSORS_ADC3));
Include the ADC driver header Enable and configure the ADC channels (can selectively choose which to enable) Request a reading Check the RE-Mote example at example/zolertia/zoul/zoul-demo.c for more details.
Exercise: make the sensor take readings as fast as possible. Print to the screen the ADC raw values and the millivolts (as this sensor is linear,
63

Sensors
the voltage corresponds to the luxes). What are the max and min values you can get? What is the average light value of the room? Create an application that turns the red LED on when it is dark and the green LED on when the room is bright. In between, all the LEDs should be off. Add a timer and measure the light every 10 seconds.
Digital Sensors
Digital sensors are normally interfaced over a digital communication protocol such as I2C, SPI, 1-Wire, Serial or depending on the manufacturer, a proprietary protocol normally on a ticking clock.
Digital sensors allow a more extended set of commands (turn on, turn off, configure interrupts). With a digital light sensor for example, you could set a threshold value and let the sensor send an interrupt when reached, without the need for continuous polling.
Remember to check the specific sensor information and data sheet for more information.
The Z1 mote has two built in digital sensors: temperature and 3-axis accelerometer. Let us start with the latter, there is an example called test-adxl345.c available for testing.
The ADXL345 is an I2C ultra-low power sensor able to read up to 16g, well suited for mobile device applications. It measures the static acceleration of gravity in tilt-sensing applications, as well as dynamic acceleration resulting from motion or shock. Its high resolution (3.9mg/ LSB) enables measurement of inclination changes smaller than 1.0°.
[37] DoubleTap detected! (0xE3) -- DoubleTap Tap x: -1 y: 12 z: 223 [38] Tap detected! (0xC3) -- Tap x: -2 y: 8 z: 220 x: 2 y: 4 z: 221 x: 3 y: 5 z: 221 x: 4 y: 5 z: 222
The accelerometer can read data in the x, y and z axis and has three types of interrupts: a single tap, a double tap and a free-fall (be careful to not damage the mote!).
The code has two threads, one for the interruptions and the other for the LEDs. When Contiki starts, it triggers both processes.
64

Sensors
The led_process thread triggers a timer that waits before turning off the LEDs. This is mostly done to filter the rapid signal coming from the accelerometer. The other process is the acceleration. It assigns the callback for the led_off event. Interrupts can happen at any given time, are non periodic and totally asynchronous.
Interrupts can be triggered by external sources (sensors, GPIOs, Watchdog Timer, etc) and should be cleared as soon as possible. When an interrupts happens, the interrupt handler (which is a process that checks the interrupt registers to find out which is the interrupt source) manages it and forwards it to the subscribed callback.
In this example, the accelerometer is initialized and then the interrupts are mapped to a specific callback functions. Interrupt source 1 is mapped to the free fall callback handler and the tap interrupts are mapped to the interrupt source 2.
/* * Start and setup the accelerometer with default * values, _i.e_ no interrupts enabled. */
accm_init(); /* Register the callback functions */ ACCM_REGISTER_INT1_CB(accm_ff_cb); ACCM_REGISTER_INT2_CB(accm_tap_cb);
We then need to enable the interrupts like this:
accm_set_irq(ADXL345_INT_FREEFALL, ADXL345_INT_TAP + ADXL345_INT_DOUBLETAP);
In the while loop we read the values from each axis every second. If there are no interrupts, this will be the only thing shown in the terminal.
Exercise: put the mote in different positions and check the values of the accelerometer. Try to understand which is x, y and z. Measure the maximum acceleration by shaking the mote. Turn on and off the LED according to the acceleration on one axis.
For the next example we will use the ZIG-SHT25, an I2C digital temperature and humidity sensor based on the SHT25 sensor from Sensirion.
65

Sensors

Figure 3.7. Temperature and humidity sensor

Parameter Sensor type Supply Voltage [V] Energy Consumption Data range
Max resolution Max current consumption

Value Temperature and Humidity 2.1 - 3.6 3.2 uW (at 8 bit, 1 measurement / s) 0-100 % RH (humidity), -40-125ºC (temperature) 14 bits (temperature), 12 bits (humidity) 300 uA

The ZIG-SHT25 sensor example is available in both examples/zolertia/zoul/testsht25.c and examples/zolertia/z1/test-sht25.c , an output example is given below:

Starting 'SHT25 test' Temperature 23.71 ºC Humidity 42.95 % RH Temperature 23.71 ºC Humidity 42.95 % RH Temperature 23.71 ºC Humidity 42.95 % RH

66

Emulate Contiki with Cooja
Temperature 23.71 ºC Humidity 42.98 %RH
As usual you can check the driver implementation at the platform/z1/dev and platform/zoul/dev directories. Check out these locations for other sensors and examples to guide you to implement your own.
Exercise: convert the temperature to Fahrenheit. Try to get the temperature and humidity as high as possible (without damaging the mote!). Try to print only “possible” values (if you disconnect the sensor, you should not print anything, or print an error message!).
3.6. Emulate Contiki with Cooja
Cooja is the Contiki network emulator. Cooja allows large and small networks of Contiki motes to be emulated at the hardware level, which is slower but allows precise inspection of the system behavior, or at a less detailed level, which is faster and allows simulation of larger networks. Cooja is a highly useful tool for Contiki development as it allows developers to test their code and systems long before running it on the target hardware. Developers regularly set up new simulations both to debug their software and to verify the behavior of their systems. Most of the examples below can be emulated in Cooja as well (except the sensor ones). In the terminal window go to the Cooja directory:
cd contiki/tools/cooja
Start Cooja with the command:
ant run
When Cooja is compiled, it will show a blue empty window. Now that Cooja is up and running, we can try it out with an example simulation.
Go to File , Open Simulation , Browse then navigate to the examples/helloworld and select the hello-world-example.csc . This will load the previously saved hello world example.
67

Create a new simulation
If you want to edit an example (for istance, to use a different type of platform), instead of choosing the Browse option, select Open and Reconfigure , this will walk you through the steps to configure the example.
3.7. Create a new simulation
Click the File menu and click New simulation . Cooja now opens up the Create new simulation dialog. In this dialog, we may choose to give our simulation a new name, but for this example, we’ll just stick with My simulation . Leave the other options at default values. Click the Create button. Cooja brings up the new simulation. You can choose what you want to visualize by using the Tools menu. The Network window shows all the motes in the simulated network, it should be empty now since we have no motes in our simulation. The Timeline window shows all communication events in the simulation over time - very handy for understanding what goes on in the network. The Mote output window shows all serial port printouts from all the motes. The Notes window is where we can put notes for our simulation. And the Simulation control window is where we start, pause, and reload our simulation.
3.8. Add motes to the simulation
Before we can simulate our network, we must add one or more motes. We do this via the Motes menu, where we click on Add motes . Since this is the first mote we add, we must first create a mote type to add. Click Create new mote type and select one of the available mote types. For this example, we click Z1 mote to create an emulated Z1 mote type. Cooja opens the Create Mote Type dialog, in which we can choose a name for our mote type as well as the Contiki application that our mote type will run. For this example, we stick with the suggested name, and click on the Browse button on the right hand side to choose our Contiki application.
68

Chapter 4. Wireless with Contiki
In the previous section we covered some of the core features of Contiki, basics of sensors and a general overview of how the applications are built, programmed and simulated in Contiki. This section introduces the wireless communication, details about radios, and basics ideas about configuring our platforms.
4.1. Preparing your device
The very first step is understanding how our platform is configured.
Each platform implements its own set of default values and configurations, to be used by underlying modules like the radio, the serial port, etc.
The places to visit for the Zolertia platform are the following:
• Specific hardware settings: parameters such as the default I2C pins, ADC channels, module-specific pin assignment and platform information can be found at platform/ zoul/remote/dev/board.h and platform/z1/platform-conf.h .
• Specific Contiki settings: UART settings, MAC driver, radio channel, IPv6, RIME and network buffer configuration, among others, can be found at platform/zoul/contikiconf.h and platform/z1/contiki-conf.h .
As a general good practice, user configurable parameters are normally allowed to be overridden by the applications, this also serves as a guideline to discern which values can be changed by the casual user, from those meant to be changed only if you really know what you are doing. Below is an example:
#ifndef UART0_CONF_BAUD_RATE #define UART0_CONF_BAUD_RATE 115200 #endif
By defining UART0_CONF_BAUD_RATE in our application’s project-conf.h , we can change the default 115200 baud rate. Notice that generally it is a good practice to add CONF to the user configurable parameters.
One of the most used tools is probably grep , a handy command to search for a text string in any document or location. One way to run this command is grep -lr "alinan . , if executed at the root of our
69

Device addressing

Contiki installation, it will list recursively all the files authored by Antonio Linan. This is a good way to check the location of a specific definition, if you are not using an IDE like Eclipse. Check man grep for more information. For windows Astrogrep 1 is a good option.
In the next section we will review the most notable parameters to configure, but as usual depending on your application and setup, the best way to ensure everything is properly set is by reviewing the specific platform configuration files, and modify or redefine accordingly.
4.1.1. Device addressing
To start working you must first define the Node ID of each node, this will be used to generate the mote’s MAC address and the IPv6 addresses (link-local and global).
RE-Mote addresses
The RE-Mote platform comes with two pre-loaded MAC addresses stored in its internal flash memory, but the user can instead choose a hardcoded one. The following switches at platform/zoul/contiki-conf.h selects the chosen one.

/**

* \name IEEE address configuration

*

* Used to generate our RIME & IPv6 address

* @{

*/

/**

* \brief Location of the IEEE address

* 0 => Read from InfoPage,

* 1 => Use a hardcoded address, configured by IEEE_ADDR_CONF_ADDRESS

*/

#ifndef IEEE_ADDR_CONF_HARDCODED

#define IEEE_ADDR_CONF_HARDCODED

0

#endif

/** * \brief Location of the IEEE address in the InfoPage when * IEEE_ADDR_CONF_HARDCODED is defined as 0 * 0 => Use the primary address location
1 http://astrogrep.sourceforge.net/

70

Device addressing

* 1 => Use the secondary address location */ #ifndef IEEE_ADDR_CONF_USE_SECONDARY_LOCATION #define IEEE_ADDR_CONF_USE_SECONDARY_LOCATION 0 #endif
If using your own hardcoded address, the following define can be overridden by the application:

#ifndef IEEE_ADDR_CONF_ADDRESS #define IEEE_ADDR_CONF_ADDRESS { 0x00, 0x12, 0x4B, 0x00, 0x89, 0xAB, 0xCD, 0xEF } #endif
Z1 mote addresses
Let’s use the ID from the mote list:

Reference Device

Description

--------------------------------------------------

Z1RC3301 /dev/ttyUSB0 Silicon Labs Zolertia Z1

The node ID should be 3301 (decimal) if no previously saved node ID is found in the flash memory.
Let’s see how Contiki uses this to derive a full IPv6 and MAC address. At platforms/z1/ contiki-z1-main.c

#ifdef SERIALNUM if(!node_id) { PRINTF("Node id is not set, using Z1 product ID\n"); node_id = SERIALNUM; }
#endif node_mac[0] = 0xc1; /* Hardcoded for Z1 */ node_mac[1] = 0x0c; /* Hardcoded for Revision C */ node_mac[2] = 0x00; /* Hardcoded to arbitrary even number so that the 802.15.4 MAC
address is compatible with an Ethernet MAC address - byte 0 (byte 2 in the DS ID) */ node_mac[3] = 0x00; /* Hardcoded */ node_mac[4] = 0x00; /* Hardcoded */ node_mac[5] = 0x00; /* Hardcoded */ node_mac[6] = node_id >> 8; node_mac[7] = node_id & 0xff; }

71

Set the bandwidth and channel
So the mote should have the following addresses:
MAC c1:0c:00:00:00:00:0c:e5 Node id is set to 3301. Tentative link-local IPv6 address fe80:0000:0000:0000:c30c:0000:0000:0ce5
Where 0xce5 is the hex value corresponding to 3301 . The global address is only set when an IPv6 prefix is assigned (by now you should know this from earlier sections). If instead you wish to have your own addressing scheme, you can edit the node_mac values at contiki-z1-main.c file. If you wish to replace the node id value obtained from the product id, you need to store a new one in the flash memory, luckily there is already an application to do so: Go to examples/zolertia/z1 location and replace the 158 for your own required value:
make clean && make burn-nodeid.upload nodeid=158 nodemac=158 && make z1-reset && make login
You should see the following:
MAC c1:0c:00:00:00:00:0c:e5 Ref ID: 3301 Contiki-2.6-1803-g03f57ae started. Node id is set to 3301. CSMA ContikiMAC, channel check rate 8 Hz, radio channel 26 Tentative link-local IPv6 address fe80:0000:0000:0000:c30c:0000:0000:0ce5 Starting 'Burn node id' Burning node id 158 Restored node id 158
As you can see, now the node ID has been changed to 158, when you restart the mote you should see that the changes have been applied:
MAC c1:0c:00:00:00:00:00:9e Ref ID: 3301 Contiki-2.6-1803-g03f57ae started. Node id is set to 158. CSMA ContikiMAC, channel check rate 8 Hz, radio channel 26 Tentative link-local IPv6 address fe80:0000:0000:0000:c30c:0000:0000:009e
4.1.2. Set the bandwidth and channel
The bandwidth and allowed channels depend on the operating frequency band. They will be determined by the spectrum regulation agency of the country, along with maximum transmitted power allowable. .The IEEE 802.15.4 standard
72

Set the bandwidth and channel
The IEEE 802.15.4 is a standard for wireless communication, it specifies the physical and media access control layers for low-rate wireless personal area networks (LRWPANs). The standard specifies the use of the 868-868.8 MHz (in Europe and many other countries), the 902-928 MHz (in United States, Canada, and some Latin America countries), or the world-wide 2.400-2.4835 GHz band part of the Industrial Scientific and Medical applications (ISM).
Figure 4.1. IEEE 802.15.4 2.4 GHz regulation requirements (electronicdesign.com, 20132)
In practice the 2.4 GHz band is being heavily used due to its world-wide availability. The ZigBee proprietary protocol by the ZigBee alliance was one of the early adopters of IEEE 802.15.4. It did so leveraging the physical and MAC layer of IEEE 802.15.4, specifying on top additional routing and networking functionality to build mesh networks. Quite recently the Thread Group 3 has proposed its own simplified IPv6-based mesh networking protocol for connecting products around the home to each other, to the Internet and to the cloud. This will surely boost the adoption of IEEE 802.15.4 and IPv6.
2 http://electronicdesign.com/what-s-difference-between/what-s-difference-between-ieee-802154-and-zigbeewireless 3 http://threadgroup.org/
73

Set the bandwidth and channel
Figure 4.2. Thread layers and standards (Thread group, 20154) Working at 2.4 GHz
As the 2.4 GHz band is also used by other technologies like WiFi and Bluetooth, this spectrum is shared and overlaps might occur. The Figure below shows the channel allocation of the 2.4 GHz IEEE 802.15.4, and the recommended channels to avoid interferences with other colocated devices. With the rise of the Bluetooth Low Energy, and the ubiquitous WiFi present in our lives, the selection of a proper operating channel is crucial in any deployment.
4 http://threadgroup.org/
74

Set the bandwidth and channel

Figure 4.3. Channel assignment
The default channel of the RE-Mote is defined as follows:

#ifndef CC2538_RF_CONF_CHANNEL

#define CC2538_RF_CONF_CHANNEL

26

#endif /* CC2538_RF_CONF_CHANNEL */

The Z1 mote defines its default channel as:

#ifdef RF_CHANNEL #define CC2420_CONF_CHANNEL RF_CHANNEL #endif

#ifndef CC2420_CONF_CHANNEL

#define CC2420_CONF_CHANNEL

26

#endif /* CC2420_CONF_CHANNEL */

The radio channel can be defined from the application’s project-conf.h or the Makefile .
The radio drivers in Contiki are implemented to comply with the struct radio_driver in core/dev/radio.h . This abstraction allows to interact with the radio using a standardized API, independently of the radio hardware. The functions to set and read radio parameters are explained below.

/** Get a radio parameter value. */ radio_result_t (* get_value)(radio_param_t param, radio_value_t *value);

75

Set the transmission power
/** Set a radio parameter value. */ radio_result_t (* set_value)(radio_param_t param, radio_value_t value);
To change the channel from the application use RADIO_PARAM_CHANNEL as follows:
rd = NETSTACK_RADIO.set_value(RADIO_PARAM_CHANNEL, value);
Where value can be any value from 11 to 26, and rd will be either RADIO_RESULT_INVALID_VALUE or RADIO_RESULT_OK .
Working at 863-950 MHz
The RE-Mote has a dual 2.4 GHz and 863-950 MHz RF interface, which can be selected alternatively, or used simultaneously (the latter currently not supported in Contiki at the moment). As default the RE-Mote uses the IEEE 802.15.4g mandatory mode for the 868 MHz band, configured for 2-GFSK modulation, 50 kbps data rate and with 33 channels available. The RE-Mote uses the Texas Instruments CC1200 RF transceiver, referred to in Contiki as dev/cc1200 . The default configuration file is located in dev/cc1200/ cc1200-802154g-863-870-fsk-50kbps.c . To change channels from the application we use the RF API:
rd = NETSTACK_RADIO.set_value(RADIO_PARAM_CHANNEL, value);
Where value can be any value from 11 to 26, and rd it will be either RADIO_RESULT_INVALID_VALUE or RADIO_RESULT_OK .
4.1.3. Set the transmission power
The radio frequency power transmission is that at the output of the transmitter before reaching the antenna. The higher the transmission power the higher the wireless range, but the power consumption usually increases as well. The range is heavily dependent on the frequency, the antenna used and its height above the ground.
76

Set the transmission power

Changing the transmission power for the Z1 (CC2420) and the REMote (CC2538)
The RE-Mote platform uses the CC2538 built-in 2.4 GHz radio. As default the transmission power is set to 3 dBm (2 mW) in the cpu/cc2538/cc2538-rf.h header as shown below.

CC2538_RF_TX_POWER_RECOMMENDED 0xD5

This recommended value is taken from the SmartRF Studio 5 .

Other values and its corresponding output power levels are shown in the next table.

Table 4.1. CC2538 Transmission power recommended values (from SmartRF Studio6)

TX Power (dBm) +7 +5 +3 +1 0 -1 -3 -5 -7 -9 -11 -13 -15 -24

Value 0xFF 0xED 0xD5 0xC5 0xB6 0xB0 0xA1 0x91 0x88 0x72 0x62 0x58 0x42 0x00

5 http://www.ti.com/tool/smartrftm-studio&DCMP=hpa_rf_general&HQS=Other+OT+smartrfstudio 6 http://www.ti.com/tool/smartrftm-studio&DCMP=hpa_rf_general&HQS=Other+OT+smartrfstudio
77

Set the transmission power

As illogical as it may sound, there might be some reasons to reduce transmission power:

• To reduce the power consumption. • To test a multi-hop network without placing the nodes too far (too
much power can saturate the receiver). • To avoid interference among co-located networks in the same area.
The current consumption can go from 24 mA to 34 mA when changing the transmission power from 0 dBm to 7 dBm (AN125 7 ).
The Z1 mote uses the Texas Instrument CC2420 RF transceiver. As default the transmission power is set to 0 dBm (1 mW), which is the maximum allowed by the radio.
The available output power and its corresponding configuration values are listed in the table below, as well as the current consumption at each level.
Table 4.2. CC2420 Transmission power (CC2420 datasheet, page 518)

TX Power

Value

mA

(dBm)

0

31

17.4

-1

27

16.5

-3

23

15.2

-5

19

13.9

-7

15

12.5

-10

11

11.2

-15

7

9.9

-25

3

8.5

For both platforms the transmission power can be changed with:

rd = NETSTACK_RADIO.set_value(RADIO_PARAM_TXPOWER, value); 7 http://www.ti.com/lit/an/swra437/swra437.pdf 8 http://www.ti.com/lit/ds/symlink/cc2420.pdf

78

Set the transmission power

Where value can be any value from the above table, and rd it will be either RADIO_RESULT_INVALID_VALUE or RADIO_RESULT_OK .

Changing the transmission power for the RE-Mote (CC1200)

As mentioned earlier, the RE-Mote has an on-board sub-1 GHz interface based on the CC1120 radio transceiver, configured to operate in the 863-950 MHz bands. The maximum transmission power allowed depends on the specific band and regulations in place, which can also impose limits on the maximum antenna gain, be sure to check the local regulations before changing the output power.
The regulations are country specific and out of the scope of this section.
The following values are taken from the SmartRF Studio 9 , using default IEEE 802.15.4g ETSI compliant configuration.

Table 4.3. CC1200 Transmission power recommended values (from SmartRF Studio10)

TX Power (dBm) +14 +13 +12 +11 +8 +6 +4 +3 +2 +1 0 -3 -40

Value 0x7F 0x7C 0x7A 0x78 0x71 0x6C 0x68 0x66 0x63 0x61 0x5F 0x58 0x41

9 http://www.ti.com/tool/smartrftm-studio&DCMP=hpa_rf_general&HQS=Other+OT+smartrfstudio 10 http://www.ti.com/tool/smartrftm-studio&DCMP=hpa_rf_general&HQS=Other+OT+smartrfstudio

79

Set the transmission power

TX Power (dBm) -6 -11 -24 -40

Value 0x51 0x46 0x42 0x41

These values correspond to the CC1200_PA_CFG1 register.
As default the CC1200 driver 11 in Contiki starts with the maximum transmission power, defined as follows:

/* The maximum output power in dBm */

#define RF_CFG_MAX_TXPOWER

CC1200_CONST_TX_POWER_MAX

The minimum and maximum allowed values are set in dev/cc1200/cc1200-const.h as shown below.

/* Output power in dBm */

/* Up to now we don't handle the special power levels PA_POWER_RAMP < 3, hence

* the minimum tx power is -16. See update_txpower().

*/

#define CC1200_CONST_TX_POWER_MIN

(-16)

/*

* Maximum output power will probably depend on the band we use due to

* regulation issues

*/

#define CC1200_CONST_TX_POWER_MAX

14

The CC1200 driver calculates the proper CC1200_PA_CFG1 register value, so we need to pass as value argument the required transmission power.

rd = NETSTACK_RADIO.set_value(RADIO_PARAM_TXPOWER, value);
Where value can be any value from -14 to 16, and rd will be either RADIO_RESULT_INVALID_VALUE or RADIO_RESULT_OK .

11 https://github.com/contiki-os/contiki/blob/master/dev/cc1200/cc1200.c
80

