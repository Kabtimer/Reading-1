M PRA
Munich Personal RePEc Archive
Data Science with Python: Algorithm, Statistics, DataViz, DataMining and Machine-Learning
Moussa Keita
February 2017
Online at https://mpra.ub.uni-muenchen.de/76653/ MPRA Paper No. 76653, posted 7 February 2017 14:56 UTC

Data Science sous Python
Algorithme, Statistique, DataViz, DataMining et Machine-Learning
____
Par
Moussa Keita, PhD Consultant Big Data-Data Science Umanis Consulting Group, Paris
Février 2017
(Version 1.0)
Résumé
La Data Science est une discipline technique qui associe les concepts statistiques aux algorithmes puissants de calculs informatiques en vue du traitement et de la modélisation des données de masse issues des phénomènes de l’observation (économiques, industriels, commerciaux, financières, managériaux, sociaux, etc..). En matière de Business Intelligence et de veille stratégique, la Data Science est devenue un outil incontournable d’aide à la prise de décisions pour les dirigeants. Elle permet d’exploiter et de valoriser tout le patrimoine informationnel interne et externe de l’entreprise. Le langage de programmation Python s’est rapidement imposé, au cours des récentes années, comme un langage de premier choix à la disposition des Data Scientists pour exploiter le potentiel grandissant du Big Data. Le gain de popularité dont bénéficie, aujourd’hui, ce langage s’explique en grande partie par les nombreuses possibilités offertes par ses puissants modules notamment d’analyses numériques et de calculs scientifiques (numpy, scipy, pandas), de visualisation de données (matplotlib) mais aussi de Machine Learning (scikit-learn). Présenté dans une approche hautement pédagogique, ce manuscrit revisite les différents concepts indispensables à la maitrise de la Data Science sous Python. Le travail est organisé en sept chapitres. Le premier chapitre est consacré à la présentation des bases de la programmation sous Python. Dans ce chapitre, nous présentons notamment les différents éléments de langage qui forment l’ossature du programme python mais aussi les différents objets de programmation qui en forment le socle. Le second chapitre est consacré à l’étude des chaînes de caractères et des expressions régulières. L’objectif de ce second chapitre est de se familiariser avec le traitement et l’exploitation des chaînes de caractères qui constituenet les valeurs des variables couramment rencontrées dans les bases de données non structurées. Le troisième chapitre est consacré à la présentation des méthodes de gestion de fichiers et de traitements de texte. Le but de ce chapitre est d’approfondir le précédent chapitre en présentant les méthodes couramment utilisées pour le traitement des données non structurées qui se présentent généralement sous forme de fichiers de textes. Le quatrième chapitre est consacré à la présentation des méthodes de traitement et d’organisation des données initialement stockées sous forme de tables de données. Le cinquième chapitre est consacré à la présentation des méthodes classiques d’analyses statistiques (analyses descriptives, tests statistiques, régression linéaires et logistiques,…). Quant au sixième chapitre, il est consacré à la présentation des méthodes de datavisualization : histogrammes, diagrammes en barres, pie-plots, box-plots, scatter-plots, courbes d’évolution,
1

graphiques en 3D,…). Enfin le septième chapitre est consacré à la présentation des méthodes de datamining et de machine-learning. Dans ce chapitre, nous présentons notamment les méthodes de réductions de dimensions des données (Analyses en Composantes Principales, Analyses Factorielles, Analyses des Correspondances Multiples) mais aussi des méthodes de classification (Classification Ascendante Hiérarchique, K-Means Clustering, Support Vector Machine, Random Forest). Toutefois, nous tenons à signaler que le manuscrit est toujours en progression. De ce fait nous restons ouverts à toutes les critiques et suggestions de nature à améliorer son contenu.
 Contact info: Email : keitam09@ymail.com Nous tenons ici à remercier les auteurs dont les travaux ont été d’un apport considérable à la rédaction de ce document. Il s’agit notamment de Cordeau et Pointal (2010), Fuchs et Pierre (2014), Le GOFF(2011), Rakotomalala Ricco, (2015) , Swinnen Gérard,(2010) ainsi que Chris Albon à travers son site http://chrisalbon.com/. Codes JEL: C8 Mots clés: Programmation, langage Python, Data science, Traitement et analyses de données, data visualization.
2

Table des matières
Chapitre 1 : Les bases de la programmation sous python ............................................................... 21
1.1. Introduction ........................................................................ 21 1.2. Les éléments structurants d’un programme Python ................ 22
1.2.1. Les variables .................................................................................... 22
1.2.1.1. Définir une variable ........................................................................................................ 22 1.2.1.2. Type d’une variable ........................................................................................................ 25 1.2.1.3. Méthodes associées aux variables .................................................................................. 27 1.2.1.3. Les opérateurs arithmétiques et logiques (booléens) ..................................................... 28
1.2.2. Les instructions conditionnelles : la clause « if… else » ........................ 30 1.2.3. Les instructions en boucle ................................................................. 32
1.2.3.1. Les instructions en boucle « while… »............................................................................. 32 1.2.3.2. Les instructions en boucle « for… in… ».......................................................................... 33
1.2.4. Les instructions break et continue dans une clause « while… » ou « for … in…» ........................................................................................................ 35 1.2.5. Les mots réservés du langage python ................................................ 35
1.3. Les principaux objets du langage Python ............................... 36 1.4. Etude des objets « liste » ...................................................... 38
1.4.1. Caractéristiques générales des listes..................................................38
1.4.1.1. Définition d’un objet liste ............................................................................................... 39 1.4.1.2. Indiçage d’une liste (slicing) ........................................................................................... 40
1.4.3. Les opérations sur les listes ............................................................... 41
1.4.3.1. Déterminer le nombre d’éléments d’une liste ................................................................ 41 1.4.3.2. Additionner des listes..................................................................................................... 42 1.4.3.3. Démultiplication des éléments d’une liste ...................................................................... 42 1.4.3.4. Modifier ou remplacer les éléments d’une liste .............................................................. 43 1.4.3.5. Ajouter de nouveaux éléments à une liste : fonction append() ....................................... 43
3

1.4.3.6. Insérer de nouveaux éléments dans une liste : fonction insert() ..................................... 44 1.4.3.7. Supprimer un élément d’une liste fonctions remove() ou delete .................................... 44 1.4.3.8. Renvoyer l’indice d’un élément en se basant sur sa valeur :fonction index() .................. 45 1.4.3.9. Compter le nombre d’occurrences d’une valeur dans une liste : fonction count()........... 45 1.4.3.10. Trier les éléments d’une liste : fonction sort()............................................................... 45 1.4.3.11. Intervertir l’ordre des éléments dans une liste : fonction reverse()................................ 46 1.4.3.12. Joindre les éléments d’une liste pour former une chaîne de caractères : fonction join()46 1.4.3.13. Tester l’existence d’un élément dans une liste : fonction in .......................................... 47 1.4.3.14. Récupérer simultanément les indices et les valeurs des éléments d’une liste : fonction enumerate() ............................................................................................................................... 47 1.4.3.15. Faire la copie d’une liste ............................................................................................... 48 1.4.3.16. Combiner les éléments de deux listes pour former une liste de couple d’éléments : fonction zip() .............................................................................................................................. 51
1.5. Les fonctions map(), filter() et reduce() pour le traitement des listes ......................................................................................... 53
1.5.1. La fonction map() ............................................................................. 53 1.5.2. La fonction filter() ............................................................................ 55 1.5.3. La fonction reduce()..........................................................................56
1.6. Etude des objets « tuples » ................................................... 57
1.6.1. Définition d’un tuple ........................................................................ 58 1.6.2. Indiçage des tuples (slicing)............................................................... 58
1.7. Etude des objets « set » ........................................................ 59 1.8. Etude des objets « array » ..................................................... 60
1.8.1. Définition d’un array ........................................................................ 61
1.8.1.1. Définition d’un array à 1 dimension ................................................................................ 61 1.8.1.2. Définition d’un array à plusieurs dimensions ................................................................. 62 1.8.1.3. Indiçage d’un array (slicing) ............................................................................................ 62
1.8.2. Déterminer la dimension d’array ....................................................... 63 1.8.3. Les opérations sur les arrays ............................................................. 63
1.8.3.1. Conversion d’un array vectoriel en array matriciel: fonction reshape() et resize()........... 63
4

1.8.3.2. Transposé d'un array matriciel: fonction transpose() ..................................................... 64 1.8.3.3. Création d'un array matriciel rempli de 0 ou 1: fonctions zeros() et ones() ..................... 64 1.8.3.4. Les opérations algébriques (matricielles) sur les arrays.................................................. 64 1.8.3.5. Utilisation de la fonction argsort() sur un array .............................................................. 65
1.9. Etude des objets « dictionnaire » ........................................... 65
1.9.1. Définition d’un dictionnaire .............................................................. 65 1.9.2. Accéder aux éléments d’un dictionnaire (slicing).................................66
1.9.2.1. Slicing d’un dictionnaire dans le cas d’une clé à valeur unique ....................................... 66 1.9.2.2. Slicing d’un dictionnaire dans le cas d’une clé à plusieurs valeurs .................................. 67
1.9.3. Modification de dictionnaire : ajout et suppression de clés ou de valeurs ................................................................................................................ 67
1.9.3.1. Ajout ou modification de clés ou de valeurs ................................................................... 67 1.9.3.2. Suppression de clés ou de valeurs dans un dictionnaire ................................................. 68
1.9.4. Renommer une clé dans un dictionnaire.............................................68 1.9.5. Tester l’existence d’une clé dans un dictionnaire : la fonction in...........68 1.9.6. Récupérer les clés ou les valeurs d’un dictionnaire (les fonctions keys() et values()) ...................................................................................................69
1.10. Etude des fonctions ............................................................69
1.10.1. Aperçu général sur quelques fonctions prédéfinies sous python : la fonction print() et la fonction input()........................................................... 70
1.10.1.1. La fonction print()......................................................................................................... 70 1.10.1.2. La fonction input() ........................................................................................................ 70
1.10.2. Les fonctions définies par l’utilisateur .............................................. 71
1.10.2.1. Définir une fonction.......................................................................................................71 1.10.2.2. Les fonctions lambda ....................................................................................................77
1.10.3. Les variables locales et les variables globales .................................... 77 1.10.4. Récupérer la valeur renvoyée par une fonction : l’instruction return ... 79 1.10.5. Utilisation des générateurs de fonction : l’instruction yield ................80 1.10.6. Gestion des erreurs et des exceptions lors de la définition d’une fonction ................................................................................................... 82
5

1.10.6.1. Utilisation des blocs ty-except...................................................................................... 82 1.10.6.2. Utilisation des clause « else » et « finally » dans une exception .................................... 85 1.10.6.3. Les exceptions déclenchées par l’utilisateur : l’instruction raise ................................... 86
1.10.7. Documenter une fonction ............................................................... 87
1.11. Les modules python ........................................................... 87
1.11.1. Importation d’un module python .....................................................88 1.11.2. Utilisation d’un module python .......................................................89
1.11.2.1. Quelques utilisations de la fonction math..................................................................... 89 1.11.2.2. Quelques exemples d’utilisation du module random.................................................... 89
1.11.3. Définir et utiliser son propre module ................................................ 91 1.11.4. Procédure d’installation et d’utilisation des modules externes ........... 91 1.11.5. Désinstaller un module ................................................................... 93
1.12. Aperçu général sur les objets « classe ».................................94 1.13. Utilisation du module pickle pour l'enregistrement et le chargement des objets python .................................................... 95
1.13.1. Utilisation de la fonction Pickler ...................................................... 95 1.13.2. Utilisation de la fonction Unpickler ..................................................96
Chapitre 2 : Etude des chaînes de caractères et des expressions régulières ......................................... 97
2.1. Les chaînes de caractères...................................................... 97
2.1.1. Définition d’une variable de type chaîne de caractères ........................ 97 2.1.2. Indiçage des chaînes de caractères (slicing) ........................................98 2.1.3. Déterminer la longueur d’une chaîne de caractères (nombre de caractères) ................................................................................................ 99 2.1.4. Addition de chaînes de caractères (concaténation) .............................99 2.1.5. Modifier la casse d’une chaîne en majuscule, minuscule ou capital : fonctions upper(), lower() et capitalize().................................................... 100 2.1.6. Rechercher un caractère (ou un motif) dans une chaîne et renvoyer son indice : fonction find().............................................................................. 100
6

2.1.7. Rechercher un caractère (un motif) dans une chaîne et remplacer par un autre : fonction replace().......................................................................... 102 2.1.8. Compter le nombre d’occurrence d’un motif dans une chaîne : fonction count() ................................................................................................... 102 2.1.9. Découper une chaîne de caractères en liste : fonction list() ou fonction split() ..................................................................................................... 102
2.1.9.1. Cas où les espaces sont traités comme des valeurs (list()) ............................................ 102 2.1.9.2. Cas où les espaces sont traités comme des séparateurs (split()) ...................................103
2.1.10. Les opérations logiques et booléennes sur les chaines de caractères. 104
2.1.10.1. La fonction startwith()................................................................................................ 104 2.1.10.2. la fonction endwith() .................................................................................................. 105 2.1.10.3. La fonction in ............................................................................................................. 105 2.1.10.4. La fonction islower()................................................................................................... 105 2.1.10.5. La fonction isupper() .................................................................................................. 105 2.1.10.6. La fonction istitle() ..................................................................................................... 105 2.1.10.7. La fonction isalpha() ................................................................................................... 106 2.1.10.8. La fonction isalnum() ................................................................................................. 106 2.1.10.9. La fonction isdigit() .................................................................................................... 106
2.1.11. Formatage de valeurs à l’intérieur d’une chaine de caractères .......... 107
2.1.11.1. Formatage avec l’opérateur de concaténation "+" ...................................................... 108 2.1.11.2. Utilisation de l’opérateur de formatage "%" % .......................................................... 108 2.1.11.3. Utilisation de la fonction format()............................................................................... 109 2.1.11.4. Formatage de valeurs indicées et création de variables indicées.................................110
2.1.12. Utilisation de l’opérateur antislash \ : mise en forme de la chaîne et traitement des caractères spéciaux .......................................................... 111
2.2. Etudes des expressions régulières (regex ou re) .................... 112
2.2.1. Définition et rôle des expressions régulières ..................................... 112 2.2.2. Les opérateurs d’expression régulière .............................................. 113 2.2.3. Exemples d’application des opérateurs d’expressions régulières ........ 115 2.2.4. Construire une expression : la fonction compile() .............................. 117
2.2.4.1. Le rôle de la fonction compile().....................................................................................117
7

2.2.4.2. Utilisation de la fonction compile() sans directives ....................................................... 117 2.2.4.3. Utilisation de la fonction compile() avec directives .......................................................118
2.2.5. Quelques fonctions associées aux expressions régulières .................. 118
2.2.5.1. La fonction search() ......................................................................................................118 2.2.5.2. La fonction match() ..................................................................................................... 120 2.2.5.3. La fonction findall().......................................................................................................121 2.2.5.4. La fonction fonction sub().............................................................................................123 2.2.5.5. La fonction findinter() ...................................................................................................123 2.2.5.6. La fonction group() ...................................................................................................... 124
2.2.6. Etude de quelques expressions régulières couramment rencontrées .. 126
2.2.6.1. Cas 1 : Correspondance avec une expression exacte uniquement ................................ 126 2.2.6.2. Cas 2 :Correspondance avec un mot ou une expression figurant dans une liste ........... 126 2.2.6.3. Cas 3 :Correspondance avec un mot présentant des variantes orthographiques ou des caractères spéciaux ...................................................................................................................127 2.2.6.4. Cas 4 : Correspondance avec une adresse e-mail sur un domaine spécifique................127 2.2.6.5. Cas 5 :Correspondance avec une adresse IP comprise dans une plage ......................... 128 2.2.6.6. Cas 6 : Correspondance avec un format alphanumérique ............................................ 129
2.2.7. Exercices de synthèse sur l’utilisation des regex ............................... 130
Chapitre 3 : Gestion de fichiers et traitements de texte sous Python.......................................................133
3.1. Aperçu général sur quelques modules de gestion de fichiers sous Python .................................................................................... 133 3.2. Utilisation du module o.s pour la gestion des fichiers et des répertoires............................................................................... 133
3.2.1. Définir un répertoire de travail......................................................... 133 3.2.2. Créer un nouveau dossier dans le répertoire défini ............................ 134 3.2.3. Renommer un dossier dans le répertoire .......................................... 134 3.2.4. Supprimer un dossier...................................................................... 134 3.2.5. Tester si un fichier existe dans le répertoire ...................................... 134 3.2.6. Supprimer un fichier exitant dans le répertoire ................................. 135
8

3.2.7. Lister l'ensemble des fichiers présents dans un répertoire (avec ou sans extensions)............................................................................................. 136 3.2.8. Découper le chemin complet : la fonction os.path.split() ................... 136 3.2.9. Recomposer le chemin complet à partir d’un chemin et du nom du fichier : la fonction os.path.joint()............................................................. 136 3.2.10. Tester si un chemin existe ............................................................. 137 3.2.11. Tester si un chemin conduit à un fichier .......................................... 137 3.2.12. Tester si le chemin indiqué est un répertoire ................................... 137 3.2.13. Ouvrir un fichier............................................................................ 137
3.3. Gestion de répertoires et de fichiers : utilisation du module shutil ............................................................................................... 139
3.3.1. Copie de dossier ou de fichiers : avec le module shutil ....................... 139
3.3.1.1. Utilisation de la fonction shutil.copyfile() ..................................................................... 139 3.3.1.2. Utilisation de la fonction shutil.copy ............................................................................ 139 3.3.1.3. Utilisation de la fonction shutil.copyfileobj................................................................... 139 3.3.1.4. Utilisation de la fonction shutil.copystat ...................................................................... 140
3.3.2. Création de fichier archive ZIP ou TAR avec shutil ............................. 140
3.4. Visualiser le contenu du fichier lu : les fonctions read(), read(n), readline(), readlines(), et xreadlines()......................................... 141
3.4.1. Utilisation de la fonction read() ....................................................... 141 3.4.2. Utilisation de la fonction readline() .................................................. 141 3.4.3. Utilisation de la fonction readlines() ................................................ 142 3.4.4. Utilisation de la fonction read(n) ..................................................... 142 3.4.5. Utilisation de la fonction xreadlines()............................................... 142 3.4.6. Gestion des lignes en blank générées par les commandes readline() et readlines() .............................................................................................. 142
3.5. Découper un texte en une liste de mots : la fonction splitlines() ou la fonction append() ............................................................. 143
3.5.1. Utilisation de la fonction splitlines() ................................................. 143
9

3.5.2. Utilisation de la boucle for avec la fonction append()......................... 143
3.6. Déplacer le curseur dans un texte : les fonctions seek() et tell() ............................................................................................... 145 3.7. Ouvrir et modifier le contenu d'un fichier : la fonction write() et writelines() .............................................................................. 145 3.8. Ouvrir un fichier en mode append 'a' .................................... 148 3.9 Ouvrir un fichier en mode binaire 'b'...................................... 149 3.10. Utilisation de la fonction « with ... as » pour la gestion des fichiers .................................................................................... 149 3.11. Encodage et décodage des textes en python ...................... 149
3.11.1. Décodage de texte........................................................................ 150 3.11.2. Encodage de texte ........................................................................ 151 3.11.3. Peut-on détecter l'encodage d'un fichier texte ?.............................. 152
3.12. Présentation du module URLLIB pour gestion des urls et la lecture de fichiers à partir des urls (uniform resource locator) ....... 153
3.12.1. Le module urllib.request ............................................................... 153
3.12.1.1. Utilisation de la fonction urllib.request.urlopen() ........................................................153 3.12.1.2. Utilisation de la fonction urllib.request.urlretrieve() ................................................... 154 3.12.1.3. Utilisation de la fonction urllib.request.Request()....................................................... 154 3.12.1.4. Cas des requêtes POST ...............................................................................................155
3.12.2. Utilisation du module requests comme alternatif de urllib.request ... 155 3.12.3. Le module urllib.error ................................................................... 156
3.12.3.1. Utilisation de la fonction urllib.error.URLError() ......................................................... 156 3.12.3.2. Utilisation de la fonction HTTPError() ........................................................................ 156
3.12.4. Le module urllib.parse() ................................................................ 156
3.12.4.1. Décomposer un url en différentes composantes ........................................................ 156 3.12.4.2. Rassembler différentes composantes en un url ..........................................................157
3.13. Extraction et gestion des textes a partir des pages html ou xml (pages avec balisages) : utilisation du module BeautifulSoup ....... 158
10

3.13.1. Utilisation du module BeautifulSoup: extraction du texte à partir d'une page htlm ou xlm avec parsing ................................................................. 158
3.13.1.1. Lecture de la page html ou xml ................................................................................... 158 3.13.1.2. Le parsing de la page récupérée ................................................................................. 158 3.13.1.3. Navigation dans le texte parsé.................................................................................... 160
3.13.2. Quelques balises html (tags).......................................................... 162 3.13.3. Utilisation du module pattern-web pour le parsing des pages web.... 164 3.13.4. Utilisation du module xml pour le parsing des pages web ................ 164 3.13.5. Utilisation du module html2text pour le parsing des pages web ....... 164 3.13.6. Utilisation du module NLTK pour le parsing des pages web ............. 164
3.14. Text mining avec le module NLTK ..................................... 165
3.14.1. Convertir un texte en format nltk................................................... 165 3.14.2. Découper une chaîne de caractères en des mots : la fonction tokenize() .............................................................................................................. 166 3.14.3. Rechercher un mot dans un texte et afficher la (les) phrase(s) qui le contient(nent) ........................................................................................ 167 3.14.4. Repertorier les n premiers mots les plus fréquents dans un texte avec la fonction FreqDist .................................................................................... 170 3.14.5. Compter le nombre d'occurences de la longueur des mots dans un texte .............................................................................................................. 170 3.14.6. Identifier des collocations de mots................................................. 171 3.14.7. Stemming, lemmatisation et post-tag des mots dans un texte ........ 171
3.14.7.1. Le stemming ou la racinisation .................................................................................... 171 3.14.7.2. La lemmatisation......................................................................................................... 173 3.14.7.3. Les étiquettes grammaticales ( les post-tags)..............................................................173 3.14.7.4. Traitement des StopWords ( les mots vides) ...............................................................174
3.15. Text Matching : calcul des Edit distances et des ratios de matching entre deux séquences de caractères ............................ 174
3 .15.1. Le module difflib .......................................................................... 174
3 .15.1.1. Utilisation de la fonction SequenceMatcher() .............................................................175
11

3 .15.1.2. Utilisation des fonctions get_matching_blocks() et get_opcodes() après SequenceMatcher() ...................................................................................................................176 3 .15.1.3. Utilisation de la fonction differ() .................................................................................176 3 .15.1.4. Utilisation de la fonction ndiff() .................................................................................. 177 3 .15.1.5. Utilisation de la fonction unified_diff()........................................................................ 177 3 .15.1.6. Utilisation de la fonction context_diff() ...................................................................... 177 3 .15.1.7. Utilisation de la fonction Htmldiff()............................................................................. 177
3 .15.2. Le module Levenshtein ................................................................ 178 3.15.3. Le module distance....................................................................... 179
3.15.3.1. Distance de Levenshtein..............................................................................................179 3.15.3.2. Distance de Hamming .................................................................................................179 3.15.3.3.Distance de Sorensen ...................................................................................................179 3.15.3.4.Distance de jaccard ..................................................................................................... 180
3.15.4. Le module FuzzyWuzzy ................................................................ 180 3.15.5. Comparaison des différentes méthodes de matching ...................... 181
3.16. Text Clustering : regroupement des termes d’un texte par des algorithmes de clustering.......................................................... 182
3.16.1. Text clustering avec l’algorithme de l’Affinity Propagation .............. 182 3.16.2. Text clustering par des algorithmes basés sur la matrice TF-IDF ...... 185
3.16.2.1. Construction de la matrice TF-IDF.............................................................................. 185 3.16.2.2. Application du K-means clustering à partir de la matrice de distance ........................ 190 3.16.2.3. Application de la Classification Ascendente Hierarchique (CAH) à partir de la matrice de distance.................................................................................................................................... 192 3.16.2.4. Application du Multidimensional scaling (MDS) à partir de la matrice de distance .... 193
3.17. Stratégie générale de pré-traitement de texte en vue de la recherche d’information, du text matching ou du text clustering . 195
Chapitre 4 : Traitement et Organisation des tables de données ........................................................... 197
4.1. Création des objets « series » .............................................. 197
4.1.1. Création d'une série à partir d'une liste de valeurs ............................. 197
12

4.1.2. Création d'une série à partir d'un dictionnaire................................... 197 4.1.3. Définir des indices pour les séries (identifiant des séries) ................... 198
4.2. Création de table de données (data frame) .......................... 198
4.2.1. Création de data frame à partir des séries......................................... 199 4.2.2. Création du dataframe à partir d'un dictionnaire............................... 199 4.2.3. Création d’un dataframe vide (d’observations) ................................. 200
4.3. Création de dataframe à partir des sources de données externes ............................................................................................... 200
4.3.1. Importation des fichiers txt et csv.................................................... 200 4.3.2. Importation de fichiers Excels ......................................................... 203 4.3.3. Importation de données à partir des sources de données non structurées .............................................................................................................. 203
4.3.3.1. Exemple 1 : Convertir un ensemble de texte en un dataframe avec des méthodes classiques de traitement de texte............................................................................................. 204 4.3.3.2. Exemple 2 : Convertir un ensemble de texte en dataframe en utilisant les expressions régulières (regex) ..................................................................................................................... 205
4.4. Exportation des données vers des formats externes ............. 206
4.4.1. Exportation vers le format csv : ....................................................... 206 4.4.2. Exportation vers le format Excel (utilisation de l’engine xlswriter ...... 206
4.5. Description de la table de données ...................................... 208 4.6. Paramétrer le nombre de colonnes et le nombre de lignes à afficher lors de l’affichage de la table de données........................ 209 4.7. Opérations sur les variables ................................................ 209
4.7.1. Sélectionner les variables................................................................ 209
4.7.1.1. Sélectionner une seule colonne .................................................................................... 209 4.7.1.2. Sélectionner plusieurs colonnes ................................................................................... 209
4.7.2. Renommer une colonne dans un dataframe..................................... 210 4.7.3. Transformer les noms des variables en miniscule ou en majuscule...... 210 4.7.4. Transformer une colonne en un index dans un dataframe.................. 210
13

4.7.5. Extraire les noms des colonnes sous forme de liste ........................... 210 4.7.6. Types des variables dans un dataframe ........................................... 211
4.7.6.1. Déterminer le type des variables : la fonction dtypes ....................................................211 4.7.6.2. Convertir le type d’une variable dans un dataframe : la fonction astype().....................211
4.7.7. Création de variable ....................................................................... 212
4.7.7.1. Création des variables avec les opérateurs simples ...................................................... 212 4.7.7.2. Création des variables avec les fonctions mathématiques ............................................213 4.7.7.3. Création des variables par recodage : recodage conditionnel....................................... 214 4.7.7.4. Recodage d'une variable continue (par intervalle de valeurs) ........................................217
4.7.8. Discrétisation d'une variable quantitative ........................................ 217 4.7.9. Convertir une variable catégorielle en une variable binaire ................ 218
4.7.9.1. Utilisation de la fonction get_dummies() ..................................................................... 218 4.7.9.2. Utilisation de la fonction patsy.dmatrix()..................................................................... 218 4.7.9.3. Utilisation de la fonction patsy.dmatrix() pour une variable numérique ....................... 219
4.7.10. Renommer les modalités d'une variable catégorielles ..................... 219 4.7.11. Suppression de variables ............................................................... 219
4.7.11.1. Supprimer une seule variable...................................................................................... 219 4.7.11.2. Suppression de plusieurs variables ............................................................................ 219 4.7.11.3. Supprimer toutes les variables dont le nom commence par un mot ........................... 220
4.7.12. Récupérer les valeurs d'une variable et les stocker sous forme de liste .............................................................................................................. 220 4.7.13. Convertir une date en chaine de caractères en une date reconnue .... 221
4.8. Opérations sur les observations .......................................... 221
4.8.1. Sélectionner des observations........................................................ 221
4.8.1.1. Sélection des observations à partir de leur indice......................................................... 221 4.8.1.2. Sélction des observations selons les valeurs d’une ou de plusieurs variables (sélection conditionnelle) ......................................................................................................................... 221 4.8.1.3. Sélectionner des observations par tirage aléatoire ...................................................... 222
4.8.2. Trier les observations ..................................................................... 223 4.8.3. Traitement des observations avec valeurs manquantes .................... 224
14

4.8.3.1. Création d’une table avec des valeurs manquantes...................................................... 224 4.8.3.2. Supprimer toutes les observations avec valeurs manquantes ...................................... 224
4.8.4. Identifier l'observation qui a la valeur maximale sur une variable ....... 225 4.8.5. Suppression d'observations ............................................................ 225
4.8.5.1. Suppression des observations sur la base des indices .................................................. 226 4.8.5.2. Suppression des observations selon une condition ...................................................... 226
4.8.6. Identification et Suppressions des obervations dupliquées dans une table ...................................................................................................... 226
4.8.6.1. Identification des observations dupliquées .................................................................. 226 4.8.6.2. Suppression des observations dupliquées ................................................................... 226
4.8.7. Comptage des valeurs dans une table .............................................. 227
4.8.7.1. Comptage des valeurs sur une seule variable ............................................................... 227 4.8.7.2. Comptage sur plusieurs variables................................................................................. 227
4.8.8. Créer un rang pour les obervations .................................................. 227
4.9. Construire une boucle DO LOOP (sur les variables ou sur les observations) ........................................................................... 228 4.10. Calculer la somme par colonne ou par ligne et calcul du cumul ............................................................................................... 228
4.10.1. Calcul de la somme par ligne ......................................................... 229 4.10.2. Calcul de la somme par colonne ..................................................... 229 4.10.3. Calcul de la somme cumulée par ligne ou par colonne...................... 229
4.11. Calcul de valeurs par groupe et agrégation des données dans une table ................................................................................. 229
4.11.1. Utilisation de la fonction groupby() ................................................ 229 4.11.2. Utilisation de la fonction groupby() combinée avec la fonction agg() 230 4.11.3 Utilisation d'une formule dans la définition d'une fonction d'aggréation .............................................................................................................. 231 4.11.4. Définition d'une agréagtion plus complexe: statistique pour pour plusieurs variable (avec plusieurs fonctions par variable) ............................ 231 4.11.5. Merging des valeurs agrégées à la table initiale............................... 232
15

4.12. Opération sur tables de données....................................... 233
4.12.1. Fusion de tables ........................................................................... 233
4.12.1.1. Fusion verticale ou juxtaposition de table (append) ................................................... 234 4.12.1.2. Fusion de deux tables sur les variables (sans clé d'identification) ............................... 234 4.12.1.3. Fusion de deux tables sur les variables avec clé d'identification (merge) .................... 234
4.12.2. Reformattage de tables (reshape).................................................. 236 4.12.3. Mettre une table sous format verticale ........................................... 236
4.13. Standardiser les variables d'une table................................ 237
Chapitre 5 : Les analyses statistiques classiques sous Python ............................................................. 239
5.1. Paramétrage de python et chargement des modules usuels .. 239 5.2. Statistiques descriptives ..................................................... 239
5.2.1. Statistiques desriptives sur les variables quantitatives ...................... 239
5.2.1.1. Utilisation du scipy.stats .............................................................................................. 239 5.2.1.2. Utilisation du module statsmodels............................................................................... 241
5.2.2. Statistiques descriptives sur les variables qualitatives ....................... 241
5.2.2.1. Tableau de fréquence univarié (tri simple) ................................................................... 241 5.2.2.2. Tableau de fréquences croisé....................................................................................... 242
5.2.3. Statistiques descriptives croisées et mesures d’associations ............. 243
5.2.3.1. Mesure d’assocation entre variables quantitatives : le coefficient de corrélation ........ 243 5.2.3.2. Mesure d’association entre variables qualitatives : le test d'indépendance de khi-deux ................................................................................................................................................. 244
5.3. Calcul de quantiles, de fonction de répartition et de fonction de densité .................................................................................... 244
5.3.1. Fonction de répartition et calcul de quantile ..................................... 244 5.3.2. Lecture des tables statistiques avec python ..................................... 245
5.3.2.1. Loi normale centrée et réduite ..................................................................................... 245 5.3.2.2. Loi de Student ............................................................................................................. 245 5.3.2.3. Loi du khi-2 .................................................................................................................. 246
16

5.3.2.4. Loi de Fisher................................................................................................................. 246
5.4. Tests d'adéquation à une Loi............................................... 246
5.4.1. Test d’adéquation à une loi normale ................................................ 246
5.4.1.1. Test de normalité d'Agostino ....................................................................................... 246 5.4.1.2. Test de Normalité Shapiro-Wilks ................................................................................. 246 5.4.1.3. Test de normalité d'Anderson-Darling ......................................................................... 247 5.4.1.4. Test de normalité de Kolmogorov-Smirnov ................................................................. 247 5.4.1.5. Le test de normalité de Lillifors .................................................................................... 247
5.4.2. Test d'adéquation à une loi de khi-deux ........................................... 247
5.5. Test de conformité à valeur de référence : test d’égalité de la moyenne à une valeur............................................................... 248 5.6. Test d'égalité de moyennes sur échantillons indépendants ... 249 5.7. Test d'égalité de moyennes sur échantillons indépendants appariés .................................................................................. 249 5.8. Comparaison de moyennes sur plusieurs groupes : le test ANOVA ................................................................................... 250 5.9. Modèles de régressions linéaires multiples ........................... 250
5.9.1. Estimation d’un modèle de régression linéaire.................................. 250
5.9.1.1. Utilisation du module statsmodels ............................................................................... 250 5.9.1.2. Utilisation du module sklearn ...................................................................................... 252
5.9.2. Analyse prédictive à partir du modele de régression linéaire avec le module sklearn ....................................................................................... 253
5.9.2.1. Estimation et validation du modèle ............................................................................. 253
5.10. Régression logistique binaire............................................. 255
5.10.1. Estimation du modèle logistique binaire......................................... 255
5.10.1.1. Utilisation du module statsmodels ............................................................................. 255 5.10.1.2. Utilisation du module sklearn..................................................................................... 256
5.10.2. Selection automatique des variables explicatives dans la regresssion logistique binaire .................................................................................... 257
17

5.10.3. Analyse prédictive à partir du modèle logistique binaire avec le module sklearn ................................................................................................... 259 5.10.4. Segmentation, scoring et ciblage avec le modele logistique binaire.. 261
5.10.4.1. Objectifs généraux ..................................................................................................... 261 5.10.4.2. Mise en œuvre de la démarche du ciblage ................................................................. 261
5.11. Estimation de modèle de régression logistique multinomiales ............................................................................................... 263
Chapitre 6 : Data visualisation avec python ......... 264
6.1. Les graphiques à barres ...................................................... 264
6.1.1. Barres simples de comparaison de moyennes ................................... 264 6.1.2. Paramétrage du graphique ............................................................. 267
6.1.2.1. Description du role de fig, ax= dans un tracé de graphique .......................................... 267 6.1.2.2. Liste des couleurs en python........................................................................................ 268 6.1.2.3. Ajouter les valeurs des barres au graphique ................................................................. 268 6.1.2.4. Définition et paramétrage des graphiques en plusieurs cadrans.................................. 269
6.1.3. Barres de comparaison (de valeurs) par groupe................................. 270 6.1.4. Barres de comparaison (de moyennes) par groupe............................ 271 6.1.5. Barres inversées (modèle pyramides des âges) ................................. 275 6.1.6. Superposition de plusieurs graphiques en barres dans une fenêtre graphique unique .................................................................................... 277
6.1.6.1. Tracer des deux graphiques en barres dans le même cadran ....................................... 278 6.1.6. 2. Tracer des deux graphiques en barres dans deux cadrans séparés .............................. 279
6.2. Les Histogrammes ............................................................. 280
6.2.1. Histogrammes simples et histogrammes combinés .......................... 280 6.2.2. Combinaison de plusieurs histogrammes dans un seul cadre graphique .............................................................................................................. 283
6.3. Les diagrammes circulaires ................................................. 291
6.3.1. Diagramme circulaire simple ........................................................... 291 6.3.2. Regrouper plusieurs diagrammes circulaires dans un seul graphique .. 293
18

6.4. Les diagrammes de fréquences ........................................... 294
6.4.1. Diagramme de fréquence sur une variable qualitative à codage numérique ( ou sur une variable quantitative)............................................ 295 6.4.2. Diagramme de fréquence sur une variable qualitative à codage en caractères............................................................................................... 296
6.5. Les graphiques en nuages de points .................................... 297
6.5.1. Graphique simple de nuage de points .............................................. 297 6.5.2. Labéliser les valeurs dans un nuage de points ................................... 299 6.5.3. Ajouter une ligne verticale ou horizontale à un nuage de point .......... 300 6.5.4. Nuage de points selon des catégories (représentation dans le même cadran)................................................................................................... 301 6.5.5. Nuage de points selon des catégories (représentation dans des cadrans différents) .............................................................................................. 303
6.6. Graphique en courbe d’évolution (ligne) .............................. 306
6.6.1. Courbe d’évolution d’une seule variable........................................... 306 6.6.2. Représenter plusieurs courbes dans un même cadran ....................... 307 6.6.3. Représenter plusieurs courbes (dans des cadrans différents) ............. 308
6.7. Graphiques en box-plot ...................................................... 309
6.7.1. Box plot simple sur une seule variable.............................................. 309 6.7.2. Box plots par catégorie ou pour plusieurs variables (representés dans le même cadran)......................................................................................... 311 6.7.3. Box plots par catégorie ou pour plusieurs variables (représentés dans des cadrans différents) .................................................................................. 313
6.8. Les graphiques en 3D: exemple: Nuage de points en 3D ....... 316
Chapitre 7: Data mining et machine-learning sous python ............................................................. 318
7.1. Analyses en composantes principales (ACP) ......................... 318 7.2. Analyses factorielles (AFC) .................................................. 319
19

7.3. Analyses des correspondances multiples (ACM) .................... 320 7.4. Classification ascendante hiérarchique (CAH) ....................... 321 7.5. K-Means clustering (méthodes des centroides) .................... 323
7.5.1. Méthodes des centroides fixes (fixer le nombre de clusters) ............... 324 7.5.2. Méthodes des centroides mobiles (aide à la détection du nombre adéquat de clusters) ................................................................................ 324
7.6. Aide à l'interprétation des clusters (projection des clusters sur des axes factoriels issus d’une ACP) ........................................... 326 7.7. Classification par les méthodes Support Vector Machine (SVM) ............................................................................................... 329 7.8. Classification par les méthodes de Random Forest................ 331 7.9. Classification par les méthode des voisins les plus proches .... 332
7.9.1. Méthode des k-voisins les plus proches ............................................ 333 7.9.2. Méthode des voisins proches dans un rayons ................................... 334
7.10. Recherche des valeurs optimales des paramètres dans les algorithmes (GRID SEARCH) ..................................................... 334
Annexe : Exercices et cas pratiques de programmation (résolus) ........................................................... 336
Exercices de programmation de base, de gestions de fchiers et de traitement de textes ................................................................ 336
Bibliographie .................................................... 362
20

Chapitre 1 : Les bases de la programmation sous python
1.1. Introduction
Python est un langage de programmation généraliste fonctionnant dans une approche orientée-objet. Il offre un environnement complet de développement comprenant un interpréteur et un ensemble de bibliothèques. Il dispose d'un très large éventail de modules qui offre au programmeur des outils très divers pour différentes utilisations : écriture d'applications Web (Zope, Django), programmes de calculs scientifiques, élaboration d’interfaces graphiques, programmation de scripts systèmes, traitement de données, traitement de texte, analyse de données, gestion réseau (librairie socket), manipulation du format xml, accès aux protocoles d'Internet (protocoles des services courriel, divers protocoles web), accès aux éléments du système d'exploitation sous-jacent (accès aux fichiers et répertoires, gestion des processus), écriture d'interfaces graphiques (librairie Tkinter), accès aux bases de données relationnelles, etc.
Il existe plusieurs avantages à choisir python comme langage de programmation pour la Data Science. D’abord, il offre tous les avantages de la programmation orientée-objet et permet d’écrire un code facilement compréhensible. L’un des plus gros atouts du système Python est sa portabilité c'est-à-dire sa capacité à fonctionner sur différentes plates-formes (Mac OS X, Unix, Windows, etc). Cette portabilité permet l’exécution du même code sous différents environnements techniques. Python est un langage interprété (c’est-à-dire que chaque ligne de code est lue puis interprétée afin d’être exécutée) au lieu d’être un langage compilé. Par ailleurs son utilisation est parfaitement adaptée à l’intégration de composants écrit dans d’autres langages tels que C, C++ ou Java. De plus, le fait d’embarquer l’interpréteur python dans une application permet d’intégrer directement les scripts python au sein des programmes sans aucune réadaptation. Cette grande flexibilité et ainsi que cette capacité à s’intégrer à différents environnements techniques y compris les services web et les bases de données en font un langage de premier choix pour les analyses du Big Data.
Fonctionnement des programmes python
On dit généralement qu’«en Python, tout est objet ». Cette expression signifie que quels que soient les données que l’on manipule, celles-ci se présentent d’abord sous forme d’objet qui se défini comme une capsule contenant à la fois les attributs et les méthodes (ou fonctions associées). C’est le fondement de la programmation orientée-objet sous python
Le langage Python, comme la majorité des langages, peut être écrit aussi bien en mode interactif qu’en mode script. Dans le premier cas, il y a une interaction directe entre l’utilisateur et l’interpréteur python. Les commandes entrées par l’utilisateur sont évaluées au fur et à mesure que touche « Entrée » est tapée. Cette première solution est pratique pour exécuter les
21

lignes de commande simples ainsi que pour tester tout ou partie d’un programme. Pour une utilisation en mode script les instructions à évaluer par l’interpréteur sont sauvegardées dans un fichier enregistré avec l’extension .py. Dans ce second cas, l’utilisateur doit saisir l’intégralité des instructions qu’il souhaite voir évaluer à l’aide de son éditeur de texte, puis demander leur exécution à l’interpréteur.
Dans ce document, nous n’allons pas nous appesantir sur les détails concernant l’installation et la mise en route de python. Nous supposons alors que cette partie est déjà réalisée. Il existe de multiples tutoriels permettant une prise en main rapide de python. A noter simplement que ce présent document est réalisé en utilisant Python version 3.4 téléchargeable à partir du lien internet https://www.python.org/download/releases/3.4.0/
1.2. Les éléments structurants d’un programme Python
Tout programme python se construit autour d’un certain nombre d’éléments qui en constituent la structure. Il s’agit notamment de la définition des variables à travers un ensemble d’opérations arithmétiques ou logiques mais aussi de la définition des instructions de manière séquentielle. On distingue plusieurs types d’instructions : les instructions inconditionnelles (c'est-à-dire des instructions qui doivent toujours être exécutées chaque fois que le programme est lancé), les instructions conditionnelles (définies avec la condition if….) et les instructions en boucles (définies avec la clause Do while… et la clause for…). Le but de cette section est d’étudier chacun de ces éléments en donnant des détails sur leur définition et leur utilisations lors l’écriture d’un code python.
En plus des variables et des instructions, les programmes Pythons peuvent aussi contenir des commentaires de code. Ces commentaires s’avèrent incontournables notamment dans les programmes plus complexes permettant à d’autres utilisateurs de comprendre la logique d’écriture. Il est donc fortement recommandé de mettre autant de commentaires que nécessaires afin de faciliter la lecture du code. Les commentaires Python sont définis à l’aide du caractère #. D’une manière générale, tout écriture apparaissant à la suite du signe # sur une ligne est traitée par l’interpréteur comme un commentaire.
1.2.1. Les variables
1.2.1.1. Définir une variable
Sous Python, une variable est un objet de programmation permettant de stocker une information en mémoire de la machine en attribuant un nom symbolique. Une variable est définie en utilisant l’opérateur mathématique = soit par assignation directe de sa valeur, ou par une assignation à partir de la valeur d’une autre variable. Exemples :
1.2.1.1.1. Définir une variable par assignation directe
x = 7 # définit la variable nommée x et lui assigne la valeur 7
22

y = 3.458 # définit la variable nommée y et lui assigne la valeur 3.458 msg = "Comment allez-vous ?" # Définit la variable nommée msg et lui assigne la valeur " Comment allez-vous ?"
Pour afficher les valeurs des trois variables définies, on utilise la fonction print()
print(x) print(y) print(msg)
Pour afficher les trois valeurs sur la même ligne on utilise une seule fonction print() en séparant les variables par des virgules :
print(x,y,msg)
NB : En mode interactif, il n’est pas nécessaire de préciser la fonction print(). Il suffit simplement de spécifier le nom de la variable et d’appuyer sur la touche Entrée. La valeur sera automatiquement affichée. Cette méthode raccourcie s’applique aussi à d’autres fonctions ou objets Python.
Le langage python offre plusieurs facilités pour réaliser les assignations de valeurs en raccourcissant les lignes de codes. On distingue par exemples les assignations multiples et les assignations parallèles.
Une assignation multiple consiste à attribuer une même valeur à plusieurs variables dans la même ligne de code. Exemple :
x = y = 7 # x et y prennent la même valeur simultanément 7.
Une assignation parallèle consiste à définir plusieurs variables en utilisant un seul symbole d’égalité. Exemple :
x, y = 4, 8.33 # On définit deux variables x et y dont les valeurs sont respectivement 4 et 8.33.
Nb : Les noms des variables (et les valeurs) sont séparées par les virgules de part et d’autre de l’égalité.
Pour fixer le nombre de décimaux lors de l’affichage d’un nombre, on utilise l’opérateur de formatage "%.nf"%nomVar où n est le nombre souhaité de décimaux à afficher et nomVar est le nom de la variable. Exemple : soit la variable x définie comme suit :
x=3.47568
On peut afficher la valeur de x avec un nombre de décimaux souhaitable comme suit :
print("%.2f"%x) # Affichage de x avec 2 chiffres après la virgule
23

print("%.3f"%x) # Affichage de x avec 3 chiffres après la virgule print("%.0f"%x) # Affichage de x avec 0 chiffres après la virgule
Le symbole f signifie float qui représente un nombre réel avec possibilité de décimaux contrairement aux nombres entiers de symbole %i (nous reviendrons plus en détails sur les différents type des variables plus tard). Le symbole % est un opérateur de formatage de valeur. Il permet de faire apparaître la valeur d’une variable même au milieu d’une chaîne de caractères (nous reviendrons également sur les opérateurs de formatage de valeurs). L’expression %.2f"%x signifie que la variable x doit être traitée comme un nombre réel avec 2 chiffres après la virgule. On peut mettre autant de valeurs qu’on souhaite. Par exemple, en mettant 0, on retombe sur le cas d’un nombre entier (aucun chiffre après la virgule). Ce qui peut être traduit en utilisant la fonction %i comme suit :
print("%.i"%x) # Affichage de x comme un entier naturel (integer)
Par ailleurs pour traiter x comme une chaine de caractères, on utilise la fonction %s (formatage en string). Ainsi, on a :
print("%.s"%x) # Affichage de x comme une chaîne de caractères
1.2.1.1.2. Définir une variable à partir d’autres variables
z1=x+y # définit la variable nommée z1 et lui assigne la somme des variables x et y z2=x+5 # définit la variable nommée z2 ajoutant 5 à la valeur de x z3=2*y # définit la variable nommée z3 en multipliant la valeur de y par 2
NB : La définition des noms des variables obéissent à des règles bien précises. En effet, un nom de variable doit débuter par une lettre ou par le caractère de soulignement (underscore _) suivi par un nombre quelconque de lettres, chiffres ou de caractères de soulignement. L’underscore est le seul caractère spécial autorisé. Par exemple, le tiret du 6 n'est jamais autorisé dans la définition d’un nom de variable.
Par ailleurs, il est conventionnel d’écrire les noms des variable en minuscule (par exemple x au lieu de X, var1 au lieu de VAR1). Lorsque la variable doit avoir un nom composée (ex : ma variable), il est préférable de commencer la spécification des autres éléments du nom par un majuscule. Ex : maVariable, testValue, etc.. Cela facilite beaucoup la compréhension d’un programme. Tout comme pour les variables, les noms des fonctions doivent commencer par des minuscules. Mais les lettres en majuscule peuvent être autorisées pour des noms composés afin de faciliter la lecture du nom. Les noms commençant par une majuscule sont utilisés pour la définition des objets de types classe (nous y reviendrons).
1.2.1.1.3. Définir une variable à partir d’une séquence de valeurs
Les séquences de valeurs sont des variables très fréquemment rencontrées dans les programmes python. Elles correspondent à un ensemble de valeurs successives et ordonnées
24

dont les valeurs peuvent être extraites comme une liste. Les séquences de valeurs sont générées en utilisant la fonction range(). Exemple :
x=range(10) # Crée une séquence de valeurs entières allant de 0 à 9 x=range(2, 10) # Crée une séquence de valeurs entières allant de 2 à 9 x=range(1, 10, 2) # Crée une séquence de valeurs entières allant de 2 à 9 avec un pas de 2. Il renvoie alors 1, 3, 5, 7 et 9
Pour afficher les valeurs générées, on peut utiliser la fonction list() ou la fonction tuple() telles que :
x=range(10) print(list(x)) # renvoie une liste :valeurs entre crochets [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] print(tuple(x)) # renvoie un tuple : valeurs entre parenthèses (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
Nous reviendrons plus en détails sur la définition des objets liste ou tuple qui correspondent chacun à un objet particulier dans Python.
1.2.1.2. Type d’une variable
Définir le type d’une variable
Le type d’une variable correspond à la nature de celle-ci. Il existe de nombreux autres types de variables (nombre entier, nombre réel, chaînes de caractères, etc). Les types de variables les plus couramment rencontrés sont les entier (int) , les nombres réels (float), les chaînes de caractères (str). A chacun de ces types de variables est associé un certain nombre d’attributs ou de méthodes. Par exemple, pour deux nombres 20 et 45. En faisant 20+45, on obtient 65. Par contre pour deux caractère A et B, en faisant "A"+"B" on obtient "AB"
Python est un langage au typage dynamique, c’est-à-dire qu’il reconnaît directement le type des variables lorsque sa valeur est indiquée. Ainsi, contrairement à d'autres langages comme le langage C, il n'y a pas de déclaration de type obligatoire lors de la création d'une variable. Exemples :
x = 2 # type entier (int) x =2. # type réel (float avec décimaux) x='2' # type caractère (string)
Pour connaitre le type d’une variable, on utilise la fonction type(). Par exemples :
Pour la définition x=2, en faisant type(x) renvoie <class 'int'> signifiant un entier (integer). Pour la définition x=2., la fonction type(x) renvoie <class 'float'> signifiant un nombre réel. Et pour la définition x='2', la fonction type(x) renvoie <class 'str'> signifiant que x est de type chaîne de caractères (string).
25

NB : Il faut remarquer que les variables en chaînes de caractères sont toujours définies avec des guillemets (qui peuvent être des guillemets simples, doubles ou triples). Avec des guillemets simples, on a des chaines de types char alors qu’avec des guillemets doubles, on obtient des chaînes de type string. Noter aussi que même si une variable est définie avec des nombres, lorsque ces nombres sont indiqués avec des guillemets, python traite cette variable comme une chaine de caractères. Néanmoins, il existe des fonctions pour convertir une variable d’un type à un autre lorsque cette conversion est autorisée. Voir les exemples suivants.
Tester le type d’une variable
Exemple : soient les variables i, j,k,m
i = 123 type(i) # renvoie <type 'int'> type(i) is int # renvoie True j = 123456789L type(j) # renvoie <type 'long'> type(j) is long # renvoie True k = 123.456 type(k) # renvoie <type 'float'> type(k) is float # renvoie True m = 'ABCD' type(m) # renvoie <type 'str'> type(m) is str # renvoie True
Convertir le type d’une variable
Exemple 1 : Conversion d’une variable de type caractère en variable de type entier ou réel.
Soit x='2' une variable en caractère définie par 2. Pour convertir cette variable en type numérique (entier), on utilise la fonction int(). On a :
x=int(x)
Pour convertir en un nombre réel autorisant les décimaux, on fait :
x=float(x)
NB : La conversion d’une variable de type caractère en variable de type numérique n’est possible que lorsque la valeur de la variable est constituée uniquement de chiffres. La conversion renvoyera un message d’erreur lorsque la valeur de x contient une lettre. Exemple : pour x='2xeb'. En essayant de convertir cette variable en type numérique int, on reçoit un message d’erreur « invalid literal for int() with base 10: '2xeb ' ». Et avec la fonction float, on reçoit le message « could not convert string to float: '2xeb' ».
Exemple 2 : Conversion d’une variable de type numérique (entier ou réel) en variable de type caractère.
26

Soit x=2 une variable numérique de type entier définie par 2. Pour convertir cette variable en type caractère, on utilise la fonction str(). On a :
x=str(x)
On utilise aussi la même fonction lorsqu’il s’agit d’une variable numérique de type réel comme par exemple x=2.4756.
x=str(x)
En conclusion, on peut noter que toutes les variables numériques sont convertible en type caractère mais une variable n’est convertible en type numérique que lorsque la valeur de celleci est constituée uniquement de chiffres. Toutefois, les conversions sont possibles vers d’autres formats de données comme les nombres du système hexadécimal.
Manipulation du type d’une variable dans un dataframe
Pour connaitre le type d’une variable dans un dataframe, on utilise la fonction dtypes. Exemple :
mydata.dtypes # renvoie le type de chaque variable présente dans la table de données mydata. mydata['myvar1'] # renvoie le type de la variable myvar1 de la table mydata mydata['myvar1', 'myvar2'] # renvoie le type des deux variables myvar1 et myvar2
NB : Les variables en caractères sont représentées par le type « object », les variable numérique entières par « int », les variables numérques décimales par « float ».
1.2.1.3. Méthodes associées aux variables
A chaque variable créée dans python, est associé un ensemble d’attributs (ex : type) mais aussi un ensemble de méthodes, c'est à dire un ensemble d’opérations de traitement et d’exploitation réalisable avec cette variable. Pour afficher l'ensemble des méthodes d'une variable, on utilise la commande dir(). Exemple :
x=2.5 # Définit une variable numérique x y='mon texte' # Définit une variable en chaîne de caractères y.
Pour afficher l’ensemble des méthodes associées à chacune de ces variables, on fait :
print(dir(x)) print(dir(y))
Ainsi, pour obtenir de l’aide sur une méthode spécifique, on utilise la fonction help() comme suit : help(x.nomMethode) # où nomMethode est le nom de la méthode considérée. Par
27

exemple, pour une variable numérique de type float, il existe une méthode nommé conjugate. Pour obtenir de l’aide sur cette fonction, on fait :

print(help(x.conjugate))

Pour afficher l’aide sur toutes les fonctions associées à la variable x, on fait simplement :

print(help(x))

1.2.1.3. Les opérateurs arithmétiques et logiques (booléens)

Deux grandes catégories d’opérateurs sont utilisées en Python pour définir les variables et les instructions. Il s’agit des opérateurs arithmétiques et algébriques et les opérateurs logiques. Les premiers permettent de réaliser les opérations mathématiques courantes tandis que les seconds permettent de réaliser des comparaisons de valeurs. Une valeur booléenne est une évaluation logique représentant l’une des deux possibilités suivantes : vrai ou faux. Les valeurs booléennes sont le résultat de l’évaluation d’expressions logiques et elles servent à faire des choix dans un programme (effectuer telle action quand telle condition est réalisée).

Le tableau ci-dessous fournit les détails sur les différents opérateurs en Python. Pour accéder à

la liste complète des opérateurs standards de python et leurs équivalents fonctions, voir la

page

https://docs.python.org/2/library/operator.html.

Consulter

http://www.tutorialspoint.com/python/python_basic_operators.htm pour quelques exemples

d’utilisations des opérateurs standards.

Addition Soustraction multiplication Division (quotient réel) Division (quotient entier) Puissance Reste de la division (modulo) Addition incrémentée

Opérateurs arithmétiques

Symbole Exemple

+

x=2+3

-

z=x-y

*

y=3*x

/

z=5/2 # renvoie 2.5

//

z=5//2 # renvoie 2

**

x**2 # x puissance 2

%

17%3 # renvoie 2

+=

x+=4 # ajoute 4 à la

valeur initiale de x

28

(équivalent à x=x+4)

Soustraction incrémentée

x-=4 # soustrait 4 de la

-+

valeur initiale de x

(équivalent à x=x-4)

Opérateurs logiques (variables booléennes et valeurs tests)

x==2 # Egalité logique ou

Egal

==

mathématique (différent

de

l’égalité

d’assignation =)

Strictement inférieur

<

x<2

Inférieur ou égal

<=

x<=2

Strictement supérieur

>

x>2

Supérieur ou égal

>=

x>=2

Différent

!=

x !=2

and

Et

(équivalent à &)

x>2 and x< 10 # expression logique composée

Or

(

Ou

équivalent à|)

x==2 or x==2 # Expression logique composée

Opérateur de négation

not (équivalent x not True à ~)

Nb : Toute expression logique renvoie deux valeurs (True ou False). La valeur True est renvoyée lorsque l’expression est vérifiée. Dans le cas contraire, elle renvoie False. Ces deux valeurs sont qualifiées de valeurs booléennes. Exemple : Soit la variable note définie comme suit :
note = 13.0
On va tester quelques expressions logiques :
print(note==13.0) # Renvoie True print(note >= 12.0 and note < 14.0) # Renvoie True
29

print(note<50) # renvoie True print(note>20) # renvoie False print(note) # renvoie False print(not note>20) # renvoie True
1.2.2. Les instructions conditionnelles : la clause « if… else »
Les instructions conditionnelles sont des opérations que le programme doit exécuter lorsqu’il expression logiques renvoie True ou False (selon le cas). Les instructions conditionnelles sont définies à l’intérieur d’une clause if…else
La structure générale d’un bloc if…else se présente comme suit :
if expression_logique : instruction 1 instruction 2 .. instruction n
else : autre_bloc_instructions
Attention au symbole « : » à la suite du mot clé if ou else qui marque la fin de la déclaration de la fonction if ou else et le début de la définition des instructions.
Noter aussi que la clause else n’est pas obligatoire c'est-à-dire qu’il peut y avoir une clause if sans clause else.
Voici ci-dessous quelques exemples d’utilisation de la fonction if.
Exemple 1 : Instructions avec une clause « if » simple
x = 150 if (x > 100):
print("x dépasse 100")
On définit d’abord une variable x en lui assignant la valeur 150. Ensuite on définit une expression logique permettant de vérifier si x est supérieur à 100 ou pas. Dans cette expression conditionnelle, lorsque l’expression logique est vraie (c'est-à-dire renvoie True), on affiche un message indiquant que x est supérieur à 100. Lorsque la condition n’est vérifiée aucun message ne sera affiché. Il faut tout de même signaler ici que puisque la valeur de x est 150 (donc supérieur à 100) alors la condition sera toujours vérifiée et le message sera tours affichée. Cela jusqu’à ce qu’on assigne une nouvelle valeur à x qui soit inférieur à 100.
NB : Dans une clause if, les instructions (ici print() ) doivent être espacées de 4 pas (avec la touche tab), de manière à ce que celle-ci soit indentée (c’est-à-dire en retrait par rapport à la clause if à laquelle elle est rattachée). En effet, dans le langage Python, les blocs d’instructions
30

sont définis grâce à la suite d’un décalage (ou indentation). Contrairement à, d’autres langages, comme le C qui utilisent des marqueurs plus explicites {bloc d’instructions }. L’avantage de rendre le décalage obligatoire comme marqueur de bloc d’instructions est qu’il oblige à une écriture claire des programmes.
Il faut aussi noter que les parenthèses utilisées avec l’instruction if sont optionnelles. Elles sont simplement utilisées pour améliorer la lisibilité de l’expression logique (qui peut être très complexe dans certains cas).
Exemple 2 : Instructions avec la clause if… else…
x = 150 if (x > 100):
print("x dépasse 100") else:
print("x ne dépasse pas 100")
Contrairement au premier exemple où il n’y avait pas d’instructions alternative à exécuter dans le cas où l’expression logique n’est pas vérifiée, dans ce deuxième exemple, on définit une instruction alternative en utilise la clause else…
x=7 if (x % 2 == 0):
print("x est pair car le reste de sa division par 2 est nul") else:
print("x est impair car le reste de sa division par 2 n’est pas nul ")
Exemple 3: Instructions avec la clause if… elif… else…
La clause if… elif… else est utilisées lorsqu’on dispose de plusieurs conditions logiques auxquelles sont associées des instructions à exécuter lorsqu’elles sont vérifiées.
x=0 if x > 0 :
print("x est positif") elif x < 0 :
print("x est négatif") else:
print("x est nul")
Nb : La clause elif peut être utilisée autant de fois qu’il y a de conditions alternatives entre la clause initiale if et la clause finale else. Toutefois, l’utilisation de la clause elif n’est pas obligatoire pour traduire les conditions alternatives. On peut simplement utiliser la clause if à la place.
31

Le résultat d’une expression logique peut être placé dans une variable booléenne. Une telle variable prend alors deux valeurs booléennes possibles (True ou False). Par exemple :
condition = (x >=0 and x <50) if condition :
print ("La condition est vérifiée") if not condition :
print ("La condition n’est pas vérifiée")
Exemple 4 : Définir des clauses « if » imbriquées
Les exemples précédents traduisent des clause de premier niveau. Dans les programmes complexes, il arrive très fréquemment que les clauses if soient imbriquées. C'est-à-dire que des clauses if sont définies à l’intérieur d’autres clauses if. Et cela à plusieurs niveaux. Voir exemple ci-dessous :
embranchement="rien" if embranchement == "vertébrés":
if classe == "mammifères": if ordre == "carnivores": if famille == "félins": print("Il s’agit peut-être d’un chat") print("c’est en tous cas un mammifère")
elif classe == "oiseaux": print("c’est peut-être un canari")
print("la classification des animaux est complexe")
1.2.3. Les instructions en boucle
Sous python, on distingue deux principales catégories d’instructions en boucles : les instructions en boucle « while… » et les instructions en boucle « for… in… »
Les instructions en boucle « while… » sont exécutées tant que la (les) condition(s) définies par l’expression logiques sont vraies. Tandis que les instructions en boucle « for…in » sont exécutées pour chaque élément pris dans un ensemble d’éléments préalablement indiquées (généralement dans un objet range ou list).
1.2.3.1. Les instructions en boucle « while… »
La syntaxe générale de la définition des instructions en boucle while se présente comme suit :
Initialisation de la variable d’incrémentation while condition :
bloc_instructions incrémentation
32

Une boucle while nécessite trois éléments pour fonctionner correctement : 1. l’initialisation de la variable de test (ou variable d’incrémentation) avant la boucle ; 2. La définition de la condition à évaluer définie en fonction de la variable de test; 3. l’incrémentation de la variable de test dans le corps de la boucle à la suite des instructions.
Là aussi, il faut prêter attention au symbole « : » qui marque la fin de la déclaration de la boucle while et le début de la définition des instructions tout comme dans le cas de l’utilisation de la fonction « if »
L’exemple ci-dessous illustre la définition d’une boucle while… :
x = 1 # Initialisation de la variable x while (x < 10):
print('La valeur de x est ', a) x = x + 1 # Incrémentation de la variable x
Dans l’exemple ci-dessus, on affiche la valeur de x tant que x est inférieur à 10. La valeur de x est initialisée à 1 et incrément avec +1 après chaque instruction print(). Comme dans la structure if, la condition est d’abord évaluée et si elle vraie, le bloc d’instructions est exécuté. Mais ici avec la clause while après exécution du bloc d’instruction, la condition est évaluée à nouveau. Cette exécution se répète jusqu’à ce que la condition devienne fausse. C’est pourquoi il n’est nécessaire de définir une variable d’incrémentation dont la valeur se modifie après chaque exécution de sorte que la condition puisse être fausse à partir d’une certaine valeur. Cette incrémentation est nécessaire pour éviter que les instructions soient indéfiniment évaluées créant ainsi une boucle infinie (ou boucle folle). Une telle situation nécessite alors un arrêt forcé de l’exécution du programme. Dans ce cas, on peut utiliser la touche « CTRL+C » pour interrompre l’exécution du programme.
NB : Il faut aussi noter que comme dans la définition des instructions en clause if, les blocs d’instruction dans une clause while sont aussi définis par indentation (décalage de positions à l’intérieur de la clause while)
1.2.3.2. Les instructions en boucle « for… in… »
La syntaxe générale de la définition d’instructions en boucle for… in… est la suivante :
for element in sequence_de_valeurs : bloc instructions
Dans cette syntaxe, le bloc d’instruction est exécuté pour chaque élément figurant dans la séquence de valeurs qui est généralement une liste de valeurs ou un tuple de valeurs (nous reviendrons sur la définition des listes et de tuples un peu plus tard).
33

Contrairement à la variable d’incrémentation dans une boucle while, la variable indice (element) n’est pas initialisée par l’utilisateur. Elle prend successivement les valeurs figurant dans la séquence parcourue.
Nb : element est ici un nom générique, on peut utiliser n’importe quel nom à la place.
Là également, il faut prêter une attention au symbole « : » qui marque la fin de la déclaration de la boucle « for » et le début de la définition des instructions tout comme dans le cas de l’utilisation de la fonction « if » et de la boucle « while »
Les exemples ci-dessous illustrent la définition d’une boucle « for ».
Exemple 1 : Instruction dans une boucle « for.. in … » simple
for i in range(1,11) : print(i)
Dans cet exemple, on affiche chaque valeur défini par la séquence de valeur range(1, 11) qui fournit en fait les valeurs allant de 1 à 10. On pouvait aussi utiliser la structure syntaxique suivante :
for i in [1,2,3,4,5,6,7,8,9,10]: print(i)
Ce qui vaut en réalité à la commande suivante :
for i in list(range(1,11)): print(i)
Exemple 2 : Boucle « for.. in… » sur une chaine de caractères
listch = "Hello world" for i in listch :
print ( i )
Attention : Dans cet exemple, il ne s'agit pas de répéter les instructions pour les deux mots mais plutôt pour chaque par lettre apparaissant dans la séquence de caractères y compris les espace. C’est la particularité des chaînes de caractères. Nous reviendrons plus en détails sur les opérations sur les chaînes de caractères plus tard.
Exemple 3 : Combinaison d’une boucle « for…in … » et d’une clause « if »
listnb = [4, 5, 6] for i in listnb:
if i == 5: print("La condition est vérifiée pour l’élement", i)
else : print("La condition ,n’est pas vérifiée pour l’élément", i)
34

mych = "Hello World" for i in mych :
if i in "AEIOUYaeiouy": print ('La lettre', i, 'est une voyelle')
else : print ('La lettre', i, 'est une consonne')
1.2.4. Les instructions break et continue dans une clause « while… » ou « for … in…»
Les mots réservés break et continue sont utilisés pour modifier le comportement d'une boucle « for…in » ou d'une boucle « while… ». L’instruction break permet d’arrêter l’évaluation de la boucle et l’exécution des instructions pour sortir prématurément de la boucle même la condition principale définissant la boucle reste encore vraie. Et l’instruction continue permet de suspendre l’exécution des instructions lorsque la condition principale est vérifiée. Les exemples ci-dessous sont des illustrations.
Exemple de boucle avec l’instruction break
for i in range(5): if i > 2: break print (i)
Au départ, cette boucle for vise à afficher tous éléments de la séquence de valeurs allant de 1 à 4. Mais avec l’instruction break définie à l’intérieur de la clause if, la boucle for est stoppée lorsque i devient supérieur à 2.
Exemple de boucle avec l’instruction continue
for i in range(5): if i == 2: continue print (i)
Au départ, cette boucle for est conçue pour afficher tous éléments de la séquence de valeurs allant de 1 à 4. Mais avec l’instruction continue définie à l’intérieur de la clause if, l’instruction print() n’est pas exécutée lorsque i prend la valeur 2. Mais elle est exécutée pour toutes les autres valeurs de la séquence.
1.2.5. Les mots réservés du langage python
Comme dans tout langage de programmation, il existe des mots clés réservés qui font partie du socle du langage. Ces mots réservés (qui sont pour la plupart des fonctions) ne peuvent pas
35

être modifiés par l’utilisateur, et leur dénomination ne peut pas être utilisée pour former le nom d’une variable, d’une fonction ou tout autre objet définis par l’utilisateur.

Sous Python, il existe 33 mots réservés dont la liste est fourni ci-dessus. Certain de ces mots clés seront sollicités à de nombreuses reprises dans nos discussions dans ce document.

and as assert break class continue def del

elif else except False finally for from global

if import in is lambda None nonlocal not

or pass raise return True try while with

yield

1.3. Les principaux objets du langage Python
Comme signalé dans les sections précédentes, un programme python fonctionne toujours sur la base des manipulations des objets. Les instructions (qu’elles soient définies dans un code libre, dans une clause if ou dans une boucle while ou for) sont toujours exécutées sur des objets. Les variables telles que discutées précédemment représentent un type particulier d’objet python. Sinon d’une manière générale, les instructions dans un programme python sont définies à partir d’une collection d’objets qui se présentent sous différentes formes de séquences de valeurs. Cette séquence de valeurs peut être par exemple constituée par un ensemble de variables à valeur unique. Ce qui signifie finalement qu’une variable définie à partir d’une seule valeur n’est généralement pas suffisant pour former l’architecture d’un programme. En effet, sous python, les variables sont généralement des objets qui prennent plusieurs valeurs. Le vecteur ou une matrice sont illustrations qui peuvent aider à comprendre la notion de collection de valeurs. Très concrètement, les principaux objets de programmation de python sont les listes, les tuples, les ensembles (set), les tableaux (array), les dictionnaires, les fonctions, les classes et les modules. Nous allons étudier plus amplement chacun de ces types d’objets dans ce chapitre. Dans cette section, nous nous limiterons d’abord à une présentation sommaire de chacun des objets. En effet, dans le langage python :
- Un objet liste est une séquence de valeurs (numériques et /ou caractères) indicées et spécifiées à l’intérieur des crochets, séparées par des virgules. Exemple :
x=[ 1 , 5 , 8, 10 ,4 , 50, 8 ] # Liste formée uniquement de chiffres y=["Olivier","ENGEL","Strasbourg"] # liste formée uniquement de caractères z=[1, "Olivier",5 , 8, "ENGEL",10, 4, 50, "Strasbourg"] # liste formée de chiffres et de caractères.
36

Un objet liste peut être généré manuellement en indiquant les valeurs entre crochets ou automatiquement en utilisant la fonction list()
x=list(range(1,10)) print(x) # renvoie [1, 2, 3, 4, 5, 6, 7, 8, 9] - Un objet tuple est une séquence de valeurs (numériques et /ou caractères) indicées et spécifiées à l’intérieur des parenthèses, séparées par des virgules. Exemple :
x=[ 1 , 5 , 8, 10 ,4 , 50, 8 ] # Tuple formé uniquement de chiffres y=["Olivier","ENGEL","Strasbourg"] # Tuple formé uniquement de caractères z=[1, "Olivier",5 , 8, "ENGEL",10, 4, 50, "Strasbourg"] # Tuple formé de chiffres et de caractères.
Un objet tuple peut être généré manuellement en indiquant les valeurs entre parenthèses ou automatiquement en utilisant la fonction tuple(). Exemple :
x=tuple(range(1,10)) print(x) # renvoie (1, 2, 3, 4, 5, 6, 7, 8, 9)
- Un objet set est une séquence de valeurs (numériques et /ou caractères) non dupliquées et non indicées, et spécifiées à l’intérieur des accolades, séparées par des virgules. Exemple :
x={ 1 , 5 , 8, 10 ,4 , 50 } # Set formée uniquement de chiffres y={"Olivier","ENGEL","Strasbourg"} # Set formée uniquement de caractères z={1, "Olivier",5 , 8, "ENGEL",10, 4, 50, "Strasbourg"} # Set formé de chiffres et de caractères
Un objet set peut être généré manuellement en indiquant les valeurs entre accolades ou automatiquement en utilisant la fonction set()
v=[2 , 4 , "orange", "viande", 4, "orange"] x=set(v) print(x) # renvoie {2, 'orange', 4, 'viande'}
- Un objet array est une séquence de valeurs se présentant sous forme de tableaux (avec des lignes et des colonnes) et exclusivement constituées de valeurs numériques indicées et spécifiées à l’intérieur des crochets, séparées par des espaces. Exemple :
x=[ 1 5 8 10 4 50 8 ] # Array à une dimension y=[ [1 5 8] [10 4 ] [50 8] ] # Array à deux dimensions (array de array) z=[ [ [1 5] [8 10]] [[4 50] 8] ] # Array à trois dimensions (array de array de array)
37

Attention : Le terme array à plusieurs dimensions ne signifie pas array à plusieurs colonnes. Il signifie array de array, ainsi de suite. On peut générer un objet array manuellement en spécifiant les valeurs comme indiquées ci-dessus. On peut aussi utiliser la fonction numpy.array(). Il faut pour cela importer le module numpy en utilisant la commande :
import numpy
Nous reviendrons plus en détails sur la définition des arrays. - Un objet dictionnaire est une séquence de valeurs (numériques et /ou caractères)
indicées par des clés et spécifiées à l’intérieur des accolades et séparées par des virgules. A chaque clé correspond une ou plusieurs valeurs. Un dictionnaire est constitué d’un ensemble clé-valeurs. Exemple :
x = {'nom':'Jean', 'poids':70, 'taille':1.75} # Clés à valeurs uniques.
y= {'Jean':[25,70,1.75],'Paul':[30,65,1.80],'Pierre':[35,75,1.65]} # Clé à plusieurs valeurs formée par une liste
Pour le dictionnaire x, les clés sont nom, poids et taille. Les valeurs correspondant à chacun de ces clés sont respectivement jean, 70 et 1.75. Pour le dictionnaire y, les clés sont Jean, Paul et Pierre alors que les valeurs sont des listes constituées de trois valeurs (âge, poids et taille). Un objet dictionnaire peut être généré manuellement en indiquant les valeurs entre accolades ou automatiquement en utilisant la fonction dict() pour créer un dictionnaire vide. Nous reviendrons plus en détails sur la définition des dictionnaires. - Un objet fonction est un programme conçu pour réaliser une opération bien précise. Par exemple la fonction print() permet d’afficher à l’écran les résultats de l’instruction qu’on lui fournit. - Un objet classe est une collection de fonctions c'est-à-dire une association de fonctions apparentées - Un objet module est une collection de classe c'est-à-dire une collection de classes apparentées
1.4. Etude des objets « liste »
1.4.1. Caractéristiques générales des listes
Comme indiqué dans la section précédente, un objet liste est une variable python définie à partir d’une séquence de valeurs (numériques et/ ou en caractères) indicées, spécifiées à
38

l’intérieur d’un crochet et séparées par des virgules. Cette définition, sans doute, descriptive et directe est formulée à partir de quelques mots clés qui méritent un peu de commentaires.
D’abord, un objet liste est une séquence de valeurs. Ce qui signifie qu’une liste est nécessairement un ensemble de valeurs (au moins une) même si théorique, il peut définir une liste vide.
Les valeurs qui constituent une liste peuvent être soit des chiffres, soit des chaines de caractères ou une combinaison des deux. Cette propriété des listes est très intéressante car elle permet d’aller au-delà de la définition traditionnelle du type d’une variable (variable numérique, variable caractère, etc). Une liste est donc d’un type plus général.
Les valeurs d’une liste sont indicées. En d’autres termes chaque valeur de la liste peut être identifiée à travers son indice c'est-à-dire sa position dans l’ordre des valeurs étant donné qu’une liste est un ensemble ordonné. En effet, la première valeur d’une liste a pour indice 0, la seconde valeur 1, …, la dernière valeur a pour indice n-1 où n est le nombre total d’éléments de la liste.
1.4.1.1. Définition d’un objet liste
Un objet liste peut être déclaré et défini manuellement ou en utilisant la fonction list(). On distingue deux catégories de listes. Les listes à une dimension (ou listes simples) et les listes à plusieurs dimensions.
1.4.1.2.1. Définition d’une liste simple
Une liste simple est une liste dont les éléments sont constitués de valeurs uniques séparées par des virgules. Exemple :
x=['lundi','mardi','mercredi',1800,20.357,'jeudi','vendredi']
La variable x est une liste simple car les éléments sont des valeurs uniques, lundi, mardi, mercredi, 1800, …,
Il faut remarquer que les éléments d’une liste peuvent être de types variés (chiffres et caractères). Pour la liste x, on constate que les trois premiers éléments sont des chaînes de caractères, le quatrième élément est un entier, le cinquième un réel. Et les deux derniers éléments sont des caractères. Les chiffres (entiers et réels) sont écrits simplement alors que les caractères sont toujours écrits entre les guillemets (simples, doubles ou triples).
Il faut noter aussi qu’on peut créer une liste en utilisant la fonction liste. Exemple :
x=list(['lundi','mardi','mercredi',1800,20.357,'jeudi','vendredi']) # défintion inéfficiente car réalisée déjà sur une liste y=list(range(10)) # Liste formée par une séquence de nombres entier de 0à9
39

Création d’une liste vide

Par ailleurs, dans certaines situations, il arrive qu’on crée d’bord une liste vide et qui sera par la suite remplie par des valeurs en utilisant la fonction append(). Pour créer une liste vide, on fait :

x=list()

Ou bien

x=[]

1.4.1.2.3. Définition d’une liste à plusieurs dimensions

Contrairement à une liste simple, une liste à plusieurs dimensions est une liste dont les éléments individuels sont constitués de plusieurs valeurs. D’une manière générale, une liste à plusieurs dimensions se présente comme une liste de listes. Les deux exemples ci-dessous sont des illustrations.

x=[[1,2,3],[2,3,4],[3,4,5]] # liste à deux dimensions (liste de listes) y= [[[1,2],[2,3]],[[4,5],[5,6]]] # liste à trois dimensions (liste de listes de listes)

1.4.1.2. Indiçage d’une liste (slicing)

1.4.1.2.2. Indiçage d’une liste simple

La liste étant une séquence de valeurs indicées, on peut accéder à chacun des valeurs en indiquant leur indice. Exemple :

x=list(['lundi','mardi','mercredi',1800,20.357,'jeudi','vendredi']) # d’une liste

Définition

print(x) # affiche tous les éléments de la liste x x[0] # renvoie le premier élément de x :lundi (Nb :l’indiçage commence toujours à 0) x[3] # renvoie l’élément d’indice 3( quatrième élément de x) :1800 x[1:3] # Renvoie tous éléments compris entre l’indice 1 et l’indice 3 (Nb : l’élément d’indice 3 est exclu) x[1:6 :2] # Renvoie tous éléments compris entre l’indice 1 et l’indice 6 avec un saut de 2 éléments à chaque fois ['mardi', 1800, 'jeudi'] (l’élément d’indice 6 est exclu). x[2 :] # renvoie tous éléments à partir de l’élément d’indice 2 ( inclu). x[:3] # renvoie tous éléments situés avant l’élément d’indice 3 (exclu) x[-1] # Indiçage négatif, renvoie le dernier élément de la liste (équivaut ici à x[6])

40

x[-2] # Indiçage négatif, renvoie l’avant-dernier élément de la liste(équivaut ici à x[5])
x[: :2] # Parcourt tous éléments compris entre l’indice 0 et le dernier indice en renvoyant tous les éléments avec un saut de 2 éléments à chaque fois ['lundi', 'mercredi', 20.357, 'vendredi'].
x[: :-1] # renvoie une liste contenant tous éléments de x en les réorganisant du dernier élement au premier élément. Il s’agit de faire reverse sur x. renvoie ['vendredi', 'jeudi', 20.357, 1800, 'mercredi', 'mardi', 'lundi']. On obient le même résultats en faisant x.reverse() x_rev=x.reverse()

Nb : En règle générale dans les slicing tout comme dans les séquences range(), les borne supérieures sont exclues des valeurs renvoyées.

1.4.1.2.4. Indiçage d’une liste à plusieurs dimensions (slicing à plusieurs niveaux)

Avec une liste à plusieurs dimensions, l’indiça se fait à plusieurs niveaux. Par exemple pour une liste à deux dimensions, l’indiçage de premier niveau permet d’accéder aux listes qui forment la liste principale (les élément-listes). Et l’indiçage de second niveau permet d’accéder aux éléments qui forment les élément-listes. Exemple :

Soit la liste x définie comme suit :

x=[[1,2,3],[2,3,4],[3,4,5]] x[0] # renvoie le premier élément-liste [1,2,3] x[0][0] # renvoie le premier élément du premier élément-liste c'est-à-dire 1 x[2] # renvoie [ 3,4,5] x[2][1] # renvoie 2 x[1:] # renvoie [[2, 3, 4], [3, 4, 5]] x[1:][0] # renvoie [2, 3, 4] x[-1] # renvoie 3, 4, 5] x[1][:2] # renvoie [2, 3] x[1][1:] # renvoie [3, 4]

[1,2,3]

1.4.3. Les opérations sur les listes
Une liste étant définie, on peut réaliser plusieurs opérations visant à modifier la structure de la liste ou les éléments qui le constituent. Dans cette section, nous passons en revue les opérations couramment réalisées sur les listes.
1.4.3.1. Déterminer le nombre d’éléments d’une liste

41

Pour connaitre le nombre d’éléments d’une liste, on utilise la fonction len(). Exemple : soit la liste x définie comme suit :
x= ['lundi', 'mardi', 'mercredi', 1800, 20.357, 'jeudi', 'vendredi']
Pour connaitre la longueur de x (nombre d’éléments de x), on fait :
print(len(x)) # cela renvoie 7
Nb : Il est possible de stocker cette valeur dans une variable pour des utilisations futures. Par exemple dans l’élaboration des boucles for utilisant les indices des éléments. Pour récupérer la valeur de len(x), on l’assigne directement à une variable. Ex :
l=len(x) print(l)
1.4.3.2. Additionner des listes
On peut additionner deux listes pour en former une seule en utilisant l’opérateur + qui permet de concaténer les listes en questions Exemples : soient les deux listes x et y définies par :
x= ['girafe','tigre'] y= ['singe','souris']
On peut créer une liste z en faisant la somme des deux listes telle que :
z= x + y print(z) # renvoie ['girafe', 'tigre', 'singe', 'souris']
L’opérateur + permet d’adjoindre les éléments de la liste y à ceux de la liste x pour former la liste z.
1.4.3.3. Démultiplication des éléments d’une liste
On peut démultiplier les éléments d’une liste en utilisant l’opérateur de multiplication * en indiquant un entier correspondant au nombre fois qu’on souhaite démultiplier les éléments. Exemple :
Soit la liste x définie comme suit :
x=['girafe', 24, 18 , 'tigre', 2400, 150 ]
On souhaite démultiplier tous les éléments de x par 3 pour former une liste y. On a :
y=x*3 print(y) # renvoie ['girafe', 24, 18, 'tigre', 2400, 150, 'girafe', 24, 18, 'tigre', 2400, 150, 'girafe', 24, 18, 'tigre', 2400, 150]
42

1.4.3.4. Modifier ou remplacer les éléments d’une liste
Il est possible de modifier un élément particulier d’une liste en se servant de son indice. Par exemple considérons la liste définie comme suit :
x= ['lundi', 'mardi', 'mercredi', 1800, 20.357, 'jeudi', 'vendredi']
On souhaite ajouter 100 à l’élément 1800. Pour cela on fait :
x[3]=x[3]+100 print(x) # renvoie ['lundi', 'mardi', 'mercredi', 1900, 20.357, 'jeudi', 'vendredi']
Pour remplacer « vendredi » par « vendredi saint », on fait :
x[6]=x[6]+ ' saint' # attention à l’espace dans ' saint' sinon on aura vendredisaint. print(x) # renvoie ['lundi', 'mardi', 'mercredi', 1900, 20.357, 'jeudi', 'vendredi saint']
On peut carrément remplacer une valeur par une nouvelle. Exemple :
x[2]= 'dimanche' # remplace mercredi par dimanche
1.4.3.5. Ajouter de nouveaux éléments à une liste : fonction append()
Il est possible d’ajouter des nouveaux éléments en plus des éléments initiaux. Pour cela, on utilise la fonction append(). Exemple : Soit la liste initiale définie comme suit :
x= ['lundi', 'mardi', 'mercredi’, ‘jeudi', 'vendredi']
On veut compléter cette liste en ajoutant samedi et dimanche. Pour cela on peut faire :
x.append('samedi') x.append('dimanche')
Il faut juste signaler que les résultats de ces deux opérations pouvaient être obtenus en utilisant l’opérateur de concaténation + comme suit :
x=x+ ['samedi'] x=x+ ['dimanche ']
Ces deux opérations correspondent à l’addition de deux listes : la première liste constituée par la liste initiale x et la seconde liste formée d’un seul élément samedi ou dimanche. La liste finale ainsi obtenue est nommée x écrasant ainsi la liste x initiale.
Utilisation de la fonction extend()
43

Par ailleurs, comme on peut le constater la fonction append() ne peut ajouter qu’un seul élément à une liste à la fois. C’est pourquoi, on peut avoir recours à la fonction extend() lorsque l’on veut ajouter plusieurs éléments en même temps. Exemple :
x= ['lundi', 'mardi', 'mercredi’, ‘jeudi', 'vendredi'] x.extend(['samedi', 'dimanche']) print(x) # renvoie ['lundi', 'mardi', 'mercredi’, ‘jeudi', 'vendredi', 'samedi', 'dimanche']
Avec la fonction extend(), les éléments à ajouter doivent être spécifiées sous forme de listes.
1.4.3.6. Insérer de nouveaux éléments dans une liste : fonction insert()
La fonction append() précédemment utilisée ajoute les nouveaux éléments à la fin de la liste initiale. En utilisant la fonction insert(), on peut insérer les nouveaux élément à n’importe quelle position dans la liste initiale en indiquant l’indice. Exemple : soit la liste initiale définie comme suit :
x= ['lundi', 'mardi', 'mercredi', 1800, 20.357, 'jeudi', 'vendredi']
On peut faire des ajouts suivants :
x.insert(2, 15) # Insère 15 dans la liste x à l’indice 2 print(x) # renvoie ['lundi', 'mardi', 15, 'mercredi', 1800, 20.357, 'jeudi', 'vendredi'] x.insert(7, 'samedi') # Insère samedi à l’indice 7 (dernière position de la liste initiale) print(x) # renvoie ['lundi', 'mardi', 'mercredi', 1800, 20.357, 'jeudi', 'vendredi', 'samedi']
1.4.3.7. Supprimer un élément d’une liste fonctions remove() ou delete
Il y a deux manières pour supprimer un élément d’une liste. La suppression en se basant sur la valeur de l’élément ou la suppression en se basant sur l’indice de l’élément. Dans le premier cas, on utilise la fonction remove() et dans le second cas, on utilise la fonction delete(). Les deux exemples ci-dessous sont des illustrations :
x= ['lundi', 'mardi', 'mercredi', 1800, 20.357, 'jeudi', 'vendredi'] x.remove('mercredi') # supprime 'mercredi' de la liste initiale x del x.[2] # supprime l’élément d’indice 2 qui correspond ici à 'mercredi'
NB : Dans les deux exemples ci-dessus, même si la fonction remove et del permettent de supprimer le même élément, il faut noter que dans certains cas, les résultats renvoyés par les deux fonctions peut être radicalement différents. En effet, si l’élément de valeur 'mercredi' avait été dupliqué dans la liste initiale x, alors la fonction remove() aurait supprimé toutes les occurrences tandis que la fonction del n’aurait supprimer que l’occurrence située à l’indice 2. Il faut donc faire attention lors du choix entre les deux fonctions.
44

1.4.3.8. Renvoyer l’indice d’un élément en se basant sur sa valeur :fonction index()
Comme nous avons vu plus haut, les opérations d’indiçage (slicing) permettent de renvoyer les valeurs des éléments en indiquant leur indice. A présent, nous souhaitons renvoyer les indices en se basant sur les valeurs. La fonction index() permet donc de faire du contre-indiçage en renvoyant les indices des valeurs indiquées. Exemple :
x= ['lundi', 'mardi', 'mercredi', 1800, 20.357, 'jeudi', 'vendredi'] x.index('mercredi') # Renvoie 2 ( l’indice de l’élément mercredi) x.index(20.357) # Renvoie 4 (l’indice de l’élément 20.357)
Nb : Lorsqu’il y a plusieurs occurrences de la même valeur dans la liste, la fonction index renvoie toujours l’indice de la première occurrence. On peut modifier ce comportement en se servant des options de la fonction index() que sont start et stop en y ajoutant d’autres fonctions.
1.4.3.9. Compter le nombre d’occurrences d’une valeur dans une liste : fonction count()
Il arrive fréquemment qu’une valeur se répète plusieurs fois dans une liste. Pour compter le nombre d’occurrences dans une liste, on utilise la fonction count(). Exemple :
x= ['lundi', 'mardi', 'lundi', 1800, 20.357, 'lundi', 'Mardi', 1800] x.count('lundi') # Renvoie 3 ( le nombre d’occurrence de lundi) x.count(20.357) # Renvoie 1 x.count(1800) # Renvoie 2 x.count('mardi') # Renvoie 1 (Attention : mardi et Mardi ne sont pas considérés comme les même valeurs)
1.4.3.10. Trier les éléments d’une liste : fonction sort()
Pour trier les éléments d’une liste dans un ordre croissant ou décroissant, on utilise la fonction sort(). Exemples : soit la liste x définie comme suit :
x=[ 12, 5 , 4 , 20 ,3, 8, 9, 51 ]
Pour trier x par ordre croissant, on fait :
x.sort() # renvoie [3, 4, 5, 8, 9, 12, 20, 51]
Et pour trier par ordre décroissant, on fait :
x.sort(reverse=True) # Renvoie [51, 20, 12, 9, 8, 5, 4, 3]
Nb : Lorsque le tri est effectué sur une liste contenant uniquement les chaînes de caractères, le tri est réalisé par ordre alphabétique (croissant ou décroissant). Toutefois lorsque le tri est
45

réalisé sur une liste contenant à la fois des chiffres et des caractères, un message d’erreur est renvoyé. L’une des solution serait alors de convertir les chiffres en type caractères avec la fonction str() ; faire le tri et ensuite reconvertir les chiffres en utilisant les fonction int() ou float().
Trier les élements d’une liste en fonction des valeurs d’une autre liste
Exemple : Soit les deux listes suivantes :
X = ["a", "b", "c", "d", "e", "f", "g", "h", "i"] Y = [ 0, 1, 1, 0, 1, 2, 2, 0, 1]
On souhaite trier la liste X selon les valeurs de la liste Y (par ordre croissant). On suit les étapes suivantes :
X_sorted=[x for (y,x) in sorted(zip(Y,X), key=lambda pair: pair[0], reverse=False)]
Cette fonction renvoie : ['a', 'd', 'h', 'b', 'c', 'e', 'i', 'f', 'g']
Pour effectuer un tri par ordre décroissant, on ajoute l’option reverse=True comme suit :
X_sorted=[x for (y,x) in sorted(zip(Y,X), key=lambda pair: pair[0], reverse=True)]
1.4.3.11. Intervertir l’ordre des éléments dans une liste : fonction reverse()
Intervertir l’ordre dans une liste c’est renverser l’ordre des éléments de sorte que le dernier élément de la liste initiale devient le premier élément de la liste finale et ainsi de suite. Pour réaliser cette opération, on utilise la fonction reverse(). Exemple :
x= ['lundi', 'mardi', 'lundi', 1800, 20.357, 'lundi', 'Mardi', 1800] x.reverse() # Renvoie [1800, 'Mardi', 'lundi', 20.357, 1800, 'lundi', 'mardi', 'lundi']
1.4.3.12. Joindre les éléments d’une liste pour former une chaîne de caractères : fonction join()
La fonction join() permet d’associer tous les éléments d’une liste pour former une seule chaîne de caractères. La jointure des éléments peut se faire avec séparateur ou sans séparateur. Dans le cas de la jointure sans séparateur, tous les éléments sont concaténés les uns à la suite des autres sans aucun espace ni autre symbole. Exemple : Soit la liste x définie par :
x = ["A", "T", "G", "A", "T"]
On peut faire les différentes jointures suivantes :
Jointure avec espace comme séparateur
46

ch1= " ".join(x) # renvoie 'A T G A T'
Jointure avec tiret comme séparateur
ch2= "-".join(x) # Renvoie 'A-T-G-A-T'
Jointure sans séparateur (ni espace)
ch3= "".join(x) # Renvoie 'ATGAT'
Attention, la fonction join() ne s’applique qu’à une liste de chaînes de caractères (pas aux listes de chiffres). Pour ceux-ci il faut d'abord changer leur type en caractères en utilisant la fonction str().
1.4.3.13. Tester l’existence d’un élément dans une liste : fonction in
Pour vérifier si un élément défini par sa valeur se trouve dans une liste , on utilise la fonction in qui renvoie une valeur booléenne (True ou False) selon que l’élément existe ou pas dans la liste. Exemple : soit la liste définie par :
x= ['lundi', 'mardi', 'lundi', 1800, 20.357, 'lundi', 'Mardi', 1800]
On peut faire des tests d’existence suivants :
'lundi' in x # renvoie True (car il y a bien lundi dans la liste x) 'samedi' in x # renvoie False 1500 in x # renvoie False 1800 in x # renvoie True 200 not in x # renvoie True
La fonction « in » s’avère utile dans de nombreuses situations. Comme nous avons vu dans les sections précédentes, elle sert dans la définition des boucles « for » qui font des itérations sur tous éléments d’une séquence notamment d’une liste. Elle peut aussi servir dans la définition des instructions conditionnelles en l’associant avec la clause « if ». Exemple :
if 1500 in x : print("Oui 1500 existe dans la liste x")
else : print("Non 1500 ,n’ existe pas dans la liste x")
1.4.3.14. Récupérer simultanément les indices et les valeurs des éléments d’une liste : fonction enumerate()
La fonction enumerate() permet de récupérer les indices et les valeurs d’une liste pour les stocker sous forme de tuple. Chacun des valeurs de ces deux variables peuvent être récupérées pour des utilisations futures.
47

Exemple 1 : Générer une liste à partir de la fonction enumerate()
Soit la liste x définie par :
x=['Jean', 'Maximilien', 'Brigitte', 'Sonia', 'Jean-Pierre', 'Sandra']
On peut par exemple définir une nouvelle liste à partir des résultats de la fonction enumerate() comme suit :
mylist=list(enumerate(x,1)) print(mylist) # renvoie [(1, 'Jean'), (2, 'Maximilien'), (3, 'Brigitte'), (4, 'Sonia'), (5, 'Jean-Pierre'), (6, 'Sandra')]
On constate alors que la fonction enumerate() crée toujours un couple de valeurs (indice/valeurs). Dans cet exemple, ces valeurs couples ont été récupérées pour former une liste nommée mylist. Nb : L’option 1 dans le fonction enumerate() signifie que les indices nouvellement crées doivent commencer par 1 au lieu de la valeur par défaut qui est 0.
Exemple 2 : Construire une boucle « for » à partir de la fonction enumerate()
Soit la liste x définie précédemment, on peut élaborer des instructions en boucle avec la fonction enumerate() comme suit :
for i, v in enumerate(x): print(i) print(v)
Dans cet exemple, on récupère chaque indice et valeur de la liste x et on les affiche en utilisant la fonction print(). On pouvait aussi définir d’autres instructions en boucle. Par exemple définir deux nouvelles listes : une constituée par les indices de la liste initiale et l’autre constituée par les valeurs. Voir exemple ci-dessous :
x=['Jean', 'Maximilien', 'Brigitte', 'Sonia', 'Jean-Pierre', 'Sandra']
listIndices=[] # Création d’une liste vide (pour les indices) listValeurs=[] # Création d’une liste vide (pour les valeurs) for i, v in enumerate(x):
listIndices.append(i) listValeurs.append(v) print(listIndices) print(listValeurs)
Remarque : la fonction append() utilisée dans la boucle for constitue une manière originale pour faire la copie d’une liste initiale qui paraît compliquer dans certaines situations (voir section sur la copie de liste un peu plus bas).
1.4.3.15. Faire la copie d’une liste
48

L’une des particularités d’une liste est que l’opération d’assignation (=) ne permet pas faire la copie d’une liste. Il permet seulement de référencer les valeurs de celle-ci. Par exemple, soit x une liste définie initialement. En définissant une liste y telle que y=x crée en réalité une référence et non une copie car en modifiant un élément de x, cela se répercute directement sur y sans aucun besoin de modification supplémentaire. Pour s’en rendre compte, penons les exemples suivants :
x = [1,2,3] # définition de la liste x y = x # définition de la liste y par assignation print(y) # renvoie [1,2,3] x[1] = -15 # Modification de la liste x ( le second élément remplacé par -15) print(y) # renvoie [1,-15,3].
On voit que cette modification de x se répercute automatiquement sur y. Ce qui démontre que la création de copie par assignation ne permet de faire qu’une copie dynamique (référencement) et non une copie définitive.
Pour faire la copy d’une liste, on peut se servir de la fonction copy() comme suit :
Il existe néanmoins plusieurs méthodes alternatives pour faire une copie d’une liste. Le choix de la méthode dépendra alors selon qu’il s’agisse d’une liste à une dimension ou une liste à plusieurs dimensions (c'est-à-dire une liste des listes).
Copie d’une liste à une dimension
La première méthode pour faire la copy d’une liste simple est d’utiliser la fonction copy(). Celleci est illustrée par l’exemple 1 ci-dessous
Exemple 1 : Utilisation de la fonction copy()
x = [1,2,3] # définition de la liste x y = x.copy() # définition de la liste y en utilisant la fonction copy print(y) # renvoie [1,2,3] x[1] = -15 # Modification de la liste x ( le second élément remplacé par -15) print(y) # renvoie [1,2,3].
Attention : La fonction copy() ne fait qu’une copie superficielle de la liste. En ce sens, elle ne fonctionne convenablement que lorsqu’il s’agit d’une liste simple (liste à une dimension). Elle n’est donc pas valable pour une liste à plusieurs dimensions.
Il existe néanmoins plusieurs autres méthodes plus ou moins conventionnelles pour faire une copie rapide d’une liste à une dimension. Les exemples suivants sont des illustrations.
Exemple 2 : Utilisation de la fonction list()
x = [1,2,3] # définition de la liste initiale x
49

y = list(x) # définition de la liste y en utilisant la fonction list() sur x x[1] = -15 # Modification de la liste x print(y) # renvoie [1,2,3].
On remarque qu’en utilisant la fonction list(), toute modification effectuée ultérieurement sur x ne se répercute plus sur y. Il faut toutefois noter que l’utilisation de la fonction list() ne fonctionne que dans le cas d’une liste à une dimension (pas dans le cas d’une liste à plusieurs dimensions).
Exemple 3 : Utilisation de l’opérateur de slicing [ :]
Pour sélectionner tous les éléments de x et les stocker dans une nouvelle liste assigner à un nouveau nom, il suffit d’utiliser l’opérateur [ :] comme suit :
x = [1,2,3] # définition de la liste initiale x y = x[:] # définition de la liste y en sélectionnant tous les élements de x x[1] = -15 # Modification de la liste x print(y) # renvoie [1,2,3].
Là encore, les modifications de x ne se répercutent plus sur y. Toutefois cette méthode reste applicable uniquement dans le cas d’une liste à une dimension.
Exemple 4 : Utilisation de la boucle « for » et de la fonction append()
x = [1,2,3] # définition de la liste initiale x y = [] # Création d’une liste vide for i in range(len(x)):
y.append(x[i]) print(y)
Cette méthode reste aussi valable uniquement dans le cas d’une liste à une dimension.
Exemple 5 : Utilisation de la fonction deepcopy()
deepcopy() est une fonction avancée appartenant au module copy qui permet de faire les copies des objets python. On peut donc utiliser cette fonction pour la copie d’une liste. Toutefois, pour l’utiliser, il faut d’abord importer le module copy comme suit :
import copy x = [1,2,3] # définition de la liste initiale x y = copy.deepcopy(x) # définition de la liste y en utilisant deepcopy() print(y) # renvoie [1,2,3].
Copie d’une liste à plusieurs dimensions
50

Pour faire la copie d’une liste à plusieurs dimensions, on utilise la fonction deepcopy() du module copy. Cette fonction est valable quelle que soit la dimension de la liste. L’exemple cidessous illustre la création d’une copie d’une liste à deux dimensions.
import copy x = [[1,2],[3,4]] # définition de la liste initiale x y = copy.deepcopy(x) # définition de la liste y en utilisant deepcopy() print(y) # renvoie [[[1,2],[3,4]]
x[1][1] = -15 # Modification de la liste x print(y) # renvoie [[[1,2],[3,4]]
NB : Il existe plusieurs autres fonctions applicables sur les listes. Pour accéder à la liste complètes des fonctions associées à une liste, il faut utiliser la fonction dir(). Par exemple la fonction dir(x) affiche toutes les fonctions disponibles pour la liste x. Et pour obtenir l’aide sur une fonction on tape la commande help( x.nomFonction). Exemple :
help(x.sort) # affiche l’aide la fonction sort() applicable à la liste x.
Attention : la plupart des fonctions qui ont été présentées ci-dessus (remove, sort, reverse, etc…) font des modifications de type « IN PLACE » sur la liste indiquée. Ce qui signifie que toute application de la fonction remplace la liste initiale par la liste modifiée. Cette situation ne convient pas dans tous les cas. C’est pourquoi, il est préférable, si nécessaire, de créer d’abord une copie de la liste la liste initiale et ensuite réalisée la modification sur cette copie créée.
1.4.3.16. Combiner les éléments de deux listes pour former une liste de couple d’éléments : fonction zip()
Nous avons vu précédemment que la fonction enumerate() renvoyait les indices et les valeurs d’une liste pour former un couple de valeur indice/ valeur organisé sous forme de liste. La fonction zip() permet de combiner les éléments de deux listes en formant une liste de couple formés par les éléments de même indice. Très concrètement, considérons les deux listes suivantes :
x1=['a', 'b', 'c'] x2=['d', 'e', 'f']
En appliquant la fonction zip() sur ces deux liste telle que :
y=list(zip(x1, x2))
On obtient une liste qui se présente telle que : [('a', 'd'), ('b', 'e'), ('c', 'f')]
Le résultat renvoyé par zip() est une liste de tuples tout comme pour enumerate()
51

NB : Puisque la fonction zip() forment les couples de valeurs à partir des éléments de même indice, lorsque les deux liste ne sont pas de même longueur, la dimension de la liste finale se limite à celle de la liste avec la longueur minimale. Les autres éléments de la grande liste sont donc ignorés.
Par ailleurs, les résultats renvoyés par la fonction zip() sont souvent utilisés pour exécuter d’autres instructions comme pour la fonction enumerate(). La structure générale de ces instructions se présente alors comme suit :
for e1, e2 in zip(liste1, liste2): instructions utilisant e1 et e2
Notons aussi que les valeurs réalisées par la fonction zip() peuvent être explicitement formulées comme suit :
for i in range(min(len(liste1), len(liste2))): e1, e2 = liste1[i], liste2[i] instructions utilisant e1 et e2
Dans cette formulation, on définit une boucle allant de 0 à la valeur minimum entre len(liste1) et len(list2). Ensuite, on récupère les valeurs de liste1 et liste2 correspondant à l'index i. Ces valeurs sont alors utilisées pour définir les instructions. Une telle formulation montre donc que l’utilisation de la fonction zip() n’est pas un passage obligé.
la fonction unzip()
Il arrive souvent que l’on veuille décomposer une liste de tuple (liste zippée) en deux listes distinctes. Il faut alors utiliser la méthode unzip. Malheureusement, il n’y a pas sous python une fonction directe qui puissent réaliser cette tâche, il faut utiliser une combinaison de fonctions y compris la fonction zip() elle-même. L’exemple ci-dessous est une illustration.
1- On définit d’abord une fonction lambda nommée myUnzip
myUnzip = lambda x: [list(i) for i in zip(*x)]
2- Ensuite, on applique cette fonction sur une liste zippée. Ex soit la liste zipListe définie comme suit :
zipList=[(1, 2), (3, 4), (5, 6)]
En appliquant la fonction myUnzip sur cette liste, on obtient une nouvelle liste nommée unzipList telle que :
unzipList= myUnzip(zipList) # Renvoie [[1, 3, 5], [2, 4, 6]]
3- Comme unzipList est une liste à deux dimensions constituée de deux éléments, on fait du slicing sur cette liste pour former deux listes séparées. On a :
52

liste1=unzipList[0] liste2=unzipList[1] print(liste1) # renvoie [1, 3, 5] print(liste2) #renvoie [2, 4, 6]
Penser donc à utiliser cette méthode chaque fois qu’on dispose d’une liste de tuple et qu’on souhaite la décomposer en deux listes distinctes.
1.5. Les fonctions map(), filter() et reduce() pour le traitement des listes
Dans cette section, nous présentons quelques fonctions qui peuvent s’avérer utiles lors du traitement des éléments d’une liste. Il s’agit notamment des fonctions map(), filter() et reduce().
1.5.1. La fonction map()
La fonction map() permet d’exécuter une fonction donnée sur chaque élément d’une liste initiale et renvoie les résultats finals sous forme d’une nouvelle liste. La fonction map() fonctionne sur le principe définit par le programme suivant :
def map(f, inputList): outputList = [] for x in inputList: outputList.append(f(x)) return outputList
Dans cette architecture, on définit une fonction qui s’appelle map(). Nous reviendrons plus en détail sur la définition des fonctions. La fonction map() prend deux arguments : une fonction f et une liste initiale inputList. Le but est d’appliquer la fonction f sur chaque élément de la liste inputList en utilisant une boucle for. Ensuite stocker au fur et à mesure le résultat obtenu dans une liste initialement vide outputList. Et enfin, renvoyer la liste finale obtenue lorsque la boucle sera bouclée. C’est le principe de la fonction map().
Le résultat final renvoyé par la fonction map() dépendra alors du choix de la fonction f. Plusieurs cas peuvent se présenter ; par exemple compter la longueur de chaque élément, compter le nombre d’occurrence de chaque élément, etc…Il faut noter que la fonction map() est beaucoup utilisée dans le traitement des données de masse. Par exemple, l’essentiel de l’algorithme Hadoop MapReduce écrit sous java est basée sur ce principe.
Les exemples ci-dessous illustrent quelques utilisation simples de la fonction map() sous python.
Exemple 1 : Déterminer la longueur de chaque mot dans une liste de mots
Soit une liste l définie par:
53

l = ["le", "kangourou", "vert"]
Nous souhaitons créer une liste contenant les longueurs des éléments. Pour cela, nous allons utiliser la fonction len en spécifiant la liste comme suit :
x=list(map(len, l)) print(x) # renvoie [2, 9, 4]
Dans cet exemple, la fonction list() sert uniquement à récupérer les résultats renvoyés par la fonction map() sous forme de liste
Exemple 2 : Convertir tous les éléments d’une liste de chaine de caractères en minuscule ou en majuscule
l = ["Le", "Kangourou", "Vert"] x=list(map(str.lower, l)) # convertir en minuscule y=list(map(str.upper, l)) # convertir en majuscule print(x) # renvoie ['le', 'kangourou', 'vert'] print(y) # renvoie ['LE', 'KANGOUROU', 'VERT']
Exemple 3: Calculer la racine carrée des éléments d’une liste
l= [1,4,9,16] # définition de la liste initiale from math import sqrt # importation de la fonction sqrt à partir du module math x=list(map(sqrt, l)) # renvoie [1.0,2.0,3.0,4.0]
Nb : on peut aussi utiliser d’autres opérations, log, exp, etc…
Exemple 4 : Application d’une fonction définie par l’utilisateur
Dans les exemple ci-dessus, la fonction map() a été exécutée à partir des fonctions déjà disponibles dans les modules standards de python. Mais dans de nombreuses situations, l’utilisateur est amené à écrire sa propre fonction pour pouvoir définir les tâches qu’il souhaite appliquer avec la fonction map(). L’exemple ci-dessus illustre l’écriture et l’utilisation des fonctions de l’utilisateur (nous reviendrons plus tard sur la définition des fonctions).
On souhaite appliquer la fonction map() sur une fonction qui renvoie le reste de la division par 2 des éléments d’une liste définie par l=[2, 5, 7, 17, 33, 21, 12, 50].
Dans ce cas, nous allons d’abord définir une fonction qui renvoie le reste de la division par 2. On suit les étapes suivantes :
def restFunction(x) : return x % 2
54

Nous avons nommé la fonction restFunction, qui prend comme argument x et qui renvoie le reste de la division de x par 2 avec l’opérateur modulo (%). En soumettant cette fonction à la fonction map(), x prendra successivement les valeurs de la liste initiale l. Ainsi on a :
restList = list(map (restFunction, l)) print(restList) # renvoie [0, 1, 1, 1, 1, 1, 0, 0]
1.5.2. La fonction filter()
Comme sa dénomination indique, la fonction filter() permet de mettre un filtre sur les éléments d’une liste afin de renvoyer ceux qui remplissent les condition définie par le filtre. Contrairement à la fonction map(), la fonction filter() exécute toujours des instructions conditionnelles. Les exemples ci-dessous sont des illustrations.
Exemple 1 : Renvoyer tous éléments alphabétiques dans une liste
Soit la liste l définie par :
l=['x', 'y', '2', '3', 'a'] # On remarque que tous les élements sont en chaînes de caractères (mais ne sont pas tous alphabétiques)
On veut construire une nouvelle liste contenant uniquement les éléments alphabétiques (excluant alors les éléments numériques). On fait :
x=list(filter(str.isalpha,l )) print(x) # renvoie ['x', 'y', 'a']
La fonction isalpha est un opérateur booléen qui vérifie si une chaine de caractères donnée est alphabétique ou non (nous reviendrons plus en détails sur les chaines de caractères dans les sections suivantes).
Exemple 2 : Récupérer les nombres impairs d’une liste
Soit la liste initiale définie par :
l=[2, 5, 7, 17, 33, 21, 12, 50]
On souhaite appliquer la fonction filter() à partir d’une fonction qui identifie les nombres impairs dans cette liste. Nous allons ici devoir élaborer une petite fonction qui effectue cette tâche. On a :
def impair(x): if x % 2 !=0: return x
impairList=list(filter(impair, l)) print(impairList) # renvoie [5, 7, 17, 33, 21]
55

Exemple 3 : Renvoyer tous les éléments d’une liste qui contiennent un motif donné.
Soit la liste définie par :
l = [ "le", "kangourou", "vert" ]
On souhaite récupérer tous les éléments de la liste qui contiennent "e".
Pour cela, on définit d’abord une petite fonction comme suit :
f= lambda x: "e" in x eList=list(filter(f, l)) print(eList) # renvoie ['le', 'vert']
Dans cet exemple, remarquer l’utilisation de la fonction lambda. En effet, comme il s’agit ici d’une instruction simple, il n’est pas nécessaire d’écrire une fonction classique avec le mot clé def. On peut se contenter de la fonction lambda qui est une fonction anonyme (sans nom défini préalable) et qui renvoie toujours un résultat équivalent à ce que fait la fonction return dans une fonction traditionnelle. Dans notre cas ici, nous avons décidé d’attribuer le nom f à la fonction lambda afin de simplifier la spécification de la fonction filter(). D’une manière générale, la structure d’une fonction lambda est toujours conçu pour renvoyer une valeur x lorsqu’une condition y est vérifiée. Dans notre cas ici, on indique de renvoyer x lorsque x contient e. En appliquant cette instruction sur la liste l, on obtient alors ['le', 'vert'] qui sont les deux éléments qui contiennent "e".
Exemple 4 : Renvoyer tous les éléments d’une liste dont la longueur est supérieure à une certaines valeurs.
Soit la liste l suivante :
l = [ "le", "kangourou", "vert" ]
On souhaite renvoyer tous les éléments dont la longueur est supérieure à 5.
Ici aussi, on peut utiliser la fonction lambda puisque l’instruction à exécuter ne nécessite forcement d’élaborer une fonction traditionnelle. Ainsi, on a :
f= lambda x: len(x)>5 lenList=list(filter(f, l)) print(lenList) # renvoie ['kangourou']
1.5.3. La fonction reduce()
La fonction reduce() est la troisième fonction du trio map()-filter()-reduce() dont le rôle est de renvoyer une information synthétique à partir d’un ensemble de valeurs définie par une liste.
56

D’une manière générale, la fonction reduce() renvoie généralement une valeur tandis que les fonction map() et filter() renvoient des listes.
Il faut noter que dans les version récentes de python la fonction reduce() n’est plus une fonction de la bibliothèque standard de python. La fonction a été intégrée au module functools qui nécessite d’abord d’être importé avant de pouvoir utiliser la fonction reduce(). A cet effet, nous utilisons d’abord la fonction import telle que :
import functools
from functools import reduce
Les exemples ci-dessus illustrent quelques utilisation de la fonction reduce()
Exemple 1 : Les opérations mathématiques courantes :
Maximum d’une liste
reduce(max, [5,8,3,1]) # renvoie 8
Somme des éléments d’une liste
import operator reduce(operator.add, [1,2,3]) # renvoie 6
Pour voir la liste complète des opérateurs arithmétiques de python sous forme de fonctions consulter la page : https://docs.python.org/2/library/operator.html
Exemple 2 : Effectuer des opérations sur les listes
Concaténation de listes
reduce(operator.concat, [[1,2],[3,4],[],[5]], []) # renvoie [1,2,3,4,5]
Jointure des éléments d’une liste
f=lambda s,x: s+str(x) reduce(f, [1,2,3,4], '') # renvoie '1234'
1.6. Etude des objets « tuples »
A l’instar des objets listes, les objets tuples sont des séquences de valeurs (numériques et/ou en caractères) dont les éléments sont indiqués entre parenthèses (crochets pour les listes) et séparés par des virgules. A la différence des listes, les éléments d’un tuple sont indicés (accessibles par slicing) mais pas modifiables. Toutefois, il est possible d’extraire les éléments pour en créer d’autres objets.
57

1.6.1. Définition d’un tuple
Les exemples ci-dessous illustrent quelques définitions de tuples.
x = (1, 2, 3, 4, 12, 5, 7, 31) # Crée un tuple de valeurs numériques y=('lundi','mardi','mercredi','jeudi','vendredi') # tuple de chaines de caractères z=('lundi','mardi','mercredi',1800,20.357,'jeudi','vendredi') # tuple de valeurs numériques et de caractères k=tuple(range(4,13)) # tuple de valeur numériques entre 4 et 12 t=tuple()
Ces cinq exemples montrent différentes manières de définition d’un tuple. La variable x est un tuple constitué uniquement de valeurs numériques. La variable y est constituée uniquement de valeurs en caractères. La variable z est un tuple qui combine les valeurs numériques et en caractères.
S’agissant de la variable k, c’est un tuple crée en utilisant la fonction tuple() à l’image de la fonction list(). Ici, le tuple est formé par une séquence de valeurs numérique générée par la fonction range().
Quant à la variable t, c’est un tuple vide qui s’obtient en utilisant la fonction tuple() sans argument.
Remarque : Pour créer un tuple d’un seul élément, il faut utiliser une syntaxe avec une virgule définie sous la (valeur_element,). Cela permet d’éviter l’ambiguïté avec la définition d’une simple variable.
y = (10,) # Crée un tuple constitué d’un seul élement 10 y=(10) # crée une variable simple dont la valeur est 10
Noter aussi qu’il est possible d’en créer un tuple sans les parenthèses, dès lors que ceci ne pose pas d’ambiguïté avec une autre expression telle que la création de variable avec assignation parallèle. Exemple :
x = 1,2,3 # Crée un tuple dont les éléments sont 1, 2 et 3 x, y, z=1,2,3 # Crée trois variables x, y, et z dont les valeurs sont respectivement 1, 2 et 3
1.6.2. Indiçage des tuples (slicing)
Comme signalé précédemment, les éléments d’un tuple sont indicés mais ils ne sont pas modifiables. Néanmoins, il est possible d’accéder aux éléments, les extraire pour d’autres utilisations (créations de variables simples, de listes, ou de nouvelles tuples, etc..).
58

Le slicing d’un tuple se fait de la même manière que dans une liste. Les exemples ci-dessous sont des illustrations.
Soit le tuple x défini comme suit :
x=('lundi','mardi','mercredi',1800,20.357,'jeudi','vendredi') print(x) # affiche tous les éléments du tuple x x[0] # renvoie le premier élément de x :lundi (Nb :l’indiçage commence toujours à 0) x[3] # renvoie l’élément d’indice 3( quatrième élément de x) :1800 x[1:3] # Renvoie tous éléments compris entre l’indice 1 et l’indice 3 (Nb : l’élément d’indice 3 est exclu) x[1:6 :2] # Renvoie tous éléments compris entre l’indice 1 et l’indice 6 avec un saut de 2 éléments à chaque fois ['mardi', 1800, 'jeudi'] (l’élément d’indice 6 est exclu).
x[2 :] # renvoie tous éléments à partir de l’élément d’indice 2 ( inclu). x[:3] # renvoie tous éléments situés avant l’élément d’indice 3 (exclu) x[-1] # Indiçage négatif, renvoie le dernier élément du tuple (équivaut ici à x[6]) x[-2] # Indiçage négatif, renvoie l’avant-dernier élément du tuple (équivaut ici à x[5])
Nb : Les éléments renvoyés par slicing peuvent être stockés dans de nouvelles variables, des listes ou dans d’autres tuples.
1.7. Etude des objets « set »
Les objets set sont des séquences de valeurs sans doublons (numériques et/ou en caractères) indiquées entre accolades et séparés par des virgules. A la différence des listes et des tuples, les set ne sont pas indicés. Les éléments sont inaccessibles par slicing. Par conséquent, ils sont non modifiables. Pour pouvoir effectuer les opérations de modifications, on est souvent obligé de transformer le set en liste en utilisant la fonction list(). Nous reviendrons sur ces aspects plus bas.
D’une manière générale, les sets sont construits à partir des listes ou des tuples. Ils sont principalement utilisés soit pour éliminer des doublons dans une séquence, soit pour tester si un élément appartient ou non à une collection. Contrairement aux autres objets, les set permettent de réaliser des opérations mathématiques sur les ensembles (union, intersection, la différence….).
Les exemples ci-dessous illustrent quelques définitions de set.
59

x = {1, 2, 3, 2, 4,7, 12, 5, 7, 31, 7} # Crée un set de valeurs numériques en supprimant les doublons de 2 et de 7 y={'lundi','mardi','mercredi','jeudi','vendredi','mardi'} # set de chaines de caractères en supprimant le doublon mardi myList=('lundi','mardi','mercredi',1800,20.357,'jeudi',1800, 'vendredi','vendredi') # définition d’une liste z=set(myList) # Crée un set à partir d’une liste k=set() # Crée un set vide
Ces exemples montrent différentes manières de définition d’un set. La variable x est un set constitué uniquement de valeurs numériques (la séquence de valeurs renvoyée ne contiendra aucun doublon). La variable y est constituée uniquement de valeurs en caractères (sans doublon). La variable z est un set crée à partir d’une liste en utilisant la fonction set(). Et la variable k est un tuple vide
Remarque : Etant donné que les éléments d’un set sont inaccessibles et non modifiables, pour pouvoir appliquer les opérations de modification, il faut d’abord transformer le set en liste, faire les modifications et reconvertir la liste modifiée en set si utile.
Par ailleurs, même si on ne peut pas modifier les éléments d’un set, on peut effectuer les opérations sur les ensembles (union, intersection, etc…) Voici-ci-dessous quelques exemples.
Soit x et y deux set définis comme suit :
x=set('abracadabra') # un set formé par les éléments de la chaine, renvoie {'c', 'a', 'b', 'r', 'd'} y=set('alacazam') # un set formé par les éléments de la chaine, renvoie {'c', 'z', 'a', 'l', 'm'} print(x-y) # lettre dans x mais pas dans y, renvoie {'b', 'r', 'd'} print(x|y) # lettres dans x ou dans y, renvoie {'b', 'r', 'm', 'd', 'z', 'l', 'c', 'a'} print(x & y) # lettre dans x et dans y, renvoie {'c', 'a'} print(x^y) # lettre qui uniquement dans x ou uniquement dans y (mais pas dans les deux en même temps), renvoie {'b', 'r', 'm', 'd', 'z', 'l'}
1.8. Etude des objets « array »
Les objets « array » sont des séquences de valeurs (uniquement numériques) se présentant sous formes de tableaux d’un ou plusieurs dimensions (vecteur ou matrice). Les arrays sont objets définis avec la fonction array() accessible à partir du module numpy (module spécialisé dans les calculs numériques sous python). Pour pouvoir donc définir un objet array, il faut, au préalable importer le module numpy comme suit :
import numpy
60

1.8.1. Définition d’un array
Les objets array sont généralement définis à partir des objets listes, tuples ou tout autre séquence de valeurs comme les range. Ceux-ci doivent être spécifiées comme argument de la fonction array().
On peut distinguer les arrays selon leur dimension : les arrays à une dimension, les arrays à deux ou plusieurs dimensions.
1.8.1.1. Définition d’un array à 1 dimension
Les exemples ci-dessous illustrent quelques cas de définition d’un array à une dimension.
import numpy # Importe le module numpy pour pouvoir utiliser la fonction array() myList= [1,2,3, 8, 24, 12] # Crée une liste nommée myList myTuple= (0,2,3, 9, 7, 13) # Crée un tuple nommée myTuple x= numpy.array(myList) # Crée un array à partir d’une liste, renvoie : array([ 1, 2, 3, 8, 24, 12]) y= numpy.array(myTuple) # Crée un array à partir d’un tuple, renvoie : array([ 0, 2, 3, 9, 7, 13]) z=numpy.arange(10) # Crée un array en utilisant la fonction arange(). Renvoie : array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
La fonction arange() est l’équivalent de la fonction range() pour les cas des arrays. Elle permet directement de générer un array à partir de la séquence de valeurs indiquée. Par conséquent l’expression z=numpy.arange(10) est un raccourci de l’expression suivante :
z=numpy.array(list(range(10))) # Renvoie : array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
Toutefois, l’avantage de la fonction arange() par rapport à la fonction range(), c’est que celle-ci peut prendre des arguments numériques de type float ou interger alors que la fonction range() ne prend que des integers. Exemple :
z=numpy.arange(2.5,4.5, 0.5) # Array de séquence numérique compris entre 2.5 et 4.5 avec un pas de 0.5 Renvoie : array([ 2.5, 3. , 3.5, 4. ])
La différence fondamentale entre un objet array à une dimension et une liste (ou un tuple) est que celui-ci est considéré comme un vecteur. Par conséquent on peut effectuer des opérations vectorielle élément par élément. Ce qui est bien commode lorsqu’on analyse de grandes quantités de données. Exemples :
Soit le array x défini par :
61

x = numpy.arange(4) # renvoie array([0, 1, 2, 3]) x + 1 # renvoie array([1, 2, 3, 4]) x + 0.1 # renvoie array([ 0.1, 1.1, 2.1, 3.1]) x * 2 # renvoie array([0, 2, 4, 6]) x * x # renvoie array([0, 1, 4, 9])
Sur le dernier exemple de multiplication, l’array final correspond à la multiplication élément par élément des deux array initiaux. Avec les listes, ces opérations n’auraient été possibles qu’en utilisant des boucles.
1.8.1.2. Définition d’un array à plusieurs dimensions
Comme pour les listes, un array à deux dimensions se définit simplement comme array de array c'est-à-dire un array dont les éléments individuels sont constitués par des arrays. Les exemples ci-dessous illustrent quelques cas de définition d’un array à plusieurs dimensions.
Array à deux dimensions :
Pour créer un array à deux dimensions à partir d’une liste, il suffit de passer en argument une liste de listes à la fonction array(). Exemple :
myList=[[1,2,3],[2,3,4],[3,4,5]] # définition d’une liste de listes x=numpy.array(myList) # Définition d’un array d’array.
Nb: un array à deux dimensions ne veut pas dire array à deux colonnes. Il suffit simplement un array constitué de liste de liste.
Array à trois dimensions :
On peut aussi créer des tableaux à trois dimensions en passant à la fonction array() une liste de listes de listes :
myList=[[[1,2],[2,3]],[[4,5],[5,6]]] # définition d’une liste de listes x=numpy.array(myList) # Définition d’un array d’array d’array (array à 3 dimensions).
1.8.1.3. Indiçage d’un array (slicing)
L’indiçage d’un array se fait de la même manière que dans le cas d’une liste. Les exemples cidessous sont des illustrations.
Cas d’un array à une dimension
x = numpy.arange(10) # Définition d’un array, renvoie array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) x[1] # renvoie l’élément d’indice 1 (correspond ici à 1)
62

x[5:] # renvoie tous les éléments à partir de l’élément d’indice 5, ici array([5, 6, 7, 8, 9])
x[: : 2] # renvoie tous les éléments avec un saut de 2 élements à chaque fois array([0, 2, 4, 6, 8])
Cas d’un array à deux dimensions
y = numpy.array([[1,2],[3,4]]) # définition d’un array à deux dimensions y[0,:] # Sélectionne tous les éléments de l’array qui a l’indice 0 dans les arrays de second niveau, renvoie array([1, 2]) y[:,0] # sélectionne tous les éléments se trouvant à l’indice 0 dans les array de second niveau, renvoie array([1, 3]) y[1,1] # Sélectionne l’élément d’indice 1 de l’array qui a l’indice 1 dans la liste des array de second niveau, renvoie 4
1.8.2. Déterminer la dimension d’array
Pour déterminer la dimension d’un array, on utilise la fonction shape(). Voir exemple cidessous :
Soit le array x défini par :
x = numpy.arange(3) numpy.shape(x) # renvoie (3,) signifiant que l’array x contient trois élements
1.8.3. Les opérations sur les arrays
Cette section décrits quelques opérations couramment effectuées sur les arrays.
1.8.3.1. Conversion d’un array vectoriel en array matriciel: fonction reshape() et resize()
les fonctions reshape() et resize()permettent de transformer un array qui se présente initialement comme un vecteur en un array matriciel en indiquant le nombre de lignes et de colonnes. Les exemples ci-dessous illustrent le type de redimensionnement qu’effectue chacune de ces deux fonctions.
x = numpy.arange(9) # définit un array de 9 élements allant de 0 à 8 numpy.reshape(x,(3,3)) # Renvoie un array matriciel 3x3 en distribuant les éléments de l’array initial sur chaque ligne en revenant à la ligne quand la ligne est remplie. numpy.resize(x,(2,2)) # Renvoie un array matriciel 2x2 en distribuant les éléments de l’array initial sur chaque ligne en revenant à la ligne quand la ligne est remplie. Il s’arrête lorsque la matrice 2x2 est remplie.
63

numpy.resize(x,(4,4)) # Renvoie un array matriciel 4x4 en distribuant les éléments de l’array initial sur chaque ligne en revenant à la ligne quand la ligne est remplie. Il continue le remplissage tant que la matrice 4x4 n’est pas totalement remplie. Le remplissage continue à partir de la première valeur de l’array initial.
Nb : La fonction reshape() nécessite que la dimension de la matrice indiquée soit compatible avec le nombre d’éléments contenus dans l’array de départ. Ce qui n’est pas obligatoire pour la fonction que resize() qui puise les valeurs en recommençant à partir du premier élément de l’array initial. Et lorsque la dimension de la matrice est plus petite que la dimension de l’array de départ, le remplissage avec la fonction resize() s’arrête lorsque le remplissage de la matrice est complet. Pour le cas de la fonction reshape, celle-ci renvoie une erreur.
1.8.3.2. Transposé d'un array matriciel: fonction transpose()
la fonction transpose() renvoie la transposée d’un array. Par exemple pour une matrice :
x = numpy.arange(9) # génère un array y=numpy.reshape(x,(3,3)) # tranforme l’array en un array matriciel 3x3 z=numpy.transpose(y) # Effectue la transposée de la matrice y
1.8.3.3. Création d'un array matriciel rempli de 0 ou 1: fonctions zeros() et ones()
Les fonctions zeros() et ones() permettent de construire des objets array contenant des 0 ou de 1, respectivement. Pour cela, il faut leur passer un tuple indiquant la dimensionnalité voulue. Les exemples ci-dessus sont illustrations.
numpy.zeros((3,3)) # Crée un array matriciel de dimension 3x3 rempli de 0 (de type float) numpy.zeros((3,3),int) # Crée un array matriciel de dimension 3x3 rempli de 0 (de type integer) numpy.ones((3,3)) # Crée un array matriciel de dimension 3x3 rempli de 0 (de type float) numpy.ones((3,3), int) # Crée un array matriciel de dimension 3x3 rempli de 0 (de type float)
Nb : Par défaut, les fonctions zeros() et ones() génèrent des réels (float), mais on peut modifier ce comportement en demandant par exemple des entiers en passant l’option int en second argument.
1.8.3.4. Les opérations algébriques (matricielles) sur les arrays
64

Les arrays étant par définitions des objets vectoriels ou matriciels, on peut effectuer des opérations algébriques comme le produit matriciel, le calcul de déterminant, l’inversion de matrice, etc… Dans la plupart de ces opérations, on utilisera la fonction linalg du module numpy. Les exemples ci-dessous sont des illustrations.
Soit l’array matriciel x défini comme suit :
x = numpy.resize(numpy.arange(4),(2,2)) # génère un array matriciel
On peut effectuer les opérations algébriques suivantes :
x2=numpy.dot(a,a) # renvoie le produit matriciel entre x et x alors x*x aurait renvoyé le produit élément par élément. numpy.linalg.inv(x) # renvoie l’inverse de la matrice x numpy.linalg.det(x) # renvoie le déterminant de la matrice x numpy.linalg.eig(x) # renvoie un tuple dont le premier élément correspond aux valeurs propres et le second élément aux vecteurs propres. Pour avoir plus de détails sur la fonction linalg, consulter la page suivante : http://docs.scipy.org/doc/numpy/reference/routines.linalg.html
1.8.3.5. Utilisation de la fonction argsort() sur un array
La fonction argsort() renvoie sous forme de liste (ou d’array) les indices qui auraient trier u l’array qui a été fournit en arguement. Exemple :
x = numpy.array([1.48,1.41,0.0,0.1]) # Crée un array print (x.argsort()) # renvoie [2 3 1 0]
[2, 3, 1, 0] indique que l'élément le plus petit est à l'index 2, le suivant le plus petit à l'index 3, puis l'indice 1, puis le plus grand est à l'indice 0. La fonction renvoie donc les indices plutôt que les valeurs.
1.9. Etude des objets « dictionnaire »
Dans une conception pythonienne, un dictionnaire (encore appelé bibilothèque) est une collection d’objets (généralement des listes, des tuples, des array) définie sur la base clévaleur. Contrairement aux listes, les tuples ou les array dans lesquels les éléments sont identifiés à partir de leur indice, dans un dictionnaire, les éléments sont identifiés à travers des clés (qui se présente généralement sous forme de chaîne de caractère). Par ailleurs, comme on peut s’attendre, un dictionnaire est une collection d’objets plus générale qui peut inclure à la fois des listes, des tuples ou des array.
Dans cette section, nous allons passer en revue quelques-unes des propriétés des objets dictionnaire.
1.9.1. Définition d’un dictionnaire
65

Un dictionnaire (ou bibliothèque) est une collection d’objets formée de couples clé-valeur séparés par des virgules, l’ensemble spécifiée à l’intérieur des accolades. Les exemples cidessous montrent quelques définitions de dictionnaires
x= {'nom':'Jean', 'age':25, 'poids':70, 'taille':1.75} y= {'Jean':[25,70,1.75],'Paul':[30,65,1.80],'Pierre':[35,75,1.65] } z= {'Jean':(25,70,1.75),'Paul':(30,65,1.80),'Pierre':(35,75,1.65) } k={'nom':'Jean','biométrie':[25,70,1.75],'score':(12,17,15),'rang':25}
Les quatre variables ci-dessus représentent quatre manières typiques de définition d’un dictionnaire.
La variable x est un dictionnaire dont les clés sont nom, age, poids et taille. Les valeurs correspondantes sont Jean, 25, 70 et 1.75. Remarquons simplement que dans cette définition de x, à chaque clé correspond une valeur unique telle la définition d’une variable simple. Toutefois, il arrive très fréquemment d’associer plusieurs valeurs à une seule clé. C’est le cas de la variable y. En effet, pour cette variable, les clés sont Jean, Paul, et Pierre. Et on associe à chacune de ces clés trois valeurs se présentant sous forme de listes correspondant respectivement à l’âge, le poids et la taille. Quant à la variable z, elle se présente comme la variable y à la seule différence que les valeurs sont spécifiées sous formes de tuples.
Enfin, concernant la variable k, sa structure démontre qu’un dictionnaire peut être constitué de plusieurs types d’objets. En effet, à la clé nom correspond une seule valeur (Jean). Il s’agit d’une variable simple. Pour la clé biométrie, les valeurs correspondantes sont spécifiées sous forme de liste (représentant respectivement l’âge, le poids et la taille), pour la clé score correspond également trois valeurs mais spécifiée sous forme de tuples (représentant les scores obtenus par Jean à trois évaluation successives) et pour la clé rang, on a une valeur unique numérique représentant le rang de Jean à la suite des trois examens qu’il a passés.
Tous ces exemples montrent donc la généralité des objets dictionnaires par rapport aux autres objets tels que les listes, les tuples, les arrays, etc…
1.9.2. Accéder aux éléments d’un dictionnaire (slicing)
Pour accéder aux éléments d’un dictionnaire on se sert des clés. Toutefois la méthode de slicing diffère selon que la clé soit constituée d’une valeur unique ou de plusieurs valeurs comme une liste, tuples, etc…
1.9.2.1. Slicing d’un dictionnaire dans le cas d’une clé à valeur unique
Soit le dictionnaire défini comme suit :
x= {'nom':'Jean', 'age':25, 'poids':70, 'taille':1.75}
Les clés de x étant définies par des valeurs uniques, on peut faire les slicing suivants
66

x['nom'] # renvoie Jean x['age'] # renvoie 25 x['taille'] # renvoie 1.75
Pour faire du slicing dans le cas d’un dictionnaire dont les clés sont à valeur unique, il suffit d’indiquer la clé dans l’opérateur de slicing [ ] à l’image des listes ou tuples pour lesquelles il faut indiquer les indices.
1.9.2.2. Slicing d’un dictionnaire dans le cas d’une clé à plusieurs valeurs
Dans le cas d’un dictionnaire dont les clés sont à valeur multiples, on distingue deux situations : les slicing de premier niveau et les slicing de second niveau. Dans le premier cas, on accède à l’ensemble des éléments qui correspondent à la clé et dans le second cas, on accède à un élément particulier de l’ensemble qui forme la clé. Les exemples ci-dessous sont des illustrations.
Soit le dictionnaire x défini comme suit :
x= {'Jean':[25,70,1.75],'Paul':[30,65,1.80],'Pierre':[35,75,1.65] }
On peut faire des slicing suivants :
x['Jean'] #renvoie [25, 70, 1.75] x['Jean'][0] #renvoie 25 x['Jean'][0 :2] #renvoie [25, 70]
Ces exemples montrent que pour accéder aux sous-éléments il faut ajouter à la clé un opérateur de slicing supplémentaire dont les arguments sont, cette fois, les indices des éléments dans la séquence de valeurs correspondant à la clé.
1.9.3. Modification de dictionnaire : ajout et suppression de clés ou de valeurs
On peut modifier un dictionnaire soit en modifiant les clés et les valeurs déjà existantes ou en ajouter des nouvelles. On peut également supprimer des valeurs mais aussi des clés. Les exemples ci-dessous illustrent ces cas.
1.9.3.1. Ajout ou modification de clés ou de valeurs
Soit le dictionnaire vide x défini comme suit :
x= {} # Crée un dictionnaire vide. On pouvait aussi utiliser x=dict()
On va ajouter des clés et des valeurs à x et essayer d’apporter des modifcations au dictionnaire
67

x['nom'] = 'Jean' # ajoute la clé-valeur nom et Jean au dictionnaire x initial x['biométrie']= [25,70,1.75] # ajoute la clé-valeur biométrie et [25,70,1.75] au dictionnaire x x['biométrie']= [30,70,1.80] # modifie les valeurs de la clé biométrie en effectuant une nouvelle définition x['biométrie'][0]= 2 # modifie l’élément d’indice 0 de la liste de valeur qui correspond à la clé biométrie (préalabelemnt définie)
1.9.3.2. Suppression de clés ou de valeurs dans un dictionnaire
Il est possible de supprimer des clés ou des valeurs dans un dictionnaire. Les exemples cidessous sont des illustrations.
Soit le dictionnaire x défini comme suit :
x= {'Jean':[25,70,1.75],'Paul':[30,65,1.80],'Pierre':[35,75,1.65] }
On peut faire des opérations de suppression suivantes :
del x['Jean'] # Supprime la clé Jean toutes les valeurs correspondantes del x['Jean'][0] # Supprime l’élément d’indice 0 dans la séquence de valeur correspondant à la clé Jean. Pour une clé à une seule valeur, on utilise del x['nomCle'] où nomCle est le nom de la clé qui a la valeur unique.
1.9.4. Renommer une clé dans un dictionnaire
Pour renommer une clé dans un dictionnaire, on utilise la fonction pop() telle que définie dans l’exemple suivant :
Soit le dictionnaire x défini comme suit :
x= {'Jean':[25,70,1.75],'Paul':[30,65,1.80],'Pierre':[35,75,1.65] }
On souhaite renommer la clé Jean comme John. Alors on utilise la méthode de renommage comme suit :
x['John']=x.pop('Jean')
1.9.5. Tester l’existence d’une clé dans un dictionnaire : la fonction in
Pour vérifier si une clé existe dans un dictionnaire, on utilise la fonction in qui renvoie une valeur booléenne (True ou False) selon que la clé existe ou pas dans la liste. Exemple : soit le dictionnaire x définir par :
68

x= {'Jean':[25,70,1.75],'Paul':[30,65,1.80],'Pierre':[35,75,1.65] }
On peut faire des tests d’existence suivants :
'Paul' in x # renvoie True (car il y a bien Paul parmi les clés de x) 'Sebastien' in x # renvoie False 'Sebastien' not in x # renvoie True 'Jean' not in x # renvoie False
Nb : Encore une fois, la fonction « in » peut s’avérer utile dans de nombreuses situations. Elle peut par exemple servir dans la définition des instructions conditionnelles sur les clés en l’associant avec la clause « if ». Exemple :
if 'Paul' in x : print("Oui, Paul est bien une clé dans le dictionnaire x")
else : print("Non, Paul n’est pas une clé dans le dictionnaire x")
1.9.6. Récupérer les clés ou les valeurs d’un dictionnaire (les fonctions keys() et values())
Dans de nombreuses situations, il arrive qu’on ait besoin de récupérer les clés ou les valeurs d’un dictionnaire pour d’autres utilisations dans le programme (ex : constituer des listes, ou des tuples, etc…). Dans ces cas, on doit d’abord récupérer les clés et les valeurs. Pour cela, on utilise les fonction keys() et values().
La fonction keys() renvoie les clés d’un dictionnaire alors que la fonction values renvoie les valeurs. Les exemples ci-dessous montrent comment utiliser ces deux fonctions.
Soit le dictionnaire x défini comme suit :
x= {'Jean':[25,70,1.75],'Paul':[30,65,1.80],'Pierre':[35,75,1.65] }
On peut récupérer les clés et les valeurs comme suit :
myKeys=x.keys() # renvoie dict_keys(['Pierre', 'Paul', 'Jean']) myValues=x.values() # renvoie dict_values([[35, 75, 1.65], [30, 65, 1.8], [25, 70, 1.75]])
Signalons alors simplement qu’il est possible de transformer ces objets en objets liste en utilisant la fonction list() comme suit :
myKeysList=list(myKeys) # renvoie ['Pierre', 'Paul', 'Jean'] myValuesList=list(myValues) # renvoie [[35, 75, 1.65], [30, 65, 1.8], [25, 70, 1.75]]
1.10. Etude des fonctions
69

Simplement définie, une fonction est un bout de programme, un ensemble d’instructions agencées dans le but de réaliser une ou plusieurs tâches bien définies. On distingue deux catégories de fonctions sous python, les fonctions prédéfinies et les fonctions écrites par les utilisateurs. Les fonctions prédéfinies sont des fonctions directement intégrées dans la bibliothèque standard du système python alors que les fonctions-utilisateurs sont écrites soit par l’utilisateur actuel ou par d’autres utilisateurs. Dans cette section, nous allons étudier comment élaborer et appliquer une fonction sous python. Mais avant cela, nous donnerons un aperçu général sur quelques fonctions de base sous python.
1.10.1. Aperçu général sur quelques fonctions prédéfinies sous python : la fonction print() et la fonction input()
La plupart des tâches de programmations réalisées sous python par les utilisateurs se basent d’abord en priorité sur une multitude de fonctions préinstallées sous python et qui font la richesse de ce langage. L’objectif de cette section n’est pas de passer en revue toutes les fonctions disponibles sous python (nous n’en n’aurons pas les moyens !). Il s’agit simplement de présenter brièvement deux fonctions de base qui sont incontournables dans la programmation python. Il s’agit de la fonction print() et de la fonction input()
1.10.1.1. La fonction print()
Comme on le sait déjà, la fonction print() a pour rôle d'afficher à l’écran les valeurs des objets spécifiés comme arguments. Exemple :
print("Bonjour", "à", "tous") x=12 print(x) y=[1, "lundi","12", 5, 3, "valeur test"] print(y)
On peut remplacer le séparateur par défaut (l’espace) par un autre caractère quelconque (ou même par aucun caractère), grâce à l’argument sep.
print("Bonjour", "à", "tous", sep= "****") print("Bonjour", "à", "tous", sep= "")
Nb : N’oublier pas aussi qu’au lieu d’utiliser la fonction print() avec plusieurs argument, on peut utiliser l’opérateur de formatage "%" ou la fonction format() afin d’afficher le message en un seul bloc (se référer à l’utilisation de ces opérateur dans les sections plus haut). Exemple :
x=42 print("La distance à parcourir dans un marathon est de %i km" %x) # renvoie La distance à parcourir dans un marathon est de 42 km
1.10.1.2. La fonction input()
70

La fonction input permet de donner la main à l'utilisateur afin qu'il saisisse la valeur d'un argument donné
Exemple 1 :
prenom = input("Entrez votre prénom : ") print("Bonjour,", prenom)
Exemple 2
print("Veuillez entrer un nombre positif quelconque : ") ch = input() num = int(ch) # conversion de la chaîne en un nombre entier print("Le carré de", num, "vaut", num**2)
Nb : Soulignons que la fonction input() renvoie toujours une chaîne de caractères. Si vous souhaitez que l’utilisateur entre une valeur numérique, vous devrez donc convertir la valeur entrée (qui sera donc de toute façon de type string) en une valeur numérique du type qui vous convient, par l’intermédiaire des fonctions intégrées int() (si vous attendez un entier) ou float() (si vous attendez un réel).
1.10.2. Les fonctions définies par l’utilisateur
Les fonctions-utilisateurs sont des bouts de programme écrits par l’utilisateur afin de réaliser des tâches bien définies. Rappelons simplement que tout programme vise à résoudre un problème donné. Il est donc essentiel que la problématique à laquelle doit répondre le programme soit clairement définie et que les instructions qui concourent à la résolution soient aussi clairement spécifiées afin de pouvoir les traduire correctement en langage informatique. Le but de cette section est d’étudier comment élaborer une fonction.
1.10.2.1. Définir une fonction
Pour définir une fonction sous Python, on utilise le mot clé « def » pour déclarer le nom de la fonction. La syntaxe générale de définition d’une fonction est la suivante : :
def nomDeLaFonction(arg1, arg2, …, argN): bloc d'instructions
def est le mot clé qui déclare le nom de la fonction. Ce mot est un mot réservé de python qui figure parmi les 33 mots réservés du langage python. Ce qui signifie qu’aucun nom d’objet ne doit prendre cette valeur. Il est utilisé uniquement pour définir une fonction.
A la suite du mot clé def, on indique le nom que doit prendre la fonction. Comme dans le cas des noms de variables, il est conseillé d’utiliser surtout des lettres minuscules, notamment au
71

début du nom. Et pour des noms composés, on peut utiliser des majuscules pour faire la transition entre les éléments qui composent le nom (ex : myFunction, fonctionTest, etc…). Notons simplement que les noms d’objets commençant par une majuscule seront réservés au cas des classes.
Après avoir déclaré le nom de la fonction, on indique entre parenthèses les noms des arguments (paramètres) à partir desquels seront définies les instructions dans le corps du programme. Notons toutefois que la déclaration des noms des paramètres n’est pas obligatoire car il peut exister des programmes sans arguments ou du moins ceux-ci seront déclarés directement dans le corps du programme. Quoiqu’il en soit, la spécification des parenthèses reste obligatoire même si aucun paramètre n’est déclaré à l’intérieur. Attention également au symbole « : » qui marque la fin de la déclaration de la fonction et le début de la définition des instructions tout comme dans le cas de l’utilisation de la fonction « if » ou des boucles « for » ou « while ».
Après avoir déclaré la fonction à travers son nom et ses arguments, la seconde étape est la spécification des blocs d’instructions. Ceux-ci doivent être définis avec un certain décalage par rapport au mot clé def (indentation) tout comme dans le cas de la définition de la fonction « if » ou des boucles « for » ou « while ». Cette indentation des blocs d’instructions est obligatoire.
Dans cette section, nous allons étudier plusieurs variantes de la définition de fonctions notamment les fonctions définies sans arguments, les fonctions avec arguments se présentant sous forme de paramètres (constants), les fonctions avec arguments se présentant sous forme de variables, etc…
1.10.2.1.1. Définition d'une fonction simple sans argument
L’exemple ci-dessous illustre la définition d’une fonction simple sans argument. Le but de la fonction est d’afficher les 20 premières valeurs de la table de multiplication par 8.
Ainsi, on a :
def tableMultiplication8(): n=1 while n <=20 : v=n*8 print(n, 'x', 8, '=', v, sep =' ') n = n +1
Quelques petites remarques peuvent être faites sur cette fonction. D’abord, la fonction est construite sur une boucle « while » définie à partir d’une variable n dont la valeur initiale est 1 et qui sera incrémentée jusqu’à ce que sa valeur atteigne 20. Ensuite, pour chaque valeur de n, on définit une variable v dont la valeur est le produit de 8 et n. Enfin, on affiche un ensemble de chaîne de caractères défini à l’intérieur de la fonction print().
72

Remarquons simplement que la variable n a été initialisée à l’extérieur de la boucle mais son incrémentation s’effectue de la boucle à la suite des blocs d’instructions spécifiés à l’intérieur de la boucle. On peut aussi remarquer deux niveaux d’indentation. Un premier niveau d’indentation est définie à partir de la déclaration def et un second niveau d’indentation est défini à la suite de la déclaration « while ». Cette règle reste valable dans tous les cas. Tout bloc d’instruction défini à la suite d’une déclaration def sera indenté. Et lorsque ce bloc d’instruction est formé d’une clause « if » ou d’une boucle « while » ou « for », les instructions appartenant à ces blocs serons indentées à leur tour et cela de façon séquentielle.
Pour exécuter la fonction tableMultiplication8() que nous venons de définir, il suffit de le référencer en indiquant son nom comme suit (n’importe où dans le programme principal).
tableMultiplication8() # appelle la fonction tableMultiplication8()
Signalons aussi qu’on pouvait aussi définir la fonction tableMultiplication8() à partir d’une boucle « for ». Dans ce cas, la fonction se présenterait comme suit :
def tableMultiplication8(): for n in range(1 ,21) : v=n*8 print(n, 'x', 8, '=', v, sep =' ')
tableMultiplication8() # appelle la fonction tableMultiplication8()
Ici, on utilise la fonction range(1, 21) qui renvoie une séquence de valeur allant de 1 à 20. Chaque élément de cette séquence est récupérée et mutilplié par 8 avec la boucle « for ». Cet exemple montre donc que la boucle « while » et « for » sont alternatives dans de nombreuses situations.
1.10.2.1.2. Définition d'une fonction dont les arguments sont des paramètres
Un paramètre est une variable qui prend une valeur constante. Dans l'exemple précédent, nous avons élaboré une table de multiplication par 8. Nous pouvons généraliser cette fonction de sorte que qu’elle puisse renvoyée la table de multiplication de n’importe quel nombre spécifié comme argument. Ces nombres étant des paramètres, il s’agit alors de définir une fonction dont les arguments sont les paramètres. Voir l’exemple ci-dessous
def tableMultiplication(base): n=1 while n <=20 : v=n*base print(n, 'x', base, '=', v, sep =' ') n = n +1
73

tableMultiplication(2) # renvoie la table de multiplication par 2 tableMultiplication(8) # renvoie la table de multiplication par 8 tableMultiplication(11) # renvoie la table de multiplication par 11
1.10.2.1.3. Définition d'une fonction dont les arguments sont des variables
Une fonction dont les arguments sont des variables est une fonction dont les arguments sont des paramètres à la seule différence que dans le premier cas l’argument plusieurs valeurs successivement lors de l’appel du programme. Exemple : Considérons la fonction tableMutplication() qui a été définie précédemment comme suit :
def tableMultiplication(base): n=1 while n <=20 : v=n*base print(n, 'x', base, '=', v, sep =' ') n = n +1
Pour que l’argument base se comporte comme une variable, on va l’attribuer plusieurs valeurs à l’intérieur d’une nouvelle boucle « while » ou « for ».
Exemple : réalisons la table de multiplication des 20 premières valeurs de tous les nombres allant de 2 à 10.
On a :
x=2 while x <=10:
tableMultiplication(x) print(" ") # insérer un espace entre deux tables x = x +1
Dans cet exemple, l’argument base devient simplement une variable qui prend les valeurs de (définie de 2 à 10).
1.10.2.1.4. Définition d'une fonction à plusieurs arguments
Dans les exemples précédents, les fonctions ont été définies à partir d’un argument unique (ou sans argument). Une fonction est généralement définie à partir de plusieurs arguments comme l’a montré que la syntaxe générale en début de section. Ces arguments peuvent être des paramètres ou des variables. Certaines peuvent être des arguments obligatoires et d’autres optionnels. Par ailleurs, lorsque la fonction est définie à partir de plusieurs arguments, ceux-ci doivent être séparés par des virgules.
Exemple : la fonction tableMultiplication () définie ci-dessus effectue la multiplication en considérant les 20 premiers éléments de la base (1 à 20). On peut généraliser cet intervalle en indiquant les valeurs de début et de fin en ajoutant deux argument supplémentaires comme suit :
74

def tableMultiplication(base, debut, fin): n = debut while n <=fin : v=n*base print(n, 'x', base, '=', v, sep =' ') n = n +1
Pour exécuter la fonction, on a :
tableMultiplication(10, 5, 20) # effectue la table de mutplication de 10 allant de 5 à 20 tableMultiplication(8, 6, 12) # effectue la table de mutplication de 8 allant de 6 à 12
NB : Dans cet exemple, base, debut et fin sont spécifiés comme paramètres. On peut aussi les traiter comme des variables en élaborant par exemple une boucle lors de l’exécution de la fonction. Exemple :
x=2 y=5 z=20 while x <=10:
tableMultiplication(x ,y, z) print(" ") # insérer un espace entre deux tables x = x +1
Cette boucle renvoie la table de multiplication de 2 à 10 (pour les éléments allant de 5 à 20).
1.10.2.1.5. Définition des valeurs par défaut pour les arguments d’une fonction
Lors de la définition d’une fonction, il est souvent conseillé de définir des valeurs par défaut pour certain arguments (notamment les arguments optionnels).
En effet, il est conseillé de rendre obligatoire certains arguments du programme et de renvoyer des messages d’erreur lorsque les valeurs ne remplissent pas un certain nombre de conditions bien définies (par exemple, l’argument ne doit pas être NULL, on ne doit pas utiliser une variable en caractère là une variable numérique est prévue, etc…). En revanche, on peut définir des valeurs par défaut pour des des arguments optionnels à condition que ces valeurs soient universelles c'est-à-dire valable quel que soit le contexte dans lequel le programme est exécuté..
En définissant les valeurs par défaut pour les arguments d’une fonction, il est possible d’appeler le programme avec une partie seulement des arguments attendus. Exemples :
def salutation(nom, titre ='Monsieur'):
75

print("Bonjour", titre, nom)
La fonction salutation ainsi définie a deux arguments : nom et titre. Une valeur par défaut a été définie pour l’argument. Ainsi lorsque la fonction salutation est appelée avec seulement l’argument nom (omettant l’argument), la fonction renvoie la valeur par défaut Monsieur. Exemple :
salutation('Dupont') # renvoie Bonjour Monsieur Dupont
Mais lorsque la fonction est appelée avec les deux arguments, la valeur par défaut est ignorée. Exemple :
En définissant les valeurs par défaut pour les arguments d’une fonction, il est possible d’appeler le programme avec une partie seulement des arguments attendus. Exemples :
salutation('Dupont', 'Mademoiselle')
NB : Les arguments sans valeur par défaut doivent être spécifiés avant les arguments avec les valeurs par défaut. Par exemple, la définition ci-dessous est incorrecte et renvoie une erreur lors de l’exécution.
def salutation(titre='Monsieur', nom):
1.10.2.1.6. Ordre des arguments lors de l’appel d’une fonction
Dans la plupart des langages de programmation, lors de l’appel d’une fonction les arguments doivent être spécifiés exactement dans le même ordre que celui dans lequel ils ont été indiqués lors de la définition de la fonction. Python fait cependant exception à cette règle en autorisant une souplesse beaucoup plus grande. En effet, on peut faire appel à la fonction en fournissant les arguments correspondants dans n’importe quel ordre, à condition de spécifier nommément les paramètres correspondants tout en assignant les valeurs. Exemple :
def salutation(nom, titre): print("Bonjour", titre, nom)
Pour appeler cette fonction dans un ordre quelconque on fait :
salutation(titre='Mademoiselle', nom='Dupont') # renvoie Bonjour Mademoiselle Dupont salutation(nom='Dupont', titre='Mademoiselle') # renvoie Bonjour Mademoiselle Dupont salutation( nom='Dupont', titre='Monsieur') # renvoie Bonjour Monsieur Dupont
76

Ces exemples montrent que l’ordre de spécification des arguments lors de l’appel de la fonction n’est pas importante tant que les noms et les valeurs des arguments sont explicitement indiquées. Cette règle reste également valable lorsque les paramètres ont reçu tous une valeur par défaut, sous la forme déjà décrite ci-dessus. Cependant, l’ordre de définition doit être respecté dans le cas où certains arguments ont des valeurs par défaut et d’autres non. Il faut juste rappeler que les arguments sans valeurs par défaut doivent être déclarés avant les arguments avec valeurs par défaut
1.10.2.2. Les fonctions lambda
Une fonction lambda est une fonction anonyme c'est-à-dire une fonction constituée d’un bloc d’instructions appelable et réutilisable comme une fonction, mais sans nom. Une fonction lambda est généralement utilisée pour des fonctions très courtes avec peu d’instructions (nécessitant pas alors d’écrire une fonction classique avec le mot clé def et un appel)
La syntaxe générale de définition d'une fonction lamda est la suivante:
lambda arg1, arg2,…, argN : bloc instructions(ou formules)
Une fonction lambda est déclarée avec le mot clé lambda qui figure par les 33 mots réservés de python. Ce mot clé est accompagné par le (ou les arguments) qui entrent dans la définition de la fonction. La fin de la déclaration est marquée par le symbole « : » à la suite duquel on spécifie les instructions. L’exemple ci-dessus illustre la défintion d’une fonction lambda.
lambda x, y : x * y
On constate que contrairement à une fonction classique, la fonction lambda n’est définie avec aucun nom. Les arguments ne sont pas obligatoirement spécifiés à l’intérieur de parenthèses.
La fonction ci-dessus a été définie avec deux arguments x et y et l’instruction qui constitue la fonction est définie comme le produit entre x et y.
Notons toutefois que même si la fonction lambda n’est pas définie avec un nom, pour récupérer la valeur renvoyée, lors de l’appel de la fonction, il faut l’assigner à une nouvelle variable. L’exemple ci-dessous illustre l’appel de la fonction lambda précédente en prenant x=2 et y=3.
x=lambda x, y : x * y x(2,3) # appelle la fonction avec x=2 et y =3; renvoie 2*3=6
1.10.3. Les variables locales et les variables globales
Lorsque nous définissons des variables à l’intérieur d’une fonction, ces variables ne sont accessibles que pour cette fonction elle-même. On dit que ces variables sont des variables « locales » à la fonction. Mais lorsque les variables sont définies à l’extérieur de la fonction dans le corps du programme principal. Ces variables sont appelées variables « globales ». Le
77

contenu d’une variable globale est visible et accessible à partir de l’intérieur d’une fonction, mais cette fonction ne peut pas modifier la valeur de la variable. Les exemples suivants permettent d’illustrer ce qui distingue une variable locale d’une variable globale.
Soit la fonction myFunction définie comme suit :
def myFunction(): p = 20 print(p, q)
p=15 q=38 print(p, q) # renvoie 15 38 myFunction() # appelle la fonction, renvoie 20 38 print(p, q) # renvoie 15 38
On constate en effet que lorsque la fonction myFunction() est appelée, la variable globale q y est accessible et sa valeur est correctement renvoyée. En revanche, pour la variable p, nous avons deux définitions. Une première définition effectuée à l’intérieur de la fonctioon myFunction() et une seconde définition effectuée dans le programme principal à l’extérieur de la fonction myFunction(). Dans la première définition, p se comporte comme une variable locale et dans la deuxième, p est une variable globale. On constate que c’est la valeur de la variable locale qui est renvoyée et la définition de la variable locale n’a aucune incidence sur la variable globale. Au final, on retient donc qu’une fonction renverra toujours la valeur d’une variable en priorité par rapport à une variable globale mais la valeur de cette dernière ne sera pas modifiée.
Cependant, on peut modifier ce comportement par défaut en permettant à la fonction de modifier la valeur de la variable globale. Dans ce cas, il faut explicitement définir la variable comme global à l’intérieur de la fonction. Exemple:
def myFunction(): global p p = 20 print(p, q)
p=15 q=38 print(p, q) # renvoie 15 38 myFunction() # appelle la fonction, renvoie 20 38 print(p, q) # renvoie 20 38
Dans cet exemple, la variable p a été déclarée comme global à l’intérieur de la fonction. Par conséquent, le programme peut modifier cette variable à tout moment lors de l’appel. La preuve est que dans la fonction print() utilisée avant l’appel de la fonction, les valeurs de p et de q définies dans le programme sont affichées. En appelant la fonction, celle-ci affiche la valeur de p définie à l’intérieur de la fonction. Cette valeur remplace d’ailleurs systématiquement la
78

précédente valeur définie à l’extérieur de la fonction. Cela se voit en utilisant la fonction print() une seconde fois à après l’appel de la fonction. Les valeurs de p devient maintenant 20. Au final, on retient qu’une fonction Python ne permet pas la modification d’une variable globale que lorsque cette variable est déclarée comme globale à l’intérieur de la fonction.
1.10.4. Récupérer la valeur renvoyée par une fonction : l’instruction return
Très fréquemment, il arrive qu’on ait besoin de récupérer pour d’autres utilisations le résultat final renvoyé par l’appel d’une fonction. Le résultat final renvoyé par une fonction est un objet qui peut être de différents types (variable simple, liste, tuples, etc…). Pour récupérer ces valeurs, on utilise l’instruction « return » qui renvoie la valeur de l’instruction à laquelle elle est rattachée. D’une manière générale, l’instruction return est spécifiée à l’intérieur d’une fonction qu’il s’agisse d’une fonction classique ou d’une fonction lambda.
Les exemples ci-dessous illustrent l’utilisation de l’instruction return dans différentes situations.
Exemple 1 : Cas où l’on renvoie une valeur unique
Soit la fonction ci-dessous qui calcule le cube d’un nombre telle que :
def calculCube(x): cube=x**3 print(cube)
On souhaite récupérer la valeur de cube et la stocker dans une nouvelle variable nommée x. Alors, on peut ajouter l’instruction return à la fonction comme suit :
def calculCube(x): cube=x**3 print(cube) return cube # renvoie la valeur de cube
Pour récupérer la valeur de cube dans la variable x on procède par assignation comme suit :
x=calculCube(5) # Calcul le cube de 5 et renvoie sa valeur (125) dans x. print(x) # renvoie 125
L’instruction return est nécessaire pour définir la variable x sinon celle-ci contiendra la valeur None.
Exemple 2 : Cas où l’on renvoie un ensemble de valeurs (ex : une liste)
On souhaite récupérer les 10 premières valeurs de la table de multiplication d’un nombre quelconque en stockant ces résultats dans une liste. Alors, on suit la méthode suivante :
79

def tableMultiplication(base): listeValeurs = [] # Définir une liste vide qui doit accueillir les
résultats n = 1 # initialisation de n à 1 while n <=10: v = n * base listeValeurs.append(v) # ajout du terme à la liste vide n = n +1 # incrémentation de n return listeValeurs
Exécutons cette fonction avec la table de multiplication par 9
x = tableMultiplication(9) # Appelle la fonction avec l’argument 9 print(x) # renvoie [9, 18, 27, 36, 45, 54, 63, 72, 81, 90]
1.10.5. Utilisation des générateurs de fonction : l’instruction yield
« yield » est un mot clé qui représente une instruction de même type que le mot clé « return », à la seule différence que return renvoie une valeur ou un ensemble de valeurs alors que l’instruction yield renvoie un générateur.
Pour mieux comprendre la logique de l’instruction yield, prenons un exemple concret comme celui-ci.
def myFunction1() : listeValeur=[] for i in range(2, 11): listeValeur.append(i**2) return listeValeur
x=myFunction1() print(x) #renvoie [4, 9, 16, 25, 36, 49, 64, 81, 100]
myFunction1 est une fonction classique qui permet de renvoyer (avec l’instruction return) la lsite des carrés de tous les éléments appartenant à la séquence de valeurs comprise entre 2 et 10
Proposons une nouvelle définition de la fonction myFunction en utilisant l’instruction yield. On a:
def myFunction2() : for i in range(2, 11): yield i**2
myGenerator=myFunction2() print(myGenerator) #renvoie <generator object myFunction2 at 0x0B3D9D78>
80

D’abord, la première différence qui transparait avec l’utilisation de l’instruction return c’est que l’instruction yield renvoie un objet générateur. Par conséquent un simple appel de la fonction myFunction2 ne permet d’afficher les valeurs renvoyées par l’instruction yield.
Dans l’exemple ci-dessus puisque l’instruction yield est définie à l’intérieur d’une boucle, on doit alors récupérer les valeurs dans le générateur (nommé ici myGenerator) une à une en élaborant une nouvelle boucle comme suit :
x=[] # Définir une liste vide qui doit accueillir les résultats for i in myGenerator :
x.append(i) print(x) #renvoie [4, 9, 16, 25, 36, 49, 64, 81, 100]
On remarque alors que l’instruction return renvoie la liste finale alors que l’instruction yield définit d’abord les valeurs et les stocke dans un objet de type générateur. On récupère alors les éléments en utilisant une boucle pour former la liste finale des valeurs qui constitue les résultats. Cet aspect représente la principale particularité de l’instruction yield par rapport à l’instruction return.
Cependant, la présentation qui vient d’être faite de l’instruction yield est une présentation un peu sommaire et simpliste. L’instruction yield est un peu plus subtile en réalité. En effet, en toute rigueur conceptuelle, lorsqu’une fonction est appelée, l’instruction yield sert à suspendre l’exécution de la fonction chaque fois qu’une instruction yield est rencontrée. L’exécution de la fonction reprend alors là où elle s’était arrêtée lorsque la fonction est appelée une nouvelle fois et sera encore suspendue lorsqu’une nouvelle instruction yield est rencontrée. Ainsi de suite. Considérons par exemple la fonction suivante.
def myFunction(): yield "Ceci est une chaîne de caractères" yield "Oui bien sûr" yield 1200
myGenerator=myFunction() #appel de la fonction et son assignation à une variable nommée myGenerator
Cette fonction contient trois spécifications de l’instruction yield. Cela signifie que pour un premier appel de la fonction, celle-ci ne va renvoyer que la valeur "Ceci est une chaîne de caractères" car l’exécution de la fonction est suspendue à chaque fois que l’instruction yield est rencontrée. Et pour un second appel, l’exécution reprend là où elle s’était arrêtée. En effet, Python sauvegarde l’état du code du générateur entre chaque appel. Au final, pour pouvoir renvoyer tous les valeurs dans une fonction il faut spécifier une boucle dont le nombre d’itérateurs est égal au nombre de fois où la fonction yield est répétée dans la fonction. D’où la nécessité d’utiliser une boucle « for.. in » afin que le code puisse être exécuté autant de fois que de yield. Par exemple, pour afficher les trois valeurs de la fonction myFunction(), on procèdera comme suit :
81

for i in myGenerator : print(i)
1.10.6. Gestion des erreurs et des exceptions lors de la définition d’une fonction
1.10.6.1. Utilisation des blocs ty-except
Lors de l’appel d’une fonction, l'interpréteur Python peut rencontrer des instructions qu'il n'est pas en mesure d'exécuter (ex : erreur de syntaxe, division par zéro, accès à un fichier qui n'existe pas, etc). Dans ces cas, il jette une exception et renvoie un message d’erreur. Par exemple, soit l’instruction définie comme suit :
val =float(input("Veuillez saisir un nombre :"))
Dans cette instruction, on passe la main à l’utilisateur en lui demandant de saisir un nombre. Et dans le cas où l'utilisateur saisit des chaînes de caractères contenant des valeurs alphabétiques ou des caractères spéciaux, python enverra un message d’erreur de type « ValueError: could not convert string to float… » car la fonction float() ne permet de convertir que des chaînes constituer des valeurs en chiffres. Dans cette situation, on est face à une exception. Si cette exception n'est pas gérée par le programme dont l'instruction fait partie, le résultat est l'arrêt du programme avec affichage d'un message d'erreur.
Mais, le langage python offre les possibilités au programmeur pour contrôler les instructions pouvant générer des exceptions et de définir ses propres traitements d'erreur. Ces traitements sont basés sur l’utilisation des mots clés « try » et « except » qui figurent également parmi les 33 mots réservés de python. Les instructions susceptibles de générer des exceptions sont placées à l’intérieur d’un bloc « try » et les instructions à exécuter en cas d’exceptions sont définies à l’intérieur d’un bloc « except ».
Un bloc try doit être accompagné d’au moins un bloc except. Plusieurs blocs except peuvent être associés à un même bloc try. Ainsi, un ensemble try-except s’écrira de la forme :
try: instructions
except ErrorType1: instructions si ErrorType1
except ErrorType2: instructions si ErrorType2
except (ErrorType3, ErrorTpe4): instructions si ErrorType3 ou ErrorType4
except: instructions si autre erreur
Il existe trois manières d’écrire la ligne except :
82

1- en indiquant le nom de l’erreur concernée : ex :
except Error:
2- en indiquant un tuple contenant plusieurs erreurs : ex :
except (Error1, ..., Errorn):
3- en n’indiquant rien :
except:
Les exemples présentés ci-après illustrent l’utilisation de des blocs try et except.
Exemple1: Demandons à l’utilisateur de saisir des valeurs et lui redemander une nouvelle fois la saisie afin qu’il entre une valeur convenable
try : val =float(input("Veuillez saisir un nombre :"))
except ValueError: print ("La valeur entrée n’est pas valide") val =float(input("Veuillez recommencer s’il vous plaît:"))
Notons ici l’erreur renvoyée en cas d’échec de la saisie est de type ValueError. D’où la présence de ce mot clé devant l’instruction. Bien sûr, il existe plusieurs autres types d’erreurs identifiables par des codes d’erreur qui permettent de les distinguer et d'effectuer les traitements adéquats.
Dans cet exemple, l’instruction except renvoie d’abord un message indiquant à l’utilisateur que la valeur saisie n’est pas valide. Ensuite, il lui passe la main une seconde fois pour qu’il saisisse une nouvelle fois.
Noter toutefois que cette structure de code ne donne la main à l’utilisateur qu’un fois à l’issue duquel si une valeur valide n’est pas saisie, le programme s’arrêtera. Mais on peut améliorer le code de sorte que la fonction donne la main à l’utilisateur autant de fois que nécessaire jusqu’à ce qu’il saisisse une valeur valide. L’exemple ci-dessous est une illustration.
test = "Pas Ok" while (test !="Ok") :
try : val =float(input("Veuillez saisir un nombre :")) test="Ok"
except ValueError:
83

print ("La valeur entrée n’est pas valide, Veuillez recommenccer s’il vous plaît")
Dans cette formulation, on définit d’abord une variable nommée test dont la valeur est "Pas Ok". Ensuite, on construit une boucle conditionnelle qui évalue chaque fois la valeur de la variable test. Tant que la valeur de la variable test est différente de «Ok », les instructions de la boucle sont exécutées. La boucle a été construite autour de deux blocs d’instructions. Le bloc try dans lequel on demande la saisie de la valeur de la variable val. Et lorsque cette saisie se passe correctement, on attribue la valeur « Ok » à test. Mais lorsque la saisie par l’utilisateur ne se passe pas correctement, les instructions du bloc except sont exécutées. Dans le bloc except, il y a l’instruction print() qui donne des indications à l’utilisateur. Une fois que ce message est affiché, la boucle reprend puisque la valeur de test n’a pas été modifiée.
Exemple 2 : Dans le deuxième exemple, on va essayer d’ouvrir un fichier en utilisant la fonction open(). Si le fichier n'est pas trouvé au chemin indiqué la fonction renvoie une exception de type IOError. La gestion de cette exception permet l'affichage d'un message adéquat :
try : nomFichier = input("Entrez un nom de fichier : ") myFichier = open(nomFichier)
except IOError: print("Erreur de lecture du fichier") sys.exit()
Remarque : Il est également possible pour le programmeur de déclencher explicitement une exception grâce à l'instruction raise <Nom d'une Exception>, et aussi il est possible de définir de nouvelles exceptions pour des besoins particuliers
Exemple 3 : Utilisation de l’instruction excpt avec l’instruction pass
Soit la liste x définie comme suit:
x= ['North', '6.47', '4.03', 'Yorkshire', '6.13', '3.76', 'Northeast', '6.19', '3.77', 'East', 'Midlands', '4.89', '3.34']
Les éléments de cette liste sont tous en caractères. On souhaite alors convertir les élements en chiffres en format numérique en utilisant la fonction float(). Nous choisissons alors d’élaborer un boucle qui scanne tous les éléments un à un tente des convertir. Dans cette situation, il n’est nécessaire de lever une exception qui indique de passer à l’élément suivant lorsque l’élément actuel n’est pas convertible. Pour cela, on élabore la boucle suivante :
for i in range(len(x) ): try: x[i] = float(x[i] ) except: pass
84

L'instruction pass permet de continuer la boucle lorsqu'une chaine de caractère non convertible est rencontrée.
L’instruction « pass » est très proche des instructions « break » et « continue » qui ont été présentées dans les sections précédentes. En effet, nous avons montré que l’instruction « break » arrête la boucle lorsqu’une condition secondaire spécifiée à l’intérieur de la boucle est vérifiée. Quant à l’instruction « continue », il suspend l’exécution des instructions de la boucle lorsqu’une condition secondaire définie à l’intérieur de la boucle est vérifiée. L’exécution de la boucle continue lorsque cette condition n’est plus vérifiée. De ce point de vue, l’instruction « continue » et « pass » sont très proches.
1.10.6.2. Utilisation des clause « else » et « finally » dans une exception
Au même titre que pour les clauses « if », il est possible d’adjoindre un bloc « else » aux blocs de gestion d’exceptions : ce dernier ne sera alors exécuté que si aucune exception n’a été levée. Par ailleurs, il est aussi possible d’ajouter un bloc « finally » à la définition d’une exception. Les instructions de ce dernier bloc seront exécutées qu’il y ait des exceptions ou pas ( par exemple instruction à exécuter pour fermer un fichier ouvert par les instructions try, etc…). L’exemple ci-dessous illustre l’utilisation des clauses else et finally.
try: num = int(input('Entrer un nombre: '))
except ValueError: print('Vous devez entrer un nombre')
else: print('Vous avez bien entré un nombre')
finally: print('Ce texte sera toujours imprimé')
Comme signalé précédemment, le bloc else est exécuté quand l’exception ne produit pas c'est-à-dire lorsque le bloc try fonctionne correctement. Quant au bloc finally, il sera toujours exécuté, même si un return, break ou continue intervient dans le code avant l’instruction finally. Exemple :
def myFunction(): try: return 1 except: pass finally: print(2)
myFunction()
85

1.10.6.3. Les exceptions déclenchées par l’utilisateur : l’instruction raise
L’instruction raise permet au programmeur de déclencher une exception. Par exemple :
raise NameError('MyError')
Cette instruction renvoie NameError: MyError
Une exception est déclenchée grâce au mot-clé raise. Il suffit alors d’indiquer le nom de l’exception levée, suivie éventuellement d’arguments. La syntaxe générale est la suivante: raise NomException(argument).
raise MyValueError('Ceci est mon erreur de test')
Si on souhaite déterminer si une erreur a été levée, mais sans la prendre en charge, il est possible de lever la même erreur dans le bloc except à l’aide de raise. Exemple :
try: raise MyException('Une exception')
except MyException: print('Il y une exception ici') raise MyError
On peut aussi décider que le programme agira différemment selon l’erreur produite. Dans l’exemple suivant, le programme teste d’abord si l’erreur est de type ZeroDivisionError auquel cas il affiche le message division par zéro. Pour un autre type d’erreur, il regarde s’il y a d’autres instructions except qui s’y rapportent. S’il y en a une, il exécute les lignes qui la suivent, sinon, le programme s’arrête et déclenche une erreur
def inverseFunction(x): y = 1.0 / x return y try : print ((-2.1) ** 3.1) print (inverse (2)) print (inverse (0)) except ZeroDivisionError: print ("division par zéro") except Exception as exc: print ("erreur inprévue : ", exc.__class__) print ("message", exc)
Il est également possible d’associer une variable à l'erreur générée c'est-à-dire stocker l’erreur dans une variable, afin de la manipuler et d’obtenir des informations plus précises : la variable spécifiée dans la ligne except est alors associée à l’exception qui a été levée. Il est alors possible d’accéder aux attributs et aux arguments de l’exception concernée. Exemple :
86

try: raise Exception('Premier argument', 'Autre argument')
except Exception as error: print(type(error)) print(error.args)
1.10.7. Documenter une fonction
Après avoir élaboré une fonction (surtout une fonction relativement long et complexe), il et fortement de la documenter afin de permettre à d’autres utilisateurs de se l’approprier rapidement. La documentation d’une fonction est généralement une chaîne de caractères qui fournit une générale de la fonction ainsi que les aides utiles. Cette description est généralement spécifiée après la déclaration du nom de la fonction avant la définition des autres blocs d’instructions. L’exemple ci-dessous illustre comment documenter une fonction et comment accéder à cette document en cas de besoin.
def volumeSphere(): "Ce programme calcule le volume d'un cube. \n La fonction est
définie \ avec un seul argument obligatoire r qui représente le rayon du cercle.\ Celui-ci peut prendre n'importe quelle valeur positive"
r=float(input("Saisir le rayon de la sphère")) import math return (4 * math.pi * r**3)/3
Dans la définition de la fonction volumeSphere, la chaine de caractères ne joue aucun rôle fonctionnel dans le script : elle est traitée par Python comme un simple commentaire, mais qui est mémorisé comme une documentation interne sur la fonction. Cette document est stockée dans un attribut appelé __doc__. Pour afficher cette attribut, on fait:
print(volumeSphere.__doc__)
Si le script du programme est édité sous l’environnement IDLE (environnement d’édition de python), on voit apparaître cette chaîne documentaire dans une « bulle d’aide », chaque fois qu’on commence à écrire le nom de la fonction ainsi documentées.
1.11. Les modules python
Tout comme les dictionnaires sont des collections d’objets (listes, tuples, set, etc..), les modules sont des collections de fonctions qui permettent de réalisées des tâches apparentées. Par exemple, le module math, contient un certain nombre de fonctions mathématiques telles que sinus, cosinus, tangente, racine carrée, etc.
87

De nombreux modules sont déjà pré-installés dans la bibliothèque standard de python. Toutefois, pour réaliser certaines tâches spécifiques, on est souvent amené à installer des modules supplémentaires (ex : numpy, scipy, matplotlib, pandas, etc..)
Dans cette section, nous menons une discussion générale sur comment installer et utiliser un module python. Nous passerons en revue quelques modules incontournables de python en matière de Data Science.
1.11.1. Importation d’un module python
Dans la plupart des cas, avant d’utiliser un module, il faut d’abord importer dans la bibliothèque en utilisant le mot clé import. L’exemple ci-dessous illustre comment importer le module math.
import math
L’instruction import permet de rendre disponible tout le module (c'est-à-dire l’ensemble des fonctions qui le constitue). Pour voir l’ensemble des fonction qui forment un module, on utilise la fonction dir(). Exemple :
dir(math)
Pour avoir l’aide sur une fonction particulière dans le module math on utilise la fonction help(). Exemple :
help(math.gamma) # renvoie l’aide sur la fonction gamma du module math
Puisqu’une fonction contient une multitude de fonction, il est souvent inutile d’importer toutes ces fonctions en appelant. Si on a besoin de quelques fonctions seulement, on peut utiliser le mot clé from (voir exemple ci-dessous)
from math import sin # Importe la fonction sinus from math import cos, sin, tan, pi # Importe respectivement les fonction cosinus, sinus, tangente et la valeur pi (3.14).
from math import * # Importe toutes les fonction associées à math (équivalent à import math)
Remarque : lorsque le nom du module est long, il peut être utile d’importer le module en utilisant un alias avec le mot clé « as » afin de lui attribuer un nom temporaire qui sera utilisé alternativement au nom initial dans le reste du programme. Exemple :
import matplotlib as plt import requests as rqs
88

On peut alors utiliser ces alias partout où on fait appel aux modules correspondant. Nous donnerons des exemples dans la suite de la section. Attention toutefois à bien choisir ces alias afin d’éviter des confusions avec les noms d’autres objets pythons ou les mots réservés.
1.11.2. Utilisation d’un module python
Les exemples ci-dessous montrent quelques utilisations des modules python après leur importation
1.11.2.1. Quelques utilisations de la fonction math
from math import * v=16 # définit une variable v x = math.sqrt (v) # Renvoie la racine carrée de v y = math.e(v) # Renvoie l’exponentiel de v z = math.log(v) # Renvoie le logarithme népérien de v
1.11.2.2. Quelques exemples d’utilisation du module random
Le module random permet de générer des séquences de nombres aléatoires. C’est un module de la bibliothèquee standard de python tout comme le module math. Pour l’importer on fait :
import random
Pour avoir un aperçu sur l’ensemble des fonctions associées, on fait
dir(random)
Pour importer quelques fonction utiles, on a :
from random import random, randint, seed, uniform, randrange,sample, shuffle # Importe quelques fonctions utiles de random
La fonction random du module random permet de générer un nombre aléatoire compris entre 0 et 1. Exemple :
import random x=random.random() # Renvoie un nombre aléatoire. print(x)
La fonction randint() renvoie un nombre aléatoire entier sélectionner dans un intervalle défini par deux bornes a et b. Exemple :
import random x=random.randint(5,17) # Renvoie un nombre aléatoire entier entre 5 et 17. print(x)
89

La fonction uniform() est comme la fonction randint() à la différence que la fonction uniform génère un nombre aléatoire (réel) suivant une loi uniforme sur un intervalle donné. Exemple :
import random x=random.uniform(5,17) # Renvoie un nombre aléatoire uniforme réel entre 5 et 17. print(x)
La particularité des fonctions de génération de nombres aléatoires c’est qu’elles renvoient toujours des nouvelles valeurs lorsqu’elles sont appelées. Alors que dans de nombreuses situations, on voudrait que le programme renvoie les mêmes valeurs afin de reproduire les résultats obtenus lors de l’exécution précédente. Pour cela, il faut fixer le paramètre seed(). Exemple :
for i in range(10) : import random random.seed(2016) x=random.random() # Renvoie 0.7379. print(x) x=random.randint(5,17) # Renvoie 12 print(x) x=random.uniform(5,17) # Renvoie 16.78 print(x)
Dans ce code, on a appliqué dix fois les fonction random(), randint() et uniform(). Mais puisque le seed est fixé à la même valeur (2016) alors les fonctions vont tirer les mêmes valeurs. D’où l’importance de l’utilisation de la fonction seed(). Pour annuler l’effet du seed et réinitialiser on utiliser la commande :
random.seed() # réinitialise le seed() à la valeur du système.
La fonction shuffle permute aléatoirement les éléments d’une liste. Exemple
import random x = [1, 2, 3, 4] # Soit une liste initialement définie comme suit : random.shuffle(x) # Effectue une première permutation aléatoire des élements print(x) random.shuffle(x) # Effectue une seconde permutation des éléments print(x)
NB : On pouvait aussi utiliser la fonction seed() afin de pouvoir reproduire les mêmes résultats après chaque permutation.
90

N’oublier pas également les fonctions randrange() et sample() qui permettent respectivement des tirages aléatoires (la première dans un intervalle avec un pas donné et la seconde un tirage aléatoire d’échantillon suivant le plan SI.
1.11.3. Définir et utiliser son propre module
On peut créer son propre module en rassemblant plusieurs fonctions dans un seul script et en l’enregistrant dans le répertoire courant avec l’extension .py. Le nom doit être un nom simple ne créant pas d’ambiguïté avec d’autres objets python. On peut choisir par exemple : myprogram.py
Une fois que le programme est enregistré dans le répertoire courant, il suffit d’importer le module comme un module classique et toutes ses fonctions (et variables) deviennent toute accessibles.
La première fois qu’un module est importé, Python crée un fichier avec une extension .pyc (ici myprogram.pyc) qui contient le bytecode (code précompilé) du module. L’appel du module se fait avec la commande:
import myprogram
Ensuite on peut utiliser les fonctions du module comme avec un module classique.
1.11.4. Procédure d’installation et d’utilisation des modules externes
Comme nous l’avons signalé un peu plus haut, de nombreux modules de python sont des modules externes qui doivent d’abord être installés afin de pouvoir effectuer certaines tâches. C’est le cas par exemples des modules de calcul scientifiques et numériques (scipy, numpy), les modules d’élaboration de graphiques (malplotlib) ou encore des modules e traiement de données, d’analyses statistiques ou de data science (pandas, Statmodels, scikit-learn, etcc).
Dans cette section, nous décrivons les étapes d’installations des modules externes ainsi que quelques astuces utiles pour une installation rapide.
En effet, pour installer un module externe python, il faut suivre les suivantes suivantes (Attention, cette méthode n’a été testée que sur python 3.4 installé sur un système Windows 7, 32bit)
1- Chercher le module sur Internet le module à télécharger et télécharger le fichier en extention whl (ou un dossier contenant les fichiers (dézipper si nécessaire). De nombreux fichier en whl peuvent être trouvés à l’adresse http://www.lfd.uci.edu/~gohlke/pythonlibs/
91

Télécharger le fichier et déposer le dans le dossier: "C:\Python34\Scripts" qui est le répertoire où est installé python 3.4
2- Lancer une page dans un éditeur de texte (Bloc-Note, Nordpad, Notepad, etcc). Enregistrer cette page quelque part, de préférence dans le répertoire "C:\Python34\Scripts" avec le nom avec l’extention .bat comme suit : "fichier_installation_modules.bat". Ce fichier étant créé, on va ajouter quelques lignes de commande qui installent automatiquement les modules qui seront indiqués. Pour ouvrir le fichier, faite clique-droit --> modifier. Le fichier avec l’extension .bat est un fichier exécutable. En faisant ouvrir, le programme s’exécute.
3-Après avoir ouvert le fichier (en mode modifier), ajouter les lignes de commande suivantes correspondant aux modules à installer:
cd C:\Python34\Scripts pip install numpy-1.9.2+mkl-cp34-none-win32.whl pip install scipy-0.15.1-cp34-none-win32.whl pip install Pillow-2.8.1-cp34-none-win32.whl pip install matplotlib-1.5.1-cp34-none-win32.whl pip install rpy2-2.7.8-cp34-none-win32.whl pip install pandas-0.17.0-cp34-none-win32.whl pip install xlrd-0.9.4-py2.py3-none-any.whl pip install xlrd-0.9.4-py2.py3-none-any.whl pip install patsy pip install requests-2.10.0-py2.py3-none-any.whl pip install beautifulsoup4 pip install lxml-3.4.4-cp34-none-win32.whl pip install html5lib-0.9999999-py2.py3-none-any.whl pip install urllib3-1.16-py2.py3-none-any.whl pip install scikit_learn-0.15.1-cp34-none-win32.whl pip install nose-1.3.7-py3-none-any.whl pip install statsmodels-0.6.1-cp34-none-win32.whl pip install python_dateutil-2.5.3-py2.py3-none-any.whl pip install mca pip install nltk pip install html2text pip install openpyxl-2.4.1-py2.py3-none-any.whl pip install XlsxWriter-0.9.3-py2.py3-none-any.whl pause
4- Après avoir ajouté ces lignes de commande, on enregistre et on ferme le fichier. Ensuite, on clique-droit--> Exécuter ou Ouvrir ou double-cliquer. L’instruction pip install se lance alors et installe tous les modules les uns à la suite des autres. Il faut noter qu’on peut aussi installer les modules dans l’invite commande de windows.
Nb : Tous ces modules indiqués ici doivent être préalablement téléchargés et déposés dans le répertoire C:\Python34\Scripts. Le nombre de modules externes à installer dépend des besoins
92

de l’utilisateur. D’une manière générale l’installation de nouveaux modules se fait au fur et à mesure que les besoins de l’utilisateur augmentent. Cette longue liste de module n’est donc pas le fruit le fruit d’une installation d’un seul jour.
Conseil technique : Attention, pour un débutant, il est conseillé de ne pas avoir une version trop avancé de python sinon, vous risquez de ne pas pouvoir avoir tous les modules téléchargeables compatibles avec votre version. Il faut donc trouver un équilibre entre le fait d’être à jour dans les versions python et la compatibilité des fonctions que vous serez amenés à utiliser. Vous pouvez consulter par exemple le site http://www.lfd.uci.edu/~gohlke/pythonlibs/ pour analyser les modules disponibles pour quelles versions de python
Dans la liste des modules spécifiées ci-dessus, on remarque deux catégories : les fichiers avec l’extention whl et les fichiers sans extension. Les fichiers avec l’extention whl ont pour la plupart dans leur nom les mots « cp34-none-win32 » ou « py2.py3-none-any ». cp34-nonewin32 signifie que le module est compatible avec la version 3.4 avec un système windows 32 bit. py2.py3-none-any signifie que le module est compatible avec python 2.x et 3.x et installable sur n’importe quel système.
Quant aux fichiers sans extensions, c’étaient au départ des fichiers sources (src) archives avec l’extension tar.gz que nous avons extrait et déposer comme un dossier dans le répertoire Scripts. Le module s’installe alors comme pour un fichier en whl. Notons toutefois que le nom des versions ne doit pas être spécifié par dans le programme d’installation. Par exemple si le dossier est nommé mca-1.0, on écrira simplement pip install mca.
Il faut aussi signaler qu’il existe une autre méthode d’installation plus simple des modules sous windows. Cela se fait à partir de l’invite commande de windows et le programme easy_install.exe présent dans le dossier Scripts. Par exemple, pour installer le module numpy, on tape la commande :
C:\Python34\Scripts\easy_install.exe numpy
Python fait lui-même la recherche du fichier d’installation (y compris sur internet) et installe le module.
Pour connaitre la version d’un module installé, on utilise la propriété __version__. Exemple : pour connaître la version de matplotlin, on fait comme suit :
Import matplotlib matplotlib.__version__
1.11.5. Désinstaller un module
Pour désinstaller un package, on utilise la commande uninstall à la place install avec pip (sans les numéros des versions). Exemple : Pour désinstaller numpy, on fait :
93

pip uninstall numpy
1.12. Aperçu général sur les objets « classe »
Une classe est un objet qui sert à construire d’autres objets avec lesquels on associe des méthodes (ou fonction) propres à cet objet. Par exemples, la classe str() est utilisée pour créer des objets en chaînes de caractères. Plusieurs méthodes sont alors associées à cet objet comme par exemple les fonctions lower, upper, etc… Pour voir l’ensemble des méthodes associées à une objet on utilise la fonction dir(nomObjet).
Les objets peuvent posséder des attributs (variables associées aux objets) et des méthodes (fonctions associées aux objets)
L’exemple ci-dessous illustre la définition d’une classe.
On va créer une classe appelée Rectangle dans laquelle on va définir un ensemble de fonctions applicable à une rectangle.
class Rectangle: "ceci est la documentation de classe Rectangle"
### 1- initialisation d'un objet def __init__(self, long = 0.0, larg = 0.0): # définition des
attributs d'un objet self avec des variables ayant des valeurs par défaut
# 2- Définition des attributs ayant pour valeur ces variables self.longueur = long # l’attribut longueur prend la valeur
long self.largeur = larg # l’attribut largueur prend la valeur larg
# 3- definir une méthode (fonction) qui calcule la surface de self def calculSurface(self): print("surface = %.2f m2 "%(self.longueur * self.largeur))
# 4- definir une méthode( fonction) qui redéfinit le rectangle en carré
def changeCarre(self, cote): self.longueur = cote self.largeur = cote
Ici, longueur et largeur sont des attributs alors que calculSurface() et changeCarre() sont des méthodes. Tous les attributs et toutes les méthodes se réfèrent toujours à self qui désigne l’objet lui-même. Attention, les méthodes prennent toujours au moins self comme argument
La classe rectangle ainsi définie peut être utilisée à d'autres fins (notamment calculer d'autres classes). Exemples :
94

rect1 = Rectangle() # crée un objet Rectangle avec les paramètres par défaut indiquée lors de la définition de la classe. print(rect1.longueur, rect1.largeur) rect1.calculSurface() # applique la méthode qui calcule la surface (avec les valeurs par défaut ici) rect1.changeCarre(30) # Change le rectangle en carré de dimension 30 rect1.calculSurface() # applique de nouveau la méthode de calcul de surface avec les nouvelle dimensions rect2 = Rectangle(2, 3) # Crée un objet Rectangle avec des paramètres indiqués rect2.calculSurface() # Calcule la surface avec ces nouvelle dimensions
1.13. Utilisation du module pickle pour l'enregistrement et le chargement des objets python
Le module pickle permet d'enregistrer un objet python dans un fichier afin de pouvoir le recupérer ultérieurement. Le fichier résultant pourra être lu depuis n'importe quel système d'exploitation (à condition, que celui-ci prenne en charge Python). Les fonctios les plus utilisées sont pickler() et Unpicler() avec respectivement les méthodes dump(), load().
1.13.1. Utilisation de la fonction Pickler
Ouvrons un fichier nommé mesobjets sous le nom x comme suit:
import pickle with open ('mesobjets', 'wb') as x : # le fichier est ouvert à la fois en mode w et b (écriture en binaire)
pickle.Pickler(x).dump(nomobjet) # crée un objet pickler à partir de nomobjet pour enregistrer dans mesobjets x
On peut faire quelques remarques par rapport à la création de l’objet pickle. D'abord le fichier mesobjets n'a pas d'extension. On peut lui assigner une. Par exemple mesobjets.txt. Ensuite le fichier a été ouvert en mode d'écriture binaire wb. Ce fichier contiendra alors les écritures binaires. Ensuite tous les objets enregsitrés seront directement renvoyés dans mesobjets avec la fonction dump(). nomobjet peut être n'importe quel objet: liste, tuple, dictionnaire, etc...)
Exemple: soient les données sur des joueurs d'un jeu et leur score définie par un dictionnaire (ou bibliothèque) comme suit:
score = {" joueur 1": 5, " joueur 2": 35, " joueur 3": 20, " joueur 4": 2} Enregistrons cet objet dans un pickle import pickle with open ('mesobjets.txt', 'wb') as x :
pickle.Pickler(x).dump(score )
95

Pour ajouter d'autres objets on appelle de nouveau la méthode dump() avec les objets à enregistrer. Exemple myobs1 = {'nom':'Jean', 'age':25, 'poids':70, 'taille':1.75} myobs2 = {'nom':'Paul', 'age':30, 'poids':65, 'taille':1.80} myobs3 = {'nom':'Pierre', 'age':35, 'poids':75, 'taille':1.65} myobs4 = {'nom':'Baptiste', 'age':28, 'poids':80, 'taille':1.90} with open ('mesobjets.txt', 'wb') as x :
pickle.Pickler(x).dump(myobs1 ) pickle.Pickler(x).dump(myobs2 ) pickle.Pickler(x).dump(myobs3 ) pickle.Pickler(x).dump(myobs4 ) En observant le contenu du fichier créé, on s’aperçoit que les données sont codées : import os os.system("cat mesobjets.txt")
1.13.2. Utilisation de la fonction Unpickler
La fonction unpickler() permet de récupérer les objets enregistrés par le pickler. Exemple : soit le pickler suivant score = {" joueur 1": 5, " joueur 2": 35, " joueur 3": 20, " joueur 4": 2} with open ('mesobjets.txt', 'wb') as x :
pickle.Pickler(x).dump(score ) Pour récupérer les objets enregsitrés, on ouvre le fichier en mode 'r' et 'b' avec la fonction unpicker et la méthode load() à la place de dump() with open ('mesobjets.txt', 'rb') as x :
monobjet=pickle.Unpickler(x).load() print(monobjet) Attention à ne pas utiliser la fonction load() une fois de trop, sinon une erreur est générée. Il est à noter qu’il existe un module équivalent mais beaucoup plus rapide, le module cpickle.
96

Chapitre 2 : Etude des chaînes de caractères et des expressions régulières
2.1. Les chaînes de caractères
Les chaînes de caractères ne sont pas des objets en tant que tels dans un programme python. Ce sont plutôt des séquences de valeurs (tout comme les données de type numériques) qui servent à définir les objets proprement dits comme les listes, les tuples, etc…
A l’image des opérations mathématiques réalisables les données numériques (addition, multiplication, division, etc..), il existe également un ensemble d’opérations de traitements et de manipulation des chaînes de caractères. Cette section a pour but de passer en revues certaines de ces opérations les plus couramment rencontrées notamment dans les opérations de traitement de texte.
Avant d’introduire la section, il faut d’abord faire une remarque importante concernant la différence entre une valeur de type caractère et une valeur de type alphabétique. En effet, une valeur alphabétique est toujours une chaîne de caractère alors qu’une chaîne de caractère n’est pas nécessairement une valeur alphabétique. Sous python, une valeur caractère est toujours exprimée entre guillemets (simple, double ou triple) alors qu’une valeur numérique est exprimée sans guillemets. On distingue deux principaux types de données : les données numériques et les données en caractères. Il faut noter qu’une valeur numérique exprimée entre guillemets est automatiquement traitée comme une valeur caractère même si elle n’est pas alphabétique. Il est important de garder à l’esprit ces détails lors de la manipulation des séquences de valeurs sous python (voir exemple ci-dessous)
x= 12 # x est une variable numérique y="12" # y est une chaîne de caractère formée par une chiffres z="mon texte" # z est une chaîne de caractères formée de valeurs alphabétiques k="Ce stylo coûte 5 euros" # k est une chaîne de caractères formée de valeur alphanumérique
Nb : Noter aussi que dans une chaîne de caractères, l’espace (blank) est un caractère qui représente une valeur à part entière dans la chaîne. Il nécessite souvent des opérations de traitement spéciales, à défaut de quoi, il se comporte comme un élément de la chaîne au même titre que les autres caractères. Nous reviendrons plus amplement sur ces aspects dans la suite de cette section.
2.1.1. Définition d’une variable de type chaîne de caractères
Une variable chaîne de caractère se défini de manière classique par une assignation directe en utilisant le symbole de l’égalité (comme cela a été discutée dans la section sur la création de variable). La seule particularité des variables caractères par rapport aux variables numériques
97

est que leurs valeurs doivent être spécifiées entre guillemets lors de l’assignation. Les trois exemples ci-dessous sont des illustrations.
ch1 = 'Seriez-vous à la réunion de ce soir ?' ch2 = '"Oui", répond-il' ch3 = "D’accord, j'apprécierai bien" ch4 = """Cette phrase est une longue chaîne de caractères contenant tous les types de guillemets: " ' « » mais aussi de nombreux caractères spéciaux""" print(ch1) print(ch2) print(ch3) print(ch4)
Ces quatre exemples montrent différentes utilisations des guillemets lors de la définition d’une variable en chaines de caractères.
Dans le premier exemple (ch1), on utilise des guillemets simples car il n’y a aucun inconvénient à cela compte tenu de la chaîne spécifiées. On pouvait aussi utiliser des guillemets doubles.
Dans le deuxième exemple (ch2), on utilise des guillemets simples car la chaînes spécifiée contient déjà des guillemets doubles comme valeur.
Dans le troisième exemple (ch3), on utilise les guillemets doubles car le texte contient des apostrophes qui sont en fait des guillemets simples.
Dans le quatrième exemple (ch4), on utilise les guillemets triples car le texte contient non seulement des guillemets simples, apostrophes et les guillemets doubles mais s’étend sur plusieurs lignes. Dans ces conditions, l’utilisation des guillemets triples s’impose.
2.1.2. Indiçage des chaînes de caractères (slicing)
Une chaîne de caractère est une séquence de valeurs ordonnées et indicées. Ce qui signifie qu’on peut accéder à chacun des éléments de la séquence en spécifiant son indice comme dans les liste. Les exemples ci-dessous sont des illustrations.
Soit la chaîne de caractères ch définie par :
ch="Christelle"
On peut faire les slicing suivant :
ch[0] # renvoie 'C' ch[2] # renvoie 'r' ch[-1] # renvoie 'e', le dernier élément de ch ch[:6] # Renvoie 'Christ' ch[6 :] # Renvoie 'elle' ch[0:10:2] # renvoie 'Crsel'
98

Remarque : les éléments d’une chaîne de caractères ne sont pas définie en fonction des mots séparés par des espace mais par les caractères qui le constituent. En effet, même si la chaîne avait été constituée par une phrase de plusieurs mots, les indiçages se feront uniquement sur la base des caractères qui forment la longue chaînes. Exemple : soit la chaîne définie par :
ch="Ceci est une chaîne de plusieurs mots"
En faisant les indiçages sur cette chaîne, on a :
ch[1] # renvoie 'e' ch[4] # renvoie ' ', l’espace vide qui sépare Ceci et est. ch[0:4] # renvoie 'Ceci'
2.1.3. Déterminer la longueur d’une chaîne de caractères (nombre de caractères)
Pour déterminer la longueur d’une chaîne, on utilise la fonction len() comme pour une liste ou pour tout autre objet python. L’exemple ci-dessus est une illustration.
ch="Ceci est une chaîne de plusieurs mots"
print(len(ch)) # renvoie 37 La chaîne ch est constituée de 37 caractères (espace compris).
2.1.4. Addition de chaînes de caractères (concaténation)
L’addition de chaînes de caractères est la juxtaposition de chaînes de caractères les unes à la suite des autres pour une former une chaîne de caractères unique. Il s’agit de la concaténation.
Pour réaliser cette opération, on utilise le symbole + entre les noms des variables chaînes. Le résultat obtenu est ensuite assignée à une nouvelle variable. Exemples :
x = 'Un petit pas pour l'homme,' y = 'un grand pas pour l'humanité' z=a+b print(z) # renvoie 'Un petit pas pour l'homme, un grand pas pour l'humanité'
Attention toutefois dans l’utilisation de l’opérateur de concaténation lorsqu’il s’agit d’associer une valeur numérique à une chaîne pour former une chaîne unique. Exemple
x= 'Le prix du stylo est' y=5 z= 'euros'
99

